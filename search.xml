<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【阅读笔记】在线社交网络方向相关</title>
      <link href="/2022/08/08/2022-08-08-%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E5%9C%A8%E7%BA%BF%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E6%96%B9%E5%90%91%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/08/08/2022-08-08-%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E5%9C%A8%E7%BA%BF%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E6%96%B9%E5%90%91%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 在线社交网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SE】数学基础知识</title>
      <link href="/2022/08/02/2022-08-02-%E3%80%90SE%E3%80%91%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/08/02/2022-08-02-%E3%80%90SE%E3%80%91%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<ul><li>高数、线代、概率论一些常用基础知识点复习</li></ul><span id="more"></span><h1 id="重点复习"><a href="#重点复习" class="headerlink" title="重点复习"></a>重点复习</h1><p><strong>高数部分</strong></p><ul><li>可导、可微、连续、可积之间的关系（一元函数+二元函数）。✅</li><li>三个中值定理的区别、联系和物理意义（罗尔、拉格朗日、柯西），微分中值定理是啥？</li><li>如何求梯度？梯度、方向导数与梯度。✅</li><li>定积分如何求？定积分的意义？</li><li>给你一个物体表面离散的一堆点，如何求任意表面的法向量？</li><li>凸函数的定义，凸函数的局部最优解一定是全局最优解吗，为什么呢？</li><li>什么是数列的极限，也就是说一个数列xn，收敛于a，你如何定义它？</li><li>用数学语言描述极限</li><li>一阶导，二阶导的物理意义，几何意义</li><li>傅里叶级数和傅里叶变换的关系</li></ul><p><strong>线代部分</strong></p><ul><li>矩阵中秩和迹是如何计算的，物理意义分别是什么？秩是什么？什么是矩阵满秩？怎么求矩阵的秩？</li><li>什么是线性变换？什么是线性空间？</li><li>什么是全等变换？</li><li>什么是极大无关组？</li><li>什么是矩阵相似？</li><li>正定矩阵是什么？</li><li>正交矩阵的定义</li><li>什么是矩阵合同</li><li>对称矩阵是什么？</li><li>特征值和特征向量几何含义？它们的意义以及之间的关系</li><li>矩阵可逆的条件？</li><li>子空间是什么？</li><li>描述一下特征值分解？</li><li>行列式的几何意义？</li><li>线代：如何理解矩阵的秩？简述向量组线性无关的含义？解释正定矩阵以及半正定矩阵？特征值的含义以及矩阵分解的物理意义？</li></ul><p><strong>概率论部分</strong></p><ul><li>解释什么是大数定理，有什么用，什么时候用？</li><li>解释什么是中心极限定理，有什么用，怎么用？数据如何处理？</li><li>全概率公式怎么写？</li><li>贝叶斯公式与应用？</li><li>介绍下正态分布，两个正态分布相加是不是还是正态分布</li><li>解释下相关系数、协方差。相关系数或协方差为0的时候能否说明两个分布无关？为什么？</li><li>极大似然估计</li></ul><p><strong>离散数学部分</strong></p><ul><li>偏序关系和等价关系</li><li>解释下等价关系和等价类</li><li>双射</li><li>什么是覆盖和划分、偏序集合、强弱连通图</li></ul><h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="可微、可导、可积、连续"><a href="#可微、可导、可积、连续" class="headerlink" title="可微、可导、可积、连续"></a>可微、可导、可积、连续</h3><blockquote><p><a href="https://blog.csdn.net/SP_FA/article/details/117473545?ops_request_misc=%7B%22request%5Fid%22%3A%22165969690516782350825991%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165969690516782350825991&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-117473545-null-null.nonecase&amp;utm_term=可导与连续的关系&amp;spm=1018.2226.3001.4450">参考阅读： 可微，可导，可积与连续的关系</a></p></blockquote><h4 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h4><p>🔴 $\textcolor{red}{连续}$</p><p>设$y=f(x)$在$x_{0}$的某一邻域内有定义，若$\lim_{x \to \infty}f(x)= f(x_{0})$，则称$f(x)$在点$x_{0}$处连续</p><ul><li><strong>三个条件</strong><ul><li>函数在该点<strong>有定义</strong></li><li>函数在该点极限$\lim_{x \to \infty}f(x)$<strong>存在</strong></li><li><strong>极限值 =  函数值</strong>：$\lim_{x \to \infty}f(x)= f(x_{0})$</li></ul></li></ul><p>🔴 $\textcolor{red}{可导}$</p><p>设$y=f(x)$在$x_{0}$的某一邻域$U(x_{0})$内有定义，当自变量$x$在$x_{0}$取得增量$\Delta x(x\neq 0) $，且$x_0 +\Delta x \in U(x_0)$时，相应的函数增量 $ \Delta y=f(x_0+\Delta x)-f(x_0)$，若极限</p><script type="math/tex; mode=display">\lim _{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}=\lim _{\Delta x \rightarrow 0} \frac{f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)}{\Delta x}</script><p>存在，则称函数在$x_0$处可导，并称这个极限值为函数在该点处的导数</p><p>🔴 $\textcolor{red}{可微}$</p><blockquote><p>参考阅读：<a href="https://zhuanlan.zhihu.com/p/38967869">如何通俗理解全微分 - 知乎 (zhihu.com)</a></p></blockquote><p>设函数$y=f(x)$ 在区间内有定义，$x_{0}$及$x_{0}+\Delta x$在区间内：</p><ul><li>若增量 $ \Delta y=f(x_0+\Delta x)-f(x_0)$可表示为$\Delta y=A\Delta x+o(\Delta x)$</li><li>其中$A$是不依赖于$\Delta x$的常数，那么称函数$y=f(x)$ 在点$x_0$处可微。</li><li>$A\Delta x$ 叫做函数$y=f(x)$在点 $x_0$处相应于$\Delta x$的微分，记作$ \mathrm dy$</li></ul><p>🔴 $\textcolor{red}{可积}$</p><ul><li>$f(x)$在区间$[a,b]$上<strong>连续</strong>，则在$[a,b]$上可积</li><li>$f(x)$在区间$[a,b]$上<strong>有界，且只有有限个间断点</strong>，则在$[a,b]$上可积</li></ul><h4 id="联系【一元函数】"><a href="#联系【一元函数】" class="headerlink" title="联系【一元函数】"></a>联系【一元函数】</h4><p>⭕ <strong>可导 必然 连续，连续 不一定 可导</strong></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/64324578">证明：连续性和可导性</a></p><p>例子：魏尔施特拉斯函数：<strong>处处连续而处处不可导</strong>：</p></blockquote><p><img src="https://s2.loli.net/2022/08/05/QLWHksud7xAlJjU.png" alt="image.png" style="zoom: 50%;"></p><p>⭕ <strong>可导 和 可微 等价</strong></p><blockquote><p><a href="https://www.zhihu.com/question/319299307#:~:text=一元函数可导，表示曲线可作切线，表示曲线光滑。. （这个没有理解难度吧！. ）. 可导表示可作切线. 一元函数可微，表示曲线段的Y增量可以用直线段的Y增量代替。. 可微表示允许以直代曲.,曲线段PC的X增量是 ，直线段PB的X增量是 。. 两者相等. 曲线段PC的Y增量是 ，直线段PB的Y增量是 。.">一元函数和二元函数，可微和可导有什么区别？ - 知乎 (zhihu.com)</a></p></blockquote><p>⭕ <strong>连续必然可积，可积不一定连续</strong></p><blockquote><p>想想可积和连续的几何意义就理解了</p></blockquote><p>⭕ <strong>可导必然可积，可积不一定可导</strong></p><blockquote><p>可导👉连续👉可积，所以可导必可积。</p><p>可积不一定连续👉不一定可导，所以可积不一定可导。</p></blockquote><h4 id="联系【多元函数】"><a href="#联系【多元函数】" class="headerlink" title="联系【多元函数】"></a>联系【多元函数】</h4><p>🔺 <strong>可导不一定连续，连续不一定可导</strong></p><blockquote><p>可导指的是<strong>可偏导</strong>，所以<strong>并不能推出在所有方向上函数连续</strong></p></blockquote><p>🔺 <strong>可微必然可导，可导不一定可微</strong></p><blockquote><p>一元函数👉可导：存在导数，可微：存在微分。</p><p>多元函数👉可导：存在<strong>偏导数</strong>，可微：存在<strong>全微分</strong>。</p></blockquote><p>🔺<strong>可微必然连续，连续不一定可微</strong></p><p>🔺<strong>偏导数连续必然可微，可微不一定偏导数连续</strong></p><blockquote><p>一个形象的角度理解：<a href="https://zhuanlan.zhihu.com/p/42504140">多元函数可微、可导、连续的关系 - 知乎 (zhihu.com)</a></p><p><strong>连续</strong>：在定义范围内曲面上没有窟窿、断崖（但可以有尖点，有折痕）</p><p><strong>(偏)导函数存在，即可导</strong>：曲面和某个切面相交的那条切线是光滑的（但是偏导函数可以在这点不连续，即极限存在但无定义)</p><p><strong>可微</strong>：曲面是光滑的(想象一个穹顶)</p></blockquote><hr><h3 id="偏导数、方向导数、梯度"><a href="#偏导数、方向导数、梯度" class="headerlink" title="偏导数、方向导数、梯度"></a>偏导数、方向导数、梯度</h3><blockquote><p>参考阅读：</p><p><a href="https://www.cnblogs.com/shine-lee/p/11715033.html">直观理解梯度，以及偏导数、方向导数和法向量等 - shine-lee - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/CSDN_SUSAN/article/details/90166474">导数，偏导数，方向导数，梯度的理解—-微积分数学基础SUSAN的博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/488961148">通俗理解方向导数与梯度 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/31942912">多元函数的偏导数、方向导数、梯度以及微分之间的关系思考 - 知乎 (zhihu.com)</a></p></blockquote><p>🔴 $\textcolor{red}{偏导数}$</p><p>对于多元函数，求导数其实也是要求一个切线的斜率，但是由于曲面上的一个点的切线有<strong>无数条</strong>，那么取那条切线的斜率？引入： <strong>偏导数</strong>。</p><p><strong>偏导数</strong>：可以理解成<strong>多元函数“退化”成一元函数时的导数</strong> ；“退化”：固定其他变量的值，只保留一个变量，依次保留每个变量，则$N$元函数有$N$个偏导数。</p><ul><li><strong>几何意义</strong>：也是切线斜率， 由于曲面上一点的切线有无数条（所有切线组成一个<strong>切面</strong>），偏导数选取的是<font color="red">垂直于各坐标轴</font>的几条特殊切线的<strong>斜率</strong>。</li><li><strong>物理意义</strong>：表示函数沿着<font color="red">某个坐标轴方向上</font>的<strong>变化率</strong></li></ul><p>以二元函数$z=f(x,y)$为例，求$(x_0,y_0,z_0)$的偏导数：</p><ul><li>对$x$的偏导数：过点$(x_0,y_0,z_0)$且垂直于$y$轴的曲线（相当于固定$y$值），在该点切线的斜率</li><li>对$y$的偏导数：过点$(x_0,y_0,z_0)$且垂直于$x$轴的曲线（相当于固定$x$值），在该点切线的斜率</li></ul><p><img src="https://s2.loli.net/2022/08/05/rkE4F6G1TfhS38i.png" alt="image.png" style="zoom:40%;"></p><p>🔴 $\textcolor{red}{方向导数}$</p><p>偏导数计算的是垂直于各坐标轴的几条特殊切线的斜率，某点的切线沿着不同方向有无数条 👉想求某点沿着<font color="red">任意方向</font>的切线斜率？引入：<strong>方向导数</strong>（补充：既然切线都分布在一个平面上，并且每一条切线都代表着函数朝着某一方向的变化率，那么在这个平面上就<strong>必定会存在唯一的一条切线的方向导数最大</strong>。（梯度为0的情况除外）</p><p>以二元函数$z=f(x,y)$为例，求$(x_0,y_0,z_0)$的某方向导数：（<a href="https://www.geogebra.org/m/Bx8nFMNc">下图动态演示地址</a>）</p><ul><li>$x$轴和$y$轴决定的平面上选择某一个方向向量（图中斜着的红色箭头），该方向所在的这个黄色平面 与 蓝色曲面相交 决定了一条过$(x_0,y_0,z_0)$的曲线（隐隐约约的红色细线描出来的部分），点在该曲线上的这条黑色切线斜率即为方向导数</li></ul><p><img src="https://s2.loli.net/2022/08/05/uRhCXbatP98DTxe.png" alt="image.png" style="zoom:33%;"></p><ul><li>设一个方向向量为$\overrightarrow{\mathrm{u}}=(\cos \alpha, \sin \alpha)$ （$\alpha$和$\beta$分别为该方向向量与$x$轴和$y$轴的夹角），则方向导数定义如下，它是个标量：<script type="math/tex; mode=display">\mathrm{D}_{\mathrm{u}} \mathrm{f}(\mathrm{x}, \mathrm{y})=\mathrm{f}_{\mathrm{x}}(\mathrm{x}, \mathrm{y}) \cos \alpha+\mathrm{f}_{\mathrm{y}}(\mathrm{x}, \mathrm{y}) \sin \alpha</script>进一步地，设偏导向量$\overrightarrow{\mathrm{A}}=\left(\mathrm{f}_{\mathrm{x}}(\mathrm{x}, \mathrm{y}), \mathrm{f}_{\mathrm{y}}(\mathrm{x}, \mathrm{y})\right)$，则上述方向导数可以改写为：<script type="math/tex; mode=display">\mathrm{D}_{\mathrm{u}} \mathrm{f}(\mathrm{x}, \mathrm{y})=\overrightarrow{\mathrm{A}} * \overrightarrow{\mathrm{u}}=|\overrightarrow{\mathrm{A}}| *|\overrightarrow{\mathrm{u}}| * \cos (\theta)</script>$ \theta$ 是偏导向量和方向向量之间的夹角。当$\theta=0$即二者同向时，方向导数$D_{u} f(x, y)$取得<strong>正</strong>最大值。反向时，则<strong>负</strong>最大值。</li></ul><p>🔴 $\textcolor{red}{梯度}$</p><p><strong>梯度：</strong>是一个矢量，函数在某点 无数个变化方向中 <strong>变化最快</strong>的 <u><strong>那个方向</strong></u></p><blockquote><p>即：偏导数构成的向量；由此：方向导数 = 梯度 * 方向向量</p></blockquote><p>函数只要<strong>每一个变量</strong>都沿着关于这个变量的<strong>偏导所指定的方向</strong>来变化，函数的整体变化就能达到最快（变化的绝对值最大）</p><p><strong>梯度的几何意义</strong>：</p><ol><li>当前位置的<strong>梯度方向</strong>，为函数在该位置处<strong>方向导数最大的方向</strong>，也是函数值<strong>上升最快的方向</strong>，反方向为下降最快的方向；</li><li>当前位置的<strong>梯度长度（模）</strong>，为最大方向导数的值</li><li>梯度（下降）的方向与<strong>等高线的切线方向垂直</strong></li></ol><p>以二元函数$z=f(x,y)$为例，其方向导数定义如下：</p><script type="math/tex; mode=display">\nabla f\left(x_{0}, y_{0}\right)=\left.\left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\right)\right|_{\left(x_{0}, y_{0}\right)}</script><hr><h2 id="微积分基础"><a href="#微积分基础" class="headerlink" title="微积分基础"></a>微积分基础</h2><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/BV1U94y1R71P?p=11&amp;spm_id_from=pageDriver&amp;vd_source=29f5937d4c8dc6b894a81d48deba4d66">3-定积分_哔哩哔哩_bilibili</a></p></blockquote><p>🔴 $\textcolor{red}{区分\Delta y和dy}$</p><p><img src="https://s2.loli.net/2022/08/06/1PtNzyeOvaKbkRV.png" alt="image.png" style="zoom:50%;"></p><h3 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h3><p>🔴 $\textcolor{red}{定义}$</p><p><img src="https://s2.loli.net/2022/08/06/O7ZjLAptkUSNln3.png" alt="image.png" style="zoom: 50%;"></p><p>🔴 $\textcolor{red}{积分上限函数}$</p><p>函数$f(x)$在区间$[a,b]$上连续，对于定积分$\int_{a}^{x} f(x) d x$每一个取值$x$都有一个对应的定积分值，记作$\Phi(x)= \int_{a}^{x} f(t) dt$</p><p>若函数$f(x)$在区间$[a,b]$上连续，则积分上限函数就是$f(x)$在$[a,b]$上的原函数</p><h3 id="两大积分中值定理"><a href="#两大积分中值定理" class="headerlink" title="两大积分中值定理"></a>两大积分中值定理</h3><p>🔴 $\textcolor{red}{第一中值定理}$</p><p>如果函数$f(x)$在闭区间$[a,b]$上连续，则在积分区间$[a,b]$上，至少存在一个点$\xi$，使$\int_{a}^{b} f(x) d x=f(\xi)(b-a) . \quad(a \leq \xi \leq b)$</p><p><img src="https://s2.loli.net/2022/08/06/7iEsOulChydFNkU.png" alt="image.png" style="zoom:50%;"></p><p>🔴 $\textcolor{red}{第二中值定理}$</p><h3 id="三大微分中值定理"><a href="#三大微分中值定理" class="headerlink" title="三大微分中值定理"></a>三大微分中值定理</h3><h3 id="牛顿-莱布尼兹公式"><a href="#牛顿-莱布尼兹公式" class="headerlink" title="牛顿-莱布尼兹公式"></a>牛顿-莱布尼兹公式</h3><p>🔴 $\textcolor{red}{定义}$</p><p>如果$F(x)$是连续函数$f(x)$在区间$[a,b]$上的一个原函数，则$\int_{a}^{b} f(x) d x=F(a)-F(b)$。</p><blockquote><p>即：一个连续函数在区间$[a,b]$上的定积分等于它的任意一个原函数在区间$[a,b]$上的增量</p></blockquote><p>🔴 $\textcolor{red}{几何解释}$</p><p>可得：$f(b)-f(a)=\sum dy$，由于$dy=f’(x)dx$，$f(b)-f(a)=\sum f’(x)dx= \int_{a}^{b}f’(x)dx $</p><p><img src="https://s2.loli.net/2022/08/06/R1O8iWub7dXer62.png" alt="image.png" style="zoom:40%;"></p><hr><h2 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h2><blockquote><p>用简单的熟悉的多项式来近似代替复杂的函数</p></blockquote><p>🔴 $\textcolor{red}{泰勒多项式}$</p><p>$f(x)$在$x_0$关于$(x-x_0)$的n阶泰勒多项式：</p><script type="math/tex; mode=display">\begin{array}{l}P_{n}(x)=f\left(x_{0}\right)+f^{\prime}\left(x_{0}\right)\left(x-x_{0}\right)+\frac{f^{\prime \prime}\left(x_{0}\right)}{2 !}\left(x-x_{0}\right)^{2}+ \cdots \quad+\frac{f^{(n)}\left(x_{0}\right)}{n !}\left(x-x_{0}\right)^{n}\end{array}</script><p>🔴 $\textcolor{red}{麦克劳林公式}$</p><p>令$x_0=0$：</p><script type="math/tex; mode=display">\begin{aligned}f(x)=& f(0)+f^{\prime}(0) x+\frac{f^{\prime \prime}(0)}{2 !} x^{2}+\cdots+\frac{f^{(n)}(0)}{n !} x^{n}+\frac{f^{(n+1)}(\theta x)}{(n+1) !} x^{n+1}(0<\theta<1)\end{aligned}</script><p>🔴 $\textcolor{red}{泰勒多项式中 阶数的作用}$</p><ul><li>阶数越高，增长速度越快；越高次项在越偏右侧影响越大</li><li>对于一个复杂函数，低阶项能更好地描述当前点附近，对于之后的走势就越来越依靠高阶项</li></ul><hr><h2 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h2><h2 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h2><blockquote><p>寻找变量受一个或多个条件限制的多元函数的极值</p><p>参考阅读：<a href="https://www.zhihu.com/question/38586401">如何理解拉格朗日乘子法？ - 知乎 (zhihu.com)</a></p></blockquote><p><img src="https://s2.loli.net/2022/08/06/JqrMlxpIzNFVwRS.png" alt="image.png" style="zoom: 30%;"></p><p>例如对于一个二元函数函数：$z=f(x,y)$在条件$\varphi(x, y)=0$下的极值，构造函数$F(x,y)=f(x,y)+\lambda \varphi(x, y)$，其中$\lambda$为拉格朗日乘数，构造下列函数求得极值点坐标：</p><script type="math/tex; mode=display">\left\{\begin{array}{c}f_{x}(x, y)+\lambda \varphi_{x}(x, y)=0 \\f_{y}(x, y)+\lambda \varphi_{y}(x, y)=0 \\\varphi(x, y)=0\end{array}\right.</script><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><blockquote><p>参考阅读：</p><p><a href="https://zhuanlan.zhihu.com/p/327042762">矩阵乘法核心思想（1）：列空间 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>🔴 $\textcolor{red}{线性变换}$</p><script type="math/tex; mode=display">\begin{array}{c}L(\overrightarrow{\mathbf{v}}+\overrightarrow{\mathbf{w}})=L(\overrightarrow{\mathbf{v}})+L(\overrightarrow{\mathbf{w}}) \\L(c \overrightarrow{\mathbf{v}})=c L(\overrightarrow{\mathbf{v}})\end{array}</script><p><strong>几何角度理解</strong>：它是网格线保持平行且等距分布的变换（1）直线在变换后仍保持直线，不弯曲 （2）原点必须固定</p><p>一种矩阵相乘的几何理解方式👉<strong>线性变换作用于给定向量</strong>：把矩阵的列看作<strong>变换后的基向量</strong>，矩阵向量乘法看作它们的线性组合</p><p><img src="https://s2.loli.net/2022/08/07/AiGpU7y1XshJtE4.png" alt="image.png" style="zoom:33%;"></p><h2 id="线性相关和线性无关"><a href="#线性相关和线性无关" class="headerlink" title="线性相关和线性无关"></a>线性相关和线性无关</h2><p>🔴 $\textcolor{red}{张成空间}$</p><p>所有可以表示为给定向量 线性组合 的向量的集合，被称为给定向量的张成空间</p><blockquote><p>仅通过向量加法和数乘，所能获得的可能向量的集合</p></blockquote><p>🔴 $\textcolor{red}{线性组合}$</p><p>m个n维向量$\alpha_{1},\alpha_{2},…,\alpha_{m}$，及m个数$k_{1},k_{2},…,k_{m}$，则向量$k_{1}\alpha_{1}+k_{2}\alpha_{2}+…+k_{m}\alpha_{m}$称为向量$\alpha_{1},\alpha_{2},…,\alpha_{m}$的一个线性组合</p><blockquote><p>多个数乘向量的和</p><p><strong>线性</strong>是指向量乘以一个标量，沿着向量的方向缩放，方向不变；<strong>组合</strong>是把多个向量加起来</p></blockquote><p>🔴 $\textcolor{red}{线性相关和线性无关}$</p><p>对m个n维向量$\alpha_{1},\alpha_{2},…,\alpha_{m}$，若<strong>存在不全为0</strong>的数$k_{1},k_{2},…,k_{m}$，使得$k_{1}\alpha_{1}+k_{2}\alpha_{2}+…+k_{m}\alpha_{m}=0$成立，则称$\alpha_{1},\alpha_{2},…,\alpha_{m}$<strong>线性相关</strong>，否则称线性无关</p><blockquote><p>或者说，一个向量可以表示为其他向量的线性组合，那么这些向量线性相关</p></blockquote><p><strong>几何角度理解</strong>：</p><ul><li><p><strong>线性相关</strong>：一组向量中至少有一个是<strong>多余</strong>的，没有对张成空间做出贡献，可以移除其中一个而不减小张成空间</p></li><li><p><strong>线性无关</strong>：一组向量中的所有向量都给张成空间<strong>增添了新的维度</strong></p><blockquote><p>比如对于$\vec a$ 和$\vec b$ 张成的二维平面，若$\vec c$  刚好落在该平面中，那么$\vec c$ 的加入对张成空间没有任何贡献，仍然是一个二维平面，说明它们三个是线性相关的；如果$\vec c$ 没有落在那个二维平面，而使得张成空间变成一个三维空间了，说明它们三个是线性无关的</p></blockquote></li><li><p><strong>或者说</strong>：一组矢量的线性相关性本质上，是描述他们所张成的<strong>广义平行四边形体积是否为零</strong>。N个向量线性无关👉他们所张成的N维体的体积不为零。于是有：<strong>线性无关矢量</strong>组成的矩阵的<strong>行列式不为零</strong>；线性相关矢量组成的矩阵的行列式必为零。</p></li></ul><p>🔴 $\textcolor{red}{空间中的一组基}$</p><p>向量空间中的一组基是<strong>张成该空间</strong>的一个<strong>线性无关</strong>的<strong>向量集合</strong></p><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>🔴 $\textcolor{red}{行列式的几何意义}$</p><p>可以理解为<strong>线性变换的比例</strong>，如果是负数，说明变换后的<strong>空间定向</strong>发生改变</p><blockquote><p>例如，一个线性变换作用于一个2x2矩阵，该线性变换的行列式是1/2，那么变换后的区域的面积变成了原来的1/2（三维则是体积的缩放）；</p></blockquote><p>若一个二维线性变换的<strong>行列式为0</strong>，说明它将整个平面<strong>压缩到一条线，甚至一个点</strong>上，👉根据行列式是否=0，就能知道这个矩阵所代表的变换是否将空间压缩到更小的维度上</p><blockquote><p>或者理解为：<strong>向量围成空间的面积或体积</strong>；行列式就是在给定一组基下，N个向量张成的一个N维广义四边形的体积。2阶行列式代表的是平面内的面积；3阶行列式自然而然就是3维空间内的体积；4阶行列式是4维空间里的超体积</p></blockquote><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>🔴 $\textcolor{red}{逆矩阵}$</p><p><strong>理论定义</strong>：</p><p><strong>理解</strong>：$Ax=v $  ⇨ $A^{-1}Ax=A^{-1}v$  ⇨ $x=A^{-1}v$</p><p>寻找一个向量$x$，使得它在经过线性变换$A$ 之后与 $v$ 重合：$Ax=v$</p><ul><li>若行列式$|A|=0$，说明线性变换$A$ 将<strong>空间压缩</strong>到了<strong>更低</strong>维度→ <strong>不存在</strong>$A^{-1}$</li><li>若$|A|\neq 0$（<strong>← 矩阵可逆的充要条件</strong>），说明原来的空间<strong>没被挤压</strong>，在这种情况下，有且仅有一个向量$x$在变换后与$v$重合</li></ul><p>即便不存在$A^{-1}$，<strong>解仍然可能存在</strong>：$A$将空间压缩为一条直线，而原本的$v$也刚好落在这条直线上</p><p>🔴 $\textcolor{red}{秩}$</p><p><strong>理论定义</strong>：</p><p><strong>几何角度理解</strong>：代表<strong>变换后的维数</strong></p><blockquote><p>若一个线性变换作用的结果是一维的，则这个变换的秩是1，二维的则是2… </p><p>一个3x3的矩阵，秩=2，说明空间被压缩</p></blockquote><p>🔴 $\textcolor{red}{列空间}$</p><p>所有可能的输出向量$Av$构成的集合称作$A$的列空间（矩阵的列所张成的空间）；</p><p>更精确地讲，秩是列空间的维数</p><blockquote><p>用于线性变换的矩阵的列 可以看作 变换后的基向量，这些变换后的基向量张成的空间就是所有可能的变换结果</p></blockquote><p>🔴 $\textcolor{red}{满秩}$</p><p>对于一个满秩变换：唯一能在变换后落在原来的点就是零向量本身；</p><p>对于非满秩变换，它将空间压缩到一个更低的维度上⇨ 会有一系列在变换后称为零向量</p><blockquote><p>一个二维线性变换将空间压缩到一条直线上，那么沿着某个不同于该直线的方向的所有向量都被压缩到原点</p></blockquote><p><strong>零空间</strong>（核）：变换后会落在原点的向量的集合；对于$Ax=0$，零空间给出了这个向量方程所有可能的解</p><h3 id="各种矩阵"><a href="#各种矩阵" class="headerlink" title="各种矩阵"></a>各种矩阵</h3><p>🔴 $\textcolor{red}{正定矩阵}$</p><p>🔴 $\textcolor{red}{正交矩阵}$</p><p>🔴 $\textcolor{red}{对称矩阵}$</p><p>🔴 $\textcolor{red}{矩阵合同}$</p><p>🔴 $\textcolor{red}{相似矩阵}$</p><h2 id="内积和外积"><a href="#内积和外积" class="headerlink" title="内积和外积"></a>内积和外积</h2><blockquote><p>点积（点乘），叉积（叉乘）</p></blockquote><h3 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h3><p>🔴 $\textcolor{red}{定义}$</p><p>设有$n$维向量，$x=\begin{pmatrix}x_1\\ x_2\\ \vdots\\ x_n\end{pmatrix}$，$y=\begin{pmatrix}y_1 \\y_2\\ \vdots \\y_n\end{pmatrix}$，$x$和$y$的内积 $x  \bullet y$ 如下：</p><script type="math/tex; mode=display">x^{T} y=\left(x_{1}, x_{2}, \cdots, x_{n}\right)\left(\begin{array}{c}y_{1} \\y_{2} \\\vdots \\y_{n}\end{array}\right)=x_1y_1+x_2y_2+...+x_ny_n</script><p>🔴 $\textcolor{red}{几何意义}$</p><p>$v\cdot w$的结果：$w$在$v$上的投影长度 乘 $v$的长度： $|w||v|cos \theta$</p><p><img src="https://s2.loli.net/2022/08/07/IaBn9Uf7jOD3PFV.png" alt="image.png" style="zoom: 33%;"></p><h3 id="外积"><a href="#外积" class="headerlink" title="外积"></a>外积</h3><p>外积的结果是<strong>一个向量</strong>，并非一个数 </p><p>以二维为例，结果就是两个向量围成的平行四边形的<strong>面积</strong></p><p><img src="https://s2.loli.net/2022/08/07/QUa8VjlWvgfxrZO.png" alt="image.png" style="zoom:33%;"></p><p>面积的计算可以考虑行列式、$|v\times w| =|v||w|sin\theta$</p><p>方向的确定（基向量的确定就是定向的基础）：</p><p><img src="https://s2.loli.net/2022/08/07/pHjM3ktqFQcrzKa.png" alt="image.png" style="zoom:33%;"></p><font color="red">真正的叉积是两个三维向量生成一个新的三维向量</font><p>方向的确定（右手定则）：</p><p><img src="https://s2.loli.net/2022/08/07/Gow7FAyfa5RbxHi.png" alt="image.png" style="zoom:33%;"></p><p>计算：</p><p><img src="https://s2.loli.net/2022/08/07/K7Bk1T4mO8gcPsi.png" alt="image.png" style="zoom:33%;"></p><h2 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h2><p>🔴 $\textcolor{red}{定义}$</p><p>给定一个矩阵$A$，寻找一个常数$\lambda$和一个非零向量$x$ ，使得向量$x$被矩阵$A$作用后所得到的向量$Ax$ 与 原向量$x$ 平行，并且满足$Ax = \lambda x$ 。那么，$\lambda$：特征值，$x$：特征向量。</p><p><strong>求特征向量</strong>：$Ax=\lambda Ix$ （$I$是单位对角阵），$(A-\lambda I)x=0$，$x$是非零向量，因为当且仅当矩阵代表的变换将空间压缩到更低维度时，才会存在一个非零向量，使得矩阵和它的乘积为0，所以最终就是求行列式$|A-\lambda I|=0$</p><p>🔴 $\textcolor{red}{理解}$</p><p><strong>几何角度理解</strong>：</p><ul><li>将一个线性变换施加在一个基上，线性变换后<strong>仍然留在</strong>原来的基所张成的空间里的向量，就是这个线性变换的特征向量，任何其他向量在变换中都有或多或少的旋转→离开它原来张成的那条直线。</li><li>每个特征向量都有一个所属的值：特征值，它是用来衡量特征向量在线性变换中拉伸或压缩比例的因子。</li></ul><blockquote><p>例如某特征向量的特征值是-1/2，意味着原向量被反向且压缩为原来的1/2，但它仍然留在原来张成的直线上，并为发生旋转。</p><p>考虑一个三维空间的旋转，若能找到这个旋转的特征向量，也就相当于找到了它的旋转轴，这种情况下，相应的特征值=1：旋转不缩放任何一个向量</p></blockquote><p><strong>特征值越大</strong>，我们可以认为<strong>对应的特征向量越重要</strong>。既然特征值表达了重要程度且和特征向量所对应，那么特征值大的就是主要信息，基于这点我们可以提取各种有价值的信息。</p><p>🔴 $\textcolor{red}{特征空间}$</p><p>特征空间包含了所有的特征向量</p><p>🔴 $\textcolor{red}{基变换}$</p><p>数据与第一个基做内积运算，结果为第一个新的坐标分量，依次类推，例如数据$(3,2)$映射到给定的一个基上的坐标：</p><script type="math/tex; mode=display">\begin{pmatrix}1/\sqrt2  &1/\sqrt2 \\-1/\sqrt2  &1/\sqrt2\end{pmatrix}\begin{pmatrix}3 \\2\end{pmatrix}=\begin{pmatrix}5/\sqrt[]{2}   \\-1/\sqrt[]{2} \end{pmatrix}</script><h2 id="特征值分解"><a href="#特征值分解" class="headerlink" title="特征值分解"></a>特征值分解</h2><hr><h1 id="概率论与梳理统计"><a href="#概率论与梳理统计" class="headerlink" title="概率论与梳理统计"></a>概率论与梳理统计</h1><h2 id="大数定律和中心极限定理"><a href="#大数定律和中心极限定理" class="headerlink" title="大数定律和中心极限定理"></a>大数定律和中心极限定理</h2><p>中心极限定理是说<font color="red">无论抽样分布如何 均值服从正态分布 </font>，而大数定律根本和正态分布无关 是说样本大了抽样分布近似总体分布</p><blockquote><p>参考阅读：</p><p><a href="https://blog.csdn.net/haoso2/article/details/85290720?ops_request_misc=%7B%22request%5Fid%22%3A%22165976780516782395311447%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165976780516782395311447&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-85290720-null-null.nonecase&amp;utm_term=大数定理&amp;spm=1018.2226.3001.4450"> 大数定理的通俗理解_haso的博客-CSDN博客</a></p><p><a href="https://www.zhihu.com/question/22913867">怎样理解和区分中心极限定理与大数定律？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/question/19911209/answer/245487255">大数定律具体是个什么概念？ - 知乎 (zhihu.com)</a></p></blockquote><h3 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h3><p>🔴 $\textcolor{red}{关键理解}$</p><ul><li><p>小数定律：如果统计数据很少，那么事件就表现为各种极端情况，而这些情况都是偶然事件，跟它的期望值一点关系都没有</p></li><li><p>大数定律：在试验不变的条件下，重复试验多次，那么随机事件出现的<strong>频率</strong>就能无限接近它的<strong>期望值（概率）</strong>。因此我们可以用样本均值来估计总体的期望。</p></li></ul><p>🔴 $\textcolor{red}{切比雪夫大数定律(一般情形)}$</p><p>设$ X_{1}, X_{2}, \ldots, X_{n}, \ldots $是由两两不相关（或两两独立）的随机变量所构成的序列, 分别具有 数学期望$E\left(X_{1}\right), E\left(X_{2}\right), \ldots, E\left(X_{n}\right), \ldots $和方差$D\left(X_{1}\right), D\left(X_{2}\right), \ldots D\left(X_{n}\right), \ldots ,$ 并且方差 有公共上界, 即存在正数  $M$ , 使得 $D\left(X_{n}\right) \leq M, n=1,2, \ldots ,$则对于任意给定的正数 $\varepsilon$ 总有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|\frac{1}{n} \sum_{k=1}^{n} X_{k}-\frac{1}{n} \sum_{k=1}^{n} E X_{k}\right|<\varepsilon\right\}=1</script><blockquote><p>这些变量的均值 依概率收敛为 这些期望的均值</p></blockquote><p>🔴 $\textcolor{red}{独立同分布的切比雪夫大数定律(特殊情形)}$</p><p>设随机变量$X_{1}, X_{2}, \ldots, X_{n}, \ldots$<strong>相互独立, 服从相同的分布</strong>, 具有数学期望$E\left(X_{n}\right)=\mu$ 和 方差$D\left(X_{n}\right)=\sigma^{2}(n=1,2, \ldots)$，则对于任意给定的正数$\varepsilon$，总有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|\frac{1}{n} \sum_{k=1}^{n} X_{k}-\mu\right|<\varepsilon\right\}=1,即随机变量序列  \overline{X_{n}}=\frac{1}{n} \sum_{k=1}^{n} X_{k} \stackrel{P}{\longrightarrow} \mu .</script><p>🔴 $\textcolor{red}{辛钦大数定律}$</p><p>设随机变量$X_{1}, X_{2}, \ldots, X_{n}, \ldots$<strong>相互独立, 服从相同的分布</strong>，具有数学期望$E\left(X_{n}\right)=\mu (n=1,2, \ldots)$，则对于任意给定的正数$\varepsilon$，总有</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|\frac{1}{n} \sum_{k=1}^{n} X_{k}-\mu\right|<\varepsilon\right\}=1</script><p>🔴 $\textcolor{red}{伯努利大数定律}$</p><blockquote><p>它的直观表达就是只要做的试验够多，出现的次数 除以 总次数的结果 接近 统计概率p</p></blockquote><p>设在每次实验中$A$发生的概率$P(A)=p$，在$n$次独立重复实验中，事件$A$发生的频率为$f_n(A)$，则对任意正数$\varepsilon$，总有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|f_n(A)-p\right|<\varepsilon\right\}=1</script><h3 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h3><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/BV1ah411q7tp/?spm_id_from=333.788&amp;vd_source=29f5937d4c8dc6b894a81d48deba4d66">中心极限定理的直观理解_哔哩哔哩_bilibili</a></p></blockquote><p>🔴 $\textcolor{red}{关键理解}$</p><ul><li><p>中心极限定理告诉我们，当样本量足够大时<strong>，样本均值的抽样分布</strong>慢慢趋近于<strong>正态分布</strong></p></li><li><p>不管总体是什么分布，任意一个<strong>总体的样本</strong>平均值都会围绕在<strong>总体的整体平均值</strong>周围，并且呈正态分布</p></li></ul><p>🔴 $\textcolor{red}{棣莫弗-拉普拉斯中心极限定理}$</p><p>设随机变量$X_n$服从参数$n$和$p$的二项分布，即$X_n\sim B(n,p)(0&lt;p&lt;1,n=1,2,\dots)$，则对于任意实数$x$，有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\frac{X_{n}-n p}{\sqrt{n p(1-p)}} \leq x\right\}=\Phi(x)</script><p>$\Phi(x)$为标准正态分布的分布函数</p><p>🔴 $\textcolor{red}{列维-林德伯格中心极限定理}$</p><p>设随机变量$X_{1}, X_{2}, \ldots, X_{n}, \ldots$<strong>相互独立, 服从相同的分布</strong>, 具有数学期望$E\left(X_{n}\right)=\mu$ 和 方差$D\left(X_{n}\right)=\sigma^{2}(n=1,2, \ldots)$，则对于任意实数$x$，有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\frac{\sum_{k=1}^{n} X_{k}-n \mu}{\sqrt{n} \sigma} \leq x\right\}=\Phi(x)</script><p>$\Phi(x)$为标准正态分布的分布函数</p><h2 id="全概率公式和贝叶斯公式"><a href="#全概率公式和贝叶斯公式" class="headerlink" title="全概率公式和贝叶斯公式"></a>全概率公式和贝叶斯公式</h2><h2 id="各种分布"><a href="#各种分布" class="headerlink" title="各种分布"></a>各种分布</h2><h2 id="协方差和相关系数"><a href="#协方差和相关系数" class="headerlink" title="协方差和相关系数"></a>协方差和相关系数</h2><h1 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h1><h2 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h2><blockquote><p>参考阅读：</p><p><a href="https://zhuanlan.zhihu.com/p/376118280">【群论入门】(2)：模算术 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/377775196">【群论入门】(3): 群的定义 - 知乎 (zhihu.com)</a></p><p><a href="https://www.bilibili.com/video/BV1qf4y1m7K1?spm_id_from=333.337.search-card.all.click&amp;vd_source=29f5937d4c8dc6b894a81d48deba4d66">【近代应用数学-南京大学】给非数学系的基础入门款 群论/实变/点集拓扑/泛函_哔哩哔哩_bilibili</a></p></blockquote><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>🔴 $\textcolor{red}{代数运算}$</p><p>设$A$非空集合，引入一个法则，使得$A$中任意两个元素与$A$中另一个元素唯一对应，那么可以把这个法则称为$A$上的一个代数运算</p><blockquote><p>例如：A是实数集合$\mathbb{R}$，法则→加法$+$；$\forall x,y\in \mathbb{R}$，$x+y\in \mathbb{R}$。</p><p>又如：向量的内积就不是一个代数运算，$\vec a,\vec b\in V$，$\vec a \cdot \vec b \in \mathbb{R}$，也就是说$V\cdot V\to \mathbb{R}$</p></blockquote><p>🔴 $\textcolor{red}{半群}$</p><p>设$(S，∗)$ 是一个代数系统，“∗”是非空集合S上的一个代数运算。若</p><p>​    （1）“∗”具有<strong>封闭性</strong>，即∗是S上的闭运算；    （2）“∗”满足<strong>结合律</strong>。</p><p>则称(S，∗)是一个半群。</p><blockquote><p>比如，G={2，4，6，8，…}，（G,+)就是一个半群，只满足结合律，没有幺元<u>0</u>，也没有逆元<u>负数</u></p></blockquote><p>🔴 $\textcolor{red}{幺元}$</p><p>设$(S，∗)$是一个代数系统，      </p><p>（1）若存在$e_右∈S$，使得对于任意的$x∈S$，有$x∗e_右=x$，则称$e_右$是<strong>右幺元</strong>。      </p><p>（2）若存在$e_左∈S$，使得对于任意的$x∈S$，有$e_左∗x=x$，则称$e_ 左$是<strong>左幺元</strong>。     </p><p>（3）若存在一个元素e∈S，它<strong>既是左幺元，又是右幺元</strong>，则称e是<strong>幺元（又称单位元）</strong>。</p><p><strong>若有幺元，则幺元唯一</strong>。    </p><blockquote><p> 证明：设$e_左，e_右∈S$分别是左幺元和右幺元，则有$e_左=e_左∗e_右=e_右$</p><p> 若有$e_1，e_2∈S$，且均是幺元，则有$e_1=e_1∗e_2=e_2$通常用$e$表示么元</p></blockquote><p>🔴 $\textcolor{red}{含幺半群}$</p><p>称含有<strong>幺元的半群</strong>为含幺半群。     </p><blockquote><p>比如 0是半群$(N，+)$的幺元，而1是半群$(N，×)$的幺元。$(N，+)$和$(N，×)$都是含幺半群</p></blockquote><p><strong>子半群</strong>：设$(S，∗)$是一个半群，$∅≠A⊆S$，若$(A，∗)$<strong>本身是一个半群</strong>，则称$(A，∗)$是$(S，∗)$的子半群</p><blockquote><p>比如：G={0，2，4，6，8，…}，（G,+)就是一个幺半群，满足结合律，<strong>有</strong>幺元<u>0</u>，也没有逆元<u>负数</u></p><p>若，G={0，±1，±2，…}，(G,+)就是一个群；</p><p>最小的群：（G,$\circ$) = {e}</p></blockquote><p>🔴 $\textcolor{red}{逆元}$</p><p>设$(S，∗)$是一个代数系统，$e∈S$是<strong>幺元</strong>，$a∈S$。     </p><p>（1）若存在$b∈S$，使得$a∗b=e$，则称$b$是$a$的<strong>右逆元</strong>；     </p><p>（2）若存在$d∈S$，使得$d∗a=e$，则称$d$是$a$的<strong>左逆元</strong>；     </p><p>（3）若存在$a^′∈S$，使得$a^′$既是$ a$的<strong>左逆元</strong>，又是$a$的<strong>右逆元</strong>，则称$a^′$是$a$的逆元。</p><blockquote><p>设(S，∗)是一个代数系统，∗满足结合律，e∈S是幺元，a∈S是任意的元素，则     </p><p>（1）若a既有左逆元，又有右逆元，则a的<strong>左逆元等于右逆元</strong>，即为a的逆元。    </p><p>（2）a的逆元<strong>若存在，则唯一</strong>。</p></blockquote><p>🔴 $\textcolor{red}{群的定义}$</p><p>$(S，∗)$是一个代数系统，若$(S，∗)$满足以下四条：       </p><p>（1）”∗”是$S$上的<strong>闭运算</strong>；       </p><p>（2）”∗”适合<strong>结合律</strong>；       </p><p>（3）存在<strong>幺元</strong>$e∈S$（又称之为单位元）；       </p><p>（4）对于$S$中的任意元素$a$，存在<strong>逆元</strong>$a^{−1}∈S$。</p><p>则称$(S，∗)$是一个群。</p><p><strong>半群</strong>：(1)+(2)；<strong>幺半群</strong>：(1)+(2)+(3)</p><p>🔴 $\textcolor{red}{左右消去律}$</p><p>设$(S，∙)$是一个代数系统。若对于任意的$x，y，z∈S$，满足       </p><p>如果$x∙y=x∙z$，那么$y=z$，则称“$∙$”运算满足左消去律；        </p><p>如果$y∙x=z∙x$，那么$y=z$，则称“$∙$”运算满足右消去律。 </p><p>设$(G，∙)$是一个群，则“$∙$”运算分别满足左、右消去律</p><p>🔴 $\textcolor{red}{群的性质}$</p><p>🔸 群$(G,\circ)$，若$a,b\in G$，$b\circ a=e$，则$a\circ b=e$</p><p>🔸 群$(G,\circ)$，$e$，$\forall a\in G$，$e\circ a=a\circ e =a$</p><p>🔸 群$(G,\circ)$ 的幺元 $e$ 是唯一的</p><p>🔸 群$(G,\circ)$ ，$\forall a\in G$，$a$ 的逆元是唯一的</p><p>🔴 $\textcolor{red}{幂}$</p><p>$a\in G,n\in \mathbb{N},a^n=a…a,\quad a^0=e,a^{-1}=a的逆元，(a^{-1})^n = a^{-n}$</p><p>∴ $a^{m+n}=a^m \circ a^n,m、n\in \mathbb{Z}$</p><p>∴ $(a^n)^m = a^{nm}$</p><p>🔴 $\textcolor{red}{阶}$</p><p>群$(G,\circ)$，$a\in G$，$a^m=e$的最小的$m\in \mathbb{N}$，$m$称为$a$的阶，若找不到$m\in \mathbb{N}$，称$a$的阶为0</p><h3 id="群的同态和同构"><a href="#群的同态和同构" class="headerlink" title="群的同态和同构"></a>群的同态和同构</h3><p>🔴 $\textcolor{red}{同态和同构}$</p><p>设$(S_1，∗)$，$(S_2，∙)$是两个代数系统，“∗” 是$S_1$上的一个二元运算，“∙” 是$S_2$上的一个二元运算。设$f$是$S_1$到$S_2$的一个映射，即$f：S_1→S_2$。若对于$S_1$中的任意两个元素$x_1，x_2$，有$f(x_1∗x_2)=f(x_1)∙f(x_2)$，则称映射$f$是$S_1到S_2$的一个同态映射。      </p><ul><li>若$f$是单射，则称$f$是一个单一同态映射；     </li><li>若$f$是满射，则称$f$是一个满同态映射；      </li><li>若$f$是<strong>双射</strong>，则称$f$是一个<strong>同构映射</strong>。 </li></ul><p>若两个代数系统之间存在一个同构映射，则称这两个代数系统是同构的。</p><p>群的同构作为群的关系，是一个等价关系：满足自反性、对称性、传递性</p><p>🔴 $\textcolor{red}{例子}$</p><p><img src="https://s2.loli.net/2022/08/08/rnCjQweYhBoMd1a.png" alt="image.png" style="zoom: 43%;"></p><p><img src="https://s2.loli.net/2022/08/08/ljGVHB5L9Xe2kAv.png" alt="image.png" style="zoom:33%;"></p><p><img src="https://s2.loli.net/2022/08/08/XRTjeDCtJnuImdL.png" alt="image.png" style="zoom: 33%;"></p><h3 id="无限群和有限群"><a href="#无限群和有限群" class="headerlink" title="无限群和有限群"></a>无限群和有限群</h3><p>🔴 $\textcolor{red}{定义}$</p><p>设$(G，∙)$是一个群，     </p><p>若$G$是<strong>无限集</strong>，则称$(G，∙)$是无限群。      </p><p>若$G$是<strong>有限集</strong>，且$|G|=n$，则称$(G，∙)$是$n$阶有限群。      </p><p>🔴 $\textcolor{red}{阶}$</p><p><img src="https://s2.loli.net/2022/08/08/G14mgtHl9iCP6XW.png" alt="image.png" style="zoom:40%;"></p><blockquote><p> 比如：在整数加群$(Z，+$)中，对于任意的$a∈Z(a≠0)$，因为对于任意的正整数n，有$a+a+⋯+a(n个a)=na≠0$      所以，$o(a)=∞$</p></blockquote><p>设$(G，∙)$是一个交换群，对于任意的$ a，b∈G$，有$(a∙b)^n=a^n∙b^n$。</p><h3 id="交换群（阿贝尔群）"><a href="#交换群（阿贝尔群）" class="headerlink" title="交换群（阿贝尔群）"></a>交换群（阿贝尔群）</h3><p>对于$G$中任意两个元素$a，b∈G$，若满足交换律$，a∙b=b∙a$，则称$(G，∙)$是<strong>交换群</strong>，又称阿贝尔（Abel）群</p><h3 id="变换群-置换群-循环群"><a href="#变换群-置换群-循环群" class="headerlink" title="变换群 置换群 循环群"></a>变换群 置换群 循环群</h3><p>🔴 $\textcolor{red}{集合的变换}$</p><p>$A$非空集合，称由$A$到<strong>自身的映射</strong>$\tau：A\to A$ 称为集合上的一个变换，记为：$a\in A\to \tau(a)\in A$</p><p>满变换、单变换、一一变换</p><p>把集合$A$上的全体变换作成集合$S=\{\tau,\lambda,\mu,\dots\}$，规定$S$上的一个代数运算$\circ$，$\forall \tau,\lambda\in  S，\tau :a\to\tau(a);\lambda:a\to\lambda(a)$， 将$\lambda \circ \tau$定义为：$a\to \lambda(\tau(a))$。（也就是两个变换的复合）</p><p>这个“乘法“满足结合律：$\forall \tau,\lambda,\mu\in S，\tau(\lambda\mu)=(\tau\lambda)\mu $</p><p>🔴 $\textcolor{red}{变换群}$</p><p>设$A$是一个非空集合，$G$是由$A$到$A$的<strong>一些映射构成的集合</strong>，若$G$是关于运算“$∘$”构成的一个群，则称$(G，∘)$是集合$A$上的一个<strong>变换群</strong>。</p><p>🔴 $\textcolor{red}{Cayley定理}$</p><p>任何一个群都与一个变换群同构</p><p>🔴 $\textcolor{red}{置换群}$</p><p>设$A$是一个非空有限集，则    </p><p>（1）称$A$上的一个变换群为$A$上的一个置换群。    </p><p>（2）对于任意的$f∈∪(A^A)$，称$f$为集合$A$上的一个置换。     </p><p>🔴 $\textcolor{red}{循环群}$</p><p>设$(G，∙)$是一个群，$g∈G$。若$G$中每一个元素都是$g$的<strong>乘方</strong>，则称$G$为<strong>循环群</strong>，称$g$为<strong>生成元</strong>，并且用符号$G=(g)$表示，即$G=(g)={g^n│n∈Z}$。</p><blockquote><p>设$(G，∙)$是一个群，$g∈G$ ，</p><p>显然有$g^2∈G，g^3∈G，⋯$，即对于任意的正整数$n$，有$g^n∈G$；      </p><p>显然有$g^{−1}∈G，g^{−2}∈G，⋯$，即对于任意的正整数$n$，有$g^−n∈G$；      </p><p>规定$g^0∈G$是$G$中幺元。 </p><p>综上所述，对于任意整数$n∈Z，g^n∈G$。     显然，$({g^n│n∈Z}，∙)$是一个群。</p></blockquote><p>设$G=(g)$是一个循环群，如果$o(g)=n$，则$|G|=n$，且$G=(g)=\{g^0=e，g，g^2，⋯，g^{n−1}\}$</p><p>（1）若$o(g)=n$，则称$G$是$n$阶<strong>有限循环群</strong>。     （2）若$o(g)=∞$，则称$G$是<strong>无限循环群</strong></p><h3 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h3><p>🔴 $\textcolor{red}{子群定义}$</p><p>设$(G，∙)$是一个群，$∅≠A⊆G$，若$(A，∙)$也是一个群，则称$(A，∙)$$是(G，∙)$的子群。</p><h3 id="子群的陪集"><a href="#子群的陪集" class="headerlink" title="子群的陪集"></a>子群的陪集</h3><p>🔴 $\textcolor{red}{右陪集}$</p><p>设$(G，∙)$是一个群，$(H，∙)$是$(G，∙)$的一个子群，$a∈G$。称$H∙a=\{ℎ∙a|ℎ∈H\}$为子群$H$的<strong>右陪集</strong></p><p>🔴 $\textcolor{red}{左陪集}$</p><p>设$(G，∙)$是一个群，$(H，∙)$是$(G，∙)$的一个子群，$a∈G$。称$a∙H=\{a∙h|ℎ∈H\}$为子群$H$的<strong>左陪集</strong></p><h3 id="正规子群和商群"><a href="#正规子群和商群" class="headerlink" title="正规子群和商群"></a>正规子群和商群</h3><p>🔴 $\textcolor{red}{正规子群}$</p><p>设$G$是一个群，$H$是$G$的一个子群。若对于<strong>任意</strong>一个$a∈G$，有$a∙H=H∙a$即$a$关于$H$的<strong>左陪集等于右陪集</strong>，则称$H$是$G$的<strong>正规子群</strong>，或者称为不变子群</p><p>🔴 $\textcolor{red}{商群}$</p><p>设$G$是一个群，$H$是$G$的正规子群，$G/H=\{aH|a∈G\}$，对于任意的$aH$，$bH∈G/H$，$(aH)⊙(bH)=(ab)H$。则$(G/H，⊙)$是一个群。该群称为$G$的<strong>商群</strong>。</p><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】并查集</title>
      <link href="/2022/08/02/2022-08-02-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2022/08/02/2022-08-02-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容：并查集</li></ul><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>用于（近乎$O(1)$）快速地：</p><ol><li>将两个集合<strong>合并</strong></li><li><strong>询问</strong>两个元素是否在一个集合当中</li></ol><p><strong>基本原理</strong>：</p><ul><li>每个集合用一颗<strong>树</strong>维护，每棵树<strong>的根节点</strong>的编号即当前集合的编号</li><li>对于每个点，都存储<strong>它的父节点</strong>是谁 ：p[x]表示x的父节点</li><li>当要找某个点是否属于某个集合时，就<strong>往上找</strong>到根节点</li></ul><p><strong>如何判断树根：</strong></p><ul><li><code>if(p[x]==x)</code></li></ul><p><strong>如何求x的集合编号</strong></p><ul><li><code>while(p[x]!=x) x=p[x]</code>;</li><li>复杂度优化（路径压缩）：当x往上找的时候，一旦找到根节点，就把这条路径上的所有节点的父节点都指向根节点；基本上就能看成O（1）</li></ul><p><strong>如何合并两个集合</strong></p><ul><li>p[x]是x的集合编号，p[y]是y的集合编号：<code>p[x]=y</code></li></ul><hr><h1 id="AcWing836-合并集合（模板题）"><a href="#AcWing836-合并集合（模板题）" class="headerlink" title="AcWing836 合并集合（模板题）"></a>AcWing836 合并集合（模板题）</h1><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>进行 m个操作，操作有两种：</p><ol><li><code>M a b</code>，将编号为 a和 b的两个数所在的集合<strong>合并</strong>，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，<strong>询问</strong>编号为 a和 b 的两个数是否在<strong>同一个集合</strong>中；</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];<span class="comment">//p[i]:编号为i的节点的父节点 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关键方法find：返回x所在集合的编号（祖宗节点）+路径压缩 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="comment">//如果x不是祖宗节点的话，就让它的父节点=它父节点的祖宗节点：往上递归</span></span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]); </span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">char</span> op;<span class="keyword">int</span> a,b;cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'M'</span>) p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b); <span class="comment">//合并两个集合</span></span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"No"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="AcWing837-连通块中点的数量"><a href="#AcWing837-连通块中点的数量" class="headerlink" title="AcWing837 连通块中点的数量"></a>AcWing837 连通块中点的数量</h1><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个包含 n个点（编号为 1∼n1∼n）的<strong>无向</strong>图，初始时图中<strong>没有</strong>边。</p><p>进行 m 个操作，操作共有三种：</p><ol><li><code>C a b</code>，在点 a 和点 b间<strong>连一条边</strong>，a和 b 可能相等；</li><li><code>Q1 a b</code>，<strong>询问</strong>点 a 和点 b 是否在<strong>同一个</strong>连通块中，a和 b可能相等；</li><li><code>Q2 a</code>，询问点 a <strong>所在</strong>连通块中<strong>点的数量</strong>；</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>两个点之间连一条边==合并两个集合；</li><li>只是多了一个统计集合中点的数量的操作而已</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N],cnt[N];</span><br><span class="line"><span class="comment">//cnt[i]表示的是 根节点i 所在集合的大小 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">p[i]=i;</span><br><span class="line">cnt[i]=<span class="number">1</span>;</span><br><span class="line">} <span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line">string op;<span class="keyword">int</span> a,b;cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">"C"</span>){</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//下面这两行顺便别颠倒了 </span></span><br><span class="line">cnt[<span class="built_in">find</span>(b)]+=cnt[<span class="built_in">find</span>(a)]; </span><br><span class="line">p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"Q1"</span>){</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"No"</span>&lt;&lt;endl;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">cout&lt;&lt;cnt[<span class="built_in">find</span>(a)]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SE】数据库</title>
      <link href="/2022/07/22/2022-07-22-%E3%80%90SE%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/07/22/2022-07-22-%E3%80%90SE%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>依稀记得大二考数据库熬夜通宵复习完大早上直接去考试 结果只考了79分的痛QAQ</p><span id="more"></span><h1 id="面试重点"><a href="#面试重点" class="headerlink" title="面试重点"></a>面试重点</h1><blockquote><p>总结自网络</p><p>参考：</p></blockquote><ul><li><p>BC范式和第三范式区别</p></li><li><p>解释范式</p></li><li><p>数据库的四个特性是什么？（类似地：解释事务的隔离性？</p></li><li><p>DBS 和 DBMS 的区别</p></li><li><p>数据库的索引有哪些分类</p></li><li><p>数据库中的选择操作，什么时候应该用到索引？</p></li></ul><h1 id="SQL一些语法"><a href="#SQL一些语法" class="headerlink" title="SQL一些语法"></a>SQL一些语法</h1><p><strong>关系型数据库</strong>（RDBMS）：建立在关系模型基础上，由多张互相连接的<strong>二维表</strong>组成的数据库</p><ul><li>特点：使用表存储：格式统一；使用SQL语言操作：标准统一</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>DDL：数据<strong>定义</strong>（define）语言；定义数据库对象（数据库、表、字段）</li><li>DML：数据<strong>操作</strong>（manipulation）语言；对数据库表的<strong>数据进行增删改</strong></li><li>DQL：数据<strong>查询</strong>（query）语言；查询数据库表的<strong>记录</strong></li><li>DCL： 数据<strong>控制</strong>（control）语言；创建数据库用户、控制数据库访问权限</li></ul><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><p>(中括号代表可选)</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES; </span><br><span class="line"># 查询当前所处的数据库</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE(); </span><br><span class="line"># 创建,字符集建议用utf8mb4不用utf8</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名[<span class="keyword">DEFAULT</span> CHARSET 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br><span class="line"># 删除</span><br><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] 数据库名;</span><br><span class="line"># 使用；</span><br><span class="line">USE 数据库名;</span><br></pre></td></tr></tbody></table></figure><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 查询当前数据库的 所有表</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"># 查询表结构</span><br><span class="line"><span class="keyword">DESC</span> 表名;</span><br><span class="line"># 查询指定表的建表语句</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"></span><br><span class="line"># 创建表，最后一个字段没有逗号</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型[COMMENT 字段<span class="number">1</span>注释],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型[COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br><span class="line"></span><br><span class="line"># 修改表</span><br><span class="line"># 添加字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度) [COMMENT 注释][约束];</span><br><span class="line"></span><br><span class="line"># 修改字段</span><br><span class="line"># 修改：字段类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型(长度);</span><br><span class="line"># 修改：字段名 和 字段类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束];</span><br><span class="line"></span><br><span class="line"># 删除字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名;</span><br><span class="line"></span><br><span class="line"># 删除表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>[IF <span class="keyword">EXISTS</span>]表名;</span><br><span class="line"># 删除指定表，并重新创建该表：清除了数据，只剩下表jie</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></tbody></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>char 和 varchar</strong>：</p><ul><li>char性能比varchar好</li><li>char定长，varchar变长</li></ul><p><strong>日期类型</strong>：</p><ul><li>DATE、TIME、YEAR、DATETIME、TIMESTAMP</li></ul><h1 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h1><p>指 DBMS应该保证数据库：<strong>免受非法、非授权用户的使用、泄露、更改和破坏</strong></p><h2 id="DBMS的安全机制分类"><a href="#DBMS的安全机制分类" class="headerlink" title="DBMS的安全机制分类"></a>DBMS的安全机制分类</h2><ul><li><strong>自主</strong>安全性机制：存取控制<ul><li>通过权限在用户之间的传递，使用户自主管理数据库安全性</li></ul></li><li><strong>强制</strong>安全性机制<ul><li>通过对数据和用户强制分类，使得不同类别用户能访问不同类别的数据</li></ul></li><li><strong>推断</strong>控制机制<ul><li>防止通过历史信息，推断出不该被其知道的信息</li><li>防止通过历史信息推断出私密信息，通常在一些由个体数据构成的公共数据库中此问题尤为重要</li></ul></li><li>数据加密存储机制<ul><li>加解密保护数据</li></ul></li></ul><h2 id="自主安全性机制"><a href="#自主安全性机制" class="headerlink" title="自主安全性机制"></a>自主安全性机制</h2><h3 id="通过授权机制实现"><a href="#通过授权机制实现" class="headerlink" title="通过授权机制实现"></a>通过<strong>授权机制</strong>实现</h3><ul><li>授权者：决定用户权利的人；授权：授予用户访问的权利</li></ul><blockquote><p>用户使用DB前，必须由DBA处获得一个账户，由DBA授予该账户一定权限；</p><p>该账户用户也可将所拥有的权限转授给其他用户，实现权限在用户间的传播和控制</p></blockquote><p>🛑 $\textcolor{red}{DBMS如何自动实现自主安全性？}$</p><ul><li>DBMS允许用户定义一些<strong>安全性控制规则</strong>（DCL）</li><li>当有DB访问操作时，DBMS<strong>自动</strong>按照安全性控制规则进行<strong>检查</strong>（安全性控制程序），检查通过则允许访问。</li></ul><p>🛑 $\textcolor{red}{自主安全性访问规则}$</p><blockquote><p>DBMS将权利和用户结合，形成一个访问规则表，依据该规则表实现对DB的安全性控制</p></blockquote><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S这个用户对O这个访问对象，在满足在P这个条件下拥有的访问权利t：</span><br><span class="line">    <span class="attr">AcessRule</span> ::= (S, O, t, P)</span><br><span class="line">        S：访问主体（用户）：用户多时，可按用户组建立访问规则</span><br><span class="line">        O：访问对象：可大可小，属性/字段、记录/元组、关系、数据库</span><br><span class="line">        t：访问权利：创建、增删改查等</span><br><span class="line">        P：谓词：拥有权利需满足的条件</span><br></pre></td></tr></tbody></table></figure><p><code>{AcessRule}</code>存放在数据字典 或称系统目录中，构成所有用户对DB的访问控制</p><p>🛑 $\textcolor{red}{下面是一个例子}$</p><p>对一个员工管理数据库<code>Employee(Pno, Pname, Page, Psex, Psalary, Dno, HEAD)</code>有如下安全性访问要求：</p><div class="table-container"><table><thead><tr><th style="text-align:center">S</th><th style="text-align:center">O</th><th style="text-align:center">t</th><th style="text-align:center">P</th></tr></thead><tbody><tr><td style="text-align:center">员工管理人员</td><td style="text-align:center">Employee</td><td style="text-align:center">读、删、插、改</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">收发人员</td><td style="text-align:center">Employee（Pname，Dno）</td><td style="text-align:center">读</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">每个员工</td><td style="text-align:center">Employee</td><td style="text-align:center">读</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">部门领导</td><td style="text-align:center">Employee</td><td style="text-align:center">读</td><td style="text-align:center">Pno=UserId</td></tr><tr><td style="text-align:center">高级领导</td><td style="text-align:center">Employee</td><td style="text-align:center">读</td><td style="text-align:center">Head=UserId</td></tr></tbody></table></div><p>🛑 $\textcolor{red}{按名控制安全性的实现方式}$</p><p><strong>实现方式一：存储矩阵</strong></p><p><img src="https://s2.loli.net/2022/08/05/1d37qUwLjeMXGrE.png" alt="image.png"></p><p><strong>实现方式二：视图</strong></p><ul><li><p>给不同用户用不同视图，就是相当于给与了不同的数据访问范围，相比矩阵更省空间</p></li><li><p>通过视图限制用户对关系中某些数据项的存取，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">视图1：create view EmpV1 as select * from Employee</span><br><span class="line">视图2：create view EmpV2 as select Pname,Dno from Employee</span><br></pre></td></tr></tbody></table></figure></li><li><p>通过视图 可将数据访问对象和谓词结合起来，限制用户对关系中某些元组的存取，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">视图1：create view EmpV3 as select * from Employee where Pno=:UserId</span><br></pre></td></tr></tbody></table></figure></li><li><p>用户定义视图后，视图便成为一新的对象，参与到存储矩阵与能力表中进行描述</p></li></ul><h3 id="用户与权利"><a href="#用户与权利" class="headerlink" title="用户与权利"></a>用户与权利</h3><p>🛑 $\textcolor{red}{SQL语言将用户分为三个级别}$</p><ul><li>超级用户（DBA）</li><li>账户级别（程序员用户）</li><li>关系级别（普通用户）</li></ul><p>🛑 $\textcolor{red}{SQL语言将权利分级}$</p><p>级别更高的权利自动包含级别低的权利；在有些DBMS中，将级别3的权利称为账户级别的权利，1和2称为关系级别的权利</p><ul><li>（级别1）<code>Select</code>：读（DB，Table，Record，Attribute…）</li><li>（级别2）<code>Modify</code>：更新<ul><li><code>Insert</code>、<code>Update</code>、<code>Delete</code></li></ul></li><li>（级别3）<code>Create</code>：创建（表空间、模式、表、索引、视图等）<ul><li><code>Create</code>、<code>Alter</code>、<code>Drop</code></li></ul></li></ul><h3 id="DCL授权命令"><a href="#DCL授权命令" class="headerlink" title="DCL授权命令"></a>DCL授权命令</h3><p>🛑 $\textcolor{red}{授权：grant}$</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT {all PRIVILEGES | privilege {,privilege..}} </span><br><span class="line">ON [TABLE] tablename | viewname</span><br><span class="line">TO {public | user-id {, user-id...}}</span><br><span class="line">[WITH GRANT OPTION];</span><br></pre></td></tr></tbody></table></figure><ul><li><code>user-id</code>：某一个用户账户，由DBA创建的合法账户</li><li><code>public</code>：允许所有有效用户使用授予的权利</li><li><code>privilege</code>：这些权利：<code>Select、Insert、Update、Delete、All privileges</code></li><li><code>with grant option</code>：允许被授权者在传播这些权利</li></ul><p>❗ 授予视图访问的权利，并不意味着授予基本表的访问权利（两个级别：关系级别和视图级别）</p><p>🛑 $\textcolor{red}{收回授权：revoke}$</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REVOKE {all privilEges | priv {, priv..}} ON tablename | viewname</span><br><span class="line">FROM {public | user {, user..} };</span><br></pre></td></tr></tbody></table></figure><p>🛑$\textcolor{red}{授权过程}$</p><ul><li>DBA创建DB，并为每个用户创建一个账户</li><li>DBA授予某用户账户级别的权利</li><li>具有账户级别的用户可以创建基本表或视图，他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问权利</li><li>拥有属主账户的用户可以将其中的部分权利授权给另外的用户，该用户也可将权利进一步授权给其他用户</li></ul><h2 id="强制安全性机制"><a href="#强制安全性机制" class="headerlink" title="强制安全性机制"></a>强制安全性机制</h2><p>🛑$\textcolor{red}{原理}$</p><ul><li>通过对数据对象进行安全性分级<ul><li>绝密(Top Secret)、机密(Secret)、可信(Confidential)、无分类(Unclassified)</li></ul></li><li>同时对用户也进行上述安全性分级</li><li>从而强制实现不同级别用户访问不同级别数据的一种机制</li></ul><p>🛑$\textcolor{red}{访问规则}$</p><ul><li>高级别用户 可以访问 低级别数据对象：<ul><li>用户S，不能读取数据对象O，除非<code>Level(S) &gt;= Level(D)</code></li></ul></li><li>高级别用户 不可以修改 低级别数据对象<ul><li>用户S，不能写数据对象O，除非<code>Level(S) &lt;= Level(O)</code></li></ul></li></ul><h1 id="嵌入式SQL语言"><a href="#嵌入式SQL语言" class="headerlink" title="嵌入式SQL语言"></a>嵌入式SQL语言</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>特别复杂的检索结果难以用一条交互式SQL语句完成,此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理</p><p>将SQL语言嵌入到某种高级语言中使用，如C/C++, Java, PowerBuilder等,又称宿主语言(Host Language)</p></blockquote><p><img src="https://s2.loli.net/2022/08/05/8SrCF41tNLgWdb6.png" alt="image.png" style="zoom: 50%;"></p><h2 id="SQL执行的提交和撤销-事务"><a href="#SQL执行的提交和撤销-事务" class="headerlink" title="SQL执行的提交和撤销+事务"></a>SQL执行的提交和撤销+事务</h2><p>SQL执行过程中，必须有<strong>提交和撤销</strong>语句才能确认其操作结果</p><p>🛑$\textcolor{red}{事务}$</p><p><strong>概念</strong>：（从应用程序员角度），事务是一个存取或改变数据库内容的程序的一次执行；或者说<strong>一条或多条SQL语句的一次执行</strong>被看作一个事务</p><p>由应用程序员提出，有开始和结束，结束前需要提交或撤销</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>概念</strong>：（从DBMS角度），事务是DBMS提供的控制数据操作的一种手段，通过这种手段，应用程序将<strong>一系列数据库操作组合</strong>在一起<strong>作为一个整体进行操作和控制</strong>，以便DBMS能提供移植性状态转换的保证。</p><p>🛑$\textcolor{red}{事务的特性：ACID}$</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p><strong>静态SQL</strong>: SQL语句在程序中已经按要求写好,只需要把一些参数通过变量传送给嵌入式SQL语句即可</p><p><strong>动态SQL</strong>: SQL语句可以<strong>在程序中动态构造</strong>，形成一个<strong>字符串</strong> ，然后再交给DBMS执行，交给DBMS执行时仍可以传递变量</p><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><p>🛑$\textcolor{red}{概念}$</p><p>又称系统目录（目录表、系统视图），是系统维护的一些表或视图的集合，这些表或视图存储了数据库中<strong>各类对象的定义信息</strong>，这些对象包括用create定义的表、列、索引、视图、权限、约束等。这些信息又称为数据库的<strong>元信息</strong>（关于数据的数据；即 模式本身的信息）</p><p>🛑$\textcolor{red}{数据字典的内容构成}$</p><ul><li>与关系相关的信息<ul><li>关系名字、每个关系的属性名及类型、视图名字及定义、完整性约束</li></ul></li><li>用户与账户信息，包括密码</li><li>统计和描述性数据：比如每个关系中的元组数目</li><li>物理文件组织信息<ul><li>关系如何存储（顺序、无序、散列）</li><li>关系的物理位置</li></ul></li><li>索引相关的信息</li></ul><h2 id="ODBC-和-JDBC"><a href="#ODBC-和-JDBC" class="headerlink" title="ODBC 和 JDBC"></a>ODBC 和 JDBC</h2><p>🛑$\textcolor{red}{ODBC}$</p><p>ODBC（open database connectivit开放式数据库连接）是一种 不同语言的语应用程序和不同数据库服务器之间<strong>通讯的标准</strong>，包含：</p><ul><li>一组API，支持<strong>应用程序和数据库服务器</strong>的交互</li><li>应用程序通过调用 ODBC API，实现<ul><li>与数据库服务器的连接</li><li>向数据库服务器发送SQL命令</li><li>逐条提取数据库检索结果中的元组传递给应用程序的变量</li></ul></li><li>具体的DBMS提供一套<strong>驱动程序</strong>（Driver库函数），供ODBC调用，以便实现数据库和应用程序的连接</li></ul><blockquote><p>⭕ 当应用程序调用<strong>ODBC API</strong>时，ODBC API会<strong>调用具体DBMS Driver库函数</strong>，DBMS Driver库函数 <strong>与 数据库服务器通信</strong>，执行相应的请求动作并返回检索结果</p></blockquote><p>🛑$\textcolor{red}{JDBC}$</p><blockquote><p>简单了解，反正会用jiu’x🤣真想深入学就去看专门讲JDBC运用的视频</p></blockquote><p>JDBC是一组Java版的应用程序接口API ，提供了<strong>Java应用程序与数据库服务</strong><br><strong>器</strong>的连接和通讯能力。</p><p><strong>概念性的基本过程</strong>：打开一个连接，创建“Statement”对象，并设置查询语句，使用Statement对象执行查询，发送查询给数据库服务器，返回结果给应用程序；处理错误的例外机制</p><p><strong>具体实施过程</strong> ：</p><ul><li><p>传一个Driver给DriverManager，<strong>加载数据库驱动</strong>。<code>Class.forName()</code></p></li><li><p>通过URL得到一个Connection对象，<strong>建立数据库连接</strong></p><p><code>DriverManager.getConnection(sDBUrI)</code></p><p><code>DriverManager.getConnection(sDBUrl,sDBUserlD,sDBPassword)</code></p></li><li><p>接着<strong>创建一个Statement对 象</strong>(PreparedStatement或CallableStatement)，用来查询或者修改数据库。<code>Statement stmt=con.createStatement()</code></p></li><li><p>查询<strong>返回</strong>一个ResultSet.<code>ResultSet rs =stmt.executeQuery(sSQL)</code></p></li></ul><h1 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h1><blockquote><p>包含：数据依赖理论、关系范式理论、模式分解理论</p></blockquote><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><blockquote><p>FD：Functional Dependence</p><p>参考书籍：《数据库系统基础教程》Jeffrey.D Ullman Jennifer Widom著</p><p>参考文章：</p><p><a href="https://blog.csdn.net/Jeremy_Tsang/article/details/108949656">完全/部分/函数依赖【通俗易懂，博主会讲人话】Jeremy_Tsang的博客</a></p><p><a href="https://blog.csdn.net/shuaishuai__/article/details/106076537?ops_request_misc=%7B%22request%5Fid%22%3A%22165979845916782391847571%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165979845916782391847571&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-106076537-null-null.nonecase&amp;utm_term=数据库闭包&amp;spm=1018.2226.3001.4450">数据库中的闭包到底是什么？_三看的博客</a></p></blockquote><p>🛑$\textcolor{red}{函数依赖的定义}$</p><p>设$R(U)$是属性集合$U=\{A_1,A_2,\dots,A_n\}$上的一个关系模式，$X$，$Y$是$U$上的两个子集，若对$R(U)$的任意一个可能的关系$r$，$r$中<font color="red">不可能有两个元组</font>满足在$X$中的属性值相等而在$Y$中的属性值不等（即：$X$中的每一个属性值，$Y$都有唯一值与之对应），则称 “$X$函数决定$Y$”  或者 ” $Y$ 函数依赖于$X$“，记作$X \rightarrow Y$。$X$为决定因素</p><blockquote><p>两个属性(集)之间的取值关系，对于R(U)，X、Y为属性集，t1、t2为R的元组，若t1[X]＝t2[X]，则t1[Y]＝t2[Y]</p></blockquote><p><img src="https://s2.loli.net/2022/08/06/CaA3EhOpzT4eQ9M.png" alt="image.png" style="zoom:50%;"></p><ul><li><p><strong>例如：</strong>U = {学号，姓名，年龄，班号，班长，课号，成绩}；那么：学号 → { 姓名，年龄 } ：意思就是学号相同的话，那么姓名和年龄也一定相同；学号 决定 姓名+年龄 </p></li><li><p><strong>非平凡的函数依赖</strong>：对$X\rightarrow Y$，但$Y\not\subset X$，则称$X\rightarrow Y$为非平凡的函数依赖；反之，则是平凡的函数依赖</p><blockquote><p>说人话：Y不是X的子集</p></blockquote></li><li><p><strong>平凡的函数依赖</strong>：</p><blockquote><p>X 可以推导出自己或者自己的一部分</p></blockquote></li></ul><p><img src="https://s2.loli.net/2022/08/06/j3rwi94VoPHC6c1.png" alt="image.png" style="zoom: 50%;"></p><p>🛑$\textcolor{red}{完全函数依赖和部分函数依赖}$</p><p>在$R(U)$中，若$X\rightarrow Y$并且对于$X$的任何真子集$X’$都有$X’\nrightarrow Y$，则称$Y$<strong>完全函数依赖</strong>于$X$，记为$X \xrightarrow{f} Y $，否则称作Y<strong>部分函数</strong>依赖于X，记为$X \xrightarrow{p} Y $</p><blockquote><p>说人话：完全函数依赖就是必须由<strong>X中的全部属性值</strong> 才能确定唯一的Y的值，X属性集中缺少任何一个属性 都不能 确定唯一的Y；</p><p>比如，想知道某位学生的某门课成绩Grade，必须得同时知道他的学号Sno和课程号Cno。如果只知道部分信息，比如只知道Sno或者Cno，无法确定Grade！此时 称Y[Grade]<strong>完全函数依赖</strong>于X[Sno,Cno]。</p><p>而想知道某位学生姓名Sname，那知道他的学号Sno就可。也就是Y[Sname]只函数依赖于X[Sno,Cno]中的子集x[Sno]，此时称Y<strong>部分函数依赖</strong>于X</p></blockquote><p>🛑$\textcolor{red}{传递函数依赖}$</p><p> 在$R(U)$中，若$X\rightarrow Y,Y\rightarrow Z$ 且 $Y\not\subset X,Z\not\subset Y,Z \not\subset X,Y\nrightarrow X$，则称$Z$传递函数依赖于$X$</p><blockquote><p>例如：知道一个学生的学号Sno，就能知道他所在的系Sdept。那知道某一个系Sdept，就能知道这个系的系主任的姓名Mname。<br>也就是，我知道了一个学生的<u>学号</u>Sno，其实我就知道了他所在系的<u>系主任的姓名</u>Mname。但这个过程中，他们是<strong>不存在直接函数依赖</strong>的，我需要通过<strong>系名称</strong>Sdept<strong>作为一个桥梁</strong>去把二者联系起来。</p></blockquote><p>🛑$\textcolor{red}{函数依赖的几个重要概念}$</p><ul><li><p><font color="red">候选键</font>（Candidate Key）：设$K$为$R(U)$中的属性或属性集合，若$K \xrightarrow{f} U $，则称$K$为$R(U)$上的候选键（最小性+唯一性）</p><ul><li>可以任选一候选键作为<font color="red">主键</font>（Primary Key）</li><li><font color="red">主属性</font>：包含在任一候选键中的属性；其他称为<font color="red">非主属性</font></li><li><font color="red">超键</font>：若$K$是$R$的一个候选键，$S\supset K$，则称$S$是$R$的一个超键（即：一个包含键的属性集，没有最小性）</li></ul></li><li><p><font color="red">外键</font>（Foreign Key）：若$R(U)$中的属性或属性组合$X$<strong>并非</strong>$R$的候选键，但<strong>却是</strong>另一关系的候选键，则称$X$为$R$的外键</p></li><li><p><font color="red">逻辑蕴涵</font>：设$F$是关系模式$R(U)$中的一个<strong>函数依赖集合</strong>, $X, Y$是$R$的属性子集，如果从$F$ 中的函数依赖能够逻辑推导出$X \to Y$ ，则称$F$逻辑蕴涵$X \to Y$，或称$X \to Y$是$F$的逻辑蕴涵。记作$\mathbf{F} \models \mathbf{X} \rightarrow \mathbf{Y}$。</p><blockquote><p>由已给出的函数依赖集，推导出其他函数依赖。<strong>推导出来的函数依赖</strong>就称作F所逻辑蕴涵的函数依赖。<br>就好像是侦探破案，掌握了几条线索，然后根据这几条线索推出来另外的线索，这另外推出来的线索就是之前线索集的逻辑蕴涵的线索。</p></blockquote></li><li><p><font color="red">闭包</font>（Closure）：被$F$逻辑蕴含的所有函数依赖集合称为$F$的闭包，记作$F^{+}$</p><blockquote><p>即：<strong>F中能所有的</strong>函数依赖 以及 能<strong>推导出来的</strong>所有的函数依赖 在一起的集合就是 F的闭包</p><p>若$F^{+}=F$，则称$F$是一个<strong>全函数依赖</strong>（函数依赖完备集）</p></blockquote></li></ul><p>🛑$\textcolor{red}{函数依赖的Armstrong公理}$</p><p>设$R(U)$是属性集$U=\{A_1,A_2,\dots,A_n\}$上的一个关系模式，$F$为$R(U)$的一组函数依赖，记作$R(U,F)$，有如下规则成立：</p><ul><li>自反律：若$Y\subseteq X \subseteq U$，则$X \to Y$ 被 $F$ 逻辑蕴涵</li><li>增广律：若$X\to Y \in F$，且$Z\subseteq U$，则$XZ \to YZ$  被 $F$ 逻辑蕴涵</li><li>传递律：若$X\to Y\in F$，且$Y\to Z$，则$X\to Z$  被 $F$ 逻辑蕴涵</li></ul><p>由$Armstrong$公理可推出如下结论（定理）：</p><ul><li>合并律：若$X\to Y$且$X\to Z$，则$X\to YZ$</li><li>伪传递律：若$X\to Y$且$WY \to Z$，则 $XW \to Z$</li><li>分解律：若$X\to Y$且$Z\subseteq Y$，则$X\to Z$</li></ul><p>一个引理：</p><ul><li>若$A_1,A_2,\dots,A_n$是属性，则$X\to A_1,A_2,\dots,A_n$当且仅当每个$A_i$有$X\to A_i(1\leq i\leq n)$</li></ul><p>🛑$\textcolor{red}{覆盖和最小覆盖}$</p><p>覆盖：对$R(U)$上的两个函数依赖集合$F、G$，如果$F^{+}=G^{+}$，则称$F$ 和$G$ 是等价的，也称$F$ 覆盖$G$ 或者$G$ 覆盖$F$ 。</p><p><strong>最小覆盖</strong>：若$F$满足以下条件，则称$F$为最小覆盖或最小依赖集：</p><ul><li>$F$ 中的每个函数依赖 的右部都是单个属性</li><li>对任何 $X\to A\in F$，有$F-\{X\to A\}$不等价于$F$：指 每个函数依赖$X\to A$ 都是不可获取的</li><li>对任何 $X\to A\in F,Z\subset X$，有$(F-\{X\to A\})\cup \{Z\to A\}$不等价于$F$：也就是说$X$ 中没有多余的属性</li></ul><p><strong>定理</strong>：每个函数依赖集$F$ 都有等价的最小覆盖$F’$</p><p>🛑$\textcolor{red}{属性闭包的计算}$</p><p><strong>思想</strong>：从一个给定的属性集合出发，重复地扩展这个集合，只要某个FD<u>左边的属性 全部 包含在这个集合</u>中，就把此FD右边的属性也包含进去。反复使用这个方法，直到不再产生新的属性为止。最后的结果集合就是给定属性集合的闭包。</p><p><strong>算法：</strong></p><p><img src="https://s2.loli.net/2022/08/06/zWLhMkYqSVbCsl1.png" alt="image.png" style="zoom: 50%;"></p><hr><h2 id="关系范式"><a href="#关系范式" class="headerlink" title="关系范式"></a>关系范式</h2><blockquote><p>范式（数据库的设计范式）是<strong>符合某一种级别</strong>的<strong>关系模式的集合</strong>。<strong>构造数据库必须遵循一定的规则</strong>。在关系数据库中，这种规则就是范式。关系数据库中的关系必须满足一定的要求，即满足不同的范式</p></blockquote><h3 id="第一范式：1NF"><a href="#第一范式：1NF" class="headerlink" title="第一范式：1NF"></a>第一范式：1NF</h3><p>🛑$\textcolor{red}{定义}$</p><p>若关系模式$R(U)$中，关系的<strong>每个分量都是不可再分</strong>的数据项（值、原子），则称$R(U)$ 属于第一范式，记作$R(U)\in 1NF$</p><p><strong>例如</strong>：<code>Star(name, address(street, city))</code>就不属于第一范式，因为<code>address</code>包含两个属性，这个分量不是原子的，可以再分</p><p>🛑$\textcolor{red}{非1NF转换为1NF}$</p><ul><li>将<strong>复合</strong>属性处理为<strong>简单</strong>属性；将多值属性与关键字单独组成一新的关系</li><li>引入新的数据模型处理：面向对象的数据模型（封装）</li></ul><h3 id="第二范式：2NF"><a href="#第二范式：2NF" class="headerlink" title="第二范式：2NF"></a>第二范式：2NF</h3><p>🛑$\textcolor{red}{定义:1NF+消除非主属性对码的部分依赖}$</p><p>若$R(U)\in 1NF$ 且$U$中的每一<font color="red">非主属性</font>都<strong>完全函数依赖</strong>于候选键，则称$R(U)$属于第二范式，记作$R(U)\in 2NF$</p><blockquote><p>2NF要求数据库表的每个实例或行 <strong>必须可以被唯一地区分</strong>。不能存在仅依赖主关键字一部分的属性。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系</p></blockquote><p><img src="https://s2.loli.net/2022/08/07/sBloZvnj7qhCOVX.png" alt="image.png" style="zoom:50%;"></p><h3 id="第三范式：3NF"><a href="#第三范式：3NF" class="headerlink" title="第三范式：3NF"></a>第三范式：3NF</h3><p>🛑$\textcolor{red}{定义：2NF+消除非主属性对码的传递依赖}$</p><p>若$R(U,F)\in 2NF$且$R$ 中<strong>不存在这样的情况</strong>：候选键$X$，属性组$Y\subseteq U$和非主属性$A$，且$A\notin X, A\notin Y,Y\not\subset X,Y\not\to X$，使得$X\to Y,Y\to A$成立。满足上述条件的$R(U)$属于第三范式，记为$R(U)\in 3NF$</p><blockquote><p>3NF要求一个数据库表中 <strong>不包含</strong>   已在<strong>其它表中已包含的非主关键字</strong>信息。</p></blockquote><h3 id="Boyce-Codd范式"><a href="#Boyce-Codd范式" class="headerlink" title="Boyce-Codd范式"></a>Boyce-Codd范式</h3><p>🛑$\textcolor{red}{定义：3NF+消除主属性对码的部分和传递依赖}$<br>若$R(U,F)\in 1NF$，若对任何$X\to Y\in F$（或$X\to A\in F$），当$Y\not\subset X$（或$A\not\subset X$）时，$X$必含有候选键，则称$R(U)$属于BC范式，记为：$R(U)\in BCNF$</p><blockquote><p>每个非平凡函数依赖的左边都必须<strong>包含键</strong>（可以是超键，不一定要最小化）</p><p>有传递依赖的，或者说不满足3NF的，也一定不满足BCNF</p></blockquote><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><h2 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h2><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>🛑$\textcolor{red}{定义}$</p><p>索引是定义在存储表（Table）的基础上，有助于 无需检查所有记录而<strong>快速定位</strong>所需记录的 一种<strong>辅助存储结构</strong>。由一系列存储在磁盘上的<strong>索引项</strong>组成，每一索引项分成以下两部分：</p><ul><li><strong>索引字段</strong>：由Table中某些列中的值串接而成。索引中通常存储了索引字段的每一个值（也有不是这样的），类似于词典中的词条</li><li><strong>行指针</strong>：指向Table中包含索引字段值的<strong>记录在磁盘上的存储位置</strong>，类似于词典中的页码<br><img src="https://s2.loli.net/2022/08/07/nLqDUCgx7BpiFH1.png" alt="image.png" style="zoom: 50%;"></li></ul><p>索引文件：存储索引项的文件；主文件：存储表</p><blockquote><p>索引文件是一种辅助存储结构，存在与否不改变存储表的物理存储结构；存在就可以明显提高存储表的访问速度：索引文件比主文件<strong>小</strong>很多，可以<strong>全部装进</strong>内存</p><p>有索引时，更新操作必须<strong>同步更新</strong>索引文件和主文件</p></blockquote><p>排序码：对主文件进行排序存储的那些属性或属性组</p><p>索引码：即索引字段，不一定具有唯一性</p><p>搜索码：在主文件中查找记录的属性或属性集</p><p>🛑$\textcolor{red}{索引文件的组织方式}$</p><ul><li><strong>排序</strong>索引文件：按索引字段值的某一种<strong>顺序</strong>组织存储</li><li><strong>散列</strong>索引文件：依据索引字段值使用<strong>散列函数</strong>分配散列桶的方式存储</li></ul><h2 id="稠密索引和稀疏索引"><a href="#稠密索引和稀疏索引" class="headerlink" title="稠密索引和稀疏索引"></a>稠密索引和稀疏索引</h2><p>🛑$\textcolor{red}{定义}$</p><p><strong>稠密索引</strong>：对于主文件中的<strong>每一个记录</strong>，都有一个索引项与之对应，指明该记录所在位置</p><p><strong>稀疏索引</strong>：部分记录</p><blockquote><p>稠密索引文件中 包含了主文件对应字段的<strong>所有不同值</strong></p><p>稀疏索引的使用：要求主文件必须按对应索引字段属性排序存储</p></blockquote><h2 id="主索引和辅助索引"><a href="#主索引和辅助索引" class="headerlink" title="主索引和辅助索引"></a>主索引和辅助索引</h2><p>🛑$\textcolor{red}{主索引}$</p><p>通常是对每一<strong>存储块</strong>有一个素引项 ，索引项的总数和存储表所占的存储块数目相同，存储表的每一个存储块的第一条记录，又称为<strong>锚记录或简称为块锚</strong></p><blockquote><p>主索引的索引字段值为<strong>块锚</strong>的索引字段值，指针指向其所在的存储块。<br>主索引是按索引字段值进行排序的一个有序文件，通常建立在有序主文件的基于主码的排序字段上，即主索引的<strong>索引字段与主文件的排序码(主码)</strong>有对应关系</p><p>主索引 是稀疏索引</p></blockquote><p>🛑$\textcolor{red}{辅助索引}$</p><p>是定义在主文件的任一或多个非排序字段上的辅助存储结构</p><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>🛑$\textcolor{red}{聚簇索引}$</p><p>索引中<strong>邻近的记录</strong>在主文件中也是<strong>邻近存储</strong>的</p><p>🛑$\textcolor{red}{非聚簇索引}$</p><p>索引中<strong>邻近的记录</strong>在主文件中<strong>不一定是邻近存储</strong>的</p><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><blockquote><p>多级索引：对索引再建立索引</p></blockquote><p>🛑$\textcolor{red}{定义}$</p><p>B+树的每一个结点都是如下这样的存储块：</p><div class="table-container"><table><thead><tr><th>$P_1$</th><th>$K_1$</th><th>$P_2$</th><th>…</th><th>$P_{n-1}$</th><th>$K_{n-1}$</th><th>$P_{n}$</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><blockquote><p>$K_i$：索引字段值</p><p>$P_i$：指针，指向索引块或数据块或数据块中记录的指针</p></blockquote><ul><li>一个存储块中有$n-1$个索引项$<p_i,k_i>$ + $1$个指针$P_n$</p_i,k_i></li><li>索引字段值$x$，若$K_{i-1}\leq x\lt K_i$的由$P_i$ 指向；在$K_{i}\leq x\lt K_{i+1}$的由$P_{i+1}$指向</li><li>非叶结点：指针指向索引块</li><li>叶结点：指针指向主文件的数据库或数据记录（叶结点的最后一个指针始终指向其下一个数据块）</li></ul><p>🛑$\textcolor{red}{B+树的两个特性}$</p><ul><li>能自动保持与主文件大小相适应的树的层次</li><li>每个索引块的指针利用率都在50%-100%之间</li></ul><p>🛑$\textcolor{red}{B+树的存储约定}$</p><p><img src="https://s2.loli.net/2022/08/07/MSxj4rwPq3dV9eR.png" alt="image.png"></p><ul><li>索引字段值重复出现于叶结点和非叶结点</li><li>指向主文件的指针 仅出现在 叶结点</li><li>所有叶结点 即可覆盖所有键值的索引</li><li>索引字段值在叶结点中按顺序排列</li></ul><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是数据库的事务？"><a href="#什么是数据库的事务？" class="headerlink" title="什么是数据库的事务？"></a><font color="red">什么是数据库的事务？</font></h2><p>🔸 DB的<strong>事务</strong>是一个不可分割的数据库操作<strong>序列</strong>，也是DB并发控制的基本单位；这组逻辑上的操作要么都执行，要么都不执行；其执行的结果必须使DB从一种<strong>一致性状态</strong>变到<strong>另一种一致性</strong>状态。</p><blockquote><p>将一系列数据库操作组合在一起，作为一个整体进行操作和控制</p><p>从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行；或者说<strong>一条或多条SQL语句的一次执行</strong>被看作一个事务；由应用程序员提出，有开始和结束，结束前需要提交或撤销</p><p>在嵌入式SQL程序中,任何一条数据库操纵语句(如exec sql select等)都会引发一个新事务的开始，只要该程序当前没有正在处理的事务。而事务的结束是需要应用程序员通过commit或rollback确认的。因此Begin Transaction 和End Transaction两行语句是不需要的。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Begin Transaction</span><br><span class="line">exec sql...</span><br><span class="line">...</span><br><span class="line">exec sql...</span><br><span class="line">exec sql commit work | exec sql rollback work</span><br><span class="line">End Transaction</span><br></pre></td></tr></tbody></table></figure><h2 id="什么是数据库的四大特性ACID？"><a href="#什么是数据库的四大特性ACID？" class="headerlink" title="什么是数据库的四大特性ACID？"></a><font color="red">什么是数据库的四大特性ACID？</font></h2><p>🔸 <strong>原子性</strong>（Atomicity）：DBMS保证事务的一组<strong>更新操作</strong>是<strong>原子不可分</strong>的，确保操作要么全做，要么全不做</p><blockquote><p>事务中任何一个sql执行失败，那么执行成功的sql也必须撤销，数据库状态回退到执行事务之前的状态</p></blockquote><p>🔸 <strong>一致性</strong>（Consistency）：事务执行前后，所有数据都必须处于<strong>一致性状态</strong>，多个事务对同一个数据读取的结果是相同的</p><blockquote><p>比如：假设用户A和用户B的钱加起来一共5000，那不管A和B之间如何转账，转账几次，事务结束后两个用户的钱加起来应该还是5000，这就是事务的一致性。</p></blockquote><p>🔸 <strong>隔离性</strong>（Isolation）：DBMS保证<strong>并发执行的多个事务之间互相不受影响</strong>。</p><blockquote><p>一个事务<strong>内部的操作</strong>及<strong>正在操作的数据</strong> 对 其他并发执行的事务是隔离的。例如事务T1和T2即使并发执行，也相当于先执行T1，再执行T2（或者相反</p></blockquote><p>🔸 <strong>持久性</strong>（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p><h2 id="事务的并发会带来什么问题？如何解决？"><a href="#事务的并发会带来什么问题？如何解决？" class="headerlink" title="事务的并发会带来什么问题？如何解决？"></a><font color="red">事务的并发会带来什么问题？如何解决？</font></h2><p>🔸 <strong>脏读</strong>：一个事务读取到另一个事务更新但<strong>尚未提交的数据</strong>。 </p><blockquote><p>事务 A 读取事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</p><p>T1修改某个数据，并将其写回磁盘，T2读取之后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，导致T2读脏数据</p></blockquote><p>🔸 <strong>不可重复读</strong>：一个事务中<strong>两次读取</strong>的数据的<strong>内容不一致</strong></p><blockquote><p>T1读取数据后，T2执行更新操作，T1再次读取时，无法再读到之前的数据</p></blockquote><p>🔸<strong>幻读</strong>：一个事务中两次读取的<strong>数据量不一致</strong>。 事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据 </p><blockquote><p>当同一条查询在不同的时间产生不同的结果集</p></blockquote><p>🔸<strong>丢失更新</strong>：两个事务读入同一数据并修改，后一提交的事务会覆盖前一事务提交的结果，就会导致前一事务的修改被丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】最短路+最小生成树+二分图</title>
      <link href="/2022/07/22/2022-07-22-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF+%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91+%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
      <url>/2022/07/22/2022-07-22-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF+%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91+%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>Content</strong><ul><li><strong>最短路</strong>：Dijkstra、Bellman-Ford、SPFA、Floyd</li><li><strong>最小生成树</strong>：Prim、Kruskal</li><li><strong>二分图</strong>：染色法、匈牙利算法</li></ul></li></ul><span id="more"></span><h1 id="1️⃣-最短路介绍"><a href="#1️⃣-最短路介绍" class="headerlink" title="1️⃣ 最短路介绍"></a>1️⃣ 最短路介绍</h1><p><strong>补充</strong>：稠密图和稀疏图的定义较模糊，邻接矩阵所需空间$O(n^2)$，邻接表所需空间$O(m)$，计算时间和空间复杂度，选择一个满足的即可。</p><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><p>求一个点到其他所有点的最短距离</p><p>​    分类：</p><ul><li><p><strong>所有边权都是正数</strong></p><ul><li>朴素Dijkstra算法：O(n^2)  （n点数，m边数）、稠密图；用邻接矩阵</li><li>堆优化版的Dijkstra算法：O(mlogn)、稀疏图；用邻接表</li></ul></li><li><p><strong>存在负权边</strong></p><ul><li>Bellman-Ford：O(nm)</li><li>SPFA：一般情况下O(m)，最坏O(nm)，也适合正权边；※但是：能用dijkstra的就别用spfa</li></ul></li></ul><h2 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h2><ul><li>Floyd算法：O(n^3)</li></ul><h1 id="Dijkstra-正权边"><a href="#Dijkstra-正权边" class="headerlink" title="Dijkstra - 正权边"></a>Dijkstra - 正权边</h1><p>从<strong>1号点到其他所有点</strong>的最短距离</p><h2 id="朴素版-稠密图-邻接矩阵"><a href="#朴素版-稠密图-邻接矩阵" class="headerlink" title="朴素版 - 稠密图 - 邻接矩阵"></a>朴素版 - 稠密图 - 邻接矩阵</h2><ul><li><strong>初始化距离</strong>：$dist[1] = 0, dist[i]= +∞$：1号点到起点的距离是1，其他所有点到起点的距离是+∞</li><li>集合S：当前<strong>已经确定</strong>的最短距离的点</li><li>for 迭代n次：<ul><li>找到不在S中的<strong>距离最近的点 t</strong></li><li>把t加入S</li><li>用t更新其他点的距离$dist[j]=min(dist[j],dist[t]+g[t][j]);$</li></ul></li></ul><blockquote><p>给定一个 n个点 m条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 1 号点到 n号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p></blockquote><p>注意：若要求任意点i到任意个点j的最短距离，只需修改dijkstra方法中的起源位置dist[i] = 0，以及返回为dist[j]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];<span class="comment">//dist[i]: 从第一个点到第i个点的最短距离 </span></span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//st[i]:标记第i个点是否在S中 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//迭代n次 </span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){<span class="comment">//找 不在S中距离的 到第一个点的距离最短的那个点 </span></span><br><span class="line"><span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[j]&lt;dist[t]))</span><br><span class="line">t=j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){ <span class="comment">//用这个点 去更新其他点到第一个点的距离 </span></span><br><span class="line">dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">}</span><br><span class="line">st[t]=<span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">g[a][b]=<span class="built_in">min</span>(g[a][b],c);<span class="comment">//处理重边 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">dijkstra</span>();</span><br><span class="line">cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="堆优化版-稀疏图-邻接表"><a href="#堆优化版-稀疏图-邻接表" class="headerlink" title="堆优化版 - 稀疏图 - 邻接表"></a>堆优化版 - 稀疏图 - 邻接表</h2><p>适合稀疏图，<code>邻接表</code>存储图</p><p>优化：用 <code>堆</code>来 存储距离：$mlogn$</p><ul><li><code>找 不在S中距离的 到源点的距离最短的那个点</code> 👉找一堆数中的最小数👉堆👉$O(1)$</li><li><code>用这个点 去更新其他点到第一个点的距离</code>👉堆中修改一个数👉$O(logn)$；</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">150005</span>,M=<span class="number">150005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>{</span><br><span class="line">e[idx]=y,ne[idx]=h[x],w[idx]=z,h[x]=idx,idx++;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap; <span class="comment">//小根堆</span></span><br><span class="line"><span class="comment">//heap维护的是 不在S中的点以及它们离起点的距离 </span></span><br><span class="line">heap.<span class="built_in">push</span>({<span class="number">0</span>,<span class="number">1</span>});<span class="comment">//dist=0 point=1；</span></span><br><span class="line"><span class="keyword">while</span>(heap.<span class="built_in">size</span>()){ </span><br><span class="line">PII k=heap.<span class="built_in">top</span>();   <span class="comment">//O(m) * O(1) -&gt; O(m)</span></span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> ver=k.second,distance=k.first;</span><br><span class="line"><span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver]=<span class="literal">true</span>;  <span class="comment">//O(m) * O(1) -&gt; O(m)</span></span><br><span class="line"><span class="comment">//用当前点更新其他点的距离 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;distance+w[i]){</span><br><span class="line">dist[j]=distance+w[i];</span><br><span class="line">heap.<span class="built_in">push</span>({dist[j],j});  <span class="comment">// 堆的插入操作时间复杂度是 O(log(n))</span></span><br><span class="line">                                         <span class="comment">// O(m) * O(log(n)) -&gt; O(mlog(n))</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="built_in">add</span>(x,y,z);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Bellman-Ford-负权边"><a href="#Bellman-Ford-负权边" class="headerlink" title="Bellman-Ford - 负权边"></a>Bellman-Ford - 负权边</h1><p><strong>思想</strong>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化源点到各顶点的路径距离。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 进行n - <span class="number">1</span>次遍历，每次遍历对 所有边 进行 “松弛操作”。</span><br><span class="line">   松弛操作：以a为起点，b为终点，ab边长度为w为例：</span><br><span class="line">    dist[a]代表 源点 到 a点 的路径长度，dist[b]代表源点s到b点的路径长度。</span><br><span class="line">    <span class="keyword">if</span>：dist[b] &gt; dist[a] + wthen：dist[b] = dist[a] + w。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> 遍历都结束后，若再进行一次遍历，还能得到s到某些节点更短的路径的话，则说明存在负权回路</span><br></pre></td></tr></tbody></table></figure><p><a href="https://blog.csdn.net/hahahahahaha5/article/details/119022511">参考阅读：Bellman——Ford算法</a></p><h2 id="AcWing-853-有边数限制的最短路-结构体"><a href="#AcWing-853-有边数限制的最短路-结构体" class="headerlink" title="AcWing 853 有边数限制的最短路 - 结构体"></a><a href="https://www.acwing.com/problem/content/855/">AcWing 853 有边数限制的最短路</a> - 结构体</h2><p>对所有边操作，可以直接采用一个<code>结构体</code>定义每条边</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代n次 <span class="comment">//这个n其实就是限制了从源点经过不超过n条边到达某些点</span></span><br><span class="line">    <span class="keyword">for</span> 所有m条边a-b：w</span><br><span class="line">        dist[b]=<span class="built_in">min</span>(dist[b],dist[a]+w);</span><br></pre></td></tr></tbody></table></figure><blockquote><p> n 个点 m 条边有向图，可能存在重边和自环， <strong>边权可能为负数</strong>。</p><p>求从 1 号点到 n 号点的<strong>最多经过 k 条边</strong>的最短距离</p><p>注意：图中可能 <strong>存在负权回路</strong> ，则不一定存在最短距离。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">505</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line"><span class="keyword">int</span> a,b,w;</span><br><span class="line">}edges[M]; </span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> last[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line"><span class="built_in">memcpy</span>(last,dist,<span class="keyword">sizeof</span> dist);  <span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line"><span class="keyword">auto</span> e = edges[j];</span><br><span class="line">dist[e.b] = <span class="built_in">min</span>(dist[e.b],last[e.a]+e.w); </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">edges[i] ={x,y,z};</span><br><span class="line">}</span><br><span class="line"><span class="built_in">bellman_ford</span>();</span><br><span class="line"><span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)  cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;dist[n]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="SPFA-正-负权"><a href="#SPFA-正-负权" class="headerlink" title="SPFA - 正/负权"></a>SPFA - 正/负权</h1><blockquote><p>Shortest Path Faster Algorithm</p></blockquote><p>思想：</p><ul><li>对Bellman-Ford算法的优化：<strong>队列</strong></li><li>Bellman_ford算法会遍历所有的边，但其实只有当一个点的<strong>前驱结点更新</strong>，该点才会更新；所以只需遍历那些<strong>到源点距离变小的点所连接的边</strong>即可👉创建一个队列存放每一次加入距离<strong>被更新（变小）的结点</strong></li></ul><h2 id="AcWing-851-spfa求最短路"><a href="#AcWing-851-spfa求最短路" class="headerlink" title="AcWing 851 spfa求最短路"></a><a href="https://www.acwing.com/activity/content/problem/content/920/">AcWing 851 spfa求最短路</a></h2><blockquote><p>1≤n,m≤$10^5$,用bellman-ford会TLE</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],w[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;<span class="comment">//存放距离变小的边 </span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">st[<span class="number">1</span>]=<span class="literal">true</span>; <span class="comment">//st：当前点是否在队列中，防止存重复点 </span></span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">st[t]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){<span class="comment">//t变小了，说明所有t的出边对应的点也会变小 </span></span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]){</span><br><span class="line">dist[j]=dist[t]+w[i];</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">st[j]=<span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="built_in">add</span>(a,b,c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">spfa</span>();</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing-852-spfa判断负环"><a href="#AcWing-852-spfa判断负环" class="headerlink" title="AcWing 852 spfa判断负环"></a><a href="https://www.acwing.com/activity/content/problem/content/921/">AcWing 852 spfa判断负环</a></h2><p>加一个cnt数组，<code>cnt[i]</code>记录到顶点<code>i</code>经过的最短路径条数，大于等于<code>n</code>说明存在负环</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],w[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">//关键是看dist有没有更新，值不重要</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>{</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">st[i]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line">}<span class="comment">//判断是否存在负环，而不是 是否存在从1开始到达的负环，所以要把所有点加进去，此时dist也不用初始化了</span></span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">st[t]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]){</span><br><span class="line">dist[j]=dist[t]+w[i];</span><br><span class="line">cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt[j]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line">st[j]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="built_in">add</span>(a,b,c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Floyd-任意两点之间"><a href="#Floyd-任意两点之间" class="headerlink" title="Floyd - 任意两点之间"></a>Floyd - 任意两点之间</h1><p>⭐<strong>一个踩坑点</strong>⭐：</p><p><code>ios::sync_with_stdio(false)</code> 取消cin的同步（就是iostream的缓冲跟stdio的同步） 取消后就<strong>cin就不能</strong>和scanf，sscanf, getchar, fgets，puts之类同时用，💔<strong>否则就可能导致输出和预期的不一样</strong>。</p><blockquote><p>刚开始取消同步，用puts输出impossible，发现顺序不对，还以为是代码问题QAQ，后来改成cout就AC了</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,M=<span class="number">20010</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> dist[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">dist[i][j]=<span class="built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line"><span class="keyword">if</span>(i==j) dist[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> dist[i][j]=INF;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">dist[x][y]=<span class="built_in">min</span>(dist[x][y],z);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">floyd</span>();</span><br><span class="line"><span class="keyword">while</span>(k--){</span><br><span class="line"><span class="keyword">int</span> x,y; cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(dist[x][y]&gt;INF/<span class="number">2</span>) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;dist[x][y]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="💦分层图💦：堆优化Dijkstra-建图"><a href="#💦分层图💦：堆优化Dijkstra-建图" class="headerlink" title="💦分层图💦：堆优化Dijkstra+建图"></a>💦分层图💦：堆优化Dijkstra+建图</h1><p><a href="https://blog.csdn.net/qq_40736036/article/details/85041838">参考阅读： 分层图</a></p><p>$n$ 个点 $m$ 条边构成一张<strong>带权</strong>无向连通图。现在可以从中选出 $k$ 条边，将<strong>边权变为零</strong>。求给定两点间<strong>最短路径</strong>。</p><blockquote><p>将点拆开，复制多层图，并利用特殊构造的边将各层相连的建图方法。</p><p>一般用于边或点有特殊限制的问题(如重复经过次数、多种价值可选等)。</p><p>需要保证拆开后的总点数规模可接受。</p></blockquote><ul><li><strong>空间复杂度及时间复杂度较高，（可以理解为2个点互连的有向图）</strong><ul><li>空间复杂度为$m\times (k+1)$，无向图在此基础上乘2</li></ul></li></ul><p>关键在<code>建图</code></p><ul><li><strong>两种方法解决：</strong><ol><li>建图时直接建成k+1层。</li><li>多开一维记录机会信息。</li></ol></li></ul><h2 id="P4568-飞行路线-洛谷"><a href="#P4568-飞行路线-洛谷" class="headerlink" title="P4568 飞行路线 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P4568">P4568 飞行路线 - 洛谷</a></h2><p><strong>题意</strong>： n 个城市，这些城市分别标记为 0 到 n-1，共 m种航线，每种航线连接两城市，航线有一定的价格。从一个城市沿着航线到达另一个城市，途中可进行转机。可免费在<strong>最多</strong> k种航线上搭乘飞机。问这次出行最少花费</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">5e4</span>+<span class="number">10</span>,K=<span class="number">50</span>; <span class="comment">//注意这里的数据范围，不然被TLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N*K],e[M*K&lt;&lt;<span class="number">1</span>],ne[M*K&lt;&lt;<span class="number">1</span>],w[M*K&lt;&lt;<span class="number">1</span>],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N*K];</span><br><span class="line"><span class="keyword">bool</span> st[N*K];</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规定顶点编号从1开始 </span></span><br><span class="line"><span class="comment">// 稀疏图，堆优化dijkstra </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[s]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;</span><br><span class="line">heap.<span class="built_in">push</span>({<span class="number">0</span>,s});</span><br><span class="line"><span class="keyword">while</span>(!heap.<span class="built_in">empty</span>()){</span><br><span class="line">PII k=heap.<span class="built_in">top</span>();</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> ver=k.second,distance=k.first;</span><br><span class="line"><span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;distance+w[i]){</span><br><span class="line">dist[j]=distance+w[i];</span><br><span class="line">heap.<span class="built_in">push</span>({dist[j],j});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;</span><br><span class="line">s++;t++;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">a++;b++;</span><br><span class="line"><span class="built_in">add</span>(a,b,c),<span class="built_in">add</span>(b,a,c);</span><br><span class="line"><span class="comment">//建立分层图</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++){</span><br><span class="line"><span class="built_in">add</span>(n*i+a,n*i+b,c);</span><br><span class="line"><span class="built_in">add</span>(n*i+b,n*i+a,c);</span><br><span class="line"><span class="comment">//两层之间建边</span></span><br><span class="line"><span class="built_in">add</span>(n*(i<span class="number">-1</span>)+a,n*i+b,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">add</span>(n*(i<span class="number">-1</span>)+b,n*i+a,<span class="number">0</span>); </span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//for(int i=1;i&lt;=k;i++) add(n*(i-1)+t,n*i+t,0);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dijkstra</span>();</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) ans=<span class="built_in">min</span>(ans,dist[t+i*n]);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同类题目：<a href="https://www.luogu.com.cn/problem/P4822">P4822 冻结 - 洛谷 </a></p><ul><li>修改一下起止点，两层之间建边的权值改为c/2 即可</li></ul><h1 id="2️⃣-最小生成树"><a href="#2️⃣-最小生成树" class="headerlink" title="2️⃣ 最小生成树"></a>2️⃣ 最小生成树</h1><ul><li><p>生成树：包含 <strong>所有顶点</strong>的 <strong>极小连通子图</strong> </p></li><li><p>最小生成树：带权连通无向图的  <strong>边的权值之和最小</strong>的那棵生成树</p></li></ul><h1 id="Prim-稠密图：-O-n-2"><a href="#Prim-稠密图：-O-n-2" class="headerlink" title="Prim-稠密图：$O(n^2)$"></a>Prim-稠密图：$O(n^2)$</h1><p>基于<strong>贪心</strong>：每次加入距离连通部分（已确定最小生成树的部分）的<strong>最近的点</strong>和<strong>对应边</strong>，连通部分逐渐扩大至整个图连通，且边权和最小。</p><p><a href="https://www.acwing.com/activity/content/code/content/48767/">参考阅读题解</a></p><ul><li><p>针对<strong>无向图</strong></p></li><li><p>先<strong>累加再更新</strong>，<strong>避免t有自环</strong>影响答案。</p><ul><li>后更新不会影响后面的结果：因为<code>dist[i]</code>为<code>i</code>到集合S的距离，当<code>t</code>放入S后，其<code>dist[t]</code>就已经没有意义，再更新也不会影响答案的正确性。</li></ul></li><li>特判一下第一次迭代，在没有做特殊处理时，第一次迭代中所有点到集合S的距离都为无穷大，且不会进行更新(也没有必要)，不需要将这条边 (第一次迭代时，找到的距离集合S最短的边) 累加到答案中，<strong>也不能认定为图不连通</strong>。</li><li>如果设置起点为i的话，在初始化<code>dist</code>数组之后，<code>dist[i] = 0</code>即可，省去每轮迭代中的两个<code>if</code>判断。</li></ul><h2 id="AcWing-858-Prim算法求最小生成树"><a href="#AcWing-858-Prim算法求最小生成树" class="headerlink" title="AcWing 858 Prim算法求最小生成树"></a><a href="https://www.acwing.com/activity/content/problem/content/924/">AcWing 858 Prim算法求最小生成树</a></h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N]; <span class="comment">//结点 i 到 j 的距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">//存储各个结点到已确定的生成树（顶点集S）的距离；区分dijkstra：到源点的距离 </span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 找剩余点到已确定生成树距离最近的点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line"><span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[j]&lt;dist[t]))</span><br><span class="line">t=j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(i&amp;&amp;dist[t]==INF) <span class="keyword">return</span> INF;<span class="comment">//图不连通</span></span><br><span class="line"><span class="keyword">if</span>(i) res+=dist[t];</span><br><span class="line">st[t]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)  <span class="comment">//更新剩余点到已确定的生成树的距离 </span></span><br><span class="line">dist[j]=<span class="built_in">min</span>(dist[j],g[t][j]); <span class="comment">//区分dijkstra：dist[t]+g[t][j] </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">g[a][b]= g[b][a]=<span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">prim</span>();</span><br><span class="line"><span class="keyword">if</span>(t==INF) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="堆优化Prim-稀疏图"><a href="#堆优化Prim-稀疏图" class="headerlink" title="堆优化Prim-稀疏图"></a>堆优化Prim-稀疏图</h1><p>$O(mlogn)$（不常用、略过，一般遇见稀疏图用下面的Kruskal）</p><h1 id="Kruskal-稀疏图：-O-mlogm"><a href="#Kruskal-稀疏图：-O-mlogm" class="headerlink" title="Kruskal-稀疏图：$O(mlogm)$"></a>Kruskal-稀疏图：$O(mlogm)$</h1><ul><li>主要对边进行操作，比如对边进行排序，考虑采用 <code>结构体</code> 建图</li><li>一条边依附的两个顶点在不同连通分量上：<code>并查集</code></li><li>prim算法需要更新其他点到集合的距离，用到边的权重，需要两条<br>但在kruskal用并差集维护，枚举的是边不是点，</li></ul><p><strong>思想</strong>：</p><ul><li>初始：n个顶点而无边 的非连通图，每个顶点自成一个连通分量 </li><li>按边的权值<strong>从小到大</strong>的顺序</li><li>不断选取当前<strong>未被选过且权值最小</strong>的边<ul><li>若该边 依附的两顶点落在T中不同的连通分量上，加入T </li><li>否则，舍弃此边，选择下一条权值最小的边；</li></ul></li><li>直到所有顶点都在一个连通分量上</li></ul><p><strong>结构体排序</strong>：</p><ul><li><p>结构体内部定义</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">const</span>&lt; (<span class="keyword">const</span> Edge&amp;W)<span class="keyword">const</span>{</span><br><span class="line">    <span class="keyword">return</span> w&lt;W.w</span><br><span class="line">} <span class="comment">// sort(edges,edges+m);</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>cmp外部函数定义</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct Edge A, struct Edge B)</span></span>{</span><br><span class="line"><span class="keyword">return</span> A.w &lt; B.w;</span><br><span class="line">} <span class="comment">// sort(edges,edges+m,cmp);</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>Lambda表达式</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(edges ,edges + m,[](<span class="keyword">auto</span> &amp; u,<span class="keyword">auto</span> &amp; v){<span class="keyword">return</span> u.w &lt; v.w ;});</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="AcWing-859-Kruskal算法求最小生成树"><a href="#AcWing-859-Kruskal算法求最小生成树" class="headerlink" title="AcWing 859 Kruskal算法求最小生成树 "></a><a href="https://www.acwing.com/activity/content/problem/content/925/">AcWing 859 Kruskal算法求最小生成树 </a></h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2</span>*N,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line"><span class="keyword">int</span> a,b,w;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge&amp;W)<span class="keyword">const</span>{</span><br><span class="line"><span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">}</span><br><span class="line">}edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a=edges[i].a, b=edges[i].b, w=edges[i].w;</span><br><span class="line">a=<span class="built_in">find</span>(a),b=<span class="built_in">find</span>(b);</span><br><span class="line"><span class="keyword">if</span>(a!=b){</span><br><span class="line">p[a]=b;</span><br><span class="line">res+=w;</span><br><span class="line">cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">edges[i]={a,b,c};</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">kruskal</span>();</span><br><span class="line"><span class="keyword">if</span>(t==INF) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3️⃣-二分图"><a href="#3️⃣-二分图" class="headerlink" title="3️⃣ 二分图"></a>3️⃣ 二分图</h1><p><a href="https://blog.csdn.net/u011815404/article/details/84260940">参考阅读：图论 —— 二分图</a></p><p><strong>概念</strong>：</p><p>⭕ <strong>二分图定义</strong>：设G=(V,E)是一个<strong>无向图</strong>，如果顶点集V 可分割为<strong>两个互不相交的子集</strong> $(A,B)$，并且图中的每条边$（i，j）$所关联的两个<strong>顶点</strong> $i$ 和 $j$ <strong>分别属于</strong>这两个不同的顶点集$(i \in A,j \in B)$，则称图G为一个二分图（二部图、偶图）</p><p>⭕ 完全二分图：集合A中的所有顶点都与集合B中的所有顶点相连的 二分图</p><p>⭕ 判定二分图的<strong>充要条件</strong>：<strong>图 G 中至少存在两个点，且图中所有回路的长度均为偶数</strong></p><h2 id="AcWing-860-判定二分图：染色法"><a href="#AcWing-860-判定二分图：染色法" class="headerlink" title="AcWing 860 判定二分图：染色法"></a><a href="https://www.acwing.com/activity/content/problem/content/926/">AcWing 860 判定二分图：染色法</a></h2><p>$O(m+n)$</p><p><strong>染色法思想</strong>：</p><ul><li><p>开始：对<strong>任意一个</strong>未染色的顶点染色。</p></li><li><p>判断其相邻的顶点中，若<strong>未染色</strong>，则将其<strong>染上</strong>和相邻顶点<strong>不同</strong>的颜色。</p></li><li><p>若<strong>已经染色</strong>且<strong>颜色和相邻顶点的颜色相同</strong>则说明不是二分图，若颜色不同则继续判断。</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">color[u]=c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(!color[j]){</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(color[j]==c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!color[i]){</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>)){</span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"No"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing-861-二分图的最大匹配：匈牙利算法"><a href="#AcWing-861-二分图的最大匹配：匈牙利算法" class="headerlink" title="AcWing 861 二分图的最大匹配：匈牙利算法"></a><a href="https://www.acwing.com/activity/content/problem/content/927/">AcWing 861 二分图的最大匹配：匈牙利算法</a></h2><p>最坏$O(mn)$，<strong>实际运行一般远小于它</strong></p><p><strong>二分图的匹配</strong>：</p><p>⭕ <strong>匹配</strong>：在给定一个二分图 G，在 G 的一个子图 M 中，若 <strong>M 的边集中的任意两条边都不依附于同一个顶点</strong>，则称 M 是一个匹配。</p><blockquote><p>匹配：一个二分图中边的集合，其中任意两条边都没有公共顶点</p><p>完美匹配：一个图的某个匹配中，所有的顶点都是匹配点</p><p>交替路：从一个<strong>未</strong>匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p><p>增广路：从一个<strong>未</strong>匹配点出发，走交替路，途径另一个未匹配点（出发的点不算）</p></blockquote><p>⭕ <strong>最大匹配</strong>：给定二分图 G 中的所有匹配，所含匹配<strong>边数最多</strong>的匹配</p><blockquote><p>st[ ]数组：可以理解为“预定数组”，比如：看成男女配对，即某一轮中某个女孩是不是被男生预定了。如果find函数 递归下去能够 帮心仪对象的对象找到备胎，那皆大欢喜；找不到备胎，预定姑娘就保持不动。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n1,n2,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> match[N]; <span class="comment">//match[j]=x：右边的j和左边的x配对</span></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line">st[j]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(match[j]==<span class="number">0</span>||<span class="built_in">find</span>(match[j])){</span><br><span class="line">match[j]=x;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="built_in">add</span>(u,v);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;i++){</span><br><span class="line"><span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(i)) ans++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="AcWing1224-交换瓶子"><a href="#AcWing1224-交换瓶子" class="headerlink" title="AcWing1224 交换瓶子"></a>AcWing1224 交换瓶子</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>N个随机排列的数字，编号1-N，<strong>每次交换任意两个数字</strong>，直到最后序号为1-N的升序，求最小交换次数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>把每个瓶子看成一个点，将每个瓶子向它应该在的位置的编号</p><p><img src="https://i.bmp.ovh/imgs/2022/04/03/194ca1fb2eaee9a7.png" style="zoom: 33%;"></p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        {</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; !st[j]; j = b[j])</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/174698/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></tbody></table></figure><p>另外，暴力出奇迹</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,cnt=<span class="number">0</span>;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]!=i){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line"><span class="keyword">if</span>(a[j]==i){</span><br><span class="line"><span class="built_in">swap</span>(a[i],a[j]);cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【总结】数据结构（总结自《算法笔记》和《王道》）</title>
      <link href="/2022/07/08/2022-07-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%80%BB%E7%BB%93%E8%87%AA%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%EF%BC%89/"/>
      <url>/2022/07/08/2022-07-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%80%BB%E7%BB%93%E8%87%AA%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li>随便记记</li></ul><span id="more"></span><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line">st.<span class="built_in">push</span>(i);<span class="comment">//O(1)</span></span><br><span class="line">st.<span class="built_in">top</span>();<span class="comment">//O(1) 取得栈顶元素</span></span><br><span class="line">st.<span class="built_in">pop</span>();<span class="comment">//O(1) 弹出栈顶元素</span></span><br></pre></td></tr></tbody></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;<span class="comment">//以下时间复杂度都是O(1)</span></span><br><span class="line">q.<span class="built_in">front</span>(); q.<span class="built_in">back</span>();</span><br><span class="line">q.<span class="built_in">push</span>();  q.<span class="built_in">pop</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="中缀转后缀-求后缀表达式"><a href="#中缀转后缀-求后缀表达式" class="headerlink" title="中缀转后缀,求后缀表达式"></a>中缀转后缀,求后缀表达式</h2><p><a href="http://codeup.hustoj.com/problem.php?cid=100000602&amp;pid=0">题目链接</a></p><p>《算法笔记》P249</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line"><span class="keyword">double</span> num;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">};</span><br><span class="line">string str;</span><br><span class="line">queue&lt;node&gt;q;<span class="comment">//后缀表达式 </span></span><br><span class="line">stack&lt;node&gt;s;<span class="comment">//符号栈 </span></span><br><span class="line">map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;op;</span><br><span class="line"><span class="comment">//中缀转后缀 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">double</span> num;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();){</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>){</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp.num=str[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span>(i&lt;str.<span class="built_in">length</span>()&amp;&amp;str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>){</span><br><span class="line">temp.num = temp.num*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">q.<span class="built_in">push</span>(temp); <span class="comment">//数字存入后缀表达式队列中</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">temp.flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;op[str[i]]&lt;=op[s.<span class="built_in">top</span>().op]){</span><br><span class="line">q.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">}<span class="comment">//如果优先级不大于栈顶符号,把栈顶符号弹出,压入到后缀表达式中</span></span><br><span class="line">temp.op=str[i];<span class="comment">//直到优先级大于栈顶符号时,压入符号栈中</span></span><br><span class="line">s.<span class="built_in">push</span>(temp);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()){<span class="comment">//符号栈剩余符号压入后缀表达式中</span></span><br><span class="line">q.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//计算后缀表达式 </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cal</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">double</span> temp1,temp2;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t.flag) s.<span class="built_in">push</span>(t);</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp2=s.<span class="built_in">top</span>().num; s.<span class="built_in">pop</span>();</span><br><span class="line">temp1=s.<span class="built_in">top</span>().num; s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t.op==<span class="string">'+'</span>) temp.num =temp1+temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t.op==<span class="string">'-'</span>) temp.num=temp1-temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t.op==<span class="string">'*'</span>) temp.num=temp1*temp2;</span><br><span class="line"><span class="keyword">else</span> temp.num=temp1/temp2;</span><br><span class="line">s.<span class="built_in">push</span>(temp);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">top</span>().num;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">op[<span class="string">'+'</span>]=op[<span class="string">'-'</span>]=<span class="number">1</span>;</span><br><span class="line">op[<span class="string">'/'</span>]=op[<span class="string">'*'</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin,str),str!=<span class="string">"0"</span>){</span><br><span class="line"><span class="keyword">for</span>(string::iterator it=str.<span class="built_in">end</span>();it!=str.<span class="built_in">begin</span>();it--){</span><br><span class="line"><span class="keyword">if</span>(*it==<span class="string">' '</span>) str.<span class="built_in">erase</span>(it);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">Change</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,<span class="built_in">Cal</span>());</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h2><p><a href="http://codeup.hustoj.com/problem.php?cid=100000605&amp;pid=1">题目链接</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">stack&lt;<span class="keyword">char</span>&gt;s;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++){</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'['</span>||str[i]==<span class="string">'('</span>||str[i]==<span class="string">'{'</span>) s.<span class="built_in">push</span>(str[i]);</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">']'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'['</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">')'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'('</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'}'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'{'</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(!flag||!s.<span class="built_in">empty</span>()) cout&lt;&lt;<span class="string">"no"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"yes"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><h2 id="图的邻接表转换为邻接矩阵存储"><a href="#图的邻接表转换为邻接矩阵存储" class="headerlink" title="图的邻接表转换为邻接矩阵存储"></a>图的邻接表转换为邻接矩阵存储</h2><p><strong>算法思想</strong>： 设图的顶点分别存储在数组<code>v[n]</code>中。首先初始化邻接矩阵。遍历邻接表，在依次遍历顶点<code>v[i]</code>的边链表时，修改邻接矩阵的第<code>i</code>行的元素值。若链表边结点的值为<code>j</code>，则置<code>arcs[i][j]=1</code>。无向、有向图均适用。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Convert</span><span class="params">(ALGraph &amp;G, <span class="keyword">int</span> arcs[M][N])</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">        p = (G -&gt; v[i]).firstarc;</span><br><span class="line">        <span class="keyword">while</span>(p != null){</span><br><span class="line">            arcs[i][p -&gt; data] = <span class="number">1</span>;</span><br><span class="line">            p = p -&gt;nextarc;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】BFS &amp; DFS</title>
      <link href="/2022/06/19/2022-06-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91BFS/"/>
      <url>/2022/06/19/2022-06-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91BFS/</url>
      
        <content type="html"><![CDATA[<ul><li>一些BFS</li></ul><span id="more"></span><h1 id="Easy-Part"><a href="#Easy-Part" class="headerlink" title="Easy Part"></a>Easy Part</h1><p>队列queue、O(2^h)、最短路(只有所有边权都是1 的时候才可以用BFS做最短路问题)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queue←初始</span><br><span class="line"><span class="keyword">while</span> queue非空{</span><br><span class="line">t←队头；扩展队头<span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcW-844-走迷宫"><a href="#AcW-844-走迷宫" class="headerlink" title="AcW-844. 走迷宫 "></a><a href="https://www.acwing.com/problem/content/846/">AcW-844. 走迷宫 </a></h2><p>给定地图，求左上走到右下的步数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>({<span class="number">1</span>,<span class="number">1</span>});</span><br><span class="line">d[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> temp=q.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">int</span> x=temp.first,y=temp.second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=m&amp;&amp;d[xx][yy]==<span class="number">-1</span>&amp;&amp;g[x][y]==<span class="number">0</span>){</span><br><span class="line">d[xx][yy]=d[x][y]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({xx,yy});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;d[n][m]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing843-n皇后问题"><a href="#AcWing843-n皇后问题" class="headerlink" title="AcWing843 n皇后问题"></a>AcWing843 n皇后问题</h2><ul><li><p>对于第r行第i列所在的对角线和反对角线</p><p><strong>对角线</strong> <code>dg[r+i]</code>，<strong>反对角线</strong><code>udg[n−r+i]</code>中的下标  <code>r+i</code>和  <code>n−r+i</code>  表示的是<strong>截距</strong></p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> dg[N],udg[N],col[N];</span><br><span class="line"><span class="comment">//dfs(r)在第r行上放皇后 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(r==n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">puts</span>(a[i]);<span class="comment">//cout&lt;&lt;a[i]&lt;&lt;endl; </span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>); <span class="comment">//换行 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//针对当前第r行，枚举 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!col[i] &amp;&amp; !dg[r + i] &amp;&amp; !udg[n - r + i]){</span><br><span class="line">a[r][i]=<span class="string">'Q'</span>;</span><br><span class="line">col[i] = dg[r + i] = udg[n - r + i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(r+<span class="number">1</span>);</span><br><span class="line">col[i] = dg[r + i] = udg[n - r + i] = <span class="literal">false</span>; </span><br><span class="line">a[r][i]=<span class="string">'.'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) a[i][j]=<span class="string">'.'</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1101-献给阿尔吉侬的花束"><a href="#AcWing1101-献给阿尔吉侬的花束" class="headerlink" title="AcWing1101 献给阿尔吉侬的花束"></a>AcWing1101 献给阿尔吉侬的花束</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n,r,c;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(PII st,PII ed)</span></span>{</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line">d[st.first][st.second]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;r&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;c&amp;&amp;g[x][y]!=<span class="string">'#'</span>&amp;&amp;d[x][y]==<span class="number">-1</span>){</span><br><span class="line">d[x][y]=d[t.first][t.second]+<span class="number">1</span>;</span><br><span class="line">PII xy={x,y};</span><br><span class="line"><span class="keyword">if</span>(xy==ed) <span class="keyword">return</span> d[x][y];</span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">PII st,ed;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++){</span><br><span class="line">cin&gt;&gt;g[i][j]; </span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'S'</span>) st={i,j};</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'E'</span>) ed={i,j};</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">int</span> ans=<span class="built_in">bfs</span>(st,ed);</span><br><span class="line"><span class="keyword">if</span>(ans!=<span class="number">-1</span>) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"oop!"</span>&lt;&lt;endl; </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1113-红与黑"><a href="#AcWing1113-红与黑" class="headerlink" title="AcWing1113 红与黑"></a>AcWing1113 红与黑</h2><h3 id="BFS写法"><a href="#BFS写法" class="headerlink" title="BFS写法"></a>BFS写法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> w,h;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(PII st)</span></span>{</span><br><span class="line">d[st.first][st.second]=<span class="number">1</span>;</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;h&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;w&amp;&amp;d[x][y]==<span class="number">-1</span>&amp;&amp;g[x][y]==<span class="string">'.'</span>){</span><br><span class="line">d[x][y]=<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">cin&gt;&gt;w&gt;&gt;h;<span class="keyword">if</span>(w==<span class="number">0</span>&amp;&amp;h==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">PII st;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w;j++){</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'@'</span>) st={i,j};</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">bfs</span>(st);</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w;j++){</span><br><span class="line"><span class="keyword">if</span>(d[i][j]==<span class="number">1</span>) cnt++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="DFS写法"><a href="#DFS写法" class="headerlink" title="DFS写法"></a>DFS写法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>},dy[]={<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">g[x][y]=<span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> a=x+dx[i],b=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;n&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;m&amp;&amp;g[a][b]==<span class="string">'.'</span>){</span><br><span class="line">res+=<span class="built_in">dfs</span>(a,b);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;m&gt;&gt;n,n||m){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;g[i];</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'@'</span>){</span><br><span class="line">x=i,y=j;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;<span class="built_in">dfs</span>(x,y)&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1096-地牢大师（三维）"><a href="#AcWing1096-地牢大师（三维）" class="headerlink" title="AcWing1096 地牢大师（三维）"></a>AcWing1096 地牢大师（三维）</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>发现有时候代码写不对注意检查：初始点的状态设置是否遗漏，bfs里面坐标的判断有无遗漏，标志数组是否遗漏</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Coo</span>{</span></span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">};<span class="comment">//存储xyz坐标 </span></span><br><span class="line"><span class="keyword">char</span> g[N][N][N]; <span class="comment">//xyz</span></span><br><span class="line"><span class="keyword">int</span> d[N][N][N];<span class="comment">//存储走到xyz的距离 </span></span><br><span class="line"><span class="keyword">int</span> l,r,c;</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},dy[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>},dz[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Coo st,Coo ed)</span></span>{</span><br><span class="line">d[st.x][st.y][st.z]=<span class="number">0</span>;</span><br><span class="line">queue&lt;Coo&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.x+dx[i],y=t.y+dy[i],z=t.z+dz[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;r&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;c&amp;&amp;z&gt;=<span class="number">0</span>&amp;&amp;z&lt;l){<span class="comment">//坐标合法 </span></span><br><span class="line"><span class="keyword">if</span>(d[x][y][z]==<span class="number">-1</span>&amp;&amp;g[x][y][z]!=<span class="string">'#'</span>){<span class="comment">//且没有被走过且可以走 </span></span><br><span class="line">d[x][y][z]=d[t.x][t.y][t.z]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({x,y,z});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(d[ed.x][ed.y][ed.z]!=<span class="number">-1</span>) cout&lt;&lt;<span class="string">"Escaped in "</span>&lt;&lt;d[ed.x][ed.y][ed.z]&lt;&lt;<span class="string">" minute(s)."</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"Trapped!"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">Coo st,ed;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;c);<span class="keyword">if</span>(l==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;r;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;c;k++){</span><br><span class="line">cin&gt;&gt;g[j][k][i];</span><br><span class="line"><span class="keyword">if</span>(g[j][k][i]==<span class="string">'S'</span>) st={j,k,i};</span><br><span class="line">i</span><br><span class="line">                        ed={j,k,i};</span><br><span class="line">} </span><br><span class="line"><span class="built_in">bfs</span>(st,ed); </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Flood-Fill算法"><a href="#Flood-Fill算法" class="headerlink" title="Flood Fill算法"></a>Flood Fill算法</h1><ul><li>针对网格图的题，找连通的块的数目</li><li>dfs，bfs；dfs有时候可能会有爆栈的风险；都能实现的话用dfs更加方便</li><li>bfs：</li></ul><hr><h2 id="AcWing1233-全球变暖"><a href="#AcWing1233-全球变暖" class="headerlink" title="AcWing1233 全球变暖"></a>AcWing1233 全球变暖</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>多少个连通块，遍历<ul><li>找连通块：遍历BFSorDFS 、或者 并查集</li></ul></li><li>多少个连通块会被淹没掉<ul><li>如何判断被淹没：一共有多少个单元totoal，多少个单元在边界bound上</li><li>等价于==》 total=bound</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];<span class="comment">//当前点是否被搜索过 </span></span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>},dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> sx,<span class="keyword">int</span> sy,<span class="keyword">int</span> &amp;total,<span class="keyword">int</span> &amp;bound)</span></span>{</span><br><span class="line">PII pi={sx,sy};</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(pi);</span><br><span class="line">st[sx][sy]=<span class="literal">true</span>;<span class="comment">//当前第一个点被遍历 记得要标记 </span></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">total++;</span><br><span class="line"><span class="keyword">int</span> is_bound=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//判断当前t是否临海 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line">            <span class="comment">//当前t周围的点的坐标合法，且岛屿没有被遍历过</span></span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n&amp;&amp;(!st[x][y])){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'.'</span>) is_bound=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'#'</span>){</span><br><span class="line">st[x][y]=<span class="literal">true</span>; q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">bound+=is_bound;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;g[i];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;<span class="comment">//被淹没的 岛屿的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line"><span class="keyword">if</span>(!st[i][j]&amp;&amp;g[i][j]==<span class="string">'#'</span>){</span><br><span class="line"><span class="keyword">int</span> total=<span class="number">0</span>,bound=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//从当前点开始，统计这个点所在的连通块 </span></span><br><span class="line"><span class="built_in">bfs</span>(i,j,total,bound);</span><br><span class="line"><span class="keyword">if</span>(total==bound) cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,cnt); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1097-池塘计数"><a href="#AcWing1097-池塘计数" class="headerlink" title="AcWing1097 池塘计数"></a>AcWing1097 池塘计数</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>dfs：遍历每个W，标记，从当前W开始八个方向深搜；每次从一个W搜完，与之相连的W都变成. </li><li>bfs：遍历每个W，标记，从当前W开始八个方向宽搜。。。。。</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">g[a][b]=<span class="string">'.'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=a+dx[i],y=b+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'W'</span>)</span><br><span class="line"><span class="built_in">dfs</span>(x,y);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//cin&gt;&gt;g[i];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) cin&gt;&gt;g[i][j];</span><br><span class="line">    <span class="comment">//连通块问题，从每个点开始bfs or dfs</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'W'</span>){</span><br><span class="line"><span class="built_in">dfs</span>(i,j);</span><br><span class="line">cnt++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p><strong>标记数组的位置很重要，一定要放在入队（q.push())之前</strong>，不然会T掉！<br>    在bfs中，如果对于之后的某个合法位置，应该入队，那么标记数组会有两种方法，第一种是在每次取队首元素的时候，标记已经遍历过当前点了，还有一种方法是在入队之前就马上标记。之前没太注意这个，但是是完全不一样的，对于8个方向，比如向<strong>左走一步是合法</strong>的，然后不马上标记的话，例如当前<strong>向下和向左</strong>都是合法的，那么当<strong>向下走时候(比如向下先入队了)，那么向左走还会被记录一次</strong>，这个很难debug出来，很奇怪的感觉</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">PII pi={a,b};</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(pi);</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//g[t.first][t.second]='.'; 不要在这个位置标记</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'W'</span>){</span><br><span class="line">                    g[x][y]=<span class="string">'.'</span>;<span class="comment">//要在这个位置标记！！！！！！！！！！！</span></span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'W'</span>){</span><br><span class="line"><span class="built_in">bfs</span>(i,j);</span><br><span class="line">cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="树与图的DFS"><a href="#树与图的DFS" class="headerlink" title="树与图的DFS"></a>树与图的DFS</h2><ul><li>有向图存储<ul><li>邻接矩阵（用的比较少，g[a] [b])，不能存储重边</li><li><strong>邻接表</strong>：每个节点开了一个表，存着<strong>这个点可以走到哪个点</strong>（内部点的存储次序无关紧要）</li></ul></li></ul><h3 id="AcW-846-树的重心"><a href="#AcW-846-树的重心" class="headerlink" title="AcW-846. 树的重心"></a><a href="https://www.acwing.com/activity/content/problem/content/909/">AcW-846. 树的重心</a></h3><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一颗树，包含 <strong>n个结点</strong>（编号 1∼n）和 n−1 条<strong>无向边</strong>。</p><p>找树的重心，并输出将重心删除后，<strong>剩余各个连通块中节点数</strong>的<strong>最大值</strong>。</p><p>重心定义：重心是指树中的一个结点，如果将这个点删除后，<strong>剩余各个连通块中点数的最大值最小</strong>，那么这个节点被称为树的重心。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>无向图：建立边的时候两个方向都要建边</li><li>枚举删掉每一个点剩余连通块的节点数量的最大值，从各个最大值中找到最小值</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> ans=N,n;</span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//标记是否被遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">idx=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//插入一条a到b的边：</span></span><br><span class="line"><span class="comment">//在a所对应的邻接表里面插入一个节点b(头插) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//从节点u深搜，返回size:以u为根的树中 点的数量 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">st[u]=<span class="literal">true</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> size=<span class="number">1</span>,res=<span class="number">0</span>;<span class="comment">//sum：删掉这个点的连通块大小的最大值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]){<span class="comment">//遍历u节点的子节点</span></span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line"><span class="keyword">int</span> s=<span class="built_in">dfs</span>(j);<span class="comment">//s：当前子树的大小 </span></span><br><span class="line">size+=s;<span class="comment">//</span></span><br><span class="line">res=<span class="built_in">max</span>(res,s);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//和删除该点后的父节点的连通块大小 比较 </span></span><br><span class="line">res=<span class="built_in">max</span>(res,n-size);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,res); </span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="树与图的BFS"><a href="#树与图的BFS" class="headerlink" title="树与图的BFS"></a>树与图的BFS</h2><h3 id="AcW-847-图中点的层次"><a href="#AcW-847-图中点的层次" class="headerlink" title="AcW-847. 图中点的层次 "></a><a href="https://www.acwing.com/activity/content/problem/content/910/">AcW-847. 图中点的层次 </a></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//d[i]存储1号点走到i号点的距离 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);<span class="comment">//-1标记没走过 </span></span><br><span class="line">d[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//初始化，然后入队 </span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//扩展 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];<span class="comment">//通过索引i找到t能到的节点编号 </span></span><br><span class="line"><span class="keyword">if</span>(d[j]==<span class="number">-1</span>){</span><br><span class="line">d[j]=d[t]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line">cout&lt;&lt;d[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="AcW-848-有向图的拓扑序列"><a href="#AcW-848-有向图的拓扑序列" class="headerlink" title="AcW-848. 有向图的拓扑序列"></a><a href="https://www.acwing.com/problem/content/850/">AcW-848. 有向图的拓扑序列</a></h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给定有向图（可能有重边和自环）</p><p>若存在拓扑序列，则输出；不存在则输出-1</p><p>若一个由图中<strong>所有点</strong>构成的序列 A满足：对于图中的每条边 <strong>(x,y)</strong>，x 在 序列A 中都出现在 y <strong>之前</strong>，则称 A 是该图的一个拓扑序列。（即：所有的边都是从前指向后的）</p><p><strong>有向无环图一定存在拓扑序列：拓扑图</strong></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>入度=0：<strong>没有任何一条边指向它</strong>，所以可以排在当前最前面的位置：将其<strong>入队</strong></li><li>宽搜，枚举所有出边，t→j ，删掉t→j：j的入度-1，</li><li>如果j的入度=0，说明j前面的都排好序了，所以j可以入队</li></ul><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;top;<span class="comment">//存放最终序列 </span></span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//入度 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span>{</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="comment">//把所有入度为0的点插入队列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!d[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">top.<span class="built_in">push</span>(t);</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];<span class="comment">//出边的点</span></span><br><span class="line">d[j]--; </span><br><span class="line"><span class="keyword">if</span>(d[j]==<span class="number">0</span>) q.<span class="built_in">push</span>(j);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断是否所有点都入队</span></span><br><span class="line"><span class="keyword">return</span> top.<span class="built_in">size</span>()==n;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b);</span><br><span class="line">d[b]++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">topsort</span>()){</span><br><span class="line"><span class="keyword">while</span>(!top.<span class="built_in">empty</span>()){</span><br><span class="line">cout&lt;&lt;top.<span class="built_in">front</span>()&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">top.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}<span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Medium-Part"><a href="#Medium-Part" class="headerlink" title="Medium Part"></a>Medium Part</h1><h2 id="最小步数模型：状态的转变"><a href="#最小步数模型：状态的转变" class="headerlink" title="最小步数模型：状态的转变"></a>最小步数模型：状态的转变</h2><p>区分最短路模型：从一个点到另一个点的最短距离（比如AcW-844走迷宫）</p><p>关键：</p><ol><li>状态的存储：<ul><li><code>queue&lt;状态&gt;</code></li><li><code>unordered_map&lt;状态，步数&gt;dist</code>：记录到达状态的距离</li><li><code>unordered_map&lt;状态，&lt;前一个状态,转移操作&gt;</code>：记录前驱，用于路径输出</li></ul></li><li>状态的切换<ul><li>根据题意;</li><li>（下标从0开始）二维到一维：<code>int x = index / row_length, y = index % col_length</code></li></ul></li><li>思路：<ul><li>将初始状态加入到队列，然后BFS扩展，直到找到目标状态为止</li></ul></li></ol><h3 id="AcW-845-八数码"><a href="#AcW-845-八数码" class="headerlink" title="AcW-845. 八数码"></a><a href="https://www.acwing.com/problem/content/description/847/">AcW-845. 八数码</a></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1、将每个3x3 理解成一个状态</span></span><br><span class="line"><span class="comment">2、从初始3x3到12345678x最小步数 -&gt; 从初始状态到目标状态 最短路</span></span><br><span class="line"><span class="comment">类比走迷宫那道题：从左上到右下的最小步数 </span></span><br><span class="line"><span class="comment">3、到达每个状态的对应一个步数：unordered_map&lt;string,int&gt;</span></span><br><span class="line"><span class="comment">4、unordered_map的count()用以统计key在unordered_map中出现的次数。</span></span><br><span class="line"><span class="comment">实际上，unordered_map不允许有重复的key。</span></span><br><span class="line"><span class="comment">因此，如果key存在，则count返回1，如果不存在，则count返回0. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(string start)</span></span>{</span><br><span class="line">queue&lt;string&gt;q;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt;d;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line">d[start]=<span class="number">0</span>;<span class="comment">//unordered_map[key]=value;</span></span><br><span class="line">string end=<span class="string">"12345678x"</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t==end) <span class="keyword">return</span> d[t];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx=t.<span class="built_in">find</span>(<span class="string">'x'</span>);</span><br><span class="line"><span class="keyword">int</span> x=idx/<span class="number">3</span>,y=idx%<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> dist=d[t];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;<span class="number">3</span>&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;<span class="number">3</span>){</span><br><span class="line"><span class="built_in">swap</span>(t[idx],t[xx*<span class="number">3</span>+yy]);</span><br><span class="line"><span class="keyword">if</span>(!d.<span class="built_in">count</span>(t)){</span><br><span class="line">d[t]=dist+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">swap</span>(t[idx],t[xx*<span class="number">3</span>+yy]);</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>];</span><br><span class="line">string start=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++){</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">start+=s[<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"><span class="comment">//cout&lt;&lt;start&lt;&lt;endl;</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">bfs</span>(start)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 2  3  4  1  5  x  7  6  8 </span></span><br></pre></td></tr></tbody></table></figure><h3 id="AcW-1107-魔板"><a href="#AcW-1107-魔板" class="headerlink" title="AcW-1107. 魔板 "></a><a href="https://www.acwing.com/problem/content/1109/">AcW-1107. 魔板 </a></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> temp[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//每个状态string，存储上一个状态string </span></span><br><span class="line"><span class="comment">//经过操作char到达 </span></span><br><span class="line">unordered_map&lt;string,pair&lt;string,<span class="keyword">char</span>&gt;&gt;pre;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt;d;<span class="comment">//存储步数 </span></span><br><span class="line"><span class="keyword">void</span> _set(string s){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) temp[<span class="number">0</span>][i]=s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">7</span>;i&lt;<span class="number">4</span>,j&gt;<span class="number">3</span>;i++,j--) temp[<span class="number">1</span>][i]=s[j];</span><br><span class="line">}</span><br><span class="line"><span class="function">string <span class="title">get</span><span class="params">()</span></span>{</span><br><span class="line">string res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) res+=temp[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--) res+=temp[<span class="number">1</span>][i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//A:交换上下 </span></span><br><span class="line"><span class="function">string <span class="title">move0</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"> <span class="built_in">swap</span>(temp[<span class="number">0</span>],temp[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//B: </span></span><br><span class="line"><span class="function">string <span class="title">move1</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"><span class="keyword">char</span> a=temp[<span class="number">0</span>][<span class="number">3</span>],b=temp[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">temp[<span class="number">0</span>][i]=temp[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">temp[<span class="number">1</span>][i]=temp[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">} </span><br><span class="line">temp[<span class="number">0</span>][<span class="number">0</span>]=a;</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">0</span>]=b;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//C: </span></span><br><span class="line"><span class="function">string <span class="title">move2</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"><span class="keyword">char</span> t=temp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">temp[<span class="number">0</span>][<span class="number">2</span>]=temp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">temp[<span class="number">0</span>][<span class="number">1</span>]=temp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">1</span>]=temp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">2</span>]=t;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(string start,string end)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(start==end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">queue&lt;string&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line">d[start]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">string state[<span class="number">3</span>];</span><br><span class="line">state[<span class="number">0</span>]=<span class="built_in">move0</span>(t);</span><br><span class="line">state[<span class="number">1</span>]=<span class="built_in">move1</span>(t);</span><br><span class="line">state[<span class="number">2</span>]=<span class="built_in">move2</span>(t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++){</span><br><span class="line"><span class="keyword">if</span>(!d.<span class="built_in">count</span>(state[i])){</span><br><span class="line">d[state[i]]=d[t]+<span class="number">1</span>;</span><br><span class="line">pre[state[i]]={t,<span class="string">'A'</span>+i};</span><br><span class="line">q.<span class="built_in">push</span>(state[i]); </span><br><span class="line"><span class="keyword">if</span>(state[i]==end){</span><br><span class="line"><span class="keyword">return</span> d[state[i]];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">string start=<span class="string">"12345678"</span>;</span><br><span class="line">string end=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">end+=<span class="built_in"><span class="keyword">char</span></span>(c+<span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="built_in">bfs</span>(start,end);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">string res;<span class="comment">//从end往前找前驱 </span></span><br><span class="line"><span class="keyword">while</span>(end!=start){</span><br><span class="line">res+=pre[end].second;</span><br><span class="line">end=pre[end].first;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(ans&gt;<span class="number">0</span>) cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【生活】Days Counter</title>
      <link href="/2022/06/17/DaysCounter/"/>
      <url>/2022/06/17/DaysCounter/</url>
      
        <content type="html"><![CDATA[<p>一些碎碎念记录</p><span id="more"></span><h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><h2 id="June"><a href="#June" class="headerlink" title="June"></a>June</h2><h3 id="17th"><a href="#17th" class="headerlink" title="17th"></a>17th</h3><ul><li>上午去把川大夏令营的章盖了，然后划水一上午</li><li>下午把网页代码写了一点，然后划水一下午</li><li>水群的时候看到fdu的夏令营开奖了，计科两位大佬入营了，太牛了，还好我没报，不然就要收到人生第一封夏令营拒信了OvO</li><li>小脑斧点赞我朋友圈了呜呜，泪目</li></ul><h3 id="18th"><a href="#18th" class="headerlink" title="18th"></a>18th</h3><ul><li>写了半天的前端</li><li>剩下半天划水</li><li>在b站刷到了以前的一部剧，《爱情宝典》，看了两集，果然还是那个年代的人做电视剧细心啊，服化道和人物形象和语言都让人觉得舒服，剧情节奏紧凑。</li></ul><h3 id="19th"><a href="#19th" class="headerlink" title="19th"></a>19th</h3><ul><li>上午把buaa的材料交了</li><li>下午睡了半个下午，写了半个下午的文档</li><li>呜呜感觉自己效率真的好低 ，一天下来好像什么也没干，等把信安赛初赛作品交了我要全身心投入复习！！！不能再像最近几天这么摸鱼了，感觉自己有好多东西要看，数据结构没复习完，计网还没开始背，操作系统也没有看，但操作系统应该很快就能看完吧。acwing的基础课还没有刷完，之前卖的linux基础课也没看，项目还没有好好整理复习。救命，怎么会有这么多事情要做，感觉自己一样都没开始做好QAQ。</li></ul><h3 id="20th"><a href="#20th" class="headerlink" title="20th"></a>20th</h3><ul><li>嗯，有点烦躁的一天。嗯，怎么说呢，学好语文真的是太重要太重要了，尤其是对于理工科。</li><li>熬一熬，再熬一熬就可以全身心地开始复习专业课了啾咪啾咪</li><li>晚上把文档搞完了，九点多就回去躺着啦嘿嘿</li></ul><h3 id="21st"><a href="#21st" class="headerlink" title="21st"></a>21st</h3><ul><li>早上自然醒太早了，把闹钟关了睡了个回笼觉结果睡过头了，上午就看了一点点点二叉树</li><li>中午回去吃完饭睡个午觉一觉睡到了三点多，开空调也能被热醒QAQ，傍晚洗完头洗完澡舒服多了，晚上等温度降下来了然后出门转一转</li><li>等晚上回来再好好学习（希望如此，但是现在就是一个毫无动力的状态，没有ddl来push我学习效率真的是太低惹。</li><li>晚上并没有好好学习，不过解决了一件麻烦事，舒服了<span class="github-emoji"><span>💮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4ae.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>先给明天画个饼🤗：早起（8点之前？），看完计网第一章，复习os第二章，刷几道基础课的题<span class="github-emoji"><span>🔨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f528.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="22nd"><a href="#22nd" class="headerlink" title="22nd"></a>22nd</h3><ul><li><p>确实早起成功了，六点半自然醒，意识醒了但是眼睛 睁不开<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，勉强睡到七点半才下床</p></li><li><p>给未来几天画个大饼</p></li><li><p>晚上摸鱼去啦，去一号门外面买了点荔枝和山竹，荔枝还是得吃妃子笑，白糖荔真的垃圾，水分和甜度都比不上妃子笑，虽然看起来大个儿又好看，但是核太大了，一颗白糖荔半颗核属于是。妃子笑yyds<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li></ul><h3 id="23rd"><a href="#23rd" class="headerlink" title="23rd"></a>23rd</h3><ul><li>上午开了个会，改了一下互联网+那个比赛的前端代码，<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>点了七口辣的火锅杯，一会儿拿完外卖再买半个西瓜再回宿舍，刷几集神探狄仁杰（真的没啥好剧可以看了，还是看这种老剧有意思，拍的真好啊），打算三点多的时候再出门吧，去院办把bit的章盖了，然后把留在院办的东西拿回来。学习，晚上再学<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>晚上不想学呜呜，呜呜能不能直接躺平等预推免啊，夏0营太耗费精力了呜呜，学不动 烦死啦，回去继续刷神探狄仁杰！！！！！！！！！！！</li></ul><h3 id="24th"><a href="#24th" class="headerlink" title="24th"></a>24th</h3><ul><li>昨天晚上南京下暴雨，一早睡到十点半才醒，中午点了黄焖鸡米饭，点的这家的不好吃，不如一号门外面的那家黄焖鸡米饭，有空出去吃一吃那家的<span class="github-emoji"><span>😮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>下午把计网的第一章看完了，好多啊好多啊，将近200页ppt，真的会谢，突然想起去年这个时候大概也在复习计网，hhh去年七月初考的计网好像是。</li><li>晚上数字图像处理的成绩出了，大三最后一门。以后再也不用卷生卷死卷分数啦 ，从大一上最初的82点几的均分，到大三下92点几的均分，还真是个逐渐“卷”化的三年，呜呜，这三年怎么这么快，呜呜<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="25th"><a href="#25th" class="headerlink" title="25th"></a>25th</h3><ul><li>上午又是一觉睡到十点多，虽然每天都是七点左右自然醒，但是醒了又没完全醒，所以继续睡<span class="github-emoji"><span>😴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f634.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>下午都在写PPT，没时间复习呜呜呜。</li><li>晚上去一号路吃了那个麻辣牛肚卷，牛肚真好吃呀，明天如果没吃晚饭的话就再去吃一次嘿嘿:happy:看计网的应用层的PPT看到了80页<span class="github-emoji"><span>💁♀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f481-2640.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，嗯，明天干啥呢，赌一波明天能不能早起，如果早起的话争取上午把应用层这一章的ppt看完吧，下午复习一下数据结构的查找那一章；晚上再过一遍os的进程这一章以及上午（可能）没看完的计网ppt</li></ul><h3 id="26th"><a href="#26th" class="headerlink" title="26th"></a>26th</h3><ul><li>早起成功，不过已经是早上十点<span class="github-emoji"><span>🕙</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f559.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，上午看了40页PPT，呜呜华东师范寄了呜呜，真就夏0营呗，呜呜呜呜，川大要是再给我寄，真的会emo呜呜，川大，我的川大<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>虽然说智能的去年前几名也是夏0营，呜呜，我知道是神仙打架，但是能不能给我一个offer保底呐QWQ，心痛呜呜，下午决定把那几个不想去的学校也报一下呜呜，能不能让我有个夏令营体验感！！！！！</li><li>15:50的时候终于把应用层这章的PPT看完了<span class="github-emoji"><span>🤠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f920.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>下午跟cbj学长聊了会儿保研的事情，呜呜感觉自己又重新燃起了自己一定有书读的期望！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</li><li>18:57把数据结构的排序这章看了2/3，好饿QwQ，出去吃昨天吃的牛肚卷！<span class="github-emoji"><span>🤗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f917.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>吃饱回来再学</li><li>牛肚卷好好吃✌，吃完回来把排序这张看完了；昨天画的饼没有实现<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>（虽然是意料之中</li><li>如果明天能够早起的话，画的饼应该就是：上午把王道的排序这章节题做了，如果互联网+的ppt浪费的时间不多的话，复习一下os的存储管理这一章，然后倒着过一遍进程和死锁那一章；</li></ul><h3 id="27th-30th"><a href="#27th-30th" class="headerlink" title="27th-30th"></a>27th-30th</h3><ul><li>头痛摸鱼睡觉不愿打字</li></ul><h2 id="July"><a href="#July" class="headerlink" title="July"></a>July</h2><h3 id="1st"><a href="#1st" class="headerlink" title="1st"></a>1st</h3><ul><li>买的摄像头和支架到了，白天复习了操作系统的文件管理（一半），还剩最后的IO设备管理</li><li>今天晚上把比赛报告改完然后看一遍，再把ppt做了，还要川大的面试ppt</li><li>2、3、4、5、希望3号之前能把os过一遍，4、5号复习数据结构，自我介绍打个草稿QwQ</li><li>等南大的机试完了（寄了）然后开始跑步运动；上旬复习408，下旬复习数学！zyl可真会画大饼呐</li></ul><h3 id="2nd"><a href="#2nd" class="headerlink" title="2nd"></a>2nd</h3><ul><li><p>越是ddl就越是懒，在摆烂的边缘疯狂试探</p></li><li><p>下午把文件管理和设备管理走马观花看完了，晚上回寝室摸鱼嘿嘿嘿</p></li><li><p>夏天的天空真的好好看，不用p图的好看</p><p><img src="https://s2.loli.net/2022/07/03/Aje27ih1sdmZpEG.jpg" alt="SHWY_N_7P9@M87J3UOU_VXK.jpg" style="zoom: 50%;"></p></li><li><p>晚上嘴馋但是不饿，点了鸡丁炒饭，我觉得酸豇豆和酸萝卜真的好吃，感觉一般般，所以吃了一个多小时一半都没吃完</p><p><img src="https://s2.loli.net/2022/07/03/wEos5eXkpqvArFu.jpg" alt="5__WOM1`GU_05CH60Q9_K83.jpg" style="zoom:20%;"></p></li><li><p>听闻某同学 北大，复旦，人大，中山，上交都入营了之后的内心活动：<br>真厉害啊不愧是ta太牛啦<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>呜呜呜不愧是我太废物啦<span class="github-emoji"><span>😿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f63f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>呜呜真就2%的人拿98%的offer<span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>好累尼玛，等川大面试完就躺平准备预推免吧，夏令营不适合我这种垃圾<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>每个高校的夏令营就是硬气，只要985和211的rk1[自抱]希望你们预推免和九推的时候也敢这么硬气<span class="github-emoji"><span>😮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>希望大佬们夏令营赶紧拿完offer早点确定，预推免不要跟我这种垃圾争<span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li></ul><h3 id="3rd"><a href="#3rd" class="headerlink" title="3rd"></a>3rd</h3><ul><li>呜呜呜我以为 今天能够把os过一遍，结果晚上才开始过进程这一章呜呜，明天就开营了淦</li><li>买了一盒周黑鸭的鸭翅，好好吃<span class="github-emoji"><span>💃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f483.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>💃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f483.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>💃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f483.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="4th"><a href="#4th" class="headerlink" title="4th"></a>4th</h3><ul><li>排队等njucs的网络测试浪费我一个下午，哼哼</li></ul><h3 id="5th"><a href="#5th" class="headerlink" title="5th"></a>5th</h3><ul><li><p>吼吼，生活费到账了，点了绝味的鸭翅，真没有周黑鸭的鸭翅好吃，这波属实周黑鸭赢！</p></li><li><p>今天发现网易云的一个新功能，就是用歌房的耳返功能来背书，真不错！！！！！！！</p></li><li><p>早上起来发现寝室没电了，问了六个人校园卡里有没有钱，结果都没有hhhh</p><p><img src="https://s2.loli.net/2022/07/05/wW6aUFudTLZe2mD.png" alt="image.png" style="zoom: 33%;"></p></li><li><p>北航入营了，得知入营的瞬间是开心的，但又发现机试过不了的话不仅无法面试，还不能报之后的预推免，悲，真的是大喜大悲，无尽的悲。这种给你希望又让你意识到最后没有希望的感觉真是太上头迷死人啦<span class="github-emoji"><span>😡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f621.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，夏令营==体验营；明天川大cs我连数据结构都没复习完，项目也没复习呜呜呜。为什么过得会比期末都痛苦啊<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，期末复习好了期末就有希望，夏令营就算复习好了也没希望，并且根本不可能复习不好，一个寄字贯穿zyl的一生</p><p><img src="https://s2.loli.net/2022/07/05/lrbLWzi1T6UQNB7.png" alt="image.png" style="zoom:33%;"></p></li><li><p>原来在学校感受到的夏天的傍晚是，趴在阳台看晚霞，听楼下小树林的蝉鸣，还有足球场上少年们的欢呼</p><p><img src="https://s2.loli.net/2022/07/05/mExB3HPnWcdN5ST.jpg" alt="~BAFHI42FAD1J___2A_D7_Y.jpg" style="zoom: 25%;"></p></li><li><p>后悔，究极后悔，<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>!<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！</p></li><li>呜呜，明天面试我真的复习不完了呜呜哒咩<span class="github-emoji"><span>😖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f616.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，执行一个宵的通，面试完回来进行一个大觉的睡<span class="github-emoji"><span>😪</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="6th"><a href="#6th" class="headerlink" title="6th"></a>6th</h3><ul><li><p>中午scu面试，英语阅读和翻译磕磕绊绊，答题也答得磕磕绊绊，夏令营的第一个面试，算是攒了一丢丢经验，赢！hhh最后也不期待有没有优营了，随缘吧</p></li><li><p>面完试回去洗了个澡，下午去院办找同学盖章，快要下雨前的天气真的又闷又热，爬个坡又出汗了，澡白洗了属于是</p></li><li><p>晚上出去一号门吃了酸汤水饺，还有他们家的素菜拼盘，素菜拼盘好便宜，七块钱那么大一盘；然后去菜市场那边买了几颗水蜜桃，还有白糖罂，呜呜现在好像没看到有妃子笑卖了，在妃子笑面前，白糖罂永远是弟弟，妃子笑就是最好吃的品种！然后称了一点那个🍇，老板说那个品种叫郁金香，不得不说真的难吃啊，真不如夏黑或者巨峰；吃完饭出来突然发现晚霞很好看</p><p><img src="https://s2.loli.net/2022/07/07/QhVYP628ewDBtXn.jpg" alt="8X~HO6__03F0~F2B4JEW_VS.jpg" style="zoom:25%;"></p><p><img src="https://s2.loli.net/2022/07/07/JSEAljVx38WUDiO.jpg" alt="4CMH4PPX_DF_LZES@HO57_X.jpg" style="zoom:20%;"></p></li><li><p>回去的路上去取了个快递，买的可乐到了，然后回院办拿了遗忘在那里的三脚架</p></li><li><p>晚上收拾了一下宿舍，把好多好多不要的书都扔了，这些仿佛不是扔掉的书，而是之前一个个立下的但是从来没有完成过的flag，悲，大学三年立了这么多flag</p><p><img src="https://s2.loli.net/2022/07/07/4TfJ2vNw8YCBMgL.jpg" alt="G5SUA7QFD9__0__7__XKENM.jpg" style="zoom:33%;"></p></li><li><p>收拾东西的时候又把当年军训的那张大合照翻了出来，真的是，每一个人现在都不像从前了，毕竟那估计是大家最丑的时候hhhhh</p><p><img src="https://s2.loli.net/2022/07/07/BHETgdk2RMGm9aW.jpg" alt="_F14C`QC1WTM_CK6P2_AB_B.jpg" style="zoom: 25%;"></p></li></ul><h3 id="8th"><a href="#8th" class="headerlink" title="8th"></a>8th</h3><ul><li>buaa爆零，当初为什么不拿csp抵！！！！后悔，算了，看来<span class="github-emoji"><span>🐁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f401.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f401.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>我注定和buaa无缘，嘤嘤嘤这是命</li><li>下午睡一觉睡到了晚上，醒来好难过好难过好难过，我真的会有书读吗<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>我怎么这么垃圾这么废物呜呜</li><li>晚上好饿，点了炸串，最近真的吃好多</li><li>淦，吃撑了不舒服，呜呜更加难过了<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>scu专硕，虽然说不定最后能递补到学硕，但感觉又不想去了，四舍五入还是夏0营</li></ul><h3 id="9th"><a href="#9th" class="headerlink" title="9th"></a>9th</h3><ul><li>不知道自己干了啥</li></ul><h3 id="10th"><a href="#10th" class="headerlink" title="10th"></a>10th</h3><ul><li><p>上午家里人打电话说了一些蛮悲伤和一些挺无奈的事情，晚上知道了一些让自己破大防的事情，非常非常，心态非常崩的一天，真的好难过好难过，2022年最难过的一天，心态崩到十一点上床一直到一点半都没睡着，然后和好朋友聊天聊到三点多<span class="github-emoji"><span>😴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f634.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。直到11号早上起来写下这个记录还是很难过，呜呜呜呜我好废物啊</p><p><img src="https://s2.loli.net/2022/07/11/3dcVNGeya5Lbf1x.jpg" alt="TW_X_ZIXCY_S_R9_WS53@6O.jpg" style="zoom:25%;"></p><p><img src="https://s2.loli.net/2022/07/11/fl5dmFIxH379oE4.jpg" alt="QR5_`TGOUG0_@DZYW0_S_G7.jpg" style="zoom: 25%;"></p></li></ul><h3 id="11th"><a href="#11th" class="headerlink" title="11th"></a>11th</h3><ul><li>好了但没完全好呜呜</li></ul><h3 id="12th"><a href="#12th" class="headerlink" title="12th"></a>12th</h3><ul><li><p>好烦<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不想学</p><p><img src="https://s2.loli.net/2022/07/13/BegP3Lf1EN4hm5Z.jpg" alt="PL__@_98W8_0T37_7_FSR_X.jpg" style="zoom:33%;"></p></li></ul><h3 id="13th"><a href="#13th" class="headerlink" title="13th"></a>13th</h3><ul><li><p>好烦<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不想学；今天七点半就起床了，buaa软院机试，寄。</p></li><li><p>昨天换的微信犯贱专用新头像，乐；</p><p><img src="https://s2.loli.net/2022/07/13/zWqyZi1maLY3kGr.jpg" alt="O537D20K97~DQRED_PR__VP.jpg" style="zoom: 25%;"></p></li><li><p>我就喜欢这种又带有一点幽默同时又讲得条理清晰的博客</p><p><img src="https://s2.loli.net/2022/07/13/PsLIB9KO8Axtd1X.png" alt="image.png" style="zoom: 43%;"></p></li></ul><h3 id="14th-17th"><a href="#14th-17th" class="headerlink" title="14th-17th"></a>14th-17th</h3><p>难过到一定程度就不想说话</p><h3 id="18th-1"><a href="#18th-1" class="headerlink" title="18th"></a>18th</h3><ul><li><p>呜呜我昨天晚上做梦了，看到了好美好美的彩虹和晚霞，真的好美好美，无法形容的美，醒来还是觉得真tmd太美了</p></li><li><p>我真的觉得 我需要花一个暑假去治愈那致郁的20min，太痛苦了呜呜呜呜<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>每次回想都超级难过和心塞呜呜呜呜，这个暑假最让我难过的事情呜呜呜</p></li><li><p>下午太困了，睡醒起来就傍晚了，还是被热醒的，很可恶。出门的时候看到晚霞挺好看，但是没有昨天梦里见到的晚霞那么好看。还得是梦比较有意思。我每次脑袋放空然后突然想到那致郁的二十分钟，都真的好难过，上大学到现在还没有什么经历带给我的后劲这么大。</p><p><img src="https://s2.loli.net/2022/07/18/tEGrTc67CjB8JwL.jpg" alt="M`3SDQ7_PE2_JW9_A3U_I_O.jpg" style="zoom: 43%;"></p><p>​        前段时间堂哥打电话闲聊家常，他随口问了我一句读书压力大不，我没太在意，半开玩笑的语气说确实有点大。后来我妈突然给我发微信说不要给自己太大压力，可能就是新闻看多了就生怕我像电视新闻里的那样想不开。倒也没有。但我细想从小到大的压力几乎都是自己给的，似乎没有外在的谁给我带来什么压力。至少在读书方面，家里人从来没要求我说一定要上什么什么大学，一定要读到研究生还是读到博士，从来没给我带来任何压力。大概自驱力太强，也大概是觉得，什么都靠不住，除了自己。</p><p>​        记得在刚上大一的时候，一位朋友曾跟我聊过社会原子化的概念，当时只是觉得有意思。现在却越来越觉得很对。原子化的每个个体都是孤独的、埋头于物质享受的，这样的个体普遍存在，并且这些个体之间也没有强有力的联系。大概人的各种想法和见解确实会随经历和时间改变，说不定过几年回看此刻的想法会觉得荒诞和可笑，管它呢，那就过几年再说吧。好像人与人之间的联系根本就是这样，一点也不紧密，大家都是原子化孤立的个体，看似牢不可破的连接只是看似而已。啧，感觉自己好悲观，也不是悲观。</p><p>​        此刻耳机里刚好放到陈奕迅的《最佳损友》这首歌，“来日陌生的是昨日最亲的某某”。我真该以一种发展和质疑的眼光看待每一段人与人之间的关系。基于一种对任何人都不可信和不值得信的态度，甚至逐渐养成了回避型依恋人格。不过我很喜欢这种有效的自我保护机制，挺好的。所以，把任何人考虑进未来规划中都是很愚蠢的想法，对我来说。所以，狠狠地自我批判一下前一段时间愚蠢的自己。</p><p>​        某朋友之前说得不错，我有点不太能认清自己，以及太在意别人的看法。太对了，别人的看法其实跟自己半毛钱关系都没有，“别人的看法”在某种角度上来看，其实就是，自己给自己戴上的一副枷锁。我tmd做什么选择，过得好不好，跟别人的看法有半毛钱关系。或者说，我tmd连自己都过不好为什么还要在意别人怎么想。世界上所有事情概括起来无非是“关我p事”和“关你p事”这两件事了。emm，我最近一定是太难过了呜呜，才会七想八想想这么多，呜呜呜不愧是本废物。回来的路上看到那些夜跑的人，意识到自己好久没有运动了。</p></li><li><p>今天中午一个人在寝室吃了螺蛳粉，晚上出门吃了黄焖鸡米饭，都挺好吃的，但是胃口不大吃了不到一般都没吃完，属实有点浪费了。</p><p><img src="https://s2.loli.net/2022/07/18/YkcCLs8oTRJy3uP.jpg" alt="BE_P_S__EYU_2___06HU3_O.jpg" style="zoom: 33%;"></p></li></ul><p>  <img src="https://s2.loli.net/2022/07/18/TicYUdItLMJQSEb.jpg" alt="N9F4NX@_E_20SS`Q_@JIIV1.jpg" style="zoom: 33%;"></p><h3 id="19th-1"><a href="#19th-1" class="headerlink" title="19th"></a>19th</h3><ul><li><p>为什么夏天可以这么困啊，整个一天都属于很想睡觉的状态；早上根本起不来<span class="github-emoji"><span>❔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2754.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li><li><p>但是没有很摆烂，下午还是学了一丢丢；</p></li><li><p>晚上点了一家之前没有吃过的酸萝卜鱼，真的好好吃，关键是汤真的好好喝！</p><p><img src="https://s2.loli.net/2022/07/19/QmoYhXlSUGCWFps.jpg" alt="KQU2VNSJJV_UH_7NJX90RPG.jpg" style="zoom: 33%;"></p></li></ul><h3 id="20th-1"><a href="#20th-1" class="headerlink" title="20th"></a>20th</h3><ul><li>星汉灿烂真的好好看，吴磊好帅，赵露思好甜呜呜呜 </li><li>晚上去跑了三公里，好久没跑步了有点拉跨了，看来以后应该要抽空多锻炼锻炼捏OwO</li></ul><h3 id="21st-1"><a href="#21st-1" class="headerlink" title="21st"></a>21st</h3><ul><li><p>突然得到seu要联系导师才能入营，得知消息后花半个小时写完套磁信，联系了之前看上的那位导师，不到五分钟的样子导师就回复了我，然后过了一会儿就发腾讯会议号说过两个多小时就面试，真的好高效啊，我赶忙给自我介绍打草稿，然后面试面了整整半个小时，说实话，感觉每一场面试都能发现自己很多问题，一紧张就语速变快不会断句的臭毛病什么时候能该啊呜呜呜，然后最后可以推荐入营了呜呜呜开心。</p></li><li><p>之前本来想着但凡能拿到seu的专硕甚至候补保个底，现在 看这个导师的方向真的越看越喜欢，感觉真的好有意思！！！！！！！！！感觉课题组氛围好像也不错，呜呜呜，如果真的能拿到夏令营的offer，如果这位导师真的愿意收我我就直接有学上就躺平了hhh。然后在绿群遇到和我报同一个导师的hxd，看来大家的想法都是出奇的一致hhhh</p><p><img src="https://s2.loli.net/2022/07/22/RgXori7K4sYpSlu.png" alt="_HBP_Y__O2IRFT5JA61B@CS.png" style="zoom: 25%;"></p></li></ul><h3 id="22nd-1"><a href="#22nd-1" class="headerlink" title="22nd"></a>22nd</h3><ul><li>没啥事，开始复习计网啦！</li></ul><h3 id="23rd-1"><a href="#23rd-1" class="headerlink" title="23rd"></a>23rd</h3><ul><li>突然想到21号晚上那个面试好像有个问题我答错了我焯，师兄问的是最短路径的算法，我突然意识到我当时答成了最小生成树的算法我焯，啊啊啊啊啊啊啊！！！！！难怪当时师兄说话的时候停顿了一下，啊啊啊，师兄该不会觉得我是傻x啊啊啊，师兄一定会觉得我究竟是什么大笨比啊TAT，我焯，好丢脸，真的好丢脸，我替师兄感到尴尬替自己 感到丢脸，当时我居然没有意识到任何问题！！！！！！！！！！！！！！！！！！现在回想起来简直是，加倍的丢脸的感觉，超级加倍<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="24th-1"><a href="#24th-1" class="headerlink" title="24th"></a>24th</h3><ul><li>计网，怎么会，这么多啊</li><li>今天买了个特别可爱的库洛米和美乐蒂的气泡，太可爱了，在列表好友里挨个炫耀了一番，真的是很好看，还会冒星星和 蝴蝶结，太可爱啦！！！！！！！！！！！！！！！！！</li></ul><h3 id="25th-1"><a href="#25th-1" class="headerlink" title="25th"></a>25th</h3><ul><li>计网，好多好多，加油加油</li><li>天才基本法的芝士世界部分拍的好好看，好热血！</li><li>今天吃了两个榴莲千层，真好吃呜呜<span class="github-emoji"><span>🙋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>我好喜欢，晚上洗完头吹干头发然后睡觉，把头发散开铺在枕头上，稍微一侧过头就能闻到洗发水的香味，忍不住把脸埋进头发的，超级助眠<span class="github-emoji"><span>👊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="26th-1"><a href="#26th-1" class="headerlink" title="26th"></a>26th</h3><ul><li>对不起一觉睡到十一点呜呜，对不起我自己（<span class="github-emoji"><span>🐷</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f437.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>外面下雨了，坐在宿舍听着歌，好安心</li><li>下午没太阳了就去取了几个快递，新买的T恤到了，颜色真不错，但是真的显壮啊<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>今天买了四个水蜜桃，花了三十块钱，心疼，不过真的好吃，谁能拒绝水蜜桃呢，软桃yyds</li><li>晚上去二运跑步，跑了三公里，出了好多汗，然后回去洗了个澡，敷了个面膜，追了个剧，好舒服嘿嘿，但是张新成和张子枫在天才基本法里面演的毫无cp感，完全嗑不到，还不如芝士世界那部分的小演员们演得好，草莓世界的部分太垃圾了:happy:</li></ul><h3 id="27th"><a href="#27th" class="headerlink" title="27th"></a>27th</h3><ul><li><p>今天早起啦！七点半就起床啦，然后去吃了个早饭（暑假第一顿早饭<span class="github-emoji"><span>🌞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>），然后去操场晒晒太阳，走了两圈，啊已经体会到退休后的幸福生活了<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><img src="https://s2.loli.net/2022/07/27/J45I1lhWubXdRvB.jpg" alt="_早饭.jpg" style="zoom: 33%;"></p></li><li><p>晚上去跑了三公里，好累好累好累，然后去一号门买了两颗水蜜桃<span class="github-emoji"><span>🍑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f351.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li><li><p>今麦郎的板面真的好好吃，好香！！！！！跑完步回来没忍住又泡了一桶，真的香<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li></ul><h3 id="28th"><a href="#28th" class="headerlink" title="28th"></a>28th</h3><ul><li><p>做梦真的很神奇，梦里我的小学高中大学同学坐在一个教室里上课hhhhhhhhh</p></li><li><p>7cake的榴莲千层真的好好吃啊，吃了两个</p></li><li><p>今天晚上跑了5公里，有点进步</p><p><img src="https://s2.loli.net/2022/07/29/9tOEJbzsTjK8Fkr.jpg" alt="4CZHP2C_I0GH1_A_69TZ~I1.jpg"></p></li></ul><h3 id="29th"><a href="#29th" class="headerlink" title="29th"></a>29th</h3><ul><li><p>今天六点二十就醒了，还是自然醒，然后去操场跑了几圈，一个人承包操场的感觉好爽</p><p><img src="https://s2.loli.net/2022/07/29/Gf2jalHuksnhMdw.jpg" alt="LEQ_@I6WC945N8S0OC_MY4S.jpg" style="zoom: 25%;"></p></li><li><p>然后去明苑吃了个早餐，星苑的早餐种类太少了，还得是明苑才行，面比星苑的好吃，但食堂的面我从来都没有吃完过，对于一个从小到大都不怎么爱吃面条的人来说<span class="github-emoji"><span>✋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/270b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，然后回去看了会儿视频，不到十点钟就困得不行，早起还真毁一天，爬上床睡了个回笼觉，做了个好奇怪的梦，融合平行时空+玄幻+现实题材的梦，还梦到外婆了，她一定是想我了。然后醒来就十一点了，被蚊子咬醒的<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><img src="https://s2.loli.net/2022/07/29/AaedUq7EwT2npBD.jpg" alt="U_C__5OC_Q4FD90~K9H30X4.jpg" style="zoom: 25%;"></p></li><li><p>今天看网上的面经，这位博主的心态属实 真的值得学习一波！🤣<strong>实在不行读本校</strong>🤣<strong>估计我也过不了</strong>🤣</p><p><img src="https://s2.loli.net/2022/07/29/5HKnRCcelMEDAoa.png" alt="image.png"></p></li></ul><h3 id="30th"><a href="#30th" class="headerlink" title="30th"></a>30th</h3><ul><li>下午练keep，晚上跑步，好累，不过很爽</li></ul><h3 id="31st"><a href="#31st" class="headerlink" title="31st"></a>31st</h3><ul><li><p>去b站搜一个知识点的讲解，感觉讲的不错，一看up主的信息，不得不感慨现在的年轻人真的好牛啊，真的好厉害</p><p><img src="https://s2.loli.net/2022/07/31/SC3WBrnpPMDNQvU.png" alt="image.png" style="zoom:43%;"></p></li><li><p>昨晚做了个梦，梦到我被人背着，长大以来好久都没被人背过呜呜，好喜欢这种感觉</p></li><li><p>下午刷了《快乐再出发》这部综艺，把最新更新的刷完了，真的太好看了！2022年度最好看综艺！不愧豆瓣评分9.5+</p></li></ul><hr><h2 id="August"><a href="#August" class="headerlink" title="August"></a>August</h2><h3 id="1st-1"><a href="#1st-1" class="headerlink" title="1st"></a>1st</h3><ul><li>8月第一天，很好，早起失败，我发现每天早上自然醒后继续睡，做的梦都好奇怪，我梦到我被一个女的跟踪，在下雨天里到处跑，然后搭摩托车，摩托车开进一片雾里，开出雾里之后就没有路了，是很高很高的悬崖，然后我就寄了QAQ</li><li>突然认为，我应该觉得，<strong>我现在有书读，有学上，暂时没有生存压力，是件很幸福的事情</strong>😶好好学习吧！</li><li>没忍住，晚上又点了烧烤，牛肉串和鸭肠好香，很好，看来前几天都白运动了，今天终于把图论这部分搞完了然后稍微背了下计网，希望明天能够早起洗个头，如果明天腿和胳膊不酸了的话晚上就去跑会步。</li><li>怎么说呢，今天还是稍微比较充实🤣，好好学习耶，良好开端！</li></ul><h3 id="2nd-1"><a href="#2nd-1" class="headerlink" title="2nd"></a>2nd</h3><ul><li>晚上去北区跑步，GPS信号好弱啊，而且下午刚下过雨，空气又潮又闷，跑着都感觉缺氧，跑了几圈就去一号门外面买水果了，巨峰葡萄真好吃，巨峰葡萄就是最有葡萄味的葡萄🤗</li></ul><h3 id="3rd-1"><a href="#3rd-1" class="headerlink" title="3rd"></a>3rd</h3><ul><li>嘶，忘了干啥了</li></ul><h3 id="4th-1"><a href="#4th-1" class="headerlink" title="4th"></a>4th</h3><ul><li>统一的茄皇牛肉面的番茄味真的好香，我把汤喝得还剩一点点然后扔垃圾桶里，现在我蹲在椅子上玩手机都能闻到旁边垃圾桶散发出的番茄香。还有今麦郎的板面也很好吃，前段时间一天狂炫两桶。然后又去教超屯了四桶回来。都怪我上个月有段时间天天吃kfc导致有点超预算了呜呜呜呜我是猪</li><li>最近天天点牛约堡的蛋堡那个套餐，附带一小瓶可乐，但我一般不喝就在搁那里屯着越屯越多，再也不打算买可乐了hh😮</li><li>战德臣教授讲的数据库真的讲得好好，b站上最棒的课程了我觉得，今天一天狂炫到了70p，笔记做了十几页;一共250p，还剩将近1/4，有点后悔一开始没拿个厚一点的笔记本啊，我好喜欢这种没有ddl逼我的学习，想学就学，爱咋学咋学🤤</li></ul><h3 id="5th-1"><a href="#5th-1" class="headerlink" title="5th"></a>5th</h3><ul><li>好好学习的一天嗷</li></ul><h3 id="6th-1"><a href="#6th-1" class="headerlink" title="6th"></a>6th</h3><ul><li><p>我靠，今天右脚不知道为什么突然好痛，还有点点肿，前脚掌走路一发力就痛到后来坐着不发力就痛，呜呜呜，痛死啦</p></li><li><p>报告，好看的晚霞！</p><p><img src="https://s2.loli.net/2022/08/13/A5YtR9ZWj7mvTno.jpg" alt="_ORYON1W3QW@A_KK3M7OCVW.jpg" style="zoom:20%;"></p></li></ul><h3 id="7th"><a href="#7th" class="headerlink" title="7th"></a>7th</h3><ul><li>呜呜脚还是好疼，等明天校医院开门呜呜</li></ul><h3 id="8th-1"><a href="#8th-1" class="headerlink" title="8th"></a>8th</h3><ul><li>早上起床忍着脚肿痛去取外卖，刚取回来又突然低血糖，缓了缓稍微好些了之后照镜子一看脸色苍白，甚至心想要是真能这么白就好了（啊我在想什么啊</li><li>每每突然无意间知道曾经的同学的现状都会觉得很惊讶，春节的时候无意间知道一个不太熟的高中同学结婚了，最近又知道人家前几个月娃都生了。前年，也差不多暑假这个时候，我同样得知另一个小学同学也生娃了。每次想到这种，差不多年纪的同龄人，过着很不同的日子就觉得，嗯，很神奇。大概是毕业后再也没见过 ，所以她们在我心中一直都是坐在教室里扎着马尾穿着校服的女同学这种印象。就，怎么说呢，虽然知道每个人的人生轨迹都不同，但，就是觉得很神奇 。我感觉我目前很难脱离学生的身份看自己，我一直都觉得我是个学生，其实本来也是，但是她感觉，就更像一个成年大人。好像同龄但又好像没有同龄人的感觉，但是这个世界本来就千姿百态嘛。嗯，有时候看到她们的人生，我就会想如果多少多少年后我也会不会该结婚生娃，但一想到这些事情我都觉得很奇怪，离我很遥远，二十多岁的人还依然觉得自己是个孩子 ，除了学生和子女这两个社会角色，其他的更有挑战性的角色我至少，现在来说，是我不敢想象的。淦，npy都没有想这么多虚头巴脑的干嘛啊咸吃萝卜淡操心</li></ul><h3 id="9th-1"><a href="#9th-1" class="headerlink" title="9th"></a>9th</h3><ul><li><p>外卖都吃腻了真的好想吃排骨炖藕，但是外卖没看到卖的，食堂也没有，我好想吃家里冬天拿高压锅炖的排骨炖藕，我能嗦好几碗。今年寒假回家第一件事就是让家里人给我做排骨炖藕南京的晚霞还是多好看的，今天去食堂看到领军训服的学弟们了，这么好的天气不军训简直是可惜了</p></li><li><p>我现在真的很怀疑校医院医生的水平，前脚掌突然就莫名其妙地又肿又痛了三天，走路一发力就痛，医生居然说是感染，明明没有外伤口没有破皮而是从骨头里面的疼，我还以为至少得给我先拍个片啊上个药啊啥的，结果医生说不用直接给我开了几瓶青霉素输液很不能理解 </p></li><li><p>会骑电瓶的人真好啊，可惜我连自行车都不敢骑</p></li><li><p>发现了，只要我闲下来就会开始焦虑。比如今天上午去输液，下午去输液，晚上躺着床上刷抖音，突然想到自己今天啥正事儿都没干，该背的没背该学的没学好焦虑啊，玩会儿手机先</p></li><li><p>好像是长这么大，记事以来第一次输液（应该），好奇妙的感觉</p><p><img src="https://s2.loli.net/2022/08/13/DMNlfCbGvU79HAR.jpg" alt="~_5XF_63_SE_~H23_@3_WFI.jpg" style="zoom:15%;"></p></li></ul><h3 id="10th-1"><a href="#10th-1" class="headerlink" title="10th"></a>10th</h3><ul><li><p>请给我快点好起来，天天输液我真的会破产，（这张拍的我看着自己都想摸自己的腿，（好变态😭</p><p><img src="https://s2.loli.net/2022/08/13/pXlmOMs48wWCRFK.jpg" alt="86BD_`_H~M2UZ4_K`6_YR@E.jpg" style="zoom: 15%;"></p></li><li><p>报告，好看的晚霞！</p><p><img src="https://s2.loli.net/2022/08/13/aB7cSY81FNnQqkz.jpg" alt="47@_VVFOP8Q_ZIPM_1TW__U.jpg" style="zoom:25%;"></p></li></ul><h3 id="11th-1"><a href="#11th-1" class="headerlink" title="11th"></a>11th</h3><ul><li><p>好像好了点</p></li><li><p>看啊，一个明明有很多事情可以做，但事情多到一件都不想做的摆烂人居然在叠星星</p><p><img src="https://s2.loli.net/2022/08/13/rnKaDyShFsbEXjO.jpg" alt="62M@E5DSXEL_QP19_@YA_`H.jpg" style="zoom:15%;"></p></li></ul><h3 id="12th-1"><a href="#12th-1" class="headerlink" title="12th"></a>12th</h3><ul><li><p>今天去教超买了两根香蕉，居然才1.9块，好久没买过这么便宜的水果了（虽然不算便宜，但看到付款1.9还是被小小地震惊了一下，这感觉就像在教超买了一半不怎么大的西瓜却花了我整整19块那种卧槽怎么这么贵的同样的震惊的感觉 </p></li><li><p>它真的，居然只给了我一根筷子。第一次吃糖芋苗感觉很一般，不会想点第二次的那种一般。这家的鸭血也不好吃，有股腥味没处理好。想念大一放国庆的时候去上海找虫眼在她学校附近吃的那家正宗成都麻辣鸭血旺，现在想起来还是觉得那是我吃过最好吃的鸭血。</p><p><img src="https://s2.loli.net/2022/08/13/AkjIGnucg57PXTa.jpg" alt="_Y_P0P9KZEO@@NOJVU3VY4K.jpg" style="zoom:15%;"></p></li></ul><h3 id="13th-1"><a href="#13th-1" class="headerlink" title="13th"></a>13th</h3><ul><li>今天突然特别想追以前看的一部剧，今天一整天把它刷完了，四十多集，虽然好狗血但还是好爱。呜呜，为什么不能活在偶像剧里啊，甜死我了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡言乱语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】模板题总结</title>
      <link href="/2022/06/15/2022-06-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A8%A1%E6%9D%BF%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2022/06/15/2022-06-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A8%A1%E6%9D%BF%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】每日一题</title>
      <link href="/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ul><li>AcWing的每日一题（</li></ul><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】DFS</title>
      <link href="/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91DFS/"/>
      <url>/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91DFS/</url>
      
        <content type="html"><![CDATA[<ul><li>所有用到DFS的题，从简单到难</li><li>栈stack、O(h)、不具有最短性</li><li>回溯、剪枝er~</li></ul><span id="more"></span><h1 id="AcW-842-排列数字"><a href="#AcW-842-排列数字" class="headerlink" title="AcW-842. 排列数字 "></a><a href="https://www.acwing.com/problem/content/844/">AcW-842. 排列数字 </a></h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//dfs每一个位置 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(x&gt;n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!st[i]){</span><br><span class="line">st[i]=<span class="literal">true</span>;</span><br><span class="line">a[x]=i;</span><br><span class="line"><span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">st[i]=<span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="AcW-843-n-皇后问题"><a href="#AcW-843-n-皇后问题" class="headerlink" title="AcW-843. n-皇后问题"></a><a href="https://www.acwing.com/problem/content/845/">AcW-843. n-皇后问题</a></h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> row[N],col[N],rd[N],ld[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(x&gt;n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">cout&lt;&lt;g[i][j];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=n;y++){</span><br><span class="line"><span class="keyword">if</span>(!col[y]&amp;&amp;!rd[x+y<span class="number">-1</span>]&amp;&amp;!ld[n+x-y]){</span><br><span class="line">g[x][y]=<span class="string">'Q'</span>;</span><br><span class="line">col[y]=rd[x+y<span class="number">-1</span>]=ld[n+x-y]=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">col[y]=rd[x+y<span class="number">-1</span>]=ld[n+x-y]=<span class="literal">false</span>;</span><br><span class="line">g[x][y]=<span class="string">'.'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) g[i][j]=<span class="string">'.'</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SE】软件设计模式例题总结</title>
      <link href="/2022/05/16/2022-05-16-%E3%80%90SE%E3%80%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BE%8B%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/16/2022-05-16-%E3%80%90SE%E3%80%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BE%8B%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>【考试向】13种设计模式的 PPT+网上+书上 的各种例题搜集汇总</p><span id="more"></span><h1 id="【行为型】策略模式"><a href="#【行为型】策略模式" class="headerlink" title="【行为型】策略模式"></a>【行为型】策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，让算法的变化独立于算法的客户。</p><h2 id="类图与使用场景"><a href="#类图与使用场景" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/LJux3dzrG4YUPWZ.png" alt="image.png"></p><ul><li>想使用对象中 <strong>各种不同的算法变体</strong>，并且希望能在<strong>运行时切换</strong>算法</li><li>有许多 <strong>仅在执行某些行为时略有不同的相似类</strong><ul><li>将不同行为抽取到一个独立类（Strategy）层次结构中，并将原始类组合成一个</li></ul></li><li>算法在Context中的逻辑不重要，可以用策略模式将类的<strong>业务逻辑与算法实现细节隔离</strong>开来</li><li>类中使用了复杂条件运算符<strong>（if-else）</strong>以在同一算法的不同变体中切换</li></ul><hr><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><p>通过某些行为来<strong>参数化</strong>对象：<u>命令模式、策略模式</u></p></li><li><p>装饰者模式更改对象的外表，策略模式更改其本质</p></li><li><p>模板方法 基于<strong>继承</strong>：允许通过扩展子类的部分内容改变部分算法；</p><ul><li><p>策略模式 基于<strong>组合</strong>：通过相应行为提供的<strong>不同策略</strong>来改变对象的行为；</p><ul><li><p>模板方法 在<strong>类</strong>层次上运作，<strong>静态</strong>。</p></li><li><p>策略模式在<strong>对象</strong>层次上运作，允许运行时动态切换</p></li></ul></li></ul></li><li><p><strong>状态模式</strong>可以视为策略模式的<strong>扩展</strong>，都基于<strong>组合</strong>；</p><ul><li><p>都通过将部分工作 <strong>委 托</strong> 给 对象 来改变在不同情景下的行为</p><ul><li><p>策略模式：这些对象（具体策略）之间完全相互独立，不知道其他对象存在;客户知道具体策略</p></li><li><p>状态模式：没有限制具体状态之间的依赖，运行自行改变在不同情景下的状态；客户不知道具体状态</p></li></ul></li></ul></li></ul><hr><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><blockquote><ul><li>找出修改频率较高的算法</li><li>声明该算法所有变体的通用策略接口<strong>Stategy</strong></li><li>将算法逐一抽取到各自的类中，都必须<strong>implements</strong>策略接口</li><li>Context类中<strong>添加一个成员变量保存Stategy的引用</strong>；提供setter方法便于修改它；</li></ul></blockquote><h3 id="例1：导游路线规划"><a href="#例1：导游路线规划" class="headerlink" title="例1：导游路线规划"></a>例1：导游路线规划</h3><p>一个导游程序，有<strong>多种</strong>规划路线的功能，包括规划公路路线、规划步行路线、规划公共交通路线，但是不久之后，可能要规划其他路线，比如骑行路线等等</p><p><img src="https://s2.loli.net/2022/05/16/1oJEcLMkDsneTXi.png" alt="image.png"></p><h3 id="例2：出行方式"><a href="#例2：出行方式" class="headerlink" title="例2：出行方式"></a>例2：出行方式</h3><p>人的出行方式<strong>多种</strong>。假如你需要前往机场。你可以选择乘坐公共汽车、预约出租车或骑自行车。这些就是你的出行策略。</p><p><img src="https://s2.loli.net/2022/05/16/dJzmc9qEQHtFelr.png" alt="image.png"></p><h3 id="例3：电影院售票"><a href="#例3：电影院售票" class="headerlink" title="例3：电影院售票"></a>例3：电影院售票</h3><p>某电影院售票系统为不同类型的用户提供<strong>不同</strong>打折方式（Discount），学生凭学生证享受8折优惠（StudentDiscount），儿童享受减免10元优惠（ChildrenDiscount），VIP用户除享受半价优惠还可积分（VIPDiscount）</p><p><img src="https://s2.loli.net/2022/05/16/iQgyCXP2o1fbDTk.png" alt="image.png"></p><h3 id="例4：税额计算"><a href="#例4：税额计算" class="headerlink" title="例4：税额计算"></a>例4：税额计算</h3><p>一个电子商务系统，其中有一个控制器对象（TaskController），用于处理销售请求，能够确认何时有人在请求销售订单，并将请求转给SalesOrder对象处理。SalesOrder对象的功能包括：允许客户通过GUI填写订单，处理税额的计算，处理订单和打印销售收据。新需求：要处理<strong>多种税额计算</strong>的方法，美国、加拿大、中国三个国家的税收方法</p><p><img src="https://s2.loli.net/2022/05/16/iQlFqTLtM1EJfBu.png" alt="image.png" style="zoom:67%;"></p><h3 id="例5：计算器"><a href="#例5：计算器" class="headerlink" title="例5：计算器"></a>例5：计算器</h3><p>设计一个简单计算器，能实现两个操作数的加减乘除四种运算</p><h3 id="例6：图书打折方式"><a href="#例6：图书打折方式" class="headerlink" title="例6：图书打折方式"></a>例6：图书打折方式</h3><p>一个贩卖各类书籍的电子商务网站的购物车（Shopping Cart）系统计算本次购物金额的方法有<strong>多种</strong>，比如：对所有的教材类图书实行每本1元的折扣；对连环画类图书提供每本7%的促销折扣；对非教材类的计算机图书有3%的折扣；对其余的图书没有折扣</p><hr><h3 id="例7：会员打折方式"><a href="#例7：会员打折方式" class="headerlink" title="例7：会员打折方式"></a>例7：会员打折方式</h3><p>现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。</p><p><img src="https://s2.loli.net/2022/05/16/z9YMfdCWLu1qPbt.png" alt="image.png"></p><h3 id="例8：各种飞机"><a href="#例8：各种飞机" class="headerlink" title="例8：各种飞机"></a>例8：各种飞机</h3><p>某软件公司现欲开发一款飞机模拟系统,该系统主要模拟<strong>不同种类</strong>飞机的飞行特征与起飞特征。还能<strong>支持模拟更多种类</strong>的飞机。</p><p><img src="https://s2.loli.net/2022/05/16/Xfmbu75wz34o2ih.png" alt="image.png" style="zoom:67%;"></p><p>对比书上的例子（照喵画虎）</p><p><img src="https://s2.loli.net/2022/05/16/316ragLTyltDMKz.png" alt="image.png" style="zoom:67%;"></p><h3 id="例9：图片滤镜"><a href="#例9：图片滤镜" class="headerlink" title="例9：图片滤镜"></a>例9：图片滤镜</h3><p>为了实现一些特殊的显示效果，某公司欲开发一款手机数码照片处理软件，在该软件中为照片(Photograph)提供了<strong>多种</strong>滤镜(Filter)效果，例如黑白滤镜(BlackWhiteFilter)、单色滤镜(MonochromaticFilter)、怀旧滤镜(NostalgicFilter)等，不同的滤镜通过不同的算法对照片进行美化，该软件可以<strong>灵活地增加一些新的</strong>滤镜效果。</p><h3 id="例10：加密"><a href="#例10：加密" class="headerlink" title="例10：加密"></a>例10：加密</h3><p>某系统需要对重要数据（如用户密码）进行加密，并提供了<strong>几种</strong>加密方案（如凯撒加密、DES加密等），对该加密模块进行设计，使得用户可以<strong>动态选择</strong>加密方式</p><hr><h3 id="例11：排序策略问题"><a href="#例11：排序策略问题" class="headerlink" title="例11：排序策略问题"></a>例11：排序策略问题</h3><p>某系统提供了一个用于对数组数据进行操作的类，该类封装了对数组的常见操作，如查找数组元素、对数组元素进行排序等。现以排序操作为例，使用策略模式设计该数组操作类，使得客户端可以动态地更换排序算法，可以根据需要选择冒泡排序或选择排序或插入排序，也能够灵活地增加新的排序算法。</p><h1 id="【行为型】观察者模式"><a href="#【行为型】观察者模式" class="headerlink" title="【行为型】观察者模式"></a>【行为型】观察者模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>定义了对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖者都会收到通知并且自动更新</p><h2 id="类图与使用场景-1"><a href="#类图与使用场景-1" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/YpCHBNUnFP7MOzc.png" alt="image.png" style="zoom:67%;"></p><ul><li>当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的</li><li>当应用中的一些对象必须观察其他对象时</li></ul><h2 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><p>关键词：<code>通知</code>, <code>出版&amp;订阅</code>，<code>一个对象变化，通知其他多个对象它变化了</code></p><blockquote><p>拥有一些值得关注的状态的对象通常被称为目标，由于它要<strong>将自身的状态改变通知给其他对象</strong>，我们也将其称为发布者（publisher，也即subject）。所有<strong>希望关注发布者状态变化</strong>的其他对象被称为订阅者（subscribers，也即observer）。为发布者类添加订阅机制，让每个对象都能订阅或取消订阅发布者事件流。该机制包括</p><p> 1）一个用于存储订阅者对象<strong>引用的列表成员变量</strong>；</p><p>2）几个用于<strong>添加或删除该列表中订阅者</strong>的公有方法。</p></blockquote><h3 id="例1：股票价格通知"><a href="#例1：股票价格通知" class="headerlink" title="例1：股票价格通知"></a>例1：股票价格通知</h3><p>当股票购买者所购买的<strong>某只股票</strong>价格变化幅度达到5%时，系统<strong>自动发送通知</strong>给购买该股票的股民</p><p><img src="https://s2.loli.net/2022/05/16/ZnXTjCpd1kWJeSx.png" alt="image.png"></p><h3 id="例2：地震监测报警"><a href="#例2：地震监测报警" class="headerlink" title="例2：地震监测报警"></a>例2：地震监测报警</h3><p>现需要开发一个地震监测报警系统，如果接收到相关<strong>监测机构</strong>发来的<strong>预警数据</strong>，系统将作出反应，将信号<strong>传递</strong>给响应设备，如广播自动播放报警信息、逃生指示灯亮起、安全门锁打开、电梯自动停用等，每一种响应设备的行为由专门的程序来控制。支持将来引入新类型的响应设备。</p><h3 id="例3：电子商务系统"><a href="#例3：电子商务系统" class="headerlink" title="例3：电子商务系统"></a>例3：电子商务系统</h3><p>一个电子商务系统，当一个新的消费用户加入系统，希望做以下两个操作：向消费者发送一封欢迎邮件；向邮局查证消费者地址</p><p><img src="https://s2.loli.net/2022/05/16/wTMrSJcxa5ZnsgC.png" alt="image.png" style="zoom:50%;"></p><h3 id="例4：机房监控系统"><a href="#例4：机房监控系统" class="headerlink" title="例4：机房监控系统"></a>例4：机房监控系统</h3><p>如果机房达到一定指定温度，<strong>传感器</strong>将作出反应，将<strong>信号传递</strong>给响应设备，如警示灯将闪烁，报警器将发出警报，安全逃生门将自动开启、隔热门将自动关闭，每一响应设备的行为由专门的程序来控制，支持将来引入新类型的响应设备。</p><p><img src="https://s2.loli.net/2022/05/16/XWw2xoZtavPzFK4.png" alt="image.png"></p><h3 id="例5：多人联机对战"><a href="#例5：多人联机对战" class="headerlink" title="例5：多人联机对战"></a>例5：多人联机对战</h3><p>某在线游戏支持多人联机对战，每个玩家都可以加入某一战队组成联盟，当战队中某一成员受到敌人攻击时将给所有盟友<strong>发送通知</strong>，盟友收到通知后将作出响应</p><p><img src="https://s2.loli.net/2022/05/16/Gb8BOLEWyvfXja6.png" alt="image.png" style="zoom: 50%;"></p><hr><h1 id="【行为型】状态模式"><a href="#【行为型】状态模式" class="headerlink" title="【行为型】状态模式"></a>【行为型】状态模式</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类</p><h2 id="类图与使用场景-2"><a href="#类图与使用场景-2" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/3174QBdu5TswFfe.png" alt="image.png" style="zoom:67%;"></p><ul><li>对象的行为依赖于它的状态（如某些属性值），<strong>状态的改变将导致行为的变化</strong></li><li>在代码中包含大量与<strong>对象状态有关的条件语句</strong>，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。</li></ul><h2 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><p>在状态模式中， 特定状态（可以）知道其他所有状态的存在，且能触发从一个状态到另一个状态的转换；<strong>行为对客户来说是透明的</strong>，客户不知道状态对象的存在</p><ul><li><p>策略则几乎完全不知道其他策略的存在。</p></li><li><p>状态可被视为策略的扩展。两者都基于组合机制：它们都通过将部分工作<strong>委派</strong>给“帮手”对象来改变其在不同情景下的行为。策略使得这些对象相互之间完全独立，它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖，且允许它们自行改变在不同情景下的状态。</p></li></ul></li></ul><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h2><p>关键词：<code>状态</code>，<code>动作使得状态转换</code></p><ul><li>为对象的<strong>每</strong>一个 <strong>所有可能状态</strong> 新建一个类(ConcreteState)，将所有该状态的对应行为抽取到这些类中</li><li>Context类持有State/ConcreteState成员变量</li></ul><h3 id="例1：信用卡账户"><a href="#例1：信用卡账户" class="headerlink" title="例1：信用卡账户"></a>例1：信用卡账户</h3><p> 信用卡业务系统，账户(Account)是核心类之一，<strong>账户</strong>存在三种状态，且在不同状态下账户存在不同的行为，具体说明如下：</p><ul><li><p>(1) 如果账户中余额大于等于0，则账户的状态为<strong>正常状态(</strong>Normal State)，此时用户既可以向该账户存款也可以从该账户取款；</p></li><li><p>(2) 如果账户中余额小于0，并且大于-2000，则账户的状态为<strong>透支状态</strong>(Overdraft State)，此时用户既可以向该账户存款也可以从该账户取款，但需要按天计算利息；</p></li><li><p>(3) 如果账户中余额等于-2000，那么账户的状态为<strong>受限状态</strong>(Restricted State)，此时用户只能向该账户存款，不能再从中取款，同时也将按天计算利息；       </p></li><li><p>(4) 根据余额的不同，以上三种状态<strong>可发生相互转换</strong>。</p><ul><li>分析：账户==Context，三种状态 == ConcreteState；封装进状态的动作：存款、取款、利息计算、根据余额进行状态转换</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/16/w1Pe5C3qoJpZGX6.png" alt="image.png"></p><h3 id="例2：开关"><a href="#例2：开关" class="headerlink" title="例2：开关"></a>例2：开关</h3><p>如果某系统要求两个开关对象（Context）要么都处于开的状态，要么都处于关的状态，在使用时它们的<strong>状态必须保持一致</strong>，开关可以由开转换到关，也可以由关转换到开</p><ul><li><p>分析：多个环境对象可能需要共享同一个状态，如果希望在系统中实现<strong>多个环境对象共享一个或多个状态对象</strong>，那么需要将这些<strong>状态对象</strong>定义为环境类的<strong>静态成员对象</strong>。</p></li><li><p>Switch里的三个state都是静态成员变量（所以应该还有下划线表示才对</p></li></ul><p><img src="https://s2.loli.net/2022/05/16/5qF7zvOZBQDwVGK.png" alt="image.png" style="zoom:80%;"></p><h3 id="例3：屏幕放大"><a href="#例3：屏幕放大" class="headerlink" title="例3：屏幕放大"></a>例3：屏幕放大</h3><p>一个屏幕放大镜工具： 用户单击“放大镜”按钮之后屏幕将放大一倍，再点击一次“放大镜”按钮屏幕再放大一倍，第三次点击该按钮后屏幕将还原到默认大小</p><ul><li>定义三个<strong>屏幕状态类</strong>NormalState、LargerState和LargestState来对应屏幕的三种状态，分别是正常状态、二倍放大状态和四倍放大状态，屏幕类Screen充当Context类</li></ul><p><img src="https://s2.loli.net/2022/05/16/xJjpWI32DAU8ZRb.png" alt="image.png"></p><h3 id="例4：纸牌游戏"><a href="#例4：纸牌游戏" class="headerlink" title="例4：纸牌游戏"></a>例4：纸牌游戏</h3><p>某纸牌游戏中，<strong>人物角色</strong>具有<strong>入门级</strong>（Primary），<strong>熟练级</strong>(Secondary)，<strong>高手级</strong>(Professional)和<strong>骨灰级</strong>(Final)四种等级，<strong>角色的等级与积分相对应</strong>，游戏胜利将增加积分，失败则扣除积分，入门级具有最基本的游戏功能play()，熟练级增加了游戏胜利积分加倍功能doubleScore（），高手级在熟练级基础上再增加换牌功能changeCards()，骨灰级在高手级基础上再增加偷看他人的牌的功能peekCards()</p><ul><li>第一眼儿看差点以为是策略模式；但是要注意“角色的等级与积分相对应”，说明等级会随着积分的改变而发生改变，游戏又对积分有各种操作；所以更应该是状态模式</li></ul><p><img src="https://s2.loli.net/2022/05/16/ICLzGuw6t8BZMKo.png" alt="image.png"></p><h3 id="例5：线程状态"><a href="#例5：线程状态" class="headerlink" title="例5：线程状态"></a>例5：线程状态</h3><p>多线程存在 5 种状态，分别为新建状态、就绪状态、运行状态、阻塞状态和死亡状态，各个状态当遇到相关方法调用或事件触发时会转换到其他状态</p><p><img src="https://s2.loli.net/2022/05/16/cKTs741XiDV5rnE.png" alt="image.png" style="zoom:67%;"></p><h3 id="例6：传输门"><a href="#例6：传输门" class="headerlink" title="例6：传输门"></a>例6：传输门</h3><p>传输门具有Open（打开）、Closed（关闭）、Opening（正在打开）、StayOpen（保持打开）、Closing（正在关闭）五种状态。触发状态的转换事件有click、complete和timeout三种。</p><hr><h3 id="例7：抽奖活动"><a href="#例7：抽奖活动" class="headerlink" title="例7：抽奖活动"></a>例7：抽奖活动</h3><p>编写程序完成APP抽奖活动，具体要求如下：</p><p>（1）加入每参加一次这个活动要扣除用户50积分，中奖概率是10%</p><p>（2）奖品数量固定，抽完就不能抽奖</p><p>（3）活动有4个状态：可以抽奖、不能抽奖、发放奖品和奖品领完</p><hr><h1 id="【行为型】模板方法模式"><a href="#【行为型】模板方法模式" class="headerlink" title="【行为型】模板方法模式"></a>【行为型】模板方法模式</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>在一个方法中定义了一个<strong>算法的骨架</strong>，将一些<strong>步骤延迟到子类</strong>中。这样子类在<strong>不改变算法结构</strong>的情况下，可以<strong>重新定义</strong>算法中的某些步骤</p><h2 id="类图与使用场景-3"><a href="#类图与使用场景-3" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/nKLYQsofcxud6NR.png" alt="image.png" style="zoom:50%;"></p><ul><li>只希望客户端扩展某个特定算法步骤，而不是整个算法或其结构时</li><li>当多个类的算法除一些细微不同之外几乎完全一样时</li></ul><blockquote><ul><li>将算法分解为一系列步骤</li><li>将这些步骤改写为方法<ul><li>步骤可以是 抽象 的，也可以有一些默认的实现。</li></ul></li><li>在“模板方法”中依次调用这些方法。</li><li>为了能够使用算法，客户端需要自行提供子类并实现所有的抽象步骤。如有必要还需重写一些步骤（但这一步中不包括模板方法自身）。</li></ul></blockquote><h2 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><p><u>工厂方法</u> 是 模板方法的一种<strong>特殊形式</strong>。工厂方法可以作为一个大型模板方法的一个步骤</p></li><li><p>模板方法基于<strong>继承</strong>机制：它允许你通过<strong>扩展子类中的部分内容</strong>来改变部分算法。</p><ul><li><p>策略基于<strong>组合</strong>机制：你可以通过对<strong>相应行为提供不同的策略</strong>来改变对象的部分行为。</p><ul><li><p>模板方法在类层次上运作，因此它是静态的。</p></li><li><p>策略在对象层次上运作，因此允许在运行时切换行为。</p></li></ul></li></ul></li></ul><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h2><p>关键词：<code>一系列步骤</code>，<code>流程</code>，<code>不同类只有某些步骤相似但不同</code></p><blockquote><ul><li>分析目标算法，确定能否将其<strong>分解为多个步骤</strong>。从所有子类的角度出发，考虑哪些步骤能够通用，哪些步骤各不相同</li><li>创建抽象基类并声明<strong>一个模板方法</strong>和代表算法步骤的<strong>一系列抽象方法</strong>。 在模板方法中根据算法结构依次调用相应步骤。可用 <code>final</code> 修饰模板方法以防止子类对其进行重写。</li><li>可考虑在算法的关键步骤之间添加钩子</li><li>为每个算法变体新建一个具体子类，它必须<strong>实现所有的抽象步骤</strong>，也可以重写部分可选步骤</li></ul></blockquote><h3 id="例1：数据库操作"><a href="#例1：数据库操作" class="headerlink" title="例1：数据库操作"></a>例1：数据库操作</h3><p>对数据库的操作一般包括连接、打开、使用、关闭等<strong>步骤</strong>，在数据库操作模板类中我们定义了connDB（）,openDB（）,useDB()，closeDB（）四个方法分别对应这四个步骤，对于<strong>不同类型</strong>的数据库（如SQLserver和Oracle），其余操作步骤都一致，<strong>只是</strong>连接数据库connDB（）方法<strong>有所区别</strong></p><ul><li>分析：将四个步骤按顺序封装到一个方法里，那个在不同类中 <strong>不同的步骤</strong> 在方法外<strong>声明为抽象方法</strong></li></ul><p><img src="https://s2.loli.net/2022/05/16/zOc76gdTuGSnmL8.png" alt="image.png" style="zoom: 50%;"></p><h3 id="例2：利息计算"><a href="#例2：利息计算" class="headerlink" title="例2：利息计算"></a>例2：利息计算</h3><p>给出一个利息计算流程，但流程中<strong>有个步骤</strong>  <strong>根据用户类型</strong> 不同计算利息的方式<strong>不同</strong></p><p><img src="https://s2.loli.net/2022/05/16/mXEFgj71iGTdkHl.png" alt="image.png" style="zoom:50%;"></p><h3 id="例3：数据图表"><a href="#例3：数据图表" class="headerlink" title="例3：数据图表"></a>例3：数据图表</h3><p>一个数据图表显示功能包括三个<strong>步骤</strong>，（从数据源获取数据，数据转换为XML，以某种图表方式显示XML格式数据）支持<strong>多种数据源和多种图表显示方式</strong>， <strong>如果</strong>已经是XML<strong>则</strong>无需进行数据转换（说明有个钩子方法）</p><ul><li>分析：钩子方法能够作为<strong>条件</strong> <strong>控制算法的流程</strong></li></ul><p><img src="https://s2.loli.net/2022/05/16/cDzb8Xf9PrRNMJn.png" alt="image.png" style="zoom:67%;"></p><h3 id="例4：豆浆制作"><a href="#例4：豆浆制作" class="headerlink" title="例4：豆浆制作"></a>例4：豆浆制作</h3><p>编写制作豆浆的程序，说明如下:</p><ul><li>制作豆浆的流程 选材—&gt;<strong>添加配料</strong>—&gt;浸泡—&gt;放到豆浆机打碎</li><li>通过<strong>添加不同的配料</strong>，可以制作出<strong>不同口味的豆浆</strong></li><li>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆<strong>都是一样</strong>的</li></ul><p><img src="https://s2.loli.net/2022/05/16/zdXoCHWbsAgv6a7.png" alt="image.png" style="zoom:50%;"></p><hr><h1 id="【行为型】命令模式"><a href="#【行为型】命令模式" class="headerlink" title="【行为型】命令模式"></a>【行为型】命令模式</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>将<strong>请求封装成对象</strong>，以便使用不同的请求、队列或日志来<strong>参数化其他对象</strong>。也支持<strong>可撤销</strong>的操作</p><h2 id="类图与使用场景-4"><a href="#类图与使用场景-4" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/gAPXm8ZUFoGqKzv.png" alt="image.png" style="zoom: 50%;"></p><ul><li>系统需要<strong>将请求调用者和请求接收者</strong>解耦，使得<strong>调用者和接收者不直接交互</strong>。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。</li><li>要支持命令的<strong>撤销(Undo)操作和恢复(Redo)操作</strong></li><li>系统需要将<strong>一组操作组合</strong>在一起形成宏命令。</li></ul><p><img src="https://s2.loli.net/2022/05/16/rBET5sk4ecMU2Rd.png" alt="image.png" style="zoom:50%;"></p><h2 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><h2 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：遥控器功能键"><a href="#例1：遥控器功能键" class="headerlink" title="例1：遥控器功能键"></a>例1：遥控器功能键</h3><p>某遥控器提供了一些按键，使用户可以自定义按键功能，如功能键FunctionButton可用于调出菜单（ShowMenu），也可用于打开帮助界面（DisplayHelp），也可用于打开机顶盒（OpenSTB）。用户可以通过修改配置文件来改变按键的用途，使<strong>按键类与功能类之间解耦</strong>，<strong>相同的按键可以对应不同的功能.</strong></p><p><img src="https://s2.loli.net/2022/05/16/7tbFPhZBWYqEozA.png" alt="image.png"></p><h3 id="例2：公告板"><a href="#例2：公告板" class="headerlink" title="例2：公告板"></a>例2：公告板</h3><p>一个基于windows平台的公告板系统，该系统提供一个主菜单（Menu），在主菜单中包含了一些菜单项(MenuItem)，可以通过Menu类的addMenuItem()方法添加菜单项，菜单项的主要方法是click()，每一个菜单项包含一个抽象命令类，具体命令类包含OpenCommand(打开命令）、CreateCommand(创建命令）和EditeCommand(编辑命令）等，命令类内置有一个excute()方法，用于调用公告板系统界面类(BoardScrean）的open（）、create()、edite（）等方法，要使<strong>MenuItem类与BoardScreen类的耦合度降低</strong></p><p><img src="https://s2.loli.net/2022/05/16/dU95ONAKxWSkCz8.png" alt="image.png"></p><h3 id="例3：餐馆点菜"><a href="#例3：餐馆点菜" class="headerlink" title="例3：餐馆点菜"></a>例3：餐馆点菜</h3><p>场景：餐馆点菜。角色：1.接收者：厨师，是命令的真正执行者。本例分为两种：做热菜的厨师和做凉菜的厨师 2.服务员：负责命令和接收者的组装，并持有命令对象（菜单），最后启动命令的也是服务员 3.命令对象：A、每一道菜是个命令对象；B、菜单（组合对象，由多道菜组成）</p><p><img src="https://s2.loli.net/2022/05/16/4NrnIeHvCx1gmPj.png" alt="image.png"></p><h3 id="例4：桌面版应用程序"><a href="#例4：桌面版应用程序" class="headerlink" title="例4：桌面版应用程序"></a>例4：桌面版应用程序</h3><p>一提供了一系列自定义功能键，用户可以通过这些功能键来实现一些快捷操作。发现不同的用户可能会有不同的使用习惯，例如有的人喜欢将第一个功能键设置为“打开帮助文档”，有的人则喜欢将该功能键设置为“最小化至托盘”，设计使用户能够<strong>灵活地进行功能键的设置</strong></p><p><img src="https://s2.loli.net/2022/05/16/XNI5ezT2obpnS4R.png" alt="image.png"></p><h3 id="例5：计算器-1"><a href="#例5：计算器-1" class="headerlink" title="例5：计算器"></a>例5：计算器</h3><p>简易计算器，可以实现简单的数学运算，还可以对运算<strong>实施撤销操作</strong></p><p><img src="https://s2.loli.net/2022/05/16/um2epAzPC6HlLNo.png" alt="image.png" style="zoom:67%;"></p><h3 id="例6：智能生活"><a href="#例6：智能生活" class="headerlink" title="例6：智能生活"></a>例6：智能生活</h3><p>（1）买一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装app就可以控制这些家电工作</p><p>（2）这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个app，分别控制，<strong>只希望有一个app就可以控制全部智能家电</strong>。</p><ul><li><p>要实现一个app控制所有智能家电的需求，则每个智能家电厂家都要提供一个<strong>统一的接口</strong>给app调用，这时 就可以考虑命令模式</p></li><li><p>命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来</p></li><li><p>动作的请求者是手机app，动作的执行者是每个厂商的一个家电产品</p></li></ul><hr><h1 id="【行为型】迭代器模式"><a href="#【行为型】迭代器模式" class="headerlink" title="【行为型】迭代器模式"></a>【行为型】迭代器模式</h1><h1 id="【创建型】工厂方法模式"><a href="#【创建型】工厂方法模式" class="headerlink" title="【创建型】工厂方法模式"></a>【创建型】工厂方法模式</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p>定义了一个<strong>创建对象的接口</strong>，但由<strong>子类决定要实例化的类</strong>是哪一个，让类把实例化<strong>推迟到子类</strong></p><h2 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：图片读取器"><a href="#例1：图片读取器" class="headerlink" title="例1：图片读取器"></a>例1：图片读取器</h3><p>现需要设计一个程序来读取多种不同类型的图片格式，针对每一种图片格式都设计一个图片读取器(ImageReader)，如GIF图片读取器(GifReader)用于读取GIF格式的图片、JPG图片读取器(JpgReader)用于读取JPG格式的图片。图片读取器对象通过图片读取器工厂ImageReaderFactory来创建，ImageReaderFactory是一个抽象类，用于定义创建图片读取器的工厂方法，其子类GifReaderFactory和JpgReaderFactory用于创建具体的图片读取器对象</p><p><img src="https://s2.loli.net/2022/05/17/6JDZLTqxybsGCzS.png" alt="image.png"></p><h3 id="例2：日志记录器"><a href="#例2：日志记录器" class="headerlink" title="例2：日志记录器"></a>例2：日志记录器</h3><p>某日志记录器 要求支持多种日志记录方式，如文件日志记录（FileLog）、数据库日志记录（DatabaseLog）等；用户可根据需要动态地选择日志记录方式 ( 我甚至觉得这个题用策略模式也不是不可以？)</p><p><img src="https://s2.loli.net/2022/05/17/rxynbwU84HaG9JQ.png" alt="image.png" style="zoom:67%;"></p><h3 id="例3：电视机工厂"><a href="#例3：电视机工厂" class="headerlink" title="例3：电视机工厂"></a>例3：电视机工厂</h3><p>有一电视机工厂，生产各种电视机。现要将原有的工厂进行分割，为每种品牌的电视机提供一个子工厂，海尔工厂专门负责生产海尔电视机，海信工厂专门负责生产海信电视机；如果需要生产其他某个品牌电视机，只需要对应增加一个新的该品牌电视机工厂即可，而原有的工厂无须做任何修改，使得整个系统具有更加的灵活性和可扩展性</p><h1 id="【创建型】抽象工厂模式"><a href="#【创建型】抽象工厂模式" class="headerlink" title="【创建型】抽象工厂模式"></a>【创建型】抽象工厂模式</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>提供一个接口，用来<strong>创建</strong> 相关或依赖对象的<strong>家族</strong>，而不需要明确指定具体类</p><h2 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：数据库"><a href="#例1：数据库" class="headerlink" title="例1：数据库"></a>例1：数据库</h3><p>某系统为了改进数据库操作的性能，自定义数据库连接对象Connection和语句对象Statement，可针对不同类型的数据库提供不同的连接对象和语句对象，如提供Oracle或MySQL专用<strong>连接类和语句类</strong>，而且用户可以通过配置文件等方式根据实际需要<strong>动态地选择</strong>系统数据库</p><p><img src="https://s2.loli.net/2022/05/17/XuAk4C2ZlOTUMGV.png" alt="image.png"></p><h3 id="例2：操作系统"><a href="#例2：操作系统" class="headerlink" title="例2：操作系统"></a>例2：操作系统</h3><p>创建在不同操作系统的视窗环境下都能够运行的系统两种操作系统：windows和unix</p><ul><li><p>windows操作系统下，使用具有windows风格的视窗构件（这里设为windowsButton对象和WindowsText对象）</p></li><li><p>Unix操作系统下，使用具有Unix风格的视窗构件UnixButton对象和UnixText对象</p></li><li><p>如何进行设计，使得 1，当需要<strong>增加对新操作系统的支持</strong>时（如系统还需要支持Solaris），现有代码不必修改（符合“开-闭原则”）    2，在系统的设计中约束用户使用的各种构件一定属于同一操作系统（不会出现将WindowsButton和UnixText一起使用这种情况）</p></li></ul><p><img src="https://s2.loli.net/2022/05/17/9ctW5GiOwuYAkIT.png" alt="image.png"></p><h3 id="例3：动物游戏"><a href="#例3：动物游戏" class="headerlink" title="例3：动物游戏"></a>例3：动物游戏</h3><p>在一个电脑游戏中，存在着美洲和非洲两块大陆。美洲大陆上有食肉动物(美洲虎)和食草动物(美洲羊) ;非洲大陆上有食肉动物(非洲虎)和食草动物(非洲羊)。电脑游戏的应用逻辑中需要实现这样的场景</p><ul><li>根据当前主人公角色所处大陆(美洲或非洲)来初始化当前游戏中的食肉动物和食肉动物</li><li>食肉动物开始追捕食草动物</li></ul><p><img src="https://s2.loli.net/2022/05/17/8CbVPz17KaAhOBk.png" alt="image.png" style="zoom:67%;"></p><h3 id="例4：驱动"><a href="#例4：驱动" class="headerlink" title="例4：驱动"></a>例4：驱动</h3><p>设计一个系统来显示和打印数据库中读出的图形，并满足：根据当前所使用硬件的配置来选择驱动——速度快的机器选择高分辨率的显示、打印驱动，速度慢的选择低分辨率的驱动：</p><p>驱动类型     在低配置硬件情况下    在高配置硬件情况下</p><p>显示驱动         LRDD                              HRDD</p><p>打印驱动         LPPD                               HPPD</p><p><img src="https://s2.loli.net/2022/05/17/vQslOhJATDp3ura.png" alt="image.png" style="zoom:67%;"></p><h1 id="【创建型】单件模式"><a href="#【创建型】单件模式" class="headerlink" title="【创建型】单件模式"></a>【创建型】单件模式</h1><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>确保类只有一个实例，并提供一个全局的访问点</p><h2 id="多线程处理"><a href="#多线程处理" class="headerlink" title="多线程处理"></a>多线程处理</h2><h3 id="双重检查加锁的理解"><a href="#双重检查加锁的理解" class="headerlink" title="双重检查加锁的理解"></a>双重检查加锁的理解</h3><p>假如在某一瞬间线程A和线程B都在调用<code>getInstance()</code>方法，此时instance对象为null值，均能通过<code>instance == null</code>的判断(<strong>第一重检查</strong>）。由于实现了<strong>synchronized加锁机制</strong>，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定代码。但当A执行完毕时，<strong>线程B并不知道实例已经创建</strong>，如果没有第二重检查的话，将继续创建新的实例，导致产生多个单例对象，违背单例模式的设计思想，因此需要进行进一步改进，在 synchronized中<strong>再进行一次(instance == null)判断</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span>{</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton instance = null;</span><br><span class="line">    <span class="comment">//被volatile修饰的成员变量可以确保多个线程都能够正确处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == null){<span class="comment">//第一重检查</span></span><br><span class="line">            <span class="built_in">synchronized</span>(LazySingleton.class){ <span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span>(instance == null){ <span class="comment">//第二重检查</span></span><br><span class="line">                     instance = <span class="keyword">new</span> <span class="built_in">LazySingleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><ul><li><p>急切实例化</p><p><img src="https://s2.loli.net/2022/05/17/iW3zKQELYD4paXj.png" alt="image.png" style="zoom: 50%;"></p></li><li><p>延迟实例化</p><p><img src="https://s2.loli.net/2022/05/17/klizjRVSZ2Jq3IN.png" alt="image.png" style="zoom:50%;"></p></li><li><p>急切实例化和延迟实例化的比较</p><ul><li><p>急切：在类被加载时就将自己实例化，它的优点在于<strong>无须考虑多线程访问问题，可以确保实例的唯一性</strong>；从<strong>调用速度和反应时间</strong>角度来讲，由于单例对象一开始就得以创建，因此要<strong>优于延迟</strong>。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该 对象就需要创建，因此从<strong>资源利用效率</strong>角度来讲，不及延迟，而且在系统加载时由于需要创建单例对象，<strong>加载时间可能会比较长</strong>。 </p></li><li><p>延迟：在第一次使用时创建，<strong>无须一直占用系统资源</strong>，实现了延迟加载，但是必须处 理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源 初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过<strong>双重检查锁定</strong>等机制进行控制，这将<strong>导致系统性能受到一定影响</strong>。 </p></li></ul></li></ul><h2 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：负载均衡器"><a href="#例1：负载均衡器" class="headerlink" title="例1：负载均衡器"></a>例1：负载均衡器</h3><p>Sunny软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台 负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责 服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何<strong>确保负载均衡器的唯一性</strong>是该软件成功的关键</p><p><img src="https://s2.loli.net/2022/05/17/2tcRkujKbyfEiZH.png" alt="image.png" style="zoom:50%;"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancer</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LoadBalancer instance;</span><br><span class="line">    <span class="keyword">private</span> List serverList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LoadBalancer</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoadBalancer <span class="title">getLoadBalancer</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line">             instance = <span class="keyword">new</span> LoadBalancer();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="例2：文档窗口"><a href="#例2：文档窗口" class="headerlink" title="例2：文档窗口"></a>例2：文档窗口</h3><p>设计一个多文档窗口（注：在Java AWT/Swing开发中可使用JDesktopPane和JInternalFrame来实现），要求在主窗体中某个<strong>内部子窗体只能实例化一</strong>次，即只能弹出一个相同的子窗体</p><ul><li>单件模式用在子窗体上</li></ul><p><img src="https://s2.loli.net/2022/05/17/xbWtmLo9VT3SvlY.png" alt="image.png" style="zoom:50%;"></p><h3 id="例3：回收站"><a href="#例3：回收站" class="headerlink" title="例3：回收站"></a>例3：回收站</h3><p>windows回收站的创建模拟  在整个视窗系统中，回收站只能有一个实例，整个系统都使用这个唯一的实例，不管如何双击“回收站”图标，打开的回收站窗口始终是唯一的一个</p><h3 id="例4：网络计数器"><a href="#例4：网络计数器" class="headerlink" title="例4：网络计数器"></a>例4：网络计数器</h3><p>网站计数器是WEB应用程序的一项基本功能，用于统计使用网站或者应用程序的人数，可反映出网站或者应用程序的受欢迎程序，对于电子商务网站可信度的研究有一定的参考价值</p><h1 id="【结构型】适配器模式"><a href="#【结构型】适配器模式" class="headerlink" title="【结构型】适配器模式"></a>【结构型】适配器模式</h1><h2 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：🐕"><a href="#例1：🐕" class="headerlink" title="例1：🐕"></a>例1：🐕</h3><p>现需要设计一个可以模拟各种动物行为的机器人，在机器人中定义了一系列方法，如机器人叫喊方法cry()、机器人移动方法move()等。如果希望在不修改已有代码的基础上使得机器人能够像狗一样叫，像狗一样跑</p><h1 id="【结构型】组合模式"><a href="#【结构型】组合模式" class="headerlink" title="【结构型】组合模式"></a>【结构型】组合模式</h1><h2 id="样例-9"><a href="#样例-9" class="headerlink" title="样例"></a>样例</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p>在水果盘(Plate)中有一些水果，如苹果(Apple)、香蕉(Banana)、梨子(Pear)，当然大水果盘中还可以有小水果盘，现需要对盘中的水果进行遍历（吃），当然如果对一个水果盘执行“吃”方法，实际上就是吃其中的水果</p><h1 id="【结构型】装饰者模式"><a href="#【结构型】装饰者模式" class="headerlink" title="【结构型】装饰者模式"></a>【结构型】装饰者模式</h1><h1 id="【结构型】外观模式"><a href="#【结构型】外观模式" class="headerlink" title="【结构型】外观模式"></a>【结构型】外观模式</h1>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划】最长上升子序列模型</title>
      <link href="/2022/04/30/2022-4-30-%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/04/30/2022-4-30-%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>动态规划中最长上升子序列模型题目总结</li></ul></li></ul><span id="more"></span><h1 id="Easy-Part"><a href="#Easy-Part" class="headerlink" title="Easy Part"></a>Easy Part</h1><blockquote><p>都是些常见基本模板题</p></blockquote><h2 id="AcWing-895-最长上升子序列（序列最长1000）"><a href="#AcWing-895-最长上升子序列（序列最长1000）" class="headerlink" title="AcWing 895. 最长上升子序列（序列最长1000）"></a><a href="https://www.acwing.com/problem/content/897/">AcWing 895. 最长上升子序列</a>（序列最长1000）</h2><blockquote><p>数列长度1＜N＜1000，求给定序列的 数值严格递增的子序列长度；【模板题】</p></blockquote><h3 id="思路-【基于动态规划】"><a href="#思路-【基于动态规划】" class="headerlink" title="思路 【基于动态规划】"></a>思路 【基于动态规划】</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/a61f3906e9a02f30.png" style="zoom:45%;"></p><ul><li>状态表示：<code>dp[i]</code>：以 <code>a[i]</code><strong>结尾</strong>的最长上升子序列的长度</li><li>初始值：<code>dp[i]=1</code>,<code>i∈[0,n−1]</code> 表示<strong>最初</strong>一个数本身就是最长上升子序列，长度为 1</li><li>状态转移：把前<code>i−1</code>个数字中所有<strong>满足条件</strong><code>dp[j]&lt;dp[i]</code>（上升子序列） 的<code>j</code>找出来，那么<code>dp[i]</code>就可以试着更新为以 <strong>dp[j] 结尾的最长上升子序列的长度+自己的长度 1</strong>，但可能更新后的结果没之前的大，最后两者取max</li></ul><h3 id="代码-O-n-2"><a href="#代码-O-n-2" class="headerlink" title="代码 $O(n^2)$"></a>代码 $O(n^2)$</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++){</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;a[i]) </span><br><span class="line">dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">} </span><br><span class="line">ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">} </span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing896-最长上升子序列（序列最长100000）"><a href="#AcWing896-最长上升子序列（序列最长100000）" class="headerlink" title="AcWing896 最长上升子序列（序列最长100000）"></a>AcWing896 最长上升子序列（序列最长100000）</h2><blockquote><p>数列长度1＜N＜100 000  ，求数值严格递增的子序列长度</p></blockquote><h3 id="思路【基于二分】"><a href="#思路【基于二分】" class="headerlink" title="思路【基于二分】"></a>思路【基于二分】</h3><p>数据达到100000，考虑$nlogn$的算法</p><h3 id="代码-O-nlogn"><a href="#代码-O-nlogn" class="headerlink" title="代码$O(nlogn)$"></a>代码$O(nlogn)$</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],q[N];<span class="comment">//q[i]表示长度是i的上升子序列最后一个数的最小值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n,cnt=<span class="number">0</span>;<span class="comment">//cnt:前i个数中最大的最长上升子序列的值</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    q[<span class="number">0</span>]=INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=cnt;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r){</span><br><span class="line">            <span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid]&lt;a[i]) l=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        cnt=<span class="built_in">max</span>(cnt,r+<span class="number">1</span>);</span><br><span class="line">        q[r+<span class="number">1</span>]=a[i];        </span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>更好理解的一种</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;stk;</span><br><span class="line">stk.<span class="built_in">push_back</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;stk.<span class="built_in">back</span>()) stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line"><span class="keyword">else</span>{ <span class="comment">//替换掉第一个大于等于它的数</span></span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=stk.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r){</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(stk[mid]&gt;=a[i]) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>; </span><br><span class="line">}  <span class="comment">// *lower_bound(stk.begin(), stk.end(), a[i]) = a[i];</span></span><br><span class="line">stk[l]=a[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;stk.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing897-最长公共子序列"><a href="#AcWing897-最长公共子序列" class="headerlink" title="AcWing897 最长公共子序列"></a>AcWing897 最长公共子序列</h2><blockquote><p>两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">状态表示（集合表示）：dp[i][j] 所有在A[<span class="number">1</span>…i]中出现过且在B[<span class="number">1</span>…j]中也出现过的子序列</span><br><span class="line">       <span class="comment">//以选到A[i]和B[j]结尾的满足条件子序列</span></span><br><span class="line">属性：   最大值</span><br><span class="line">状态计算（集合划分）：根据A[i]是否等于B[j]</span><br><span class="line">    <span class="number">1</span>) A[i] == B[j] dp[i][j] → dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="number">2</span>) A[i] != B[j] dp[i][j] → <span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br></pre></td></tr></tbody></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=y;i++) cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=y;j++){</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[x][y]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="P1439-最长公共子序列"><a href="#P1439-最长公共子序列" class="headerlink" title="P1439 最长公共子序列"></a><a href="https://www.luogu.com.cn/problem/P1439">P1439 最长公共子序列</a></h2><blockquote><p>给出 1,2,…n 的两个排列 P1 和 P2 ，求它们的最长公共子序列。n&lt;=100 000</p></blockquote><p>数据范围大，按上一题的思路明显不行，所以考虑：</p><p>因为是1到 n的排列，所以两个子序列的元素都相同，只是位置不同</p><p>比如</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">P1</span>: <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> 映射成→ a b c d e  那么</span><br><span class="line"><span class="attribute">P2</span>: <span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> 映射成→ e a b c d  所以转换成求单个序列的最长上升子序列问题（AcWing<span class="number">896</span>）</span><br></pre></td></tr></tbody></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line">a[x]=i;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line">b[i]=a[x];</span><br><span class="line">}</span><br><span class="line"><span class="comment">//求b[]的最长上升子序列</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;stk;</span><br><span class="line">stk.<span class="built_in">push_back</span>(b[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(stk.<span class="built_in">back</span>()&lt;b[i]) stk.<span class="built_in">push_back</span>(b[i]);</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">*<span class="built_in">lower_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),b[i])=b[i];</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">cout&lt;&lt;stk.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing-902-最短编辑距离"><a href="#AcWing-902-最短编辑距离" class="headerlink" title="AcWing 902. 最短编辑距离"></a><a href="https://www.acwing.com/activity/content/problem/content/1094/">AcWing 902. 最短编辑距离</a></h2><blockquote><p>给两字符串 A 和 B，将 A 经过若干操作变为 B，求出将 A 变为B 至少需要的操作次数。可进行操作有：</p><ol><li>删除–将字符串 A 中的某个字符删除。</li><li>插入–在字符串 A 的某个位置插入某个字符。</li><li>替换–将字符串 A 中的某个字符替换为另一个字符。</li></ol></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">状态表示：dp[i][j]: 将A的前i个字符变成B的前j个字符</span><br><span class="line">    属性：最小操作次数</span><br><span class="line">状态计算：</span><br><span class="line">    <span class="number">1</span>) a[i]==b[j]: → dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="number">2</span>) 删除：dp[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">   插入：dp[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">       替换: dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">           </span><br><span class="line">关于初始化：</span><br><span class="line"><span class="number">1.</span>在<span class="keyword">for</span>遍历的时候需要用到的但是事先没有的 就要预处理 → 往往就是<span class="number">0</span>、<span class="number">1</span>之类的 </span><br><span class="line"><span class="number">2.</span>如果要找min → INF; 要找有负数的max → -INF</span><br><span class="line">因此：</span><br><span class="line">  f[<span class="number">0</span>][i]：如果a初始长度是<span class="number">0</span>，只能用插入操作让a变成b</span><br><span class="line">  f[i][<span class="number">0</span>]：如果b初始长度是<span class="number">0</span>，只能用删除操作让a变成b</span><br></pre></td></tr></tbody></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];<span class="comment">//dp[i][j]将A的前i个字母变成B的前j个字母的操作次数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a+<span class="number">1</span>;<span class="comment">//使得a从下标1开始存储 </span></span><br><span class="line">cin&gt;&gt;m&gt;&gt;b+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[<span class="number">0</span>][i]=i;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="comment">//删除or删除 </span></span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//or替换</span></span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>,dp[i][j]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing-899-编辑距离"><a href="#AcWing-899-编辑距离" class="headerlink" title="AcWing 899. 编辑距离"></a><a href="https://www.acwing.com/activity/content/problem/content/1006/">AcWing 899. 编辑距离</a></h2><blockquote><p> n个长度不超过 10 的字符串以及m 次询问，每次询问给出一个字符串和一个操作次数上限。</p><p>对每次询问，求给定的 n 个串中有多少个串可以在上限操作次数内经过操作变成询问给出的字符串。</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> s[N][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">char</span> a[],<span class="keyword">char</span> b[])</span></span>{</span><br><span class="line"><span class="keyword">int</span> lena=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> lenb=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lena;i++) dp[i][<span class="number">0</span>]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lenb;i++) dp[<span class="number">0</span>][i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++){</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dp[lena][lenb];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;(s[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">15</span>];cin&gt;&gt;(b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>; cin&gt;&gt;len;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp); <span class="comment">//注意点</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dis</span>(s[i],b)&lt;=len) cnt++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Medium-Part"><a href="#Medium-Part" class="headerlink" title="Medium Part"></a>Medium Part</h1><blockquote><p>非模板题目，在基础模板上的一丢丢变化且不难的题</p></blockquote><h2 id="AcWing-1014-登山"><a href="#AcWing-1014-登山" class="headerlink" title="AcWing 1014. 登山"></a><a href="https://www.acwing.com/activity/content/problem/content/1260/">AcWing 1014. 登山</a></h2><blockquote><p>给定序列，求先单调上升再单调下降的最长子序列长度</p></blockquote><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>先分别按数组 顺序和逆序 求以<code>a[i]</code>结尾的最长上升子序列长度<code>f[i]</code></p><p>得到以<code>a[i]</code>结尾的先上升后下降的最长子序列长度即为<code>f[i]+g[i]-1</code></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N],g[N],a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">f[i]=<span class="number">1</span>,g[i]=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++){</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;a[j]) f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;i;j--){</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;a[j]) g[i]=<span class="built_in">max</span>(g[i],g[j]+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans,f[i]+g[i]<span class="number">-1</span>);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kademlia基本原理</title>
      <link href="/2022/04/19/2022-04-19-Kademlia%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2022/04/19/2022-04-19-Kademlia%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>分布式路由算法Kademlia的原理理解</p><span id="more"></span><h1 id="Kademlia"><a href="#Kademlia" class="headerlink" title="Kademlia"></a>Kademlia</h1><p>来源：<a href="https://www.jianshu.com/p/f2c31e632f1d">易懂分布式 | Kademlia算法 - 简书 (jianshu.com)</a></p><blockquote><p>ps：这篇文章真的写得太棒啦！！！！！是我所看过讲Kademlia文章中逻辑最清晰表达最棒的一篇文章！</p></blockquote><h2 id="基本原理理解"><a href="#基本原理理解" class="headerlink" title="基本原理理解"></a>基本原理理解</h2><p><strong>Kad算法</strong> 是一种<strong>分布式存储</strong>及路由的算法，DHT (Distributed Hash Table) 的一种</p><p>Kad优点：</p><ul><li>对于任意一个有[ 2^(n−1) ,2^n)个节点的网络，<strong>最多只需要n步</strong>搜索即可找到目标节点；</li><li>K-bucket的更新机制一定程度上保持了网络的<strong>活性和安全性</strong></li></ul><blockquote><p>分布式存储：<strong>不设立中心化</strong>的服务器，所有（资源）文件<strong>分散存储</strong>在各个节点上</p></blockquote><p><strong>DHT</strong>：一种去中心化的分布式系统</p><ul><li>在这类系统中，每个node分别维护<strong>一部分的存储内容</strong>以及<strong>其他</strong>（部分）<strong>节点的路由/地址</strong><ul><li>使得网络中任何节点的进入和退出，对整个网络造成的影响最小。</li></ul></li></ul><hr><p><strong>考虑的问题</strong>：</p><ul><li>分配：如何进行资源分配，把分配的内容存储到各个节点上，新增或者删除内容如何处理</li><li>路由：如果某节点 想要<strong>获取</strong>某个特定的资源，<strong>如何找到</strong>存储资源的节点\地址\路径</li></ul><hr><p><strong>针对每个节点</strong>：</p><ul><li><p>被分配到的资源 以<key,value>的形式储存；</key,value></p><blockquote><p>通俗的理解：key-资源名（确切一点，是资源名的hash值），value-资源内容</p></blockquote></li><li><p>维护一张路由表；用来去找其他节点</p><ul><li>这张路由表，也称为“k-bucket”（k桶）</li><li>路由表<strong>按异或距离分层</strong><ul><li>本节点的nodeID 异或  目标节点的nodeID</li></ul></li><li>记录<strong>有限</strong>个数的<strong>其他节点的ID</strong> （nodeID）、IP地址和端口</li></ul></li></ul><hr><p><strong>为什么每个节点不能拥有其他所有的节点路由信息</strong>：</p><ul><li>分布式系统中，节点的进入退出十分频繁<ul><li>如果每次变动都全网广播，通讯量很大</li></ul></li><li>不安全：如果一个节点被攻破的话</li></ul><hr><p><strong>分布式存储后，资源如何存储和查找？</strong></p><p>例子：</p><blockquote><p>假设《分布式算法》这本书的书名的hash值是 <strong>00010000</strong>，那么这本书就会被要求存在学号为<strong>00010000</strong>的同学手上。（这要求hash算法的值域与node ID的值域一致。Kademlia的Node ID是160位2进制。这里的示例对Node ID进行了简略）<br> 但还得考虑到会有同学缺勤。万一<em>00010000</em>今天没来上学（节点<strong>没有上线或彻底退出</strong>网络），那《分布式算法》这本书岂不是谁都拿不到了？那算法要求这本书不能只存在一个同学手上，而是被要求<strong>同时存储在学号最接近00010000</strong>的<strong>k</strong>位同学手上，即<em>00010001</em>、<em>00010010</em>、<em>00010011</em>…等同学手上都会有这本书。</p><p>同样地，当你需要找《分布式算法》这本书时，将书名hash一下，得到 <em>00010000</em>，这个便是索书号，你就知道该找哪（几）位同学了。</p></blockquote><p>剩下的问题，就是找到这（几）位同学的手机号（路由）。</p><p>但是，你手中的通讯录里<strong>可能没他们的手机号</strong></p><p>即是：已知源节点<strong>持有的路由表</strong>，和 目的节点<strong>target</strong>的<strong>nodeID</strong>，如果找到目的节点的IP</p><blockquote><p>算法的核心思路：</p><p>当你知道<strong>目标同学Z</strong>与你之间的<strong>距离</strong>（这个距离通过你的nodeID和目标的nodeID异或得到）</p><p>你可以在你的通讯录（即：路由表）上先找到一个你认为与同学Z<strong>最相近的同学B</strong>，请同学B再进一步去<strong>查找同学Z</strong>的手机号。</p><p>每个同学只维护<strong>一部分</strong>的通讯录，这个通讯录按照距离分层（可以理解为按学号与自己的学号从第几位开始不同而分层），即k-bucket1, k-bucket 2, k-bucket 3…</p><p>虽然每个k-bucket中实际存在的同学人数逐渐增多，但每个同学在它自己的每个k-bucket中<strong>只记录k位同学</strong>的手机号</p></blockquote><p><strong>对应</strong>：每个k-bucket只存 k个节点的地址与端口，这里的k是一个<strong>可调节的常量参数</strong></p><blockquote><p>由于学号（节点的ID）有160位，所以每个同学的通讯录中共分160层（节点共有160个k-bucket）。整个网络最多可以容纳2^160个同学（节点），但是每个同学（节点）最多只维护<strong>160 * k</strong> 行通讯录（其他节点的地址与端口）</p></blockquote><hr><p><strong>节点的定位</strong>：</p><p>A同学（学号<em>00000110</em>）想找《分布式算法》，A首先需要<strong>计算</strong>书名的<strong>哈希值</strong>，hash(《分布式算法》) = <strong>00010000</strong>。那么A就知道ta需要找到<strong>00010000</strong>号同学（命名为Z同学）或学号与Z<strong>邻近的</strong>同学。<br> Z的学号<em>00010000</em>与自己的<strong>异或距离</strong>为 <em>00010110</em>，距离范围在[2^4, 2^5)，所以这个Z同学可能在k-bucket 5中（或者说，Z同学的学号与A同学的学号从第5位开始不同，所以Z同学可能在k-bucket 5中）。<br> 然后<strong>A同学看看自己的k-bucket 5</strong>有没有Z同学：</p><ul><li>如果有，那就直接联系Z同学要书；</li><li>如果没有，在k-bucket 5里<strong>随便找一个</strong>B同学（注意任意B同学，它的学号第5位肯定与Z相同，即它与Z同学的距离会小于24，相当于比Z、A之间的<strong>距离缩短了一半以上</strong>），请求B同学在它自己的通讯录里按同样的查找方式找一下Z同学：<ul><li>如果B知道Z同学，那就把Z同学的手机号（IP Address）告诉A；</li><li>如果B也不知道Z同学，那<strong>B按同样的搜索方法</strong>，可以在自己的通讯录里找到一个离Z更近的C同学（Z、C之间距离小于2^3），把C同学推荐给A；A同学请求C同学进行下一步查找。<strong>（递归）</strong></li></ul></li></ul><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h3><ul><li><strong>keyspace</strong><ul><li>nodeID有多少位</li><li>决定每个节点的路由表有几层</li></ul></li><li><p><strong>k</strong></p><ul><li>每一层k-bucket里<strong>装k个node信息</strong>：<nodeid, ip,="" address="" ,port=""></nodeid,></li><li>每次查找node，<strong>返回k个node信息</strong></li><li>对于某个特定的data，它的ID也就是所说的key，离其key<strong>最近的k个节点</strong>也要存储这个data</li></ul></li><li><p>α</p><ul><li>每次向其他node请求查找某个node时，会<strong>向α个node发送请求</strong></li></ul></li></ul><hr><h3 id="节点的指令"><a href="#节点的指令" class="headerlink" title="节点的指令"></a>节点的指令</h3><blockquote><p>每个节点只有4个指令</p></blockquote><ul><li>PING：测试一个节点是否在线</li><li>STORE：要求一个节点存储一份数据</li><li>FIND_NODE：根据nodeID查找一个node</li><li>FIND_VALUE：根据KEY查找一个data，跟FIND_NODE十分相似</li></ul><hr><h3 id="k-bucket的维护和更新机制"><a href="#k-bucket的维护和更新机制" class="headerlink" title="k-bucket的维护和更新机制"></a>k-bucket的维护和更新机制</h3><blockquote><p>保证任何节点的加入和离开都不影响整体网络</p></blockquote><ul><li>每个bucket里的节点都按最后一次接触的时间倒序排列<ul><li>也就是：最近接触的放在队尾</li></ul></li><li>每次执行四个指令中的任何一个，都会触发更新</li><li>当<font color="green">一个节点</font>和<strong>自己</strong>接触时，检查它是否在<strong>自己</strong>的k-bucket中<ul><li>在：把<font color="green">这个节点</font>挪到k-bucket列表的末尾</li><li>不在：PING一下列表最头部的<font color="orange">一个节点</font><ul><li>PING通：把<font color="orange">旧节点</font>挪到列表的末尾，丢弃<font color="green">新节点</font></li><li>PING不通：删除<font color="orange">旧节点</font>，并将<font color="green">新节点</font>加入列表</li></ul></li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 信安赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SE】线性代数</title>
      <link href="/2022/04/17/2022-04-17-%E3%80%90SE%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
      <url>/2022/04/17/2022-04-17-%E3%80%90SE%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>线性代数基本概念复习总结</p><span id="more"></span><p>[先挖个坑….]</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SE】词法分析器和语法分析器的设计</title>
      <link href="/2022/04/15/2022-04-15-%E3%80%90SE%E3%80%91%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/04/15/2022-04-15-%E3%80%90SE%E3%80%91%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>实现词法分析器</li><li>实现语法分析器</li></ul></li></ul><span id="more"></span><h1 id="1-词法分析器"><a href="#1-词法分析器" class="headerlink" title="1. 词法分析器"></a>1. 词法分析器</h1><h2 id="1-1-基本原理"><a href="#1-1-基本原理" class="headerlink" title="1.1 基本原理"></a>1.1 基本原理</h2><ul><li><p><strong>正规文法</strong></p><ul><li>也称<strong>3型</strong>文法 G=(VN,VT,S,P)</li><li>其中P中的每一条规则都有下述形式：<code>A-&gt;aB或A-&gt;a</code>，其中A和B是非终结符，a是终结符的闭包</li></ul></li><li><p><strong>不确定的有穷自动机NFA</strong></p><blockquote><p>一个不确定的 有穷自动机M 是一个五元组：$M=（K,\sum,f,S,Z)$</p></blockquote><ul><li>K：有穷集，每个元素称为一个<strong>状态</strong></li><li><p>Σ：有穷字母表，每一个元素称为一个<strong>输入符号</strong></p></li><li><p>f：一个映射</p></li><li>S ⊆ K：非空初态集（对于<strong>DFA，初态唯一</strong>）</li><li>Z ⊆ K：终态集</li></ul></li><li><p><strong>字符串t能被DFA所接收</strong></p><ul><li>对于$\sum^{*}$中的任何符号串t，若存在一条从初态节点到某一终态节点的道路，且这条道路的所有弧的标记符连接成的符号等于t，则称t可被这个DFA所接收（识别），若DFA的初态节点同时又是终态节点，则空字($\epsilon$)可为DFA所接收</li></ul></li></ul><h2 id="1-2-设计思路"><a href="#1-2-设计思路" class="headerlink" title="1.2 设计思路"></a>1.2 设计思路</h2><p>​    最先开始先以课本上给出的简单构词规则进行编写代码，进行调试，然后逐步扩充和完善构词规则，进行编码和调试。严格按照词法分析流程，根据规定的正规文法，先<strong>构建NFA</strong>，再利用子集法<strong>确定为DFA</strong>，分模块逐步完成主要函数。最后再通过DFA，读入测试程序进行扫描进行词法分析，得到<strong>输出的token序列</strong>或者错误信息。生成 token 列表（三元组：所在行号，类别，token 内容）。由于算法所用数据结构和C++中许多已有数据结构概念相符，因此可考虑用C++代码编写，充分利用C++中的STL库，十分方便算法的实现。总体流程图如下：</p><p><img src="https://i.bmp.ovh/imgs/2022/05/03/b31be7f16a2e2127.png" style="zoom: 30%;"></p><h2 id="1-3-文件结构"><a href="#1-3-文件结构" class="headerlink" title="1.3 文件结构"></a>1.3 文件结构</h2><div class="table-container"><table><thead><tr><th>路径</th><th>文件说明</th></tr></thead><tbody><tr><td>Lexical\TXT\GRAMMAR.txt</td><td>存放构词规则（正规文法）</td></tr><tr><td>Lexical\TXT\INCHAR.txt</td><td>存放终结符</td></tr><tr><td>Lexical\TXT\KEYWORDS.txt</td><td>存放关键字</td></tr><tr><td>Lexical\TXT\LIMITER.txt</td><td>存放界符(限定符）</td></tr><tr><td>Lexical\TXT\OPERATOR.txt</td><td>存放操作符</td></tr><tr><td>Lexical\TXT\ROW.txt</td><td>存放源程序中每一行的token数，便于语法分析器的报错提示</td></tr><tr><td>Lexical\TXT\SOURCE.txt</td><td>存放源程序代码</td></tr><tr><td>Lexical\TXT\TOKEN_TRIAD.txt</td><td>存放输出的token序列（三元组）</td></tr><tr><td>Lexical\TXT\TOKEN.txt</td><td>存放输出的token序列（二元组）</td></tr><tr><td>Lexical\TXT\WRONG.txt</td><td>存放语法分析器的报错信息，同时便于语法分析器的分析判断</td></tr><tr><td>Lexical\lexical.cpp</td><td>函数实现</td></tr><tr><td>Lexical\path.h</td><td>文件路径定义的头文件</td></tr><tr><td>Lexical\lexical.h</td><td>函数和变量声明的头文件</td></tr><tr><td>Lexical\main.cpp</td><td>主函数</td></tr></tbody></table></div><h2 id="1-4-构词规则"><a href="#1-4-构词规则" class="headerlink" title="1.4 构词规则"></a>1.4 构词规则</h2><p>基于本课程考核要求的内容，确定词法分析的构词如下：</p><p><img src="https://i.bmp.ovh/imgs/2022/05/03/a19bf29f8f13c3e2.png" style="zoom:40%;"></p><p>因此，根据构词规则设置正规文法，文法中的各项产生式的作用和之间的<strong>逻辑关系和分类</strong>如下：</p><ol><li>界符(限定符)</li></ol><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095219277.png" alt="image-20220503095219277" style="zoom: 30%;"></p><ol><li><p>标识符</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095318581.png" alt="image-20220503095318581" style="zoom: 33%;"></p></li><li><p>运算符</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095435881.png" alt="image-20220503095435881" style="zoom: 33%;"></p></li><li><p>常量</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095607966.png" alt="image-20220503095607966" style="zoom:80%;"></p></li></ol><h2 id="1-5-具体实现"><a href="#1-5-具体实现" class="headerlink" title="1.5 具体实现"></a>1.5 具体实现</h2><h3 id="（1）初始化所有加载项：void-init"><a href="#（1）初始化所有加载项：void-init" class="headerlink" title="（1）初始化所有加载项：void init()"></a>（1）初始化所有加载项：void init()</h3><p>预处理，从各文本文件中加载终结符、关键字、操作符、界符到各自的数据结构中。</p><div class="table-container"><table><thead><tr><th>类型</th><th>数据结构</th><th>函数名</th></tr></thead><tbody><tr><td>终结符</td><td>vector<char>INCHAR</char></td><td>void load_inchar();</td></tr><tr><td>关键字</td><td>vector<string> KEYWORDS</string></td><td>void load_keywords();</td></tr><tr><td>操作符</td><td>vector<string> OPT</string></td><td>void load_opt();</td></tr><tr><td>界符</td><td>vector<string>LIMITER</string></td><td>void load_limiter();</td></tr></tbody></table></div><h3 id="（2）创建NFA：void-createNFA"><a href="#（2）创建NFA：void-createNFA" class="headerlink" title="（2）创建NFA：void createNFA()"></a>（2）创建NFA：void createNFA()</h3><ul><li><p><strong>数据结构定义</strong></p><ul><li><p>NFA中的一条边的数据结构，结构体存储三元组的形式：边的起点，边的输入（权重），边的终点</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503100210138.png" alt="image-20220503100210138" style="zoom: 50%;"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Triad</span> {</span></span><br><span class="line">&nbsp; <span class="keyword">char</span> startPoint, input, endPoint;</span><br><span class="line">} Triad;</span><br></pre></td></tr></tbody></table></figure></li><li><p>NFA的数据结构： 结构体保存<code>initialState</code>-初态，<code>finalState</code>-终态，<code>f</code>-NFA中所有边的集合</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NFA</span> {</span></span><br><span class="line">&nbsp; <span class="keyword">char</span> initialState;</span><br><span class="line">&nbsp; vector&lt;<span class="keyword">char</span>&gt; finalState;</span><br><span class="line">&nbsp; vector&lt;Triad&gt; f;</span><br><span class="line">} NFA;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>读入的正规文法创建NFA</strong></p><ul><li><p>根据<strong>右线性</strong>正规文法的转换规则（注：t 为 VT 或ε）：</p><pre><code>① 增加一个终态结点，开始符号对应的结点作为初态② 对形如 A→t 的规则，引一条从A到终态结点的弧，标记为t③ 对形如 A→tB 的规则，引一条从A到B的弧，标记为t</code></pre></li><li><p>算法具体流程图如下，由于NFA的终态集合采用的是vector，最后需要对vector的元素进行去重，但代码运行时即使不去重也没有影响。</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503100618138.png" alt="image-20220503100618138" style="zoom:50%;"></p></li></ul></li></ul><h3 id="（3）将NFA转换成DFA：void-NFA-TO-DFA"><a href="#（3）将NFA转换成DFA：void-NFA-TO-DFA" class="headerlink" title="（3）将NFA转换成DFA：void NFA_TO_DFA()"></a>（3）将NFA转换成DFA：void NFA_TO_DFA()</h3><p>​    首先，定义DFA的数据结构，利用结构体保存初态-initialState、终态集合-finalState、边的集合-f；在定义DFA的边的集合时，并没有采用像NFA一样的结构体来定义边，而是采用一个二维数组<code>f[MAX_NODES][MAX_NODES]</code>，比如<code>f[state][input]=nextState</code>就表示从当前状态<code>state</code>输入字符<code>input</code>后转移到下一个状态<code>nextState</code>，将char隐式地转换成int类型作为数组下标，在代码中利用change函数实现，比如初始状态表示字符<code>S</code>对应int中0，其余状态<code>A</code>对应int中的1，<code>B</code>对应int中的2……以此类推。的实现了O(1)查找，提高了算法的效率。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DFA</span> {</span></span><br><span class="line">&nbsp; <span class="keyword">char</span> initialState;</span><br><span class="line">&nbsp; vector&lt;<span class="keyword">char</span>&gt; finalState;</span><br><span class="line">&nbsp; <span class="keyword">int</span> f[MAX_NODES][MAX_NODES]; &nbsp;</span><br><span class="line">} DFA;</span><br></pre></td></tr></tbody></table></figure><p>算法的关键部分的伪代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开始e-<span class="built_in">closure</span>(K0)令C为中唯一成员，并且它是未被标记的。</span><br><span class="line"><span class="built_in">While</span> (C 中存在尚未标记的子集T) <span class="keyword">do</span></span><br><span class="line">{    标记T；</span><br><span class="line">     <span class="built_in">For</span>(每个输入字符a) <span class="keyword">do</span></span><br><span class="line">      {   U:=e-<span class="built_in">closure</span>(<span class="built_in">move</span>(T,a))</span><br><span class="line">          <span class="built_in">If</span> (U不在C中) then</span><br><span class="line">          { 将U作为未标记的子集加载C中；}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中，需要求闭包和move集：</p><ul><li><p><strong>求状态集T的闭包:</strong></p><ul><li><p>对应代码的函数名为<code>set&lt;char&gt; e_closure(set&lt;char&gt; T)</code>。</p></li><li><p>传入参数，类型为<code>set&lt;char&gt;</code>的状态集T，函数返回状态集T的一个闭包。</p></li><li>求T的闭包即是求状态集<strong>T中的任何状态</strong>，及<strong>经过任意条ε弧所能到达的状态</strong>的集合。</li><li>由于集合的概念和C++的STL中的set概念一致，所以采用的是set类型来保存所有满足要求的状态，这样就没有重复元素，不需要去重。</li></ul></li><li><p><strong>求集合I的move集：</strong></p><ul><li><p>对应代码的函数名为<code>set&lt;char&gt; move(set&lt;char&gt; I, char input)</code>。</p></li><li><p>传入参数，类型为<code>set&lt;char&gt;</code>  的集合I，和一个char类型的字符input，求它的move集，即是求所有可以从I中的某一状态经一条input弧所能到达的状态，返回满足要求的状态的集合。</p></li></ul></li></ul><p>定义完求闭包和求move集的函数后，编写NFA转换成DFA的算法。根据伪代码转换的具体算法流程图如下：</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503111033602.png" alt="image-20220503111033602" style="zoom:50%;"></p><h3 id="（4）读入源程序进行词法分析：void-scanSourceCode"><a href="#（4）读入源程序进行词法分析：void-scanSourceCode" class="headerlink" title="（4）读入源程序进行词法分析：void scanSourceCode()"></a>（4）读入源程序进行词法分析：void scanSourceCode()</h3><p>​    首先，在读入源程序之前，需要将源程序一些不必要的换行和tab符号过滤掉，然后存到数组中，然后对这些已经用空格分隔该来的预处理字符串序列进行处理，将一个个字符串分割成一个个单词，初始化对应的单词类型为空串，具体算法执行流程如下：</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503125941169.png" alt="image-20220503125941169" style="zoom:50%;"></p><p>​    然后单词分割完毕后，对每个单词进行类型判断，通过DFA的状态转移表f对字符串序列逐个处理，每处理一个更新当前状态，直至状态为-1即找不到下一个状态为止，判断当前是否是因为未知符号导致的中断，将已经识别的字符串作为一个token识别其属于关键字，操作符，界符，常数和标识符的哪一种。具体算法执行流程如下：</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503130118347.png" alt="image-20220503130118347" style="zoom:50%;"></p><h3 id="（5）其他非关键函数"><a href="#（5）其他非关键函数" class="headerlink" title="（5）其他非关键函数"></a>（5）其他非关键函数</h3><ul><li>包括：打印NFA、打印DFA、关键词、界符等的判断函数、状态重命名函数、过滤源程序函数等等。</li></ul><h2 id="1-6-实例分析"><a href="#1-6-实例分析" class="headerlink" title="1.6 实例分析"></a>1.6 实例分析</h2><ul><li><p>输入正确源程序，词法分析成功，无误。</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503220718340.png" alt="image-20220503220718340" style="zoom:30%;"></p></li><li><p>修改源程序，检查，能够报出错误信息，指明出错位置</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503221014826.png" alt="image-20220503221014826" style="zoom:30%;"></p></li></ul><h1 id="2-LR-1-语法分析器"><a href="#2-LR-1-语法分析器" class="headerlink" title="2. LR(1)语法分析器"></a>2. LR(1)语法分析器</h1><h2 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h2><ul><li><strong>LR分析法</strong><ul><li>根据<strong>状态栈</strong>，和<strong>向右顺序查看</strong>输入串的$k(k≥0)$ 个符号，就可以唯一地确定分析器的动作<strong>是移进还是归约</strong>和用哪个产生式归约，因而能就确定唯一的句柄。</li><li>LR分析法的归约过程是规范推导的逆过程，所以LR分析过程是一种规范归约的过程</li></ul></li><li><strong>LR分析器</strong><ul><li>总控程序</li><li>分析表：Action-Goto表</li><li>分析栈：状态栈、符号栈；<ul><li>分析器的动作由栈顶状态和当前输入符号来确定<ul><li>移进：当$S_{j}=GOTO[S_{i},a]$ 成立，将$S_{j}$ 移入到状态栈，将$a$ 移入符号栈</li><li>归约：当栈顶形成句柄$\beta$ ，用$\beta$ 归约为相应的非终结符</li><li>接受：归约到文法符号栈中只剩下开始符号S，并且输入符号串结束，分析成功</li><li>报错：当遇到状态栈顶为某一状态下出现不该遇到的文法符号时报错，无法接受该句子</li></ul></li></ul></li></ul></li><li><strong>几种LR分析法的区别</strong><ul><li><strong>LR(0)</strong><ul><li>分析过程不需要向右查看输入符号</li><li>不存在<strong>移进-归约</strong> 和 <strong>归约-归约</strong> 冲突，即 R(0)文法分析<strong>不能解决这两种冲突</strong>，所以适用范围最小</li></ul></li><li><strong>SLR(1)</strong><ul><li>简单的LR(1)，存在<strong>多余（无效）归约</strong>的情况</li><li>不存在归约-归约冲突，<strong>有可能存在移进-归约冲突</strong>，但是如果可以用 follow集解决则是 SLR文法。换句话说，SLR文法分析过程可以解决归约-归约冲突，但是<strong>不一定能解决移进-归约冲突</strong>。用 follow集来处理即出现移进-归约冲突的两条产生式，如果其 follow集相交为空则为 SLR文法，反之不是。</li></ul></li><li><strong>LR(1)</strong><ul><li>因为 LR(1)文法的范围比较大，所以文法几乎都是 LR(1)的</li></ul></li></ul></li><li><strong>项目集中的项目种类</strong><ul><li>移进项目、待约项目、归约项目、接受项</li></ul></li></ul><h2 id="2-2-设计思路"><a href="#2-2-设计思路" class="headerlink" title="2.2 设计思路"></a>2.2 设计思路</h2><ul><li>读入二型文法产生式文档，识别出所有终结符和非终结符，求相应的First集</li><li>构建初始项目集，对核其闭包，进行状态转移，得到项目集族，构建Action-Goto表</li><li>构造分析表。</li></ul><p>编码过程中，严格分模块进行，每完成一个模块就进行一个模块的测试和校正。大量使用STL极大的简便了繁琐的编码。</p><h2 id="2-3-文件结构"><a href="#2-3-文件结构" class="headerlink" title="2.3 文件结构"></a>2.3 文件结构</h2><div class="table-container"><table><thead><tr><th>路径</th><th>文件说明</th></tr></thead><tbody><tr><td>Parser\TXT\ACTION_GOTO.txt</td><td>存放产生的Action-Goto表</td></tr><tr><td>Parser\TXT\ANALYSIS.TXT</td><td>存放分析表</td></tr><tr><td>Parser\TXT\GRAMMAR.txt</td><td>存放文法表</td></tr><tr><td>Parser\TXT\ITEMSET.txt</td><td>存放产生的项目集</td></tr><tr><td>Parser\main.cpp</td><td>主函数</td></tr><tr><td>Parser\parser.cpp</td><td>函数实现</td></tr><tr><td>Parser\parser.h</td><td>函数和变量声明的头文件</td></tr><tr><td>Parser\path.h</td><td>文件路径定义的头文件</td></tr></tbody></table></div><h2 id="2-4-语法规则"><a href="#2-4-语法规则" class="headerlink" title="2.4 语法规则"></a>2.4 语法规则</h2><p>​    实现基本的运算，赋值，定义变量，if-else，while，do-while，for，switch-case分支语句的判别。抽象的文法映射成程序中的文法规则的逻辑分类如下：</p><ol><li><p>程序框架</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144649721.png" alt="image-20220503144649721" style="zoom: 50%;"></p></li><li><p>赋值语句</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144737724.png" alt="image-20220503144737724" style="zoom:45%;"></p></li><li><p>操作语句</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144812202.png" alt="image-20220503144812202" style="zoom: 45%;"></p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144847851.png" alt="image-20220503144847851" style="zoom:40%;"></p></li><li><p>分支语句</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144921107.png" alt="image-20220503144921107" style="zoom:60%;"></p></li><li><p>代码块</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144941722.png" alt="image-20220503144941722" style="zoom:50%;"></p></li></ol><h2 id="2-5-具体实现"><a href="#2-5-具体实现" class="headerlink" title="2.5 具体实现"></a>2.5 具体实现</h2><h3 id="（1）预处理阶段：读取给定的二型文法文件"><a href="#（1）预处理阶段：读取给定的二型文法文件" class="headerlink" title="（1）预处理阶段：读取给定的二型文法文件"></a>（1）预处理阶段：读取给定的二型文法文件</h3><ul><li><p>数据结构定义</p><ul><li><p>二型文法产生式的数据结构</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Grammar</span>{</span></span><br><span class="line">&nbsp; &nbsp; <span class="keyword">char</span> left;</span><br><span class="line">&nbsp; &nbsp; string right;</span><br><span class="line">}Grammar;</span><br></pre></td></tr></tbody></table></figure></li><li><p>存放所有产生式的数据结构</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Grammar&gt; grammar; </span><br></pre></td></tr></tbody></table></figure></li><li><p>定义存放token的数据结构，将词法分析器获取的token的<strong>单词映射成一个字符</strong>，存入token字符串中</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    &nbsp;string token;</span><br></pre></td></tr></tbody></table></figure></li><li><p>定义存放终结符和非终结符的数据结构，VT存放终结符，其中不包括epsilon，epsilon单独处理； VN存放非终结符。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">char</span>&gt; VT; &nbsp;</span><br><span class="line">set&lt;<span class="keyword">char</span>&gt; VN;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>算法具体流程如下：</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503145537941.png" alt="image-20220503145537941" style="zoom:60%;"></p></li></ul><h3 id="（2）创建项目集族和Action-Goto表：void-create-char-left-char-right"><a href="#（2）创建项目集族和Action-Goto表：void-create-char-left-char-right" class="headerlink" title="（2）创建项目集族和Action-Goto表：void create(char left,char right)"></a>（2）创建项目集族和Action-Goto表：void create(char left,char right)</h3><ul><li><p><strong>数据结构定义</strong></p><ul><li><p>LR(1)项目集中的一条项目</p><ul><li><p><code>left</code>项目的产生式左边，<code>right</code>产生式右边，<code>position</code>圆点的位置，规定在<code>right[position]</code>的左边，<code>index</code> 本项目产生式在文法中的位置索引，<code>forward</code>向前搜索符集；</p></li><li><p>另外重载 <code>＜</code> 和 <code>==</code>便于后续的一些比较</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Item</span>{</span></span><br><span class="line"><span class="keyword">char</span> left; </span><br><span class="line">string right;</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> index; </span><br><span class="line">set&lt;<span class="keyword">char</span>&gt; forward; </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> struct Item &amp; item) <span class="keyword">const</span>{...详细见代码...}</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> struct Item &amp; item) <span class="keyword">const</span>{...详细见代码...} </span><br><span class="line">}Item;</span><br></pre></td></tr></tbody></table></figure></li><li><p>LR(1)项目集族的数据结构</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;Item&gt; Itemset[<span class="number">1000</span>];  </span><br></pre></td></tr></tbody></table></figure></li><li><p>Action-Goto表的数据结构</p><p>​    因为Action和Goto表的<strong>移进项没有本质区别</strong>，只有Action中的移进和归约态有区别。因为终结符和非终结符本代码都只用了一个字符表示，所以采用了char到int的隐式转换作为二维数组的索引，实现了O(1)的查找。。再判断的时候也和256作比较再进行下一步的判断。例如<code>ActionGoto[state][input]</code>的值表示栈顶状态为<code>state</code>时，遇见字符<code>input</code>所要执行的动作。</p><p>​    <strong>对ActionGoto数组的值的规定</strong>：</p><ul><li>-1 标识接受动作；</li><li>-2 标识不存在这个状态转移，即出错动作；</li><li>其余：Action表中的移进和归约用是否加256区分：x标识移进动作，x+256表示规约动作</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ActionGoto[<span class="number">300</span>][<span class="number">300</span>]; </span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>算法具体流程</strong></p><p>​    left是增广文法的左部非终结符，right是原文法的起始非终结符，用于初始化初始项目集，然后创建所有项目集，得到最终的项目集族，采用的是宽搜的方式，遍历所有终结符和非终结符。</p><p>​    如果能进行状态转移，那么就核和闭包，扩充项目集。若与原项目集不同则加入到项目集族，增加一条状态转移；若相同则只增加一条状态转移（指向自己），同时填充ActionGoto数组。</p><p>​    直至项目集族中不再有新项目集出现为止。在建好项目集族后，再来遍历项目集族判断项目集中是否含有归约项，区分和填充ActionGoto数组中的归约项和接受项。</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503204749919.png" alt="image-20220503204749919" style="zoom:77%;"></p><p>在构造DFA项目集的过程中，还涉及到以下函数调用</p><p>| 函数作用         | 函数名                                            | 说明                                                         |<br>| :———————- | ————————————————————————- | —————————————————————————————— |<br>| 求核             | <code>set&lt;Item&gt; getKernel(char c, set&lt;Item&gt; itemSet)</code>  | 遍历项目集中的每个项目，与文法进行匹配即可                   |<br>| 求闭包           | <code>set&lt;Item&gt; getClosure(set&lt;Item&gt; itemSet)</code>         | 通过while循环，循环体内遍历项目集中的每一个项目，若还有能扩充项目则继续迭代，直至项目集中的每一个项目不再能进行扩充。 |<br>| 求向前搜索符号集 | <code>set&lt;char&gt; getForward(char c, set&lt;char&gt; forward)</code> | 关键在于需要进行c是否为epsilon以及c是否能推出空来判断相应的动作，得到向前搜素符。 |<br>| 求First集        | <code>void getFirstSet()</code>                              | 通过while循环，循环体内遍历每一个文法，直至每个非终结符的First集不再发生改变就停止迭代，若还有变化则继续迭代。 |</p></li></ul><h3 id="（3）扫描token序列进行语法分析：void-scanSourceToken-string-token-str"><a href="#（3）扫描token序列进行语法分析：void-scanSourceToken-string-token-str" class="headerlink" title="（3）扫描token序列进行语法分析：void scanSourceToken(string token_str)"></a>（3）扫描token序列进行语法分析：void scanSourceToken(string token_str)</h3><p>​    首先检查词法分析无误，然后再进行语法分析，依据Action-Goto表依次对输入的token进行分析，根据当前的项目集（即DFA状态）和当前的token找Action-Goto表中的对应项，根据表中对应的值，判断是移进还是归约还是acc还是报错。如果是移进则更新当前状态，同时将状态和token入栈；如果是归约，则符号栈和状态栈依据归约文法进行退栈和入栈，同时根据最新的状态和token进行移进。直至acc或者检测到语法出错，则迭代结束。具体流程图如下：</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503210635580.png" alt="image-20220503210635580" style="zoom:50%;"></p><h2 id="2-6-实例分析"><a href="#2-6-实例分析" class="headerlink" title="2.6 实例分析"></a>2.6 实例分析</h2><ul><li>输入正确源程序，语法分析成功，无误。</li></ul><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503221437398.png" alt="image-20220503221437398" style="zoom:33%;"></p><ul><li><p>修改源程序，检查，能够报出错误信息，指明出错位置</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503221705649.png" alt="image-20220503221705649" style="zoom:33%;"></p></li></ul><h1 id="3-运行环境说明"><a href="#3-运行环境说明" class="headerlink" title="3. 运行环境说明"></a>3. 运行环境说明</h1><ul><li><p>操作系统：Windows 10</p></li><li><p>运行环境：Visual Studio Code</p></li><li><p>说明：编译链接Lexical或者Parser中的各个.cpp文件，然后运行main.cpp即可，Visual Studio Code环境下推荐CodeRunner插件一键运行；若更改源程序进行语法分析器的测试，请先运行词法分析器得到相应的token，再进行语法分析</p></li></ul><h1 id="3-课设总结"><a href="#3-课设总结" class="headerlink" title="3. 课设总结"></a>3. 课设总结</h1><p>​    本次课设花了将近两周的时间，首先由于是上学期学的编译原理，时间一长难免有些遗忘，所以在写代码前提前粗略地复习了一下之前学过的知识。在写代码过程中的同时，将理论知识转换成实际代码，也加深了我对编译原理课程所学知识的理解，也对我的代码能力有一定的提高。在写代码的过程中，感受到了选择一项好的数据结构的重要性，尤其是对C++中STL的实际应用，各种各样的数据结构让我体会到了STL的简便性。</p><p>​    在本次课设中，也遇到了一些磕磕碰碰，比如在进行语法分析器的设计，因为之前用的是书上的例子，导致之前开的保存项目集族的全局变量并没有很大，结果在代入自己的文法时，异常中断，最后通过开一大数组解决问题。还比如，在进行set的遍历时，删除了容器的部分元素，导致当前迭代器失效，通过预先获取下一步的迭代器，再删除现有的迭代器解决问题。</p><p>​    但是通过此次课程设计，让我体会到代码的模块化能够大大地节省编码过程中的调试时间，使代码逻辑层次更加清晰的好处。在编码过程中，将各个算法所用到的函数一个个写好，分阶段测试函数，整合算法，边写边检查和调试，就能够保证最终整合代码运行时报错模块数量最少。上学期虽然编译原理学得不错，但是转换成具体可用的程序来说，仍是有点陌生，但通过手动实现词法分析器和语法分析器，让我加深了对编译原理的理解和运用，总体来说收获颇丰。</p>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链的一些简单理解</title>
      <link href="/2022/04/12/2022-04-12-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
      <url>/2022/04/12/2022-04-12-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>关于比特币、以太坊、区块链结构</p><span id="more"></span><h1 id="比特币-区块链1-0"><a href="#比特币-区块链1-0" class="headerlink" title="比特币-区块链1.0"></a>比特币-区块链1.0</h1><ul><li><p>高度自治，</p></li><li><p>无国界贸易：</p><p><img src="https://i.bmp.ovh/imgs/2022/04/12/638806197ed4b7c7.png" style="zoom: 50%;"></p></li><li><p>不可篡改：交易一旦完成，交易数据不可篡改</p></li><li>隐私安全：每个用户可以拥有一个或多个账户，且无需提供用户信息，只需要提供密钥即可</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/12/f7ca63ac0036f299.png" style="zoom:50%;"></p><h2 id="去中心化模型"><a href="#去中心化模型" class="headerlink" title="去中心化模型"></a>去中心化模型</h2><p>去中心化模型：点对点（P2P）通信</p><p>去中心化<strong>并不是没有中心，而是中心不断的变化</strong>，每一次的中心都是由节点竞争而来</p><h2 id="账本隐私和快速对账"><a href="#账本隐私和快速对账" class="headerlink" title="账本隐私和快速对账"></a>账本隐私和快速对账</h2><p>比特币如何保护账本隐私：</p><ul><li>比特币系统利用<strong>哈希</strong>算法对交易信息进行加密、保护隐私<ul><li>交易信息：账户、信息内容</li></ul></li><li>哈希算法<ul><li><strong>能够提取事物的特征</strong></li><li>通过哈希值是<strong>无法反推</strong>出原来的明文</li><li>哈希算法 可以保护隐私和<strong>对账</strong><ul><li>只要哈希值不一样，账本中的数据就存在差异</li></ul></li></ul></li></ul><h2 id="账本一致性"><a href="#账本一致性" class="headerlink" title="账本一致性"></a>账本一致性</h2><p>比特币系统规则：<strong>最长链</strong>为可信任的链条</p><p>比特币中的<strong>矿工</strong>：创造区块，使链增长</p><p><img src="https://i.bmp.ovh/imgs/2022/04/12/78b98e299aa26c30.png" alt=""></p><h3 id="争夺记账权的方式：工作量证明"><a href="#争夺记账权的方式：工作量证明" class="headerlink" title="争夺记账权的方式：工作量证明"></a><strong>争夺记账权的方式：工作量证明</strong></h3><ul><li><p>工作量证明（Proof of Work）简称<strong>POW</strong></p></li><li><p>节点通过竞争PoW求解来获取记账权</p><ul><li>包括区块挖掘在内的区块链活动都是具有<strong>强时效性</strong>的竞争活动，竞争过程中，拥有<strong>哈希和拓扑优势</strong>的节点将有更高的概率获胜</li></ul></li><li><p>通过重复计算Nonce直至哈希值小于目标哈希值的过程：挖矿；这一整套算法成为POW算法</p></li><li><p>算力的体现就是单位时间内Nounce尝试的次数</p><p><a href=""><img src="https://s1.ax1x.com/2022/04/12/LnFzMd.png" style="zoom: 67%;"></a></p></li><li><p>伪造账本想要成为朱利安，必须要和比特币系统其余的人比拼算力，只有长时间的保持算力优先，才有伪造账本的可能。但<strong>保持长时间的算力优先的难度巨大</strong>，有可能高于伪造账本的获利</p></li></ul><h2 id="比特币的分叉"><a href="#比特币的分叉" class="headerlink" title="比特币的分叉"></a>比特币的分叉</h2><ul><li>不同矿工，使用不同版本的比特币系统进行挖矿，导致链条分叉<ul><li>硬分叉：系统的更新导致出现分支，无法合并,比如区块的扩容、</li><li>软分叉：可以合并</li></ul></li><li>这是矿工再比特币系统 协议层面上产生了分歧</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>比特币不是一种货币，是一个分布式的账本系统</p></li><li><p>账本记录交易过程，由节点广播道网络，保持其余节点数据一致</p></li></ul><hr><h1 id="区块链技术的形成"><a href="#区块链技术的形成" class="headerlink" title="区块链技术的形成"></a>区块链技术的形成</h1><p>区块链技术</p><ul><li>分布式数据存储<ul><li>每个参与者电脑上备份</li><li>账本实时同步和对账–&gt;保证公开透明</li></ul></li><li>点对点传输</li><li>共识机制<ul><li>比特币系统的主链容易出现短暂的分叉，这个分叉最终是会合并到主链上去的</li><li>比特币系统采用pow算法保证了账本的一致性，也让比特币系统变得更加安全可靠</li></ul></li><li>加密算法</li></ul><h1 id="以太坊-区块链2-0"><a href="#以太坊-区块链2-0" class="headerlink" title="以太坊-区块链2.0"></a>以太坊-区块链2.0</h1><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><strong>比特币的不足</strong>：</p><ul><li>交易速度慢</li><li>POW算法、耗电</li><li>仅仅完成了货币的去中心化，而现实中货币的价值建立在国家的公信力的基础上。</li></ul><p><strong>以太坊的改进</strong>：</p><ul><li><p>交易速度加快</p></li><li><p>POW+POS算法，逐步向POS算法过度</p></li><li><p>引入<strong>智能合约</strong></p><ul><li><p>不受人为因素的影响，没有黑幕</p></li><li><p>违反规则，直接扣除保证金</p></li></ul></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>以太坊</strong>是运行在计算机网络中的<strong>软件</strong>，它确保<strong>数据</strong>以及<strong>智能合约的小程序</strong>可以在没有中心协调者的情况下，被所有网络中的 计算机复制和处理</p><p><strong>以太坊平台能够承载应用</strong></p><p>以太坊的愿景是创建一个<strong>无法停止</strong>，<strong>抗屏蔽</strong>（审查）和<strong>自我维持</strong>的<strong>去中心化</strong>世计算机</p><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>智能合约：跑在以太坊系统中的合同，其实质是<strong>一段代码</strong></p><ul><li>它们像公示出来的法律合同，违反它们的人将遭到处罚</li></ul><p><strong>智能合约</strong>能表达：<strong>规则明确，不受主观因素影响</strong>的业务、规则不轻易修改的业务</p><ul><li>如果业务规则经常变化，无法通过智能合约编写，因为智能合约小程序一旦写完，运行在以太坊，是无法通过软件升级去进行规则更新的</li></ul><h2 id="ghost协议"><a href="#ghost协议" class="headerlink" title="ghost协议"></a>ghost协议</h2><p>以太坊快速出块产生的问题：区块分叉</p><hr><h1 id="区块链结构"><a href="#区块链结构" class="headerlink" title="区块链结构"></a>区块链结构</h1><p><img src="https://i.bmp.ovh/imgs/2022/04/13/eb0ad5cd836bb5a6.png" style="zoom:50%;"></p><p>Merkle树，快速<strong>归纳和校验大</strong>规模数据完整性的数据结构</p><ul><li>最下面的<strong>叶子节点存储哈希值或数据</strong></li><li>每个中间节点是<strong>两个子结点的内容的哈希值</strong>，</li><li><p>根节点也是两个子结点内容的哈希值</p></li><li><p>只要存储数据的叶子节点由任何的变动，都会传递道相应的父节点，<strong>导致其Merkle树的根节点发生变化</strong></p></li></ul><h2 id="区块链的P2P网络"><a href="#区块链的P2P网络" class="headerlink" title="区块链的P2P网络"></a>区块链的P2P网络</h2><h3 id="混合式：集中式-分布式"><a href="#混合式：集中式-分布式" class="headerlink" title="混合式：集中式+分布式"></a>混合式：集中式+分布式</h3><ul><li><p>网络中存在多个<strong>超级节点</strong>组成的<strong>分布式</strong>网络</p></li><li><p>而每个超级节点由多个<strong>普通节点</strong>和它组成局部的<strong>集中式</strong>网络</p></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/340e3a8ce5c9f06e.png" style="zoom: 33%;"></p><ul><li>新节点的加入：<ul><li>先选择一个超级节点进行通信</li><li>该超级节点再推送给其他超级节点列表给新加入节点<ul><li><strong>洪泛广播只发生在超级节点</strong>之间，避免大规模洪泛</li></ul></li><li>加入节点根据列表中的超级节点状态选择一个具体的超级节点作为父节点</li></ul></li></ul><hr><h3 id="比特币网络：混合式"><a href="#比特币网络：混合式" class="headerlink" title="比特币网络：混合式"></a>比特币网络：混合式</h3><p><strong>所有节点</strong>都会 </p><ul><li>参与校验、广播交易和区块信息；</li><li>发现和维持与其他节点的连接</li></ul><p><strong>全节点Full Node</strong></p><ul><li><p>承担网络中<strong>交易和区块的验证</strong>工作</p></li><li><p>包含<strong>完整的区块链数据库</strong>，包括所有交易数据</p></li></ul><p><strong>轻节点（LightWeight Node）或SPV节点</strong></p><ul><li>只存储区块链数据库的<strong>一部分</strong><ul><li>一般<strong>只存储区块头</strong>而不存储交易数据，通过<strong>简化交易验证（SPV）</strong>完成交易检验</li><li>验证<strong>前置交易</strong>的有效性</li></ul></li></ul><hr><p>比特币网络中的节点四大功能（只有<strong>比特币核心节点</strong>才会包含所有四大功能）：</p><ul><li>钱包 <strong>W</strong>allet<ul><li>PC或手机客户端的功能，用户通过钱包查看自己的账户余额，管理钱包地址和密钥，发起交易等</li><li>除了<strong>比特币核心钱包是全节点</strong>，大部分钱包都是轻节点</li></ul></li><li>挖矿 <strong>M</strong>iner<ul><li>挖矿节点通过解决<strong>PoW算法</strong>问题，与其他挖矿节点相互<strong>竞争创建新区块</strong></li><li><strong>独立矿工</strong>：全节点，存储完整的区块链数据库</li><li><strong>矿池矿工</strong>：和<strong>其他节点一起</strong>连接到矿池，参与集体挖矿<ul><li>形成了一个<strong>集中式矿池网络</strong>，中心节点是一个矿池服务器，其他挖矿节点全部连接到矿池服务器</li></ul></li></ul></li><li>区块链数据库 Full <strong>B</strong>lockchain</li><li>网络路由 <strong>N</strong>etwork Routing Node</li></ul><hr><p>整个比特币网络：</p><ul><li><strong>主网络</strong>：不同节点间使用<strong>比特币协议作</strong>为通信协议的的网络</li><li><strong>矿池网络</strong>：扩展网络<ul><li>不同的矿池网络可能使用不同的矿池挖矿协议<ul><li>Stratum协议：支持挖矿节点，支持瘦客户钱包</li></ul></li></ul></li><li>矿池矿工和矿池服务器之间的通信协议：<strong>矿池挖矿协议</strong></li><li>矿池服务器作为全节点与其他比特币节点使用<strong>主网络的比特币协议</strong>通信</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/98092e4534e957d3.png" alt=""></p><p>比特币传播网络（比特币中继网络）：</p><p>一个专门的传播网络：<strong>加快新区块在矿工之间的同步传播</strong></p><p>矿工创建新区块后，需要<strong>广播给全网</strong>所有节点，当全网都接受了该区块，给矿工的挖矿奖励才有效，然后才好开始下一个区块Hash的计算；</p><ul><li>矿工必须最大限度缩短区块的广播和下一个区块计算之间的时间</li></ul><hr><h3 id="结构化P2P"><a href="#结构化P2P" class="headerlink" title="结构化P2P"></a><strong>结构化P2P</strong></h3><ul><li>分布式网络：<strong>结构化</strong>网络、所有节点<strong>按照某种结构有序</strong>组织<ul><li>对比分布式网络：随机网络</li></ul></li><li>结构化网络的实现，基于DHT算法<ul><li><strong>DHT</strong>（Distributed Hah Table，分<strong>布式哈希表</strong>） <ul><li>网络模型，不涉及具体实现</li><li>解决分布式环境下快速准确地路由、定位数据</li><li>具体的实现算法：Chord、CAN、Kademlia等等<ul><li>以太坊网络采用Kademlia</li></ul></li></ul></li></ul></li></ul><hr><h4 id="DHT"><a href="#DHT" class="headerlink" title="DHT"></a><strong>DHT</strong></h4><p>P2P的两种空间：</p><ul><li>资源空间：所有节点保存的<strong>资源集合</strong></li><li>节点空间：所有<strong>节点的集合</strong></li></ul><p>对所有资源和节点编号：对资源名称或内容用<strong>hash函数变成一个数值</strong></p><ul><li>一个资源一个ID、一个节点一个ID、资源ID和节点ID建立映射关系</li><li>将资源n的<strong>索引信息</strong>存到节点n上，要搜资源n，则找节点n<ul><li>能够避免洪泛广播</li><li>能够快速准确路由 和 定位数据</li></ul></li></ul><p>DHT算法在资源编号和节点编号上使用 <strong>分布式哈希表</strong>，使得资源空间和节点空间的编号具有唯一性、均匀分布式</p><hr><h3 id="以太坊网络：结构化P2P"><a href="#以太坊网络：结构化P2P" class="headerlink" title="以太坊网络：结构化P2P"></a>以太坊网络：结构化P2P</h3><ul><li>采用<strong>Kad</strong>emlia算法实现：分布式哈希技术</li></ul><p>Kad网络</p><ul><li>每个节点由一个唯一的节点ID</li><li>不同节点间的距离：逻辑距离，两个节点ID<strong>异或</strong>得到</li><li>给定一个节点a和距离L，<strong>有且仅有一个节点</strong>使得a^b=L</li><li>通过这种方式能有效度量Kad网络中不同节点间的逻辑距离</li></ul><hr><p>近期的区块链架构</p><p><img src="https://i.bmp.ovh/imgs/2022/04/13/bcd6f70393329c9e.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 信安赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【总结】字符串处理总结</title>
      <link href="/2022/04/08/2022-04-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
      <url>/2022/04/08/2022-04-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容：<ul><li>总结各类模拟题型中的一些字符串处理</li></ul></li></ul><span id="more"></span><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><strong>C语言里压根就没有string这个类</strong>，所以字符串都是通过<strong>char数组</strong>来存储的，而<string.h>这个头文件里声明的函数原型也全是针对char数组的种种操作。<strong>直到C++中才出现了string这个类</strong>(注意是类，不是类型)</string.h></p><h1 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> 大写字母 = 小写字母-<span class="string">'a'</span>+<span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span> 大写字母 = <span class="built_in">toupper</span>(小写字母);</span><br><span class="line"><span class="comment">//cout&lt;&lt;(char)toupper(c[i])直接cout要类型转换，因为toupper返回的时int的ascii</span></span><br><span class="line"><span class="keyword">char</span> 小写字母 = <span class="built_in">tolower</span>(大写字母);</span><br></pre></td></tr></tbody></table></figure><h1 id="string-char-int-之间的相互转换"><a href="#string-char-int-之间的相互转换" class="headerlink" title="string char[] int 之间的相互转换"></a>string char[] int 之间的相互转换</h1><h2 id="string-转-char"><a href="#string-转-char" class="headerlink" title="string 转 char[]"></a>string 转 char[]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">a=s.<span class="built_in">c_str</span>(); <span class="comment">//string转char数组</span></span><br></pre></td></tr></tbody></table></figure><h2 id="string-转-int"><a href="#string-转-int" class="headerlink" title="string 转 int"></a>string 转 int</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s=<span class="string">"123"</span>;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">stoi</span>(s); <span class="comment">//output:123</span></span><br><span class="line"><span class="comment">//同理还有：</span></span><br><span class="line"><span class="comment">//stoll():转换成long long</span></span><br><span class="line"><span class="comment">//stod():转换成double；stof():转换成floay</span></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></tbody></table></figure><h2 id="char-转-string"><a href="#char-转-string" class="headerlink" title="char[] 转 string"></a>char[] 转 string</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[]=<span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line">string s=ch</span><br></pre></td></tr></tbody></table></figure><h2 id="char-转-int"><a href="#char-转-int" class="headerlink" title="char[] 转 int"></a>char[] 转 int</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[]=<span class="string">"124"</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">atoi</span>(ch);</span><br></pre></td></tr></tbody></table></figure><h2 id="int-转-string"><a href="#int-转-string" class="headerlink" title="int 转 string"></a>int 转 string</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">123</span>;</span><br><span class="line">string s=<span class="built_in">to_string</span>(a);</span><br></pre></td></tr></tbody></table></figure><h2 id="int-转-char"><a href="#int-转-char" class="headerlink" title="int 转 char[]"></a>int 转 char[]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number =<span class="number">123</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">itoa</span>(number, s, <span class="number">10</span>);<span class="comment">//将number转换成十进制存在s数组中</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number =<span class="number">123</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(s,<span class="string">"%d"</span>,number);<span class="comment">//将number转换成十进制存在s数组中</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></tbody></table></figure><h1 id="字符串读取"><a href="#字符串读取" class="headerlink" title="字符串读取"></a>字符串读取</h1><h2 id="getline-cin-string-namae-end-char-读取一行"><a href="#getline-cin-string-namae-end-char-读取一行" class="headerlink" title="getline(cin,string_namae,end_char)读取一行"></a>getline(cin,string_namae,end_char)读取一行</h2><p>接受一个字符串，可以接受空格并输出</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str; </span><br><span class="line"><span class="built_in">getline</span>(cin,str); <span class="comment">//输入：ss ss ss</span></span><br><span class="line">cout&lt;&lt;str&lt;&lt;endl;  <span class="comment">//输出：ss ss ss</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin,str,<span class="string">'a'</span>);<span class="comment">//一个直到‘a’结束，其中任何字符包括'\n'都能够读入</span></span><br></pre></td></tr></tbody></table></figure><p>当同时使用<code>cin&gt;&gt;</code>和<code>getline(cin,str)</code>的时候，在<code>cin&gt;&gt;</code>输入完成之后，<code>getline(cin,str)</code>(str是真正想要的串)之前，需要<strong>先</strong><code>getline(cin,str)</code>（这个str是一个打算用来存储换行符的串）；<font color="red">将换行从输入流缓存中清除</font></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">string line;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">getline</span>(cin,line); <span class="comment">//清除缓存的换行!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="built_in">getline</span>(cin,line);</span><br></pre></td></tr></tbody></table></figure><h2 id="gets-char-读取一行"><a href="#gets-char-读取一行" class="headerlink" title="gets(char*)读取一行"></a>gets(char*)读取一行</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> t[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">gets</span>(t);</span><br><span class="line"><span class="built_in">puts</span>(t);</span><br></pre></td></tr></tbody></table></figure><h1 id="STL-string常用方法"><a href="#STL-string常用方法" class="headerlink" title="STL string常用方法"></a>STL string常用方法</h1><h2 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string line=<span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">int</span> st=<span class="number">3</span>,len=<span class="number">2</span>;</span><br><span class="line">string s1=<span class="built_in">substr</span>(line,st,len);</span><br><span class="line"><span class="comment">//从line的st位置开始，截取len长度的字符串</span></span><br></pre></td></tr></tbody></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> idx= line.<span class="built_in">find</span>(<span class="string">"cde"</span>);<span class="comment">//查得到则返回第一个下标，</span></span><br><span class="line"><span class="comment">//找不到会返回一个诡异的数字（反正比字符串长）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx=line.<span class="built_in">find</span>(<span class="string">"cde"</span>,<span class="number">2</span>);<span class="comment">//从第index=2的位置往后找</span></span><br></pre></td></tr></tbody></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">"0123456"</span>;</span><br><span class="line">string s=<span class="string">"aa"</span>;</span><br><span class="line">str=s.<span class="built_in">insert</span>(<span class="number">4</span>,s);<span class="comment">//0123aa456</span></span><br><span class="line"><span class="comment">//在str[4]之前插入s</span></span><br></pre></td></tr></tbody></table></figure><h2 id="大小写转换-1"><a href="#大小写转换-1" class="headerlink" title="大小写转换"></a>大小写转换</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transform(处理对象容器起始地址，处理对象容器结束地址，存放结果的容器地址，处理操作（可自定义））</span></span><br><span class="line"><span class="built_in">transform</span>( str.<span class="built_in">begin</span>() , str.<span class="built_in">end</span>() , str.<span class="built_in">begin</span>() , ::tolower );<span class="comment">//化为小写</span></span><br><span class="line"><span class="built_in">transform</span>( str.<span class="built_in">begin</span>() , str.<span class="built_in">end</span>() , str.<span class="built_in">begin</span>() , ::toupper );<span class="comment">//化为大写</span></span><br></pre></td></tr></tbody></table></figure><h1 id="string-h头文件"><a href="#string-h头文件" class="headerlink" title="string.h头文件"></a>string.h头文件</h1><p><code>strlen(char*)</code></p><p><code>strcmp(char* a, char* b)</code>字典序比较</p><ul><li>a&lt;b;返回负整数</li><li>a==b;返回0</li><li>a&gt;b;返回正整数</li></ul><p><code>strcpy(char* a ,char* b)</code>把a复制给b</p><p><code>strcat(char* a ,char* b)</code>把b接到a后面</p><h1 id="sscanf和sprintf"><a href="#sscanf和sprintf" class="headerlink" title="sscanf和sprintf"></a>sscanf和sprintf</h1><p><code>scanf(char* , "" ,&amp;)</code></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> t[<span class="number">100</span>]; <span class="built_in">gets</span>(t);<span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">sscanf</span>(t,<span class="string">"%d"</span>,a);<span class="comment">//把t以整型格式输入到a中</span></span><br><span class="line"><span class="built_in">sscanf</span>(t,<span class="string">"%d:%lf,%s"</span>,&amp;n,&amp;db,str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(t,<span class="string">"%d"</span>,a);<span class="comment">//把整型的a输出到字符串t中</span></span><br></pre></td></tr></tbody></table></figure><h1 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"aaa"</span>,b[]=<span class="string">"aaa"</span>;  </span><br><span class="line">string A = <span class="string">"AAA"</span>, B = <span class="string">"AAA"</span>;  </span><br><span class="line">cout &lt;&lt;<span class="string">"*a和*b的值分别是："</span> &lt;&lt;*a &lt;&lt; <span class="string">"，"</span> &lt;&lt; *b &lt;&lt; endl;  </span><br><span class="line">cout &lt;&lt;<span class="string">"*“aaa”的值是："</span>&lt;&lt; *<span class="string">"aaa"</span> &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的比较方法：</span></span><br><span class="line">cout &lt;&lt;<span class="string">"利用 == 比较a,b两个字符串，结果是（相等为1，不等为0）："</span> &lt;&lt;(a==b) &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的比较方法:</span></span><br><span class="line">cout &lt;&lt; <span class="string">"利用strcmp()比较a，b两个字符串，结果是（相等为0，不等非0）："</span>&lt;&lt;<span class="built_in">strcmp</span>(a,b) &lt;&lt; endl;  </span><br><span class="line">cout &lt;&lt; <span class="string">"利用 == 比较A,B两个string，结果是（相等为1，不等为0）："</span>&lt;&lt;(A==B) &lt;&lt; endl;  </span><br><span class="line">cout &lt;&lt; <span class="string">"利用compare()比较A,B两个string，结果是（相等为0，不等非0）："</span> &lt;&lt; A.<span class="built_in">compare</span>(B) &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br></pre></td></tr></tbody></table></figure><h1 id="int-isdigit-char"><a href="#int-isdigit-char" class="headerlink" title="int isdigit(char)"></a>int isdigit(char)</h1><p><code>isdigit</code>是计算机C(C++)语言中的一个函数，主要用于检查其参数<strong>是否为十进制数字字符</strong>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span> <span class="comment">//C</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span>  <span class="comment">//C++</span></span></span><br><span class="line"><span class="comment">//检查参数 c 是否为阿拉伯数字0 到9。</span></span><br><span class="line"><span class="comment">//若参数c为阿拉伯数字0~9，则返回非0值，否则返回0。</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】贪心</title>
      <link href="/2022/03/28/2022-03-28-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E8%B4%AA%E5%BF%83/"/>
      <url>/2022/03/28/2022-03-28-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>一些贪心的题：区间问题、Huffman树、排列不等式、其他类型</li></ul></li></ul><span id="more"></span><h1 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h1><font color="red">区间问题的贪心一般都是上来先按左端点or右端点排序</font><p>然后手动模拟一下贪心，找性质，多找几组样例试试</p><h2 id="AcWing905-区间选点"><a href="#AcWing905-区间选点" class="headerlink" title="AcWing905 区间选点"></a>AcWing905 区间选点</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定<strong>N个闭区间</strong>，在数轴上选择尽量少的点，使<strong>每个区间至少包含</strong>一个选出的点，求选择的点的<strong>最小数量</strong></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/d297674baef4ce99.png" alt=""></p><ul><li>将每个区间<strong>按右端点</strong>从小到大<font color="red">排序</font></li><li>按照这个顺序从小到大<strong>枚举每个区间</strong><ul><li>对于当前区间，比如首先选择区间①的右端点，区间②、③都<strong>包含</strong>该点，所以直接pass（不在②、③区间选择点），继续往后枚举</li><li>当枚举到区间④时，发现区间①的右端点<strong>不在</strong>区间④内，所以此时<strong>选择</strong>区间④的右端点</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>,INF=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>{</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="comment">//重载小于号，按r从小到大排序 </span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Range&amp;W)<span class="keyword">const</span>{</span><br><span class="line"><span class="keyword">return</span> r&lt;W.r;</span><br><span class="line">}</span><br><span class="line">}range[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;range[i].l&gt;&gt;range[i].r;</span><br><span class="line"><span class="built_in">sort</span>(range,range+n);</span><br><span class="line"><span class="keyword">int</span> ed=-INF;  <span class="comment">//ed：当前区间右端点，初始化为最小值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(ed&lt;range[i].l){ <span class="comment">//如果前一个区间的右端点＜当前区间的左端点 </span></span><br><span class="line">ans++;</span><br><span class="line">ed=range[i].r;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing908-最大不相交区间数量"><a href="#AcWing908-最大不相交区间数量" class="headerlink" title="AcWing908 最大不相交区间数量"></a>AcWing908 最大不相交区间数量</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定<strong>N个闭区间</strong>，在数轴上<strong>选择若干区间</strong>，之间<strong>互不相交</strong>，求可选区间的<strong>最大</strong>数量</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li><strong>实际上和上题一样</strong>，区间相交 == 这几个区间能被同一个点覆盖 == 就只能从这几个区间中选择一个区间</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><ul><li>和上题一模一样</li></ul><h2 id="AcWing906-区间分组"><a href="#AcWing906-区间分组" class="headerlink" title="AcWing906 区间分组"></a>AcWing906 区间分组</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><ul><li><p>简单的理解，就是一种可以<strong>自动排序</strong>的队列</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;结构名,vector&lt;结构名&gt;,greater/less&lt;结构名&gt;&gt; 队列名</span><br><span class="line"><span class="comment">// greater代表升序,从小到大; less代表降序,从大到小</span></span><br><span class="line"><span class="comment">//比如小根堆:</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt;heap;</span><br><span class="line">heap.<span class="built_in">size</span>();</span><br><span class="line">heap.<span class="built_in">empty</span>();<span class="comment">//heap为空则返回1</span></span><br><span class="line">heap.<span class="built_in">push</span>(k);<span class="comment">//在heap队列中插入k</span></span><br><span class="line">heap.<span class="built_in">pop</span>();<span class="comment">//删除heap队列中的第一个元素,小根堆的话,就是删除最小的那个</span></span><br><span class="line">heap.<span class="built_in">top</span>();<span class="comment">//返回heap队列中的第一个元素,并不删除</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定<strong>N个闭区间</strong>，将其分组，使得<strong>每组</strong>里面的各个区间<strong>没有交集</strong>，求<strong>最小</strong>分组数量</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li><p>将所有区间按照<strong>左端点</strong> 从小到大<font color="red">排序</font></p></li><li><p>从前往后处理每个区间</p><ul><li><strong>判断能否将其放到</strong>某个 现有 的组中<code>L[i]＞MAX_r</code>：<strong>==</strong> 判断每一组的<strong>右端点最右</strong>的区间是否跟它<strong>有交集</strong> <ul><li>如果和每一个组都有交集，则开一个新的组，把当前区间放进去</li><li>如果和某一个组无交集，将当前组的<code>MAX_r</code>放进去，并更新<code>MAX_r</code></li></ul></li></ul></li><li><p>理解：循环到该区间时，在此之前有很多组，每组里面有很多个不相交的区间，<strong>每个组</strong>里面都有<strong>一个</strong>MAX_r；</p><p><img src="https://s3.bmp.ovh/imgs/2022/03/effb589caed4b102.png" style="zoom: 40%;"></p><p><img src="https://i.bmp.ovh/imgs/2022/03/6821c2d7023fdd3a.png" style="zoom:40%;"></p><p><img src="https://s3.bmp.ovh/imgs/2022/03/7e41023452060a5b.png" style="zoom:40%;"></p></li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>{</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Range&amp;M)<span class="keyword">const</span>{</span><br><span class="line"><span class="keyword">return</span> l&lt;M.l;</span><br><span class="line">}</span><br><span class="line">}range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> l,r; </span><br><span class="line">cin&gt;&gt;range[i].l&gt;&gt;range[i].r;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">sort</span>(range,range+n);</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(heap.<span class="built_in">empty</span>()||heap.<span class="built_in">top</span>()&gt;=range[i].l){<span class="comment">//第一个区间or当前区间左端点小于最小Max_r</span></span><br><span class="line">heap.<span class="built_in">push</span>(range[i].r);  <span class="comment">//新增一个</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">heap.<span class="built_in">pop</span>();  <span class="comment">//大于最小Max_r，就把堆顶那个最小Max_r弹出，更新为当前区间的r</span></span><br><span class="line">heap.<span class="built_in">push</span>(range[i].r);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;heap.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing907-区间覆盖"><a href="#AcWing907-区间覆盖" class="headerlink" title="AcWing907 区间覆盖"></a>AcWing907 区间覆盖</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p><strong>N个闭区间</strong>，一个线段区间[s,t] ，选择尽量<strong>少</strong>的区间，将指定<strong>线段区间完全覆盖</strong></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>将所有区间按<strong>左端点从小到大</strong>排序</li><li>从前往后依次枚举每个区间，<ul><li>在所有<strong>能覆盖s</strong>(左端点≤s的情况下)的区间中，选择一个<strong>右端点最大</strong>的区间</li><li>然后，将<strong>s更新</strong>为右端点的最大值</li><li><strong>直到</strong>右端点<strong>大于t</strong></li></ul></li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h1><h2 id="AcWing148-合并果子"><a href="#AcWing148-合并果子" class="headerlink" title="AcWing148 合并果子"></a>AcWing148 合并果子</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>N堆果子，每次<strong>任意合并两堆</strong>，每次合并消耗的体积等于这两堆重量之和，求合并完消耗的<strong>最小体力</strong></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>经典huffman模型，每次合并重量最小的两堆</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="comment">//定义小根堆：优先队列，对push进去的元素，会从小到大自动排序 </span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;heap;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> a;cin&gt;&gt;a;</span><br><span class="line">heap.<span class="built_in">push</span>(a);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(heap.<span class="built_in">size</span>()&gt;<span class="number">1</span>){</span><br><span class="line"><span class="comment">//每次取最小的两个合并 </span></span><br><span class="line"><span class="keyword">int</span> a=heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> b=heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line">ans+=(a+b);</span><br><span class="line"><span class="comment">//合并后再push到小根堆中 </span></span><br><span class="line">heap.<span class="built_in">push</span>(a+b);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h1><h2 id="AcWing913-排队打水"><a href="#AcWing913-排队打水" class="headerlink" title="AcWing913 排队打水"></a>AcWing913 排队打水</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p><strong>n个</strong>人排队打水，第i个人装满水的时间是ti，问如何排队使得所有人<strong>等待时间之和最小</strong></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p><a href="https://imgtu.com/i/q6ydhj"><img src="https://s1.ax1x.com/2022/03/29/q6ydhj.png" alt="q6ydhj.png" style="zoom: 50%;"></a></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[N];</span><br><span class="line">ll n,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">ans+=a[i]*(n-i<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing104-货舱选址"><a href="#AcWing104-货舱选址" class="headerlink" title="AcWing104 货舱选址"></a>AcWing104 货舱选址</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p><a href="https://imgtu.com/i/q6hctK"><img src="https://s1.ax1x.com/2022/03/29/q6hctK.png" alt="q6hctK.png" style="zoom: 33%;"></a></p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h1><h2 id="AcWing104-货仓选址"><a href="#AcWing104-货仓选址" class="headerlink" title="AcWing104 货仓选址"></a>AcWing104 货仓选址</h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>数轴上N个坐标，求一个坐标到每个坐标的距离之和最小，求距离最小值</p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>这个点在中间</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll n,ans;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++){</span><br><span class="line">ans+=<span class="built_in">abs</span>(a[n<span class="number">-1</span>-i]-a[i]);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h1 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h1><h2 id="AcWing1055-股票购买"><a href="#AcWing1055-股票购买" class="headerlink" title="AcWing1055 股票购买"></a>AcWing1055 股票购买</h2><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><p>长度为 N数组，第 i个数字表示一个给定股票在第 i天的价格。</p><p>计算你所能获取的<strong>最大利润</strong>。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>低买高出就行</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;a[i+<span class="number">1</span>]){</span><br><span class="line">ans+=a[i+<span class="number">1</span>]-a[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIP-2-频率域滤波</title>
      <link href="/2022/03/24/2022-03-06-DIP-2-%E5%82%85%E9%87%8C%E5%8F%B6/"/>
      <url>/2022/03/24/2022-03-06-DIP-2-%E5%82%85%E9%87%8C%E5%8F%B6/</url>
      
        <content type="html"><![CDATA[<ul><li>关于一些 让我自己觉得<strong>我自己就是个智障</strong>QAQ的东西  瞎几把乱写的通俗理解</li></ul><span id="more"></span><ul><li>任何<strong>周期函数</strong>，都可以看作 不同振幅、不同相位<strong>正弦波的叠加</strong></li><li>滤波：从某条曲线中去除一些特定的频率成分</li><li><p>频率分量：不同频率的正弦波</p><ul><li>将角频率为ω0的正弦波cos（ω0）看作基础，那么频域的基本单元就是ω0</li></ul></li><li><p>cos(0t)也就是一条直线，可以理解成一个周期长的正弦波</p><ul><li>所以在频率域，0频率 称为 直流分量</li></ul></li><li>频域的基本单元也可以理解为<strong>一个始终在旋转的圆</strong></li><li>简单说就是如果从时间域分析信号时，时间是横坐标振幅是纵坐标。而在<strong>频率域</strong>分析的时候则是<strong>频率是横坐标</strong>，<strong>振幅是纵坐标</strong></li><li><p>频域图像，也就是俗称的<strong>频谱</strong></p></li><li><p>空间域就是你看到的一个个像素。频率域就是空间域经过傅立叶变换的信号</p></li><li>在 图像处理中，频域反应了图像在空域<strong>灰度变化剧烈程度</strong>，也就是图像<strong>灰度的变化速度</strong>，也就是图像的梯度大小。对图像而言，图像的边缘部分是突变部分，变化较 快，因此反应在频域上是高频分量；图像的噪声大部分情况下是高频部分；图像平缓变化部分则为低频分量。也就是说，傅立叶变换提供另外一个角度来观察图像， 可以将图像从灰度分布转化到频率分布上来观察图像的特征。书面一点说就是，傅里叶变换提供了一条从空域到频率自由转换的途径。</li></ul><hr><ul><li>二维傅里叶变换就是 <strong>将一个图像分解称若干个复平面波之和</strong></li></ul><p>二维连续傅里叶变换的公式：</p><script type="math/tex; mode=display">F（u,v)=\int_{-\infin}^{+\infin} \int_{-\infin}^{+\infin} f(x,y)e^{-j2\pi(ux+vy)}dxdy</script><p>将<strong>图像f</strong> 与<strong>每个不同频率的不同方向的复平面波</strong>做内积</p><p>给定一幅图像f, 能够算出<strong>每个平面波在图像中的成分是多少</strong></p><p>也就说，求这个图像 ，在<strong>基上的投影</strong></p><ul><li>傅里叶谱的<strong>每个位置存储的数</strong>代表了所在位置复平面波 在图像中的成分占多数，</li><li>每个位置存储的数* 该位置所代表的平面波求和得到原来的图像</li></ul><p>已知一幅图像f（x,y), 二维离散傅里叶变换公式，一对uv值对应了基底的一种形式，也就是对应了一个对应频率下的复平面波，那么F（u，v）的模就可以用来在这个频率下的复平面波对图像的影响，可以把它看作一个权重，表示该频率对图像的贡献程度，傅里叶谱</p><ul><li>傅里叶谱，中间部分代表低频，四周代表高频</li><li><p>不同的频率有不同的幅度，</p><ul><li>如果谱中 ，亮度越高 ，意味着频幅越大，亮度越按，意味着频幅越小</li><li>而这个频幅，又代表这对应的该频率对原图像的影响程度<ul><li>一幅图像分解成 若干个 不同频率的复平面波之和，这个之和 应该是带权相加，而那个频幅就相当于这个权</li></ul></li></ul></li><li><p>频谱图中的每一个点都与空域中的<strong>整幅图像相关</strong>，相当于每一个点都代表一个用于表示原图的波或者频率；这个点越亮，代表着用于表示原图的那个频率占比越重</p></li><li>频域是一个全局的概念。<strong>低频高频，都是对于整幅图片而言的</strong>。低频幅度大 是因为图片大部分区域都是缓慢变化的，而锐利的边缘则非常稀疏（即高频幅度小）</li><li>频谱上的点与空域上的点不是一一对应的。<strong>频谱上每一点都与空域所有点有关</strong>，反之，空域每一点都与频谱上所有点有关。这可以从傅里叶变换的公式直观看出来。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理Digital Image Processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SE】软件设计模式</title>
      <link href="/2022/03/22/2022-03-22-%E3%80%90SE%E3%80%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/22/2022-03-22-%E3%80%90SE%E3%80%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>策略模式</li><li>装饰者模式、工厂模式、单件模式、命令模式</li><li>模板方法模式：封装算法</li><li>迭代器和组合模式：管理良好的集合</li><li>状态模式：事物的状态</li></ul></li><li><strong>参考学习资料</strong>：<strong>《HeadFirst 设计模式》</strong></li></ul><span id="more"></span><h1 id="设计原则总结"><a href="#设计原则总结" class="headerlink" title="设计原则总结"></a>设计原则总结</h1><h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p>找出应用中<strong>可能需要变化之处</strong>，把它们<strong>独立</strong>出来，不要和那些不需要变化的代码混在一起</p><p>理解：</p><ul><li>变化的部分：每次有新的需求，会使<strong>某方面代码发生变化</strong></li><li>把这部分变化的<strong>抽取出来</strong></li><li>即：把会变化的部分取出并<strong>封装</strong>起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分</li><li>效果：代码变化引起的不经意的后果变少，系统变得更有<strong>弹性</strong></li></ul><h2 id="针对接口"><a href="#针对接口" class="headerlink" title="针对接口"></a>针对接口</h2><p><strong>针对接口编程</strong>，而不是针对实现编程</p><p>理解：</p><ul><li>实质就是，针对<strong>超类型编程</strong></li><li>明确地理解：变量的<strong>声明类型是超类型</strong>——抽象类或者接口</li></ul><p>区分</p><ul><li><p>针对实现编程</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog d = <span class="keyword">new</span> Dog(); <span class="comment">//Dog是抽象类Animal的具体实现</span></span><br><span class="line">d.bark();</span><br></pre></td></tr></tbody></table></figure></li><li><p>针对接口、超类型编程</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">animal.makeSound();  <span class="comment">//多态调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在运行时指定具体实现的对象:</span></span><br><span class="line">a = getAnimal();</span><br><span class="line">a.makeSound();</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="多用组合"><a href="#多用组合" class="headerlink" title="多用组合"></a>多用组合</h2><p><strong>多用组合、少用继承</strong></p><p>理解：</p><ul><li><p>比如在创建ModelDuck这个具体类时，在它的构造器里实例化了FlyBehavior和QuackBehavior这两个类（接口）；这就是使用了组合</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ModelDuck</span><span class="params">()</span> </span>{</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyNoWay();</span><br><span class="line">        quackBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//其他代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h2><blockquote><p>详细例子 见” 观察者模式 “  </p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>为了交互对象之间的松耦合设计而努力</p><hr><ul><li>松耦合的设计能够让我们建立有<strong>弹性</strong>的OO系统，能够应对变化，因为对象之间的<strong>互相依赖降到了最低</strong></li><li>当两个对象之间松耦合，它们依然<strong>可以交互</strong>，但是<strong>不太清楚</strong>彼此的细节；</li></ul><hr><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><ul><li>内容：<strong>类应该对扩展开放，对修改关闭</strong></li><li>允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为：<ul><li>这样设计具有弹性</li><li>可以应对改变</li><li>可以接受新的功能来应对改变的需求</li></ul></li></ul><hr><h2 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h2><h3 id="使用了好莱坞原则的模式："><a href="#使用了好莱坞原则的模式：" class="headerlink" title="使用了好莱坞原则的模式："></a><strong>使用了好莱坞原则的模式：</strong></h3><ul><li>工厂模式</li><li>观察者模式</li><li>模板方法模式</li></ul><hr><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>（高层组件对待低层组件的方式：）<strong>别调用我们，我们会调用你</strong></p><p>允许低层组件将自己挂钩到系统上，但<strong>高层</strong>组件会<strong>决定什么时候和怎样使用</strong>这些低层组件</p><p><img src="https://i.bmp.ovh/imgs/2022/04/09/1bc81e862f7a5d9d.png" style="zoom:50%;"></p><p>说明：低层组件<strong>并不是 不可以</strong>调用高层组件中的方法。</p><ul><li>事实上，在低层组件结束时，常常会调用从超类继承而来的方法</li><li>我们要做的是，<strong>避免</strong>高低层组件之间有<strong>明显的环状依赖</strong></li></ul><h3 id="好莱坞原则与依赖倒置原则的关系"><a href="#好莱坞原则与依赖倒置原则的关系" class="headerlink" title="好莱坞原则与依赖倒置原则的关系"></a>好莱坞原则与依赖倒置原则的关系</h3><ul><li>依赖倒置原则：避免使用具体类，<strong>多使用抽象</strong></li><li>好莱坞原则：用在<strong>创建框架or组件</strong>上的一种技巧，让<strong>低层组件能够被挂钩进计算</strong>中，而且不会让高层组件依赖低层组件<ul><li>创建一个弹性的设计，允许低层结构能够相互操作，而且又防止其他类太过依赖它们</li></ul></li><li><strong>二者都在解耦，依赖倒置原则更注重于避免依赖</strong></li></ul><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="依赖-use-a"><a href="#依赖-use-a" class="headerlink" title="依赖(use a)"></a>依赖(use a)</h2><p><img src="https://i.bmp.ovh/imgs/2022/05/11/94ce2459fc4a0dbe.png" style="zoom: 50%;"></p><p>A类只作为B类中方法的<strong>参数或返回值或局部变量或调用A的静态方法</strong></p><p>则A类与B类之间存在依赖关系</p>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B_Driver</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">(A_Car a)</span></span>{}<span class="comment">//作为方法的参数</span></span><br><span class="line">    <span class="function">A_Car <span class="title">method2</span><span class="params">()</span></span>{、</span><br><span class="line">        A_Car.method();<span class="comment">//调用静态方法</span></span><br><span class="line">        A_Car a = <span class="keyword">new</span> A_Car; <span class="comment">//作为局部变量</span></span><br><span class="line">        <span class="keyword">return</span> a; <span class="comment">//作为返回值</span></span><br><span class="line">    }</span><br><span class="line">}<span class="comment">//B依赖于A(B要用到A)</span></span><br></pre></td></tr></tbody></table></figure><p><strong>关联</strong><br><strong>A类作为B类的属性</strong>（成员变量），则A类与B类之间存在关联关系</p><h2 id="组合（整体-contains-a-部分）"><a href="#组合（整体-contains-a-部分）" class="headerlink" title="组合（整体 contains a 部分）"></a>组合（整体 contains a 部分）</h2><blockquote><p>整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期。这种关系比聚合更强，也称为强聚合。</p><p>如果<code>A</code><strong>contains a</strong> <code>B</code>，则<code>A</code>需要知道<code>B</code>的生存周期，即可能<code>A</code>负责生成或者释放<code>B</code>，或者<code>A</code>通过某种途径知道<code>B</code>的生成和释放。</p></blockquote><p><strong>组合关系也属于关联关系</strong>，A类作为B类的属性，并且在<strong>B类中包含了A类的实例化过程</strong>，则A类与B类之间存在组合关系。</p><ul><li><p>比如C类实例化B类时，B类会在构造方法中对A类进行实例化，A类与B类的产生和灭亡<strong>完全同步</strong>。组合关系下B类中的A属性不可能为null。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>{</span><br><span class="line">    <span class="keyword">new</span> B();</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">new</span> A;<span class="comment">//构造方法中对A类进行实例化</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="聚合（整体-has-a-部分"><a href="#聚合（整体-has-a-部分" class="headerlink" title="聚合（整体 has a 部分)"></a>聚合（整体 has a 部分)</h2><blockquote><p>此时整体与部分之间是可分离的，它们可以具有<strong>各自的生命周期</strong>，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。</p><p>例如，公司部门与员工的关系，一个员工可以属于多个部门，一个部门撤消了，员工可以转到其它部门。</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2022/05/11/95a2baf4660044c5.png" style="zoom:50%;"></p><p><strong>聚合关系属于关联关系</strong>，A类作为B类的属性，但<strong>A类的实例化不是在B类中实现</strong>的，则A类与B类之间存在聚合关系。</p><ul><li><p>比如在C类中实例化了A类，并将A类对象通过<strong>B类对象的set方法</strong>或B类的<strong>带参数构造器传入</strong>B中。聚合关系下B类中的A属性有可能为null。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>{</span><br><span class="line">    <span class="keyword">new</span> A();</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setXX</span><span class="params">(A)</span></span>{ XX=A};<span class="comment">//将A类对象通过B类对象的set方法传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A)</span></span>{} <span class="comment">//将A类对象通过B类的带参数构造器传入B中</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><p><img src="https://i.bmp.ovh/imgs/2022/04/11/b073f9f623e28513.png" style="zoom:50%;"></p><p>如上，<strong>使用继承</strong>来提供Duck的行为<strong>存在的缺点</strong>：</p><ul><li><strong>代码</strong>在多个子类中<strong>重复</strong><ul><li>有些子类的有些行为相同</li></ul></li><li>运行时的行为<strong>不容易改变</strong></li><li><strong>很难知道</strong>所有鸭子的全部行为<ul><li>每知道一个都要在父类中添加一个</li></ul></li><li>改变会<strong>牵一发动全身</strong>，造成不想要的改变<ul><li>比如，父类中添加一个fly，所有子类都继承fly，然而并不是所有鸭子都能fly</li></ul></li></ul><p>可见，因为<strong>鸭子的行为在子类中不断地 改变，让所有子类都拥有这些行为是不恰当的</strong></p><hr><p>那么，使用如下的接口呢？</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/ac498f3c0a5e6d15.png" style="zoom:67%;"></p><p>使用接口的话，子类的fly和quack中仍有很多重复代码，且<strong>代码无法复用</strong></p><hr><p>因为鸭子的<strong>行为是不断变化的</strong>，根据<strong>封装变化</strong>的原则，可以将鸭子的变化的行为从Duck类中<strong>抽取</strong>出来</p><ul><li>变化的行为：fly（）、quack（）；它们会<strong>随着鸭子的不同而改变</strong></li><li>把这两个行为抽取出来，<strong>建立两个新类各自代表这两个行为</strong></li></ul><p>同时，我们想要在运行时动态地改变某种鸭子的飞行行为，根据针对接口编程的原则：</p><ul><li><strong>每个接口代表每个行为</strong>，Duck类不负责实现接口，而是有<strong>行为类</strong>来实现接口</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/11/ff0a976277f80515.png" style="zoom:67%;"></p><p>这样设计，可以让这些动作被其他对象复用，因为上面<strong>这些东西实际上跟Duck类已经无关。</strong></p><p>也就是说，鸭子现在将fly和quack行为 <strong>委托给别人处理</strong>，而不是使用在Duck类或Duck的子类中的fly和quack</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><img src="https://s1.boluo.link/2022/04/11/4821dccd837d3a02f4caf03b72c999f7.png" style="zoom:67%;"></p><h2 id="策略模式定义"><a href="#策略模式定义" class="headerlink" title="策略模式定义"></a>策略模式定义</h2><p>策略模式定义了<strong>算法族、分别封装</strong>起来，让它们之间可以互相替换，此模式让算法的<strong>变化独立于</strong>算法的<strong>客户</strong></p><p>理解：</p><ul><li>定义了算法族：比如上面的实现FlyBehavior的一组行为类，这就是一个算法族，这个算法族里面的各种行为可以替换</li><li>FlyBehavior的变化和原来的Duck无关，被独立了出来</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/05/12/535f1ba33d843f5d.png" alt=""></p><ul><li><strong>Context类：</strong>它是使用算法的角色，它在解决某个问题（即实现某个方法）时可以<strong>采用多种策略</strong>。在Context类中维持一个<strong>对抽象策略类（Strategy）的引用实例</strong>，用于定义所采用的策略。</li><li><strong>Strategy（抽象策略类）：</strong>它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。Context类通过<strong>Strategy类中声明</strong>的方法 在<strong>运行时调用ConcreteStrategy类</strong>中实现的算法。</li><li><strong>ConcreteStrategy（具体策略类）：</strong>它实现了在抽象策略类中声明的算法，在运行时，具体策略类将<strong>覆盖</strong>在Context类中定义的抽象策略类对象，使用一<strong>种具体的算法实现</strong>某个业务处理。</li></ul><p>使用场景：</p><ul><li>有很多相关的类，具有不同的行为</li><li>算法有很多变种</li><li>算法使用的数据无需客户知晓</li><li>对很多行为有很多if-else语句</li></ul><p>好处</p><ul><li>提供一种替代继承的方法</li><li>去掉if-else语句</li><li>同种行为提供不同实现</li></ul><p>缺点</p><ul><li>客户应该知道所有策略</li><li>策略和Context之间的通信开销</li><li>太多策略的类</li></ul><hr><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="引例一"><a href="#引例一" class="headerlink" title="引例一"></a>引例一</h2><p>三种布告板：1.显示当前的状况、2.气象统计、3.简单预报</p><p>一个WeatherData能够<strong>追踪</strong>来自气象站的最新的<strong>数据</strong>，WeatherData会将<strong>三个布告板</strong>的显示<strong>更新</strong>。</p><p>具体流程：</p><ul><li>WeatherData有getter方法，取得来自气象站的测量值：温度、湿度、气压</li><li>一旦更新了新数据，一个measurementsChanged（）被调用<ul><li><strong>立即</strong>将三个布告板信息<strong>更新</strong></li></ul></li><li>该系统必须可货站，可以<strong>任意添加或删除</strong>任何布告板</li></ul><h2 id="引例二"><a href="#引例二" class="headerlink" title="引例二"></a>引例二</h2><p>报纸的订阅：</p><ul><li>报社出版报纸</li><li>客户向报社订阅报纸，只要报社有新报纸出版，就会送来。只要是订阅客户，就会一直收到报纸</li><li>不想看报纸，取消订阅，就不会收到报纸</li><li>只要报社孩子啊，就会有人向它订阅or取消订阅</li></ul><h2 id="出版者subject-订阅者subscriber-观察者模式"><a href="#出版者subject-订阅者subscriber-观察者模式" class="headerlink" title="出版者subject+订阅者subscriber=观察者模式"></a>出版者subject+订阅者subscriber=观察者模式</h2><h3 id="模式特点"><a href="#模式特点" class="headerlink" title="模式特点"></a>模式特点</h3><ul><li>subject管理某些数据<ul><li>subject数据改变，<strong>通知</strong>subscriber，新的数据会以某种形式送到subscriber</li></ul></li><li>subscriber（也就是observer） <strong>订阅</strong>subject，以便subject管理的数据改变时，subscriber能<strong>收到更新</strong><ul><li>如果没有订阅subject，就<strong>不是</strong>subscriber，当subject数据改变时就<strong>不会收到通知</strong></li></ul></li></ul><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>观察者模式定义了对象之间的<strong>一对多依赖</strong>，这样一来，当一<strong>个对象改变状态</strong>时，它的所有<strong>依赖者</strong>都会<strong>收到通知</strong>并且<strong>自动更新</strong>。</p><blockquote><p>一对多：这个一就是Subject，多就是Observer</p><p>实现观察者模式的方法不一种，但是以包含<strong>Subject和Observer接口</strong>的类的设计最常见</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2022/04/16/a15dc0ac0d11cc06.png" style="zoom: 50%;"></p><ul><li>主题是<strong>具有状态</strong>（真正用于数据）的对象，并且可以控制这些状态</li><li>观察者<strong>使用</strong>这些状态，<strong>依赖主题</strong>告诉观察者状态何时改变</li></ul><h2 id="松耦合的体现"><a href="#松耦合的体现" class="headerlink" title="松耦合的体现"></a>松耦合的体现</h2><ul><li>ConcreteSubject只知道ConcreteObserver实现了Observer接口<ul><li>ConcreteSubject不需要直到ConcreteObserver的具体类是谁，做了啥等等</li></ul></li><li><p>可以随时增加或删除ConcreteObserver</p><ul><li>因为<strong>ConcreteSubjectt唯一依赖</strong>的是一个实现Observer接口的 <strong>对象列表</strong></li></ul></li><li><p>当增加新的ConcreteObserver时，ConcreteSubject无需修改；</p><ul><li>只要实现Obeserver接口，注册为ConcreteObserver即可</li><li><strong>改变其中任一方，并不会影响另一方</strong></li></ul></li><li>可以独立地复用ConcreteSubject和ConcreteObserver</li></ul><hr><h2 id="引例一的实现"><a href="#引例一的实现" class="headerlink" title="引例一的实现"></a>引例一的实现</h2><p><img src="https://i.bmp.ovh/imgs/2022/04/16/b9037905c9f224df.png" style="zoom:55%;"></p><ul><li><strong>每个ConcreteObserver都有一个ConcreteSubject的引用</strong>，这样之后想要取消注册的话就会很方便</li></ul><h2 id="Java内置的观察者模式"><a href="#Java内置的观察者模式" class="headerlink" title="Java内置的观察者模式"></a>Java内置的观察者模式</h2><p><img src="https://i.bmp.ovh/imgs/2022/04/16/0dbb9471c85354fd.png" style="zoom:67%;"></p><h2 id="观察者模式使用到的原则"><a href="#观察者模式使用到的原则" class="headerlink" title="观察者模式使用到的原则"></a>观察者模式使用到的原则</h2><ul><li>找出程序中<strong>变化</strong>的方面，然后将其和固定不变的方面向<strong>分离</strong><ul><li>会改变的时主题的状态，观察者的数目和类型</li><li>采用观察者模式可以改变依赖主题状态的对象的同时 不必改变主题</li></ul></li><li><strong>针对接口编程</strong>，不针对实现编程<ul><li>主题和观察者都使用接口</li><li>观察者利用主题 的接口向主题注册</li><li>主题利用 观察者接口 通知观察者</li><li>松耦合</li></ul></li><li><strong>多用组合</strong>，少用继承<ul><li>利用 组合，将许多观察者组合进主题中</li><li>对象之间 的依赖关系不是通过继承产生，而是运行时通过组合的方式产生</li></ul></li></ul><hr><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><ul><li>不用继承 如何达到复用？<ul><li><strong>组合和委托</strong> 可以在运行时具有继承行为的结果</li><li>利用继承设计子类的行为，是在编译时静态决定的，而且所有子类都会继承到相同的行为。</li><li>如果利用<strong>组合</strong> 扩展对象的行为，就可以在运行时动态扩展</li><li>通过<strong>动态地组合对象</strong>，可以写新的代码添加新功能 且 无需修改现有代码（符合开闭原则）</li></ul></li></ul><h2 id="认识装饰者模式"><a href="#认识装饰者模式" class="headerlink" title="认识装饰者模式"></a>认识装饰者模式</h2><ul><li>例如：以“饮料”为<strong>主体</strong>，在运行时以调料来“<strong>装饰</strong>”饮料</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/a0d7fddf8d6a7266.png" style="zoom: 67%;"><img src="https://i.bmp.ovh/imgs/2022/03/b5619a2a5ba71c61.png" alt=""></p><h2 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h2><ul><li>装饰者和被装饰者：<strong>相同的超类型</strong><ul><li>在任何需要<strong>原始对象</strong>（被包装）的场合，都可以用<strong>装饰过的对象</strong>代替它</li></ul></li><li><strong>一个 or 多个</strong>装饰者 包装一个对象</li><li>对象可以在<strong>任何时候</strong>被装饰<ul><li>运行时 <strong>动态地、不限量</strong>地装饰</li></ul></li><li><font color="red">装饰者可以在<strong>所委托</strong>的被装饰者的<strong>行为</strong>之前 与/或 之后，加上自己的<strong>行为</strong>，以达到特定目的</font><ul><li>这里的行为，或者说是<strong>责任</strong>，实际上指的就是…可以实现的一些<strong>功能</strong></li></ul></li></ul><h2 id="定义装饰者模式"><a href="#定义装饰者模式" class="headerlink" title="定义装饰者模式"></a>定义装饰者模式</h2><ul><li>定义：<font color="red">动态地将<strong>责任</strong> 附加到对象上。若要扩展功能，装饰者提供了比继承更有<strong>弹性</strong>的替代方案</font></li></ul><h2 id="装饰者模式的类图"><a href="#装饰者模式的类图" class="headerlink" title="装饰者模式的类图"></a>装饰者模式的类图</h2><p><img src="https://i.bmp.ovh/imgs/2022/03/54ca5a8ca57c2592.png" alt=""></p><ul><li><p>类图分析</p><ul><li><p><strong>Component</strong>：它的引入可以使客户端以<strong>一致的方式处理</strong>未被装饰以及装饰之后的对象，实现客户端的透明操作</p><blockquote><p>客户端不知道处理的未被装饰的对象，还是装饰过的对象</p></blockquote></li><li><p><strong>ConcreteComponent</strong>：定义具体的构件，实现了Component声明的方法，ConcreteDecorator可以给它增加额外的职责</p></li><li><p>Decorator：用于给ConcreteComponent增加职责，但是具体职责在子类中实现。</p><ul><li>它<strong>维护一个指向抽象构建对象的引用</strong></li><li>通过该引用可以调用装饰之前的构件对象的方法，并通过其扩展子类的方法，达到装饰的目的。</li></ul></li></ul></li><li><p><strong>重点说明</strong></p><ul><li>看似Decorator扩展子Component类，但是，重点在于：<font color="green">装饰者和被装饰者 必须类型一致</font>，也就是<font color="green">有共同的超类</font><ul><li>换言之，就是利用继承达到“<strong>类型匹配</strong>”，而<strong>不是利用继承获得“行为”</strong></li></ul></li><li>因为装饰者<strong>必须能取代</strong>被装饰者，所以它们必须有相同的“接口”</li><li>当装饰者与组件组合时，就是在加入新的行为，所得到的新的行为，<strong>并不继承子超类，而是由组合对象得来</strong><ul><li>行为如果不是来自超类，就是子类覆盖后的版本</li><li>可以在任何时候，实现新的装饰者增加新的行为</li></ul></li></ul></li></ul><h2 id="一个栗子实现"><a href="#一个栗子实现" class="headerlink" title="一个栗子实现"></a>一个栗子实现</h2><p><img src="https://i.bmp.ovh/imgs/2022/03/34829ab9f6f28015.png" style="zoom: 67%;"></p><h3 id="首先实现最上面的抽象类Beverage"><a href="#首先实现最上面的抽象类Beverage" class="headerlink" title="首先实现最上面的抽象类Beverage"></a>首先实现最上面的抽象类Beverage</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span></span>{</span><br><span class="line">    String discription = <span class="string">"Unknown Beverage"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDiscription</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> discription;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//cost必须在子类中实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="然后实现下面的抽象类Condiment"><a href="#然后实现下面的抽象类Condiment" class="headerlink" title="然后实现下面的抽象类Condiment"></a>然后实现下面的抽象类Condiment</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩展自Beverage，这样就能取代Beverage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDiscription</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="写饮料的代码（具体组件（被装饰对象））"><a href="#写饮料的代码（具体组件（被装饰对象））" class="headerlink" title="写饮料的代码（具体组件（被装饰对象））"></a>写饮料的代码（具体组件（被装饰对象））</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span></span>{</span><br><span class="line">discription = <span class="string">"Espresso"</span>;</span><br><span class="line">    }<span class="comment">//实例变量discription继承自Beverage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="写调料代码（具体装饰者）"><a href="#写调料代码（具体装饰者）" class="headerlink" title="写调料代码（具体装饰者）"></a>写调料代码（具体装饰者）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span></span>{</span><br><span class="line">    <span class="comment">//要让Mocha引用一个Beverage</span></span><br><span class="line">    <span class="comment">//也就是之前所说的：每个装饰者都有一个组件（被装饰者），也就是说，装饰者有一个实例变量来保存某个Component的引用</span></span><br><span class="line">    Beverage beverage;</span><br><span class="line">    <span class="comment">//把饮料（被装饰者）当作构造器的参数，将其记录在实例变量中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.beverage = beverage;<span class="comment">//运行时才知道</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//利用“委托”，得到被装饰者的Discription，再附加自己的“，Mocha”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDiscription</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> beverage.getDiscription() + <span class="string">",Mocha"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//利用“委托”，得到被装饰者的cost，再加上自己的cost</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.20</span>+beverage.cost();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>装饰者模式优缺点</strong><ul><li>优：比静态继承有更多的<strong>灵活</strong>性；在<strong>高层类中防止过多特征</strong></li><li>缺：太多<strong>小类</strong>（指的是 具体的装饰者类），导致复用变得复杂</li></ul></li><li><strong>装饰者模式使用时机</strong><ul><li>需要为一个对象<strong>动态的添加责任</strong>（功能），并且<strong>不影响其他</strong>对象</li><li>处理可撤销的责任（？啥意思）</li><li>当生成子类不可行的时候，比如需要大量子类来支持各种排列组合（<strong>类爆炸</strong>）</li></ul></li><li><strong>其他要点</strong><ul><li>继承是扩展的一种形式，但 并不是获得灵活性最好的方式</li><li><strong>组合 和 委托</strong> 可以用在动态时添加新行为</li><li>装饰者类 反映了它们所装饰对象的类型（装饰者类型 <strong>==</strong> 被装饰对象类型）</li><li>可以将一个组件<strong>用任意数量</strong>的装饰者包装</li></ul></li></ul><hr><h1 id="工厂模式——创建对象"><a href="#工厂模式——创建对象" class="headerlink" title="工厂模式——创建对象"></a>工厂模式——创建对象</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><blockquote><p>简单工厂 其实不是一个设计模式，而是一种<strong>编程习惯</strong></p></blockquote><ul><li>首先，看下面的代码，可以分析出<strong>变化 和不变</strong>的部分</li><li>变化的：<strong>new出来pizza的口味</strong> (type)：比如cheesePizza，pepperoniPizza，这些pizza可能根据实际情况而不断发生改变（增加or删除某些口味）</li><li>不变的：<strong>其他制作流程</strong>：<code>prepare,bake,cut...</code></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/e91c1e95a2bb31b1.png" style="zoom: 40%;"></p><ul><li>可见，创建pizza对象的部分是不断变化的，因此可以对 <strong>对象的创建 进行封装</strong><ul><li>将<strong>创建对象</strong>的代码从<code>orderPizza()</code>中<font color="red"><strong>抽离</strong></font>出来</li><li>把抽离出来的者部分代码<font color="red"><strong>搬到另一个新的对象</strong></font><code>SimplePizzaFactory</code>中，这个新对象<strong>只管</strong>如何创建pizza</li></ul></li><li>称这个新对象 为<font color="purple"><strong>“工厂”</strong></font></li></ul><h3 id="建立一个简单披萨工厂：用于创建pizza"><a href="#建立一个简单披萨工厂：用于创建pizza" class="headerlink" title="建立一个简单披萨工厂：用于创建pizza"></a>建立一个简单披萨工厂：用于创建pizza</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span></span>{</span><br><span class="line">    <span class="comment">//所有客户都用这个createPizza方法来实例化对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>{</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//...中间则是从原来的orderPizza中抽离出来的代码</span></span><br><span class="line">        <span class="keyword">if</span>(type.equals=<span class="string">"cheese"</span>){</span><br><span class="line">pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>...</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">         <span class="keyword">return</span> pizza;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>这样做的<strong>好处</strong><ul><li><code>SimplePizzaFactory</code>可以<strong>有许多的客户</strong>，把<strong>创建pizza</strong>的代码封装到一个类里面，当以后实现改变时 (比如增加or删除某种口味的pizza)，<strong>只需要修改这一个类</strong>即可</li></ul></li></ul><h3 id="重做PizzaStore类"><a href="#重做PizzaStore类" class="headerlink" title="重做PizzaStore类"></a>重做PizzaStore类</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span></span>{</span><br><span class="line"><span class="comment">//对factory的引用</span></span><br><span class="line">    SimplePizzaFactory factory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span><span class="params">(SimplePizzaFactory factory)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.factory = factory;</span><br><span class="line">    }</span><br><span class="line">   <span class="comment">//orderPizza就成了SimplePizzaFactory的客户</span></span><br><span class="line">   <span class="comment">//意思就是 当客户orderPizza需要pizza时，就让factory做一个给它 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span>{</span><br><span class="line">        <span class="comment">//这里将原来的new出各种口味的pizza 替换成 工厂对象的创建方法 ，不再使用new具体实例化</span></span><br><span class="line">        <span class="comment">//使得orderPizza不再依赖于具体类型</span></span><br><span class="line">pizza = factory.createPizza(type);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//....后面是其他方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/73fcade61a39dfdb.png" style="zoom: 50%;"></p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote><p>内容太长不看总结版：</p><p>工厂方法模式 实际上就是，在 抽象超类 中<strong>写一个抽象</strong>（没有具体实现，只是个接口）的方法（工厂方法），它是用来<strong>创建对象</strong>的，这个超类中的<strong>其他方法</strong>会<strong>用到</strong>这个抽象方法<strong>创建的对象</strong>，但是其他方法用的时候并<strong>不关心</strong>这个对象究竟是什么类型的。</p><p>然后，继承这个超类的子类必须去<strong>实现这个抽象方法</strong>，来创建<strong>具体的对象</strong>（确定这个对象是啥类型的）</p><p>看懂 PizzaStore的框架和类图就懂辽</p></blockquote><ul><li><p>变化的是地区（风味）：比如虽说都是cheese披萨，但在不同的地区的风味不一样，有NY的cheese披萨，有Chicago的cheese披萨等等</p><blockquote><p>回顾：对比简单工厂模式，变化的是各种口味，比如cheese披萨，pepperoni披萨等等…</p></blockquote></li><li><p>我们希望：让pizza的制作活动局限于PizzaStore类（说人话：各地区加盟店pizza的制作<strong>流程固定</strong>不变），同时加盟店可以<strong>自由制作该区域的风味</strong></p></li></ul><h3 id="给PizzaStore（抽象类）使用的框架"><a href="#给PizzaStore（抽象类）使用的框架" class="headerlink" title="给PizzaStore（抽象类）使用的框架"></a>给PizzaStore（抽象类）使用的框架</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        <span class="comment">//createPizza 从工厂对象中重新移回到PizzaStore里面</span></span><br><span class="line">        pizza = createPizza(type);</span><br><span class="line">        <span class="comment">/**************************************************/</span></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="comment">/*中间是制作流程，固定不变，希望所有加盟店的处理流程都一致*/</span></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//下面这就是咱们所谓的 "工厂方法"，抽象的，</span></span><br><span class="line">    <span class="comment">//因为我们希望加盟店能够自由制作风味，</span></span><br><span class="line">    <span class="comment">//所以方法具体的实现肯定在各地区的加盟店（就是PizzaStore的子类）来实现createPizza方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>因此，将PizzaStore作为超类，每个地域的类型（NYPizzaStore、ChicagoPizzaStore…）<strong>继承</strong>PizzaStore，<strong>这样制作流程得以固定</strong>，而每个子类可以通过实现<code>createPizza</code>接口来<strong>自由决定如何制作比萨</strong></li></ul><h3 id="允许子类做决定"><a href="#允许子类做决定" class="headerlink" title="允许子类做决定"></a>允许子类做决定</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/ab9127afbb9517d2.png" style="zoom: 50%;"></p><p>超类的<code>orderPizza</code>方法<strong>并不知道</strong>正在创建的pizza是哪一种（因为人家的createPizza只是个接口）</p><p>所以在各地域的PizzaStore中分别<strong>实现</strong>各自这个createPizza接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在NYStylePizzaStore</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYStylePizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span></span>{</span><br><span class="line">    <span class="comment">//这个NYStylePizzaStore子类 全权负责实例化哪一个具体Pizza</span></span><br><span class="line">    <span class="comment">//扩展自PizzaStore，必须实现createPizza这个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(type)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"cheese"</span>)){</span><br><span class="line">            pizza = <span class="keyword">new</span> NYStyleCheesePizza();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>.... </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//在ChicagoStylePizzaStore</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoStylePizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(type)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"cheese"</span>)){</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoStyleCheesePizza();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>....</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p><code>orderPizza</code> 调用<code>createPizza</code>时，是由某个具体的<strong>披萨店子类</strong>（比如NYStyleStore..）创建披萨</p><ul><li><p><strong>子类并不是实时</strong>做出这样的决定的，但从<code>orderPizza</code>的角度来看，只要选择在<code>NYStylePizzaStore</code>订购披萨，<strong>那么就是<code>NYStylePizzaStore</code> 这个子类决定</strong></p><blockquote><p>严格来讲：并非由这个子类实际“做决定”，而是由顾客决定到哪一家的披萨店才决定了披萨的风味（听起来 嗯，听君一席话如听一席话般的废话….)</p></blockquote></li></ul></li></ul><h3 id="声明一个工厂方法"><a href="#声明一个工厂方法" class="headerlink" title="声明一个工厂方法"></a>声明一个工厂方法</h3><font color="red">工厂方法 用来**处理对象的创建**，并将这样的行为封装在子类中，这样，（好处：）客户程序中关于超类的代码 就和 子类对象创建的代码 解耦了</font><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> Product <span class="title">factoryMethod</span><span class="params">(String type)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>工厂方法 必须返回一个产品（比如pizza），而 超类中的其他方法 通常会使用到这个工厂方法的 返回值 （比如超类PizzaStore里的orderPizza中使用了返回的pizza）</li><li>工厂方法本质是一个<strong>抽象的方法</strong></li><li>理解上面红色的那段话：<ul><li>处理对象的创建：这个<strong>工厂方法就是用于创建一个对象</strong>的</li><li>并将这样的行为封装在子类中：因为工厂方法是抽象的，必须由<strong>子类来具体实现该方法</strong>，</li><li>客户程序中关于超类的代码：就是<strong>超类</strong>中的代码，比如<code>PizzaStore</code>中的<code>orderPizza</code></li><li>子类对象创建的代码：也就是实际了创建<strong>具体产品</strong>的代码，比如子类<code>NYStylePizzaStore</code>里面的<code>createPizza</code>创建产品</li><li>”解耦“ 的理解：在PizzaStore中，<code>orderPizza</code>对Pizza做了很多事(bake,cut等等)，但是Pizza是抽象的，<code>orderPizza</code><strong>并不知道实际哪些具体的类</strong>参与了进来，也就是 我们实现了<strong>面向抽象编程 而不是面向具体编程</strong></li></ul></li></ul><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><ul><li>关键把下面这张图的思路看懂</li></ul><h3 id="Pizza本身（抽象类）"><a href="#Pizza本身（抽象类）" class="headerlink" title="Pizza本身（抽象类）"></a>Pizza本身（抽象类）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span></span>{</span><br><span class="line">    String name;</span><br><span class="line">    String dough;</span><br><span class="line">        ....</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>{.....}</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>{....}</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>{....}</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>{.....}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体的Pizza子类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYStyleCheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NYStyleCheesePizza</span><span class="params">()</span></span>{</span><br><span class="line">name=<span class="string">"xx"</span>;dough=<span class="string">"xx"</span>;....</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>{<span class="comment">/*可以覆盖抽象类的方法*/</span>}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="这个栗子的类图"><a href="#这个栗子的类图" class="headerlink" title="这个栗子的类图"></a>这个栗子的类图</h3><ul><li>所有工厂模式 都是用来<strong>封装对象的创建</strong>，<strong>工厂方法模式</strong><font color="red">通过让<strong>子类决定该创建的对象</strong>是什么，来达到<strong>对象创建的过程封装</strong>的目的</font></li></ul><p><a href="https://imgtu.com/i/q3SWxP"><img src="https://s1.ax1x.com/2022/03/23/q3SWxP.png" alt="q3SWxP.png" style="zoom:50%;"></a></p><ul><li>从<strong>平行的类层级</strong>角度来看</li></ul><p><a href="https://imgtu.com/i/q3puIH"><img src="https://s1.ax1x.com/2022/03/23/q3puIH.png" alt="q3puIH.png" style="zoom:50%;"></a></p><h3 id="重点-定义工厂方法模式-类图（Factory-Method-Pattern）"><a href="#重点-定义工厂方法模式-类图（Factory-Method-Pattern）" class="headerlink" title="* 重点 * 定义工厂方法模式+类图（Factory Method Pattern）"></a>* 重点 * 定义工厂方法模式+类图（Factory Method Pattern）</h3><ul><li><p><strong>工厂方法模式</strong>：定义了一个<strong>创建对象</strong>的接口，但由<strong>子类决定要实例化的类</strong>是哪一个。工厂方法让类把<strong>实例化推迟到子类</strong></p><blockquote><p>理解：比如之前的栗子中，PizzaStore（超类）定义了一个<strong>抽象的接口</strong><code>createPizza</code>，它只是一个接口！！！我们只知道这个接口的目的是  告诉大家创建一个Pizza，但并没有实现！！！！</p><p>而Pizza具体怎么创建（即：new出来的Pizza究竟是啥类型的Pizza）就需要继承PizzaStore的<strong>子类</strong>来<strong>实现</strong>这个接口。</p><p>即：<code>NYStylePizzaStore</code>类中的<code>createPizza()</code>方法里面的 比如这句代码 <code>pizza = new NYStyleCheesePizza();</code> 才将Pizza给实例化成一个具体的<code>NYStyleCheesePizza</code></p></blockquote></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/281e12be43dbaa9e.png" style="zoom: 67%;"></p><ul><li><p>所谓<strong>“决定”</strong>，指的是 在编写创建者类（Creator）时，<strong>不需要知道实际创建的产品具体是啥</strong>。</p><blockquote><p>比如之前PizzaStore里面调用pizza.cut()，pizza.bake()等等，我们不需要知道这个pizza究竟哪种口味的pizza</p></blockquote></li><li><p>选择了<strong>使用哪个子类</strong>，自然就决定了实际创建的产品是什么</p><blockquote><p>因为我们的子类 把 工厂方法createPizza给具体实现了</p></blockquote></li><li><p>当只有一个ConcreteCreator时：工厂方法模式 能够将产品的<strong>“实现”</strong> 从<strong>“使用”</strong>中解耦，增加or改变产品的实现 Creator也不会受影响</p><blockquote><p>这里的“实现”，也就是 产品的创建</p></blockquote></li><li><p>工厂方法 和创建者 <strong>并不总是抽象</strong></p><ul><li>可以定义一个 默认的工厂方法 来生产某些具体的产品，这样即使创建者没有任何子类，依然可以创建产品（这是书上说的，？我暂时无法理解）</li></ul></li><li><p><font color="red">简单工厂和工厂方法的差异</font>：</p><ul><li>简单工厂 <strong>把全部的事情</strong>（比如创建不同口味的pizza）在<strong>一个地方</strong>处理完了（这个地方就是之前的SimplePizzaFactory）<ul><li>简单工厂可以将对象的创建 封装起来，但不具备工厂方法的弹性：简单工厂不能变更在创建的产品</li></ul></li><li>工厂方法，就是<strong>创建一个框架</strong>（抽象的方法），让子类决定如何实现（实现这个抽象方法）<ul><li>比如：超类PizzaStore里面的orderPizza提供了一般的框架；orderPizza以工厂方法createPizza来创建具体类，制造出实际的pizza</li></ul></li></ul></li><li><p>”工厂“ 的<strong>好处</strong></p><ul><li>避免代码重复，方便维护</li><li>客户在实例化对象时，<strong>只依赖接口</strong>，而不是具体类</li><li>代码更有<strong>弹性</strong>，应对未来的扩展</li></ul></li></ul><h3 id="对象依赖（依赖倒置原则）"><a href="#对象依赖（依赖倒置原则）" class="headerlink" title="对象依赖（依赖倒置原则）"></a>对象依赖（依赖倒置原则）</h3><ul><li><p>看下图代码，<code>DependentPizzaStore</code>这个<strong>类</strong>里面的<strong>一些方法的实现</strong> 需要<strong>用到</strong> 很多<strong>其他具体的类</strong>，即所说它 <strong>依赖</strong> 于其他具体的类</p><blockquote><p>比如 要实现createPizza，就需要使用各种具体的Pizza类，比如NYStyleCheesePizza等等；</p><p>所以坏就坏在，只要它DependentPizzaStore所依赖的这些具体的类有啥改动，就必须把DependentPizzaStore这个的代码翻出来进行改动</p></blockquote></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/b9c50c1050280077.png" style="zoom:50%;"></p><font color="red">**依赖倒置原则**：要依赖**抽象**，不要依赖具体类</font><ul><li><p>不能让高层组件依赖 低层组件，而且不管高低层，都应该<strong>依赖于抽象</strong></p><blockquote><p>高层组件：由<strong>其他低层组件</strong>定义其行为的类。比如PizzaStore是高层组件，它的行为是由Pizza定义的，（PizzaStore创建所有不同的Pizza对象）而Pizza本身是低层组件</p></blockquote></li></ul><p>一个PizzaStore可以制作不同类型的Pizza，这些不同类型的Pizza都是Pizza，所以可以让它们<strong>共享同一个Pizza接口</strong>，那么我们 就抽象出了一个Pizza类，而对于PizzaStore来讲，它只要制作出Pizza就行了，不用理会具体的Pizza类</p><p><img src="https://i.bmp.ovh/imgs/2022/03/6cd322f7cd1a5208.png" style="zoom:67%;"></p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote><p>首先，抛开前面的东西，现在的栗子虽然和上面都是采用Pizza，但是跟上面的那些东西毫无关系，不要把这个栗子和之前的栗子关联起来</p></blockquote><ul><li>每个不同的地区有不同的加盟店，每个加盟店都要制作Pizza，但是对于某一种比如cheese Pizza，虽然都是cheese Pizza，但是在不同加盟店<strong>所使用的原料的具体种类并不完全相同</strong>。</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/890301e4a420a3f1.png" style="zoom: 67%;"></p><h3 id="首先，建造出抽象出来的原料工厂"><a href="#首先，建造出抽象出来的原料工厂" class="headerlink" title="首先，建造出抽象出来的原料工厂"></a>首先，建造出抽象出来的原料工厂</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Clams <span class="title">createClam</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">}<span class="comment">//原料工厂都需要生产Dough、Sauce等等，但具体生产的啥Dough，啥Sauce 就用子类来实现</span></span><br></pre></td></tr></tbody></table></figure><ul><li>这个抽象的原料工厂（<strong>接口</strong>） 其实就相当于提供了一个大致的框架，每个区域的工厂（<strong>实现接口的类</strong>）把这个框架给具体实现</li><li>所以，接下来</li><li>为每个区域<strong>创建一个具体</strong>的工厂，<strong>继承</strong>自这个<code>PizzaIngredientFactory</code>，具体<strong>实现每一个</strong>create方法</li></ul><h3 id="创建纽约原料工厂"><a href="#创建纽约原料工厂" class="headerlink" title="创建纽约原料工厂"></a>创建纽约原料工厂</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaIngredientFactory</span> <span class="keyword">implements</span> <span class="title">PizzaIngredientFactory</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThinCrustDough(); <span class="comment">//这个具体的原料工厂生产的Dough就是ThinCrustDough</span></span><br><span class="line">        <span class="comment">//要有一组原料类供工厂使用，这些类可以在合适的区域共享，</span></span><br><span class="line">        <span class="comment">//比如在NY可以使用ThinCrustDough，在Chicago也可以使用ThinCrustDough</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MarinaraSauce();</span><br><span class="line">    }</span><br><span class="line">    ...<span class="comment">//同理，下面是其他的实现的接口方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="重做Pizza"><a href="#重做Pizza" class="headerlink" title="重做Pizza"></a>重做Pizza</h3><h4 id="抽象的Pizza"><a href="#抽象的Pizza" class="headerlink" title="抽象的Pizza"></a>抽象的Pizza</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span></span>{</span><br><span class="line">    <span class="comment">//每个pizza都持有一组在prepare时会用到的原料</span></span><br><span class="line">    Dough dough;</span><br><span class="line">    Sauce sauce;....</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="具体的Pizza"><a href="#具体的Pizza" class="headerlink" title="具体的Pizza"></a>具体的Pizza</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>{</span><br><span class="line">    PizzaIngredientFactory ingredientFactory;</span><br><span class="line">    <span class="comment">//要制作Pizza，必须要一个工厂来提供原料，所以每个Pizza都要获得一个工厂</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span><span class="params">(PizzaIngredientFactory ingredientFactory)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//prepare一步步制作Pizza，每当使用原料，就从工厂要</span></span><br><span class="line">        dough = ingredientFactory.createDough();</span><br><span class="line">        sauce = ingredientFactory,createSauce();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Pizza店"><a href="#Pizza店" class="headerlink" title="Pizza店"></a>Pizza店</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NewYork的Pizza店</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Pizza <span class="title">createPizza</span><span class="params">(String item)</span></span>{</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>; </span><br><span class="line">        <span class="comment">//这家店由NewYork的原料工厂负责生产所有原料</span></span><br><span class="line">        PizzaIngredientFactory = <span class="keyword">new</span> NYPizzaIngredientFactory();</span><br><span class="line">        <span class="keyword">if</span>(items.equals(<span class="string">"cheese"</span>)){</span><br><span class="line">            <span class="comment">//将工厂传递给每个Pizza，Pizza从工厂中获取原料</span></span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> ...</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.bmp.ovh/imgs/2022/03/ed29a07c1bd29a7d.png" style="zoom: 67%;"></p><h3 id="总体实现"><a href="#总体实现" class="headerlink" title="总体实现"></a>总体实现</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PizzaStore nyPizzaStore = <span class="keyword">new</span> NYPizzaStore();<span class="comment">//要有一个NY的pizza店</span></span><br><span class="line">nyPizzaStore.orderPizza(<span class="string">"cheese"</span>);<span class="comment">//在店里店一个cheese Pizza</span></span><br><span class="line">Pizza pizza = createPizza(<span class="string">"cheese"</span>);<span class="comment">//orderPizza调用createPizza</span></span><br><span class="line"><span class="comment">//传入的参数是cheese，所有要生产一个cheesePizza，需要具体的原料工厂</span></span><br><span class="line">Pizza pizza = <span class="keyword">new</span> CheesePizza(nyIngredientFactory);</span><br><span class="line"><span class="comment">//pizza获得工厂后，pizza.prepare()就开始准备原料</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>{</span><br><span class="line">dough = factory.createDough();</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        }</span><br><span class="line"><span class="comment">//之后 pizza.bake(),cut()....</span></span><br></pre></td></tr></tbody></table></figure><h3 id="※-定义抽象工厂模式-类图"><a href="#※-定义抽象工厂模式-类图" class="headerlink" title="※ 定义抽象工厂模式+类图"></a>※ 定义抽象工厂模式+类图</h3><font color="red">抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类</font><p><img src="https://i.bmp.ovh/imgs/2022/03/2cde0ebb92239b6e.png" style="zoom:67%;"></p><p><img src="https://i.bmp.ovh/imgs/2022/03/40a969dfb82c50dc.png" style="zoom:67%;"></p><ul><li><p><strong>抽象工厂</strong>的方法 经常以<strong>工厂方法</strong>的形式实现</p><blockquote><p>理解：PizzaIngredientFactory里的所有create方法都是抽象的，没有具体实现，而是每个继承它的子类覆盖实现这些方法</p></blockquote></li></ul><h2 id="三种工厂模式的比较"><a href="#三种工厂模式的比较" class="headerlink" title="三种工厂模式的比较"></a>三种工厂模式的比较</h2><h3 id="三种类图对比总结"><a href="#三种类图对比总结" class="headerlink" title="三种类图对比总结"></a>三种类图对比总结</h3><ul><li>简单工厂：<strong>用来生产 同一等级结构中的任意产品（对于新加的产品，无能为力）</strong></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/355f4b3aa8a92aac.png" style="zoom:50%;"></p><ul><li><p>工厂方法：<strong>用来生产同一等级结构的固定产品（支持增加任意产品）</strong></p><p><img src="https://i.bmp.ovh/imgs/2022/03/3eb03ec2dbe04f8c.png" style="zoom:50%;"></p></li><li><p>抽象工厂：<strong>用来生产不同产品族的全部产品</strong>（对于新增加的产品，无能为力，支持增加产品族）</p></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/fac2ed68e7d0b475.png" style="zoom:50%;"></p><h3 id="抽象工厂-VS-工厂方法"><a href="#抽象工厂-VS-工厂方法" class="headerlink" title="抽象工厂 VS 工厂方法"></a>抽象工厂 VS 工厂方法</h3><ul><li><p>共同点：都是用来 <strong>创建对象</strong>的，把客户从所使用的具体实际产品中解耦</p></li><li><p>不同点</p><ul><li><p>工厂方法使用<strong>继承</strong></p><blockquote><p>利用工厂方法创建对象，需要扩展（继承）一个类，并覆盖它的工厂方法；</p></blockquote></li><li><p>抽象工厂：使用<strong>对象组合</strong>；使用时机：<strong>创建产品家族&amp;让制造的相关产品结合起来</strong></p><blockquote><p>它可以把<strong>一群相关的产品集合</strong>起来：</p><p>抽象工厂 提供一个用来创建<strong>一个产品家族</strong>的抽象类型，它的子类定义了具体产品实现</p></blockquote></li></ul></li></ul><hr><h1 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h1><ul><li><p>用来创建独一无二的，<strong>只能有一个实例</strong>的对象</p><blockquote><p>因为，<strong>有些对象我们只需要一个</strong>，如果制造多个会导致许多问题</p><p>可以确保程序中使用的全局资源只有一份，对资源敏感的对象特别重要</p></blockquote></li><li><p>单件模式可以确保<strong>只有一个示例</strong>被创建，并且可以在<strong>需要时</strong>才创建</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line"><span class="comment">// 利用静态变量 来记录这个 唯一的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">// 声明为私有：只有Singleton类内才可以调用它</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{};</span><br><span class="line">    <span class="comment">// 利用静态方法来实例化这个唯一的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>){</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>调用<code>Singleton</code>里面的静态方法：<code>Singleton.getInstance()</code></p><blockquote><p>getInstance()：静态方法，也就是类方法；对静态方法的调用要使用类名 </p></blockquote></li><li><p><strong>延迟实例化</strong>：如果不需要这个实例，它就永远不会产生</p></li><li><p>要想取得<code>Singleton</code>的一个实例，我们必须”请求“得到这么一个实例，而不是自行new 一个<code>Singleton</code>出来，（反正也new不出来，因为构造器是private）。所以我们可以，调用静态方法<code>getInstance</code>来请求得到 这个类的实例，这相当于一个<strong>全局访问点</strong></p><ul><li>从上面的代码易知：这个实例可能是在这次调用的时候被创建出来的，也可能是之前已经创建出来的。反正它只有一个</li></ul></li></ul><h2 id="一个栗子-1"><a href="#一个栗子-1" class="headerlink" title="一个栗子"></a>一个栗子</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChocolateBoiler</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChocolateBoiler uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> empty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> boiled;</span><br><span class="line">    <span class="keyword">private</span> ChocolateBoiler{</span><br><span class="line">         empty = <span class="keyword">true</span>;</span><br><span class="line">         boiled = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChocolateBoiler <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>){</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> ChocolateBoiler();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 其他方法(){...}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定义单件模式"><a href="#定义单件模式" class="headerlink" title="定义单件模式"></a>定义单件模式</h2><font color="red">单件模式：确保一个类中只有一个实例，并提供一个全局访问点</font><p><img src="https://i.bmp.ovh/imgs/2022/03/a1995c3b195e07d2.png" style="zoom:50%;"></p><p>但是上面这种经典的单件模式在多线程的情况下会出现问题</p><p><img src="https://i.imgtg.com/2022/03/25/bDb6c.png" alt="bDb6c.png"></p><p>对于多线程的处理：把<code>getInstance()</code>变成<strong>同步方法</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{...}</span><br></pre></td></tr></tbody></table></figure><ul><li>这样，可以迫使每个线程进入该方法之前，需要等待别的线程离开该方法，保证不会有两个线程同时进入该方法</li><li>但是，只有在new uniqueInstance的时候才需要同步，所以这会拖垮性能</li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="getInstance的性能不是很关键，就不用解决"><a href="#getInstance的性能不是很关键，就不用解决" class="headerlink" title="getInstance的性能不是很关键，就不用解决"></a>getInstance的性能不是很关键，就不用解决</h4><ul><li>但如果<code>getInstance</code>使用在程序频繁运行的地方，就必须解决，否则运行效率会大幅下降</li></ul><h4 id="“急切”创建实例，而不用延迟实例化的做法"><a href="#“急切”创建实例，而不用延迟实例化的做法" class="headerlink" title="“急切”创建实例，而不用延迟实例化的做法"></a>“急切”创建实例，而不用延迟实例化的做法</h4><ul><li><p>如果总是创建并使用单件实例or在创建和运行时负担不繁重，可以急切创建此单件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line">    <span class="comment">//JVM在加载这个类的时候马上创建唯一的单件实例（静态初始化实例）</span></span><br><span class="line">    <span class="comment">//保证在任何线程访问uniqueInstance之前，一定先创建了它</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{};</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="双重检查加锁"><a href="#双重检查加锁" class="headerlink" title="双重检查加锁"></a>双重检查加锁</h4><ul><li><strong>首先检查</strong>实例是否已经创建，若<strong>未创建，才进行同步</strong>–&gt;保证只有第一次同步</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 检查实例，如果未创建，就进行同步</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>){</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class){ <span class="comment">//再检查一次</span></span><br><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>){</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="命令模式——封装调用"><a href="#命令模式——封装调用" class="headerlink" title="命令模式——封装调用"></a>命令模式——封装调用</h1><blockquote><p>刚学这个模式的时候狠狠地难受到了，一开始始终理不清书上餐厅点餐和遥控器这个两个栗子的相通点，看了两遍书才看明白，啊啊啊啊，本 一学就废 的fw真的好羡慕世界上那些理解能力超强 一学就会 的人呐QAQ </p></blockquote><h2 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h2><ul><li><p>遥控器栗子：</p><p><img src="https://i.bmp.ovh/imgs/2022/03/fa998e3329087c97.png" style="zoom: 50%;"></p></li></ul><ul><li><p>请求者：<strong>遥控器</strong>；执行者：<strong>某个家电</strong></p></li><li><p>命令对象：封装的东西–&gt;  家电的具体的执行工作+家电</p><blockquote><p>比如，遥控器想要打开电灯，那么就把“电灯+电灯的打开动作“，<strong>封装</strong>成一个请求对象，也就是我们所说的“<strong>命令对象</strong>”；</p><p>换种理解方式就是：一个<strong>命令对象</strong> 封装了 命令的执行者（也就是<strong>“谁执行”</strong>）+执行者的执行动作（也就是<strong>“具体怎样执行”</strong>）</p><p>遥控器的<strong>每个按钮插槽都存储一个命令对象</strong>，只要按下，命令对象就执行封装在它里面的工作</p></blockquote></li><li><p>用一个餐厅的栗子来对比</p></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/7ef5a0a9067296db.png" style="zoom:50%;"></p><ul><li>命令模式 可以将<strong>“动作的请求者” 从“动作的执行者”</strong> 对象中解耦</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/b60131071f364eb0.png" style="zoom: 67%;"></p><h2 id="第一个命令对象"><a href="#第一个命令对象" class="headerlink" title="第一个命令对象"></a>第一个命令对象</h2><ul><li>为<strong>所有命令声明一个接口</strong>，只要命令execute，就可以让命令的接收者执行动作</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>首先实现一个打开电灯的<strong>命令</strong> (这个<code>LightOnCommand</code>命令就是一个<strong>命令对象</strong>)<ul><li>它封装了<strong>执行者<code>light</code>+具体动作<code>light.on()</code></strong>)</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    Light light;</span><br><span class="line">    <span class="comment">//传入执行“开灯”命令的执行者light </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//一旦调用，就由这个light接受命令，执行动作</span></span><br><span class="line">    <span class="comment">//execute封装了 执行命令的 执行者 所要执行的所有动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{</span><br><span class="line">        light.on();        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>使用</strong>命令对象（先假设遥控器上只有一个插槽</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRemoteControl</span></span>{</span><br><span class="line">    Command slot；<span class="comment">//一个插槽持有一个命令对象 用来控制一个设备</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRemoteControl</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="comment">//设置该插槽 持有的命令是什么；</span></span><br><span class="line">    <span class="comment">//比如传入ligthOn，就让这个插槽持有“开灯”这个命令，那么我按这个按钮，就是开灯，</span></span><br><span class="line">    <span class="comment">//如果传入lightOff，那么这个插槽就持有“关灯”这个命令，我按这个按钮，就变成了关灯；</span></span><br><span class="line">    <span class="comment">//所以可以传入不同的命令，实现按下当前按钮，执行不同的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span></span>{</span><br><span class="line">        slot = command;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//一旦按下按钮（发出请求），插槽持有的命令就可以执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buttonWasPressed</span><span class="params">()</span></span>{</span><br><span class="line">        slot.execute();</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个测试 就是命令模式的客户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControlTest</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        SimpleRemoteControl remote = <span class="keyword">new</span> SimpleRemoteControl();</span><br><span class="line">        <span class="comment">//new出来的这个light 就是请求的接收者(真正执行这个命令的东西)</span></span><br><span class="line">        Light light = <span class="keyword">new</span> light();</span><br><span class="line">        <span class="comment">//客户负责创建一个具体的命令对象，同时要设置这个命令的接收者</span></span><br><span class="line">        <span class="comment">//相当于：顾客下了一个订单，</span></span><br><span class="line">        LightOnCommand lightOn = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line">        <span class="comment">//remote就相当于服务员，服务员一天能接受很多很多的订单，相当于setComand可以接受不同的参数；此刻，当下，传入lightOn这个参数，代表服务员接受了lightOn这个订单</span></span><br><span class="line">        remote.setCommand(lightOn);</span><br><span class="line">        <span class="comment">//然后服务员知道所有订单都支持buttonWasPressed这个方法，一旦有订单，也就是有了一个命令，这个命令的执行只需要按一下按钮就彻底执行完毕了</span></span><br><span class="line">        remote.buttonWasPressed();</span><br><span class="line">        <span class="comment">//只要buttonWasPressed，这个button绑定的命令就立马执行</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定义命令模式"><a href="#定义命令模式" class="headerlink" title="定义命令模式"></a>定义命令模式</h2><font color="red">命令模式：将“请求”封装成对象，以便使用不同的请求、队列、或者日志来参数化其他对象。命令模式也支持可撤销的操作</font><ul><li>理解<ul><li>参数化：比如遥控器的一个插槽，可以用 不用的请求(也就是命令) 当参数<code>remote.setCommand(参数)</code></li></ul></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/1bbbc28bdd1b10d9.png" style="zoom: 67%;"></p><ul><li>遥控器除了在按下按钮时，调用这个按钮对应的命令对象的execute方法之外<strong>其他什么都不知道</strong></li><li>当遥控器有两个按钮，希望可以控制客厅和厨房的电灯时，因为<strong>命令对象里可以封装这个命令的接收者</strong>，所以只需要创建两个LightCommand命令，一个绑定客厅的电灯，一个绑定厨房的电灯，按钮一按下，各自的execute就执行</li></ul><h3 id="将命令指定到插槽"><a href="#将命令指定到插槽" class="headerlink" title="将命令指定到插槽"></a>将命令指定到插槽</h3><ul><li>遥控器每个插槽 对应一个命令，当按下按钮，相应命令对象的execute就会被调用，execute方法中命令的接收者（家电）的动作就会被调用（具体见下列代码）</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span></span>{</span><br><span class="line">    Command[] onCommands;</span><br><span class="line">    COmmand[] offCommands;</span><br><span class="line">    <span class="keyword">public</span> RemoteControl{</span><br><span class="line">        onCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        offCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        COmmand noCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++){</span><br><span class="line">            onCommands[i] = noCommand;</span><br><span class="line">            offCommands[i] = noCommand;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> slot,Command onCommand,Command offCommand)</span></span>{</span><br><span class="line">        onCommands[slot] = onCommand;</span><br><span class="line">        offCOmmands[slot] = offCommand;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//调用下列方法就相当于按下按钮，那么这个按钮插槽绑定了的一个命令对象就会执行execute</span></span><br><span class="line">    <span class="comment">//这个命令对象就存储在onCommands[slot]</span></span><br><span class="line">    <span class="comment">//所调用的execute方法里面就写了 命令的执行者和执行者的动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span></span>{</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span></span>{</span><br><span class="line">        offCommands[slot].execute();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实现命令"><a href="#实现命令" class="headerlink" title="实现命令"></a>实现命令</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(Light light)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{</span><br><span class="line">        light.off();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>NoCommand是一个<strong>空对象</strong>——什么事都不做：当不想返回一个有意义的对象就可以使用。</li><li>也可以将处理null的责任转移给空对象</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{}  <span class="comment">//实现一个什么都不做的命令</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteLoader</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line">        <span class="comment">//首先，创建所有的家电</span></span><br><span class="line">        Light livingRoomLight = <span class="keyword">new</span> Light(<span class="string">"Living Room"</span>);</span><br><span class="line">        <span class="comment">//...创建其他家电...</span></span><br><span class="line">        <span class="comment">//创建所有家电的命令对象</span></span><br><span class="line">        LightOnCOmmand livingRoomLightOn = <span class="keyword">new</span> LightOnCommand(livingRoomLight);</span><br><span class="line">        <span class="comment">//...创建其他命令对象...</span></span><br><span class="line">        <span class="comment">//将创建完的命令对象加载到遥控器插槽中</span></span><br><span class="line">        remoteControl.setCommand(<span class="number">0</span>,livingRommLightOn,livingRoomLightOff);</span><br><span class="line">        <span class="comment">//...其他...</span></span><br><span class="line">        <span class="comment">//上述准备完毕，按下每个插槽的开关按钮就行</span></span><br><span class="line">        remoteControl.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        remoteControl.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//...按下其他开关按钮...  </span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/71c71a9f6056631a.png" style="zoom: 67%;"></p><h2 id="实现撤销"><a href="#实现撤销" class="headerlink" title="实现撤销"></a>实现撤销</h2><ul><li>撤销最近的那个动作</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>实现具体类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{</span><br><span class="line">        light.on();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>{</span><br><span class="line">        light.off();<span class="comment">//execute是打开，所以undo该是关闭</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>修改遥控器类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControlWithUndo</span></span>{</span><br><span class="line">    Command[] onCommands;</span><br><span class="line">    Command[] offCommands;</span><br><span class="line">    Command undoCommand; <span class="comment">//加入undoCommand这个实例变量，用来追踪最后被调用的命令</span></span><br><span class="line">    <span class="comment">//不管何时撤销按钮被按下，都可以取出这个命令（在执行撤销命令之前的最后那个非撤销命令）并调用它undo方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteControlWithUndo</span><span class="params">()</span></span>{</span><br><span class="line">        onCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        offCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        Command noCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++){</span><br><span class="line">            OnCommands[i] = noCommand;</span><br><span class="line">            OffCommands[i] = noCommand;</span><br><span class="line">        }</span><br><span class="line">        undoCommand = noCommand;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> slot,Command onCommand,Command offCommand)</span></span>{</span><br><span class="line">        onCommands[slot] = onCommand;</span><br><span class="line">        offCommands[slot] = offCommand;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span></span>{</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">        undoCommand = onCommands[slot];<span class="comment">//当按下当前按钮时，记录当前按钮绑定的命令 到undoCommand中</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoButtonWasPushed</span><span class="params">()</span></span>{</span><br><span class="line">        undoCommand.undo(); <span class="comment">//当按下撤销按钮时，可以撤销最近的一个命令</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="使用状态实现撤销"><a href="#使用状态实现撤销" class="headerlink" title="使用状态实现撤销"></a>使用状态实现撤销</h2><ul><li>吊扇允许<strong>多种转速</strong>，允许被关闭</li><li>在吊扇的命令类中加入“撤销” ：实现追踪吊扇的<strong>最后设置的速度</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CeilingFanHighCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    CeilingFan ceilingFan;</span><br><span class="line">    <span class="keyword">int</span> prevSpeed;  <span class="comment">//这就是增加的状态，来追踪吊扇之前的速度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CeilingFanHighCommand</span><span class="params">(CeilingFan ceilingFan)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.ceilingFan = ceilingFan;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{</span><br><span class="line">        prevSpeed = ceilingFan.getSpeed();<span class="comment">//在改变吊扇速度之前，先保存速度</span></span><br><span class="line">        ceilingFan.high();</span><br><span class="line">    }</span><br><span class="line">    <span class="function">pubilc <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(prevSpeed  == CeilingFan.HIGH){</span><br><span class="line">            ceilingFan.high();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(prevSpeed == CeilingFan.Medium){</span><br><span class="line">            ceilingFan.medium();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(prevSpeed == CeilingFan.LOW){</span><br><span class="line">            ceilingFan.low();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(prevSpeed == CeilingFan.OFF){</span><br><span class="line">            ceilingFan.off();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteLoader</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        RemoteControlWithUndo remoteControl = <span class="keyword">new</span> RemoteControlWithUndo();</span><br><span class="line">        CeilingFan ceilingFan = <span class="keyword">new</span> CeilingFan(<span class="string">"Living Room"</span>);</span><br><span class="line">        CeilingFanHighCommand ceilingFanHigh = <span class="keyword">new</span> CeilingFanHighCommand(ceilingFan);</span><br><span class="line">        <span class="comment">//..同理，再创建一个中速命令（省略）</span></span><br><span class="line">        remoteControl.setCommand(<span class="number">1</span>,ceilingFanHigh,ceilingFanOff);</span><br><span class="line">        <span class="comment">//..先开启中速度，然后关闭</span></span><br><span class="line">        remoteControl.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        remoteControl.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        remoteControl.undoButtonWasPushed();<span class="comment">//撤销，回到中速</span></span><br><span class="line">        remoteControl.onButtonWasPushed(<span class="number">1</span>);<span class="comment">//开启高速</span></span><br><span class="line">        remoteControl.undoButtonWasPushed();<span class="comment">//撤销高速，回到中速</span></span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果希望能够按下按钮多次，撤销很早以前的状态，就可以使用一个<strong>堆栈</strong>记录操作命令的每一个过程；一旦按下撤销按钮，就可以从堆栈中取出最上层的命令，调用undo方法</li></ul><h3 id="使用宏命令"><a href="#使用宏命令" class="headerlink" title="使用宏命令"></a>使用宏命令</h3><ul><li><p>我们想要在不改变遥控器的情况下，只按一个按钮，就能控制所有装置（同时打开电灯、电视等等）</p></li><li><p>宏命令</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    Command[] commands;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MacroCommand</span><span class="params">(Command[] commands)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.commands = commands;<span class="comment">//宏命令存储一堆命令</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{ <span class="comment">//宏命令执行时，数组存储的命令一次性全部执行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;commands.length();i++){</span><br><span class="line">        commands[i].execute();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//当然也可以撤销，按下撤销按钮，宏命令内所有命令都被撤销</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;commands.length();i++){</span><br><span class="line">            commands[i].undo();</span><br><span class="line">        } </span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>首先，创建想要进入宏的命令集合</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建所有装置</span></span><br><span class="line">Light light = <span class="keyword">new</span> Light(<span class="string">"Living Room"</span>);</span><br><span class="line">TV tv = <span class="keyword">new</span> TV(<span class="string">"Living Room"</span>);</span><br><span class="line"><span class="comment">//创建所有on命令</span></span><br><span class="line">LightOnCommand lightOn = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line">TVOnCommand tvOn = <span class="keyword">new</span> TVOnCommand(tv);</span><br><span class="line"><span class="comment">//...创建所有off命令...</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>创建两个数组，一个记录所有开启命令，一个记录所有关闭命令</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Command[] partyOn = {lightOn,tvOn};</span><br><span class="line">Command[] partyOff = {lightOff,tvOff};</span><br><span class="line"><span class="comment">//创建对应的宏持有这两个数组</span></span><br><span class="line">MacroCommand partyOnMarcro = <span class="keyword">new</span> MacroCommand(partyOn);</span><br><span class="line">MacroCommand partyOffMacro = <span class="keyword">new</span> MacroCommand(partyOff);</span><br></pre></td></tr></tbody></table></figure></li><li><p>将宏命令指定给按钮</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remoteControl.setCommand(<span class="number">0</span>,partyOnMacro,partyOffMacro);</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="命令模式的更多用途：队列请求"><a href="#命令模式的更多用途：队列请求" class="headerlink" title="命令模式的更多用途：队列请求"></a>命令模式的更多用途：队列请求</h2><p>老师没讲，暂时不看</p><h2 id="命令模式的更多用途：日志请求"><a href="#命令模式的更多用途：日志请求" class="headerlink" title="命令模式的更多用途：日志请求"></a>命令模式的更多用途：日志请求</h2><p>老师没讲，暂时不看</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>命令模式</strong>将 <strong><u>发出请求的对象</u></strong> 和 <strong><u>执行请求的对象</u></strong>解耦</li><li>发出请求的对象和执行请求的对象 通过 <strong><u>命令对象</u></strong> 沟通</li><li>命令对象 <strong>封装</strong>了 <strong><u>命令的接收者</u></strong> 和 <u><strong>一个or一组动作</strong></u></li><li>调用命令对象的<code>excute()</code>发出请求，接收者的<strong>动作被调用</strong></li></ul><hr><h1 id="适配器模式与外观模式"><a href="#适配器模式与外观模式" class="headerlink" title="适配器模式与外观模式"></a>适配器模式与外观模式</h1><blockquote><p>包装某些对象，让它们的接口看起来不像自己 而是像别的东西；</p><p>这样就可以在设计中，将类的接口转换成想要的接口，以便实现不同的接口</p></blockquote><ul><li>适配器：将一<strong>个接口转换成另一个接口</strong>，以符合客户的期望</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/5bd9aaff0bcdbcaa.png" style="zoom:33%;"></p><ul><li>面向对象适配器<img src="https://i.bmp.ovh/imgs/2022/03/a2c5343156e97baf.png" style="zoom:33%;"></li></ul><h2 id="披着鸭子皮的火鸡"><a href="#披着鸭子皮的火鸡" class="headerlink" title="披着鸭子皮的火鸡"></a>披着鸭子皮的火鸡</h2><ul><li><p>鸭子类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>火鸡类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">}<span class="comment">//被适配者</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>假设<strong>缺鸭子</strong>对象，<strong>用火鸡冒充</strong>，但是接口不同，所以先写个适配器吧</p></li><li><p><strong>适配器</strong>（TurkeyAdapter）将 <strong>被适配者</strong>（Turkey） 适配成 <strong>目标</strong>接口（Duck）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们需要的是duck，但是现在只有turkey，所以这个适配器需要实现duck的接口</span></span><br><span class="line"><span class="comment">//可见：适配器实现了目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span></span>{</span><br><span class="line">    Turkey turkey;<span class="comment">//利用对象组合，用Turkey的实现来满足客户对鸭子的需求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.turkey = turkey; <span class="comment">//可见：适配器持有 被适配者turkey的实例</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>{<span class="comment">//实现duck的所有方法(适配器实现了目标接口)</span></span><br><span class="line">        turkey.gobble();  <span class="comment">//具体实现其实是turkey的方法，把它封装到duck的quack里而已</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) turkey.fly();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>测试适配器</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckTestDrive</span></span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">       MallardDuck duck = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">       WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">       <span class="comment">//把这个火鸡包装进适配器中，让它看起来像鸭子</span></span><br><span class="line">       Duck turkeyAdapter = <span class="keyword">new</span> TurkeyAdapter(turkey);</span><br><span class="line">       testDuck(turkeyAdapter);</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">//testDuck相当于客户，依据目标接口（Duck）实现的：duck.quack,fly</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDuck</span><span class="params">(Duck duck)</span></span>{</span><br><span class="line">       duck.quack();</span><br><span class="line">       duck.fly();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="适配器模式解析"><a href="#适配器模式解析" class="headerlink" title="适配器模式解析"></a>适配器模式解析</h2><p><img src="https://i.bmp.ovh/imgs/2022/03/6c4883665ec5904d.png" style="zoom:67%;"></p><ul><li><p>客户通过<font color="red">目标接口</font> 调用 <font color="red">适配器</font>的方法 对适配器发出请求</p></li><li><p>适配器 使用 <font color="red">被适配者接口</font>，把请求转换成 被适配者的一个或多个调用接口</p></li><li><p>客户接受到调用的结果，但未察觉适配器在起转换作用</p></li></ul><h2 id="定义适配器模式-类图"><a href="#定义适配器模式-类图" class="headerlink" title="定义适配器模式+类图"></a>定义适配器模式+类图</h2><font color="red">适配器模式：将一个类的接口，转换成客户期望的另一个类的接口。适配器让原本接口不兼容的类可以合作无间</font><ul><li><p>通过<strong>创建适配器</strong> 进行接口转换</p></li><li><p>好处</p><ul><li>适配器 将客户（比如testDuck）从实现的接口<strong>解耦</strong></li><li>如果想改变接口，适配器可以<strong>将改变的部分封装</strong>起来</li></ul></li><li><p><strong>对象</strong>适配器</p><p>适配器 和 被适配者 使用<strong>对象组合</strong>：被适配者的<strong>子类</strong>都可以<strong>搭配适配器</strong>使用</p><p><img src="https://i.bmp.ovh/imgs/2022/03/ea2903ba5f12223a.png" style="zoom:67%;"></p></li><li><p><strong>类</strong>适配器</p><p>（Java 不支持多重继承</p><p><img src="https://i.bmp.ovh/imgs/2022/03/06a0ea3bb86ade77.png" style="zoom:80%;"></p></li></ul><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>最初的茶和咖啡各自的四个步骤里面包括了</p><ul><li><strong>同样</strong>的方法：把水煮沸、倒进杯子</li><li><strong>相似</strong>的方法：沸水冲泡茶叶&amp;沸水冲泡咖啡粉、加柠檬&amp;加牛奶</li><li>同样的<strong>执行步骤</strong>：执行顺序相同</li></ul><p>因此，可以将其抽象泛化成一个模板方法</p><p><img src="https://i.bmp.ovh/imgs/2022/04/09/bb395cb66de3b8bb.png" style="zoom: 50%;"></p><h2 id="模板方法定义"><a href="#模板方法定义" class="headerlink" title="模板方法定义"></a>模板方法定义</h2><p><a href="https://github.com/z-y-LiaN/Software-Design-Pattern/tree/master/Template">Github：课本代码实现总结</a></p><p><strong>模板方法模式</strong> 在一个<strong>方法</strong>中定义一个<font color="red">算法的骨架</font>，而将一些步骤<font color="red">延迟到子类</font>中。模板方法使得子类可以在<strong>不改变算法结构</strong>的情况下，<strong>重新定义</strong>算法中的<strong>某些</strong>步骤</p><p>理解</p><ul><li>所谓模板，本质是个方法，一个用<strong>一组步骤</strong>来定义算法的方法<ul><li>保证由<strong>子类提供算法某一部分的实现</strong>，而算法结构保持不变</li></ul></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/09/9e1722efc57cbd1b.png" style="zoom: 43%;"></p><h2 id="对模板方法进行挂钩"><a href="#对模板方法进行挂钩" class="headerlink" title="对模板方法进行挂钩"></a>对模板方法进行挂钩</h2><p>钩子：声明在<strong>抽象类</strong>中的（具体）方法，<strong>只有空的或者默认</strong>的实现。</p><p>有了钩子，子类可以自主决定要不要覆盖这个钩子，如果不覆盖，抽象类会提供一个默认的实现</p><font color="green">何时使用抽象方法，何时使用钩子：</font><ul><li>子类<strong>必须提供</strong>算法中某个方法或步骤的<strong>实现</strong>：抽象方法</li><li>不是必须，而是<strong>可选</strong>的：钩子</li></ul><hr><p>子类必须实现抽象类中的<strong>所有抽象方法</strong></p><h2 id="好莱坞原则与模板方法"><a href="#好莱坞原则与模板方法" class="headerlink" title="好莱坞原则与模板方法"></a>好莱坞原则与模板方法</h2><p><img src="https://i.bmp.ovh/imgs/2022/04/09/6420977290ad11c0.png" style="zoom:50%;"></p><h2 id="模板方法和策略模式的对比"><a href="#模板方法和策略模式的对比" class="headerlink" title="模板方法和策略模式的对比"></a>模板方法和策略模式的对比</h2><ul><li>策略模式定义了一个算法族，分别封装起来，让它们之间可以相互替换。每个算法都被封装，客户可以很方便的使用不同的算法，而且将算法的变化独立于客户</li><li>模板方法模式定义了一个算法的框架，将一些步骤延迟到子类。这样对于算法的某个步骤就有不同的，但仍能控制整个算法的结构</li><li>策略模式和模板方法模式都是封装算法；<ul><li>策略模式采用<strong>对象组合</strong>，更加<strong>灵活</strong>，依赖性比模板方法模式弱</li><li>模板方法模式采用<strong>继承</strong>，对算法有<strong>更强的控制</strong>，所以依赖性比策略模式强；<strong>没有重复代码</strong>，对象更少，更<strong>高效</strong></li></ul></li><li>注意：工厂方法模式是模板方法模式的一个特例</li></ul><h2 id="模板方法的例题"><a href="#模板方法的例题" class="headerlink" title="模板方法的例题"></a>模板方法的例题</h2><font color="red">关键词：步骤、流程、某些流程不一样</font><hr><p>1.对数据库的操作一般包括连接、打开、使用、关闭等<strong>步骤</strong>，在数据库操作模板类中我们定义了connDB（）,openDB（）,useDB()，closeDB（）四个方法分别对应这<strong>四个步骤</strong>，对于不同类型的数据库（如SQLserver和Oracle），<strong>其操作步骤都一致</strong>，只是连接数据库connDB（）方法有所区别，现使用模板方法模式对其进行设计</p><hr><p>2.某软件公司欲为某银行的业务支撑系统开发一个利息计算模块，利息计算<strong>流程</strong>如下：<br>(1) 系统根据账号和密码验证用户信息，如果用户信息错误，系统显示出错提示；（<strong>具体方法）</strong><br>(2) 如果用户信息正确，则根据<strong>用户类型的不同使用不同的利息计算公式</strong>计算利息（如活期账户和定期账户具有不同的利息计算公式）；<strong>（这是个不同的步骤，抽象方法）</strong><br>(3) 系统显示利息。<strong>（具体方法）</strong><br>试使用模板方法模式设计该利息计算模块。</p><p><img src="https://i.bmp.ovh/imgs/2022/04/09/271f71928f6d6291.png" style="zoom: 33%;"></p><hr><p>3.某软件公司欲为销售管理系统提供一个数据图表显示功能，该功能的实现包括如下<strong>几个步骤</strong>：<br>(1) 从数据源获取数据；<br>(2) 将数据转换为XML格式；<br>(3) 以某种图表方式显示XML格式的数据。<br>该功能支持<strong>多种数据源和多种图表</strong>显示方式，但所<strong>有的图表显示操作都基于XML格式的数据，因此可能需要对数据进行转换</strong>，如果从数据源获取的数据已经是XML数据则无须转换</p><hr><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>让客户<strong>遍历</strong>你的对象而无法窥视你存储对象的方式</p><p><img src="https://i.bmp.ovh/imgs/2022/04/10/9e3c335e18674026.png" alt=""></p><p>显然，这两种不同的菜单表现方式会让事情变得复杂化，我们需要实现一个<strong>同时使用这两个菜单</strong>的客户代码 </p><ul><li><p>比如一个waitress类（客户）需要遍历打印菜单中的每一项 printMenu()</p></li><li><p>但是这两份存储菜单项的菜单里所<strong>使用的数据结构不同</strong></p></li><li><p>导致printMenu()要分别遍历每份菜单，比如</p><p><img src="https://i.bmp.ovh/imgs/2022/04/10/8044cb7679393e81.png" style="zoom: 50%;"></p></li></ul><p>考虑让这两个菜单<strong>实现一个相同的接口</strong>：</p><ul><li><p>可以看到 <strong>发生变化的部分</strong>是不同集合类型所造成的遍历，因此可以<strong>考虑封装遍历</strong></p></li><li><p>因此，创建一个对象：迭代器，利用它来封装“<strong>遍历</strong>集合内的每个对象的过程”</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = dinerMenu.createIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()){</span><br><span class="line">    MenuItem menuItem = (MenuItem)iterator.next();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>所以，接下来的具体实现是：</p><ul><li>定义一个<strong>迭代器接口</strong>Iterator </li><li>为每个菜单各自定义<strong>实现一个具体的Iterator类</strong>：DinerMenuIterator、PancakeHouseMenuIterator</li><li><p>改写原菜单：<strong>遍历菜单时需要获得它的迭代器</strong>，所以原菜单要有一个createIterator()方法来获取对应的迭代器</p></li><li><p>waitress（客户代码）想要遍历所有菜单里面的所有菜单项，只需要获取到对应的迭代器，利用迭代器的方法遍历就行。</p></li></ul><hr><p><img src="https://i.bmp.ovh/imgs/2022/04/10/3def41655a370abf.png" style="zoom: 67%;"></p><h2 id="利用Java-util-Iterator来清理"><a href="#利用Java-util-Iterator来清理" class="headerlink" title="利用Java.util.Iterator来清理"></a>利用Java.util.Iterator来清理</h2><ul><li>PancakeHouseMenu：对于ArrayList不需要创建自己的迭代器，直接调用iterator()方法即可</li><li>DinerMenu：写一个具体的迭代器实现Iterator</li><li>让waitress不依赖于具体的DinerMenu和PancakeHouseMenu类：<ul><li>添加一个Menu接口，只有createIterator（）方法</li><li>具体的Menu去实现这个Menu接口类</li><li>这样waitress可以<strong>针对抽象</strong>（Menu）编程，而<strong>不是针对具体编程</strong>，实现解耦</li></ul></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/10/742898cea6ea5dda.png" style="zoom: 67%;"></p><h2 id="定义迭代器模式"><a href="#定义迭代器模式" class="headerlink" title="定义迭代器模式"></a>定义迭代器模式</h2><p>迭代器模式 提供一种方法<strong>顺序访问</strong>每一个聚合对象中的各个元素，而不暴露其内部的表示</p><hr><ul><li>迭代器模式把元素之间游走的责任交给迭代器实现，而不是句合对象。</li><li>使我们能够游走（遍历）聚合内的每一个元素，而又不保留其内部的表示</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/10/5c5d97f561d6df88.png" style="zoom: 50%;"></p><h2 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h2><p><strong>一个类应该只有一个引起变化的原因</strong></p><hr><p>理解</p><ul><li><p>当我们允许一个类不但要完成自己的事情（管理某种集合），还同时担负起更多的责任（例如遍历）时，我们就给了这个类两个变化的原因：</p><ul><li>集合改变、类随之改变</li><li>遍历方式改变、类随之改变</li></ul><p>比如最初的没有使用迭代器模式的<code>DinerMenu</code>和<code>PancakeHouseMenu</code>；<code>DinerMenu</code>既需要管理存储菜单项的数组，又需要参与到数组遍历中</p></li><li><p><strong>类的每个责任都有改变的潜在区域</strong>，超过一个责任，意味着超过一个改变的区域</p></li></ul><p>内聚：度量一个类或模块紧密地达到单一目的或责任</p><ul><li>具有<strong>高内聚</strong>的模块或类：只支持一组相关的功能</li><li>具有<strong>低内聚</strong>的模块或类：支持一组不相干的功能</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/10/42177f8fd9fba002.png" style="zoom:67%;"></p><p><img src="https://i.bmp.ovh/imgs/2022/04/10/8ac487f1936f16df.png" style="zoom:62%;"></p><hr><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>基于上面的例子，我们希望在DinerMenu中添加一个甜点的子菜单</p><p><img src="https://i.bmp.ovh/imgs/2022/04/10/9e6b14f2808ab76e.png" style="zoom:50%;"></p><p>因此，我们需要：</p><ul><li>需要某种<strong>树形结构</strong>，可以容纳菜单、子菜单、菜单项</li><li>需要确定<strong>能够在每个菜单的各个项之间的游走</strong>，而且至少要像现在用迭代器一样方便</li><li>需要<strong>更有弹性</strong>地在菜单项之间游走：可以只遍历甜点菜单，可以遍历餐厅整个菜单</li></ul><h2 id="组合模式定义"><a href="#组合模式定义" class="headerlink" title="组合模式定义"></a>组合模式定义</h2><p>组合模式允许你 将组合对象 <strong>组合成树形结构</strong> 来表现 “整体/部分“层次结构。组合能让客户以<strong>一致的方式</strong>处理<strong>个别</strong>对象以及对象<strong>组合</strong></p><hr><ul><li>组合模式让我们能够用<strong>树形的方式</strong>创建对象的结构，树里面包含了<strong>组合以及个别的对象</strong></li><li>使用组合结构，我们能把<strong>相同的操作</strong>应用在组合和个别对象上；<ul><li>即：大多数情况下，可以<strong>忽略</strong>对象组合和个别对象的<strong>差别</strong></li></ul></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/05/14/5e0b935975b7340f.png" style="zoom:80%;"></p><h2 id="利用组合设计菜单"><a href="#利用组合设计菜单" class="headerlink" title="利用组合设计菜单"></a>利用组合设计菜单</h2><ul><li>创建一个<strong>组件接口</strong>，作为菜单和菜单项的<strong>共同接口</strong>，这样就能用统一的做法来处理菜单和菜单项。</li></ul><ul><li>实现菜单组件：MenuComponent<ul><li>它的目的是为叶节点和组合节点提供一个共同的接口</li><li>它的方法要<strong>提供默认的实现</strong>，这样菜单项或菜单不想实现某些方法 就可以不实现</li></ul></li></ul><hr><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p><a href="https://github.com/z-y-LiaN/Software-Design-Pattern/tree/master/State">Github：状态模式课本代码实现总结</a></p><p>针对一种像这种状态机的模型</p><p><img src="https://www.hualigs.cn/image/6252e3a06ba5f.jpg" style="zoom:50%;"></p><p>我们把每个状态的<strong>行为都放在</strong>各自的<strong>状态类</strong>中，每个状态只要实现它的动作就行</p><p>所以用户施加在糖果机上的<strong>动作</strong>，只需要<strong>委托给代表当前状态的状态对象</strong>就行===》多用组合，少用继承</p><p><img src="https://i.bmp.ovh/imgs/2022/05/13/ffc03cadd6316732.png" style="zoom: 33%;"></p><ul><li>将每个状态的行为局部化到它自己的类中</li><li>将容易产生问题的if语句删除，方便维护</li><li>让每个状态<strong>对修改关闭</strong>，让糖果机<strong>对扩展开放</strong>，因此可以加入新的状态类</li></ul><h2 id="定义状态模式"><a href="#定义状态模式" class="headerlink" title="定义状态模式"></a>定义状态模式</h2><p>状态模式  允许对象在<strong>内部状态改变</strong>时<strong>改变</strong>它的<strong>行为</strong>，对象看起来<strong>好像修改</strong>了它 的<strong>类</strong></p><p>理解：</p><ul><li>将状态<strong>封装成</strong>独立的<strong>类</strong>，并将动作<strong>委托</strong>到代表<strong>当前状态的对象</strong>，行为随着内部状态而改变<ul><li>比如：糖果机处于不同状态，对它执行相同动作，得到的结果可能不同</li></ul></li><li>从客户的视角，如果说你<strong>使用的对象能够改变它的行为</strong>，那你就会觉得，这个对象实际上是从别的类实例化而来的，而实际上是使用<strong>组合</strong>通过简单<strong>引用</strong>不同的 状态对象造成的假象</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/11/97377ff0ed4987fb.png" style="zoom:67%;"></p><h2 id="状态模式和策略模式对比"><a href="#状态模式和策略模式对比" class="headerlink" title="状态模式和策略模式对比"></a>状态模式和策略模式对比</h2><font color="red">它俩类图一样，但是意图不一样</font><blockquote><p>所以说，千万不要从类图上区分模式，要从它的用途和目的去区分</p></blockquote><ul><li><p><font color="red">状态模式</font>：将 <strong>一群行为封装在状态对象</strong>中，行为对于客户来说是<strong>透明</strong>的。正常情况下，客户<strong>不知道</strong>状态对象的存在</p><blockquote><p>Contex的行为可以随时委托给那些状态对象中第一个，随着时间流逝</p><p>当前<strong>状态在状态对象集合中游走改变</strong>，以反映出context内部的状态，因此 context的行为也会跟着改变</p><p>但是！！！！context的客户对于状态对象了解不多，<strong>甚至浑然不觉</strong></p><p>可以把状态模式想成是不用在context中放置许多条件判断的替代方案</p><p>通过将<strong>行为包装进状态对象</strong>，可以通过在context内简单地<strong>改变状态对象</strong>来<strong>改变context的行为</strong></p></blockquote></li><li><p><font color="red">策略模式</font>中，客户通常<strong>委托所要组合</strong>的对象<strong>改变行为，由客户决定做改变</strong></p><blockquote><p>客户通常 <strong>主动指定</strong>Context所要组合的<strong>策略对象</strong>是哪一个</p><p>可以把策略模式想成除了<strong>继承之外的 一种弹性替代</strong>方案</p><ul><li>如果使用继承定义了一个类的行为，可能被整个行为困住</li><li>但通过策略模式，可以<strong>通过组合不同的对象</strong>来改变行为</li></ul></blockquote></li><li><p><strong>代码对比</strong></p></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/823ae8b39805c03c.png" style="zoom:50%;"></p><ul><li>例如上图<strong>策略模式</strong>的客户代码，客户是<strong>明确知道</strong>拥有的策略对象，可以由客户自己<strong>随意指定</strong></li><li>例如下图<strong>状态模式</strong>的客户代码，客户只知道要进行这些操作，而这些操作的具体实现是委托给具体的状态的，<strong>客户根本不知道当前的状态对象</strong></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/f6bffdd837e284cd.png" style="zoom:50%;"></p><ul><li>即是：状态模式中，客户调用<code>gumballMachine.insertQuarter()</code>方法，实际上会<strong>委托</strong>给持有的<code>state</code>状态对象<code>insertQuarter</code>来执行，从而进行状态转换</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/5783f145b9bc36e1.png" style="zoom:60%;"></p><h2 id="状态转换由谁执行"><a href="#状态转换由谁执行" class="headerlink" title="状态转换由谁执行"></a>状态转换由谁执行</h2><p><a href="https://github.com/z-y-LiaN/Software-Design-Pattern/tree/master/State/StateChange">Github：一个代码例子</a></p><ul><li>当状态转换是<strong>固定</strong>的，就适合放<strong>在Context类</strong>中</li><li>当状态转换是更<strong>动态</strong>的，通常会放在<strong>状态类</strong>中<ul><li>缺点：状态间产生了依赖</li></ul></li></ul><h2 id="一个练习"><a href="#一个练习" class="headerlink" title="一个练习"></a>一个练习</h2><p>信用卡业务系统</p><p>​    Sunny软件公司欲为某银行开发一套信用卡业务系统，银行账户(Account)是该系统的核心类之一，通过分析，Sunny软件公司开发人员发现在该系统中，账户存在<strong>三种状态</strong>，且在不同状态下账户存在不同的行为，具体说明如下：</p><ul><li><p>如果账户中余额大于等于0，则账户的状态为<strong><em>\</em>正常状态(Normal State)**</strong>，此时用户既可以向该账户<strong><em>\</em>存款**</strong>也可以从该账户<strong><em>\</em>取款**</strong>；</p></li><li><p>如果账户中余额小于0，并且大于-2000，则账户的状态为<strong><em>\</em>透支状态(Overdraft State)**</strong>，此时用户既可以向该账户存款也可以从该账户取款，但需要<strong><em>\</em>按天计算利息**</strong>；</p></li><li><p>如果账户中余额等于-2000，那么账户的状态为<strong><em>\</em>受限状态(Restricted State)**</strong>，此时用户只能向该账户存款，不能再从中取款，同时也将按天计算利息；</p></li></ul><p>根据余额的不同，以上<strong><em>\</em>三种状态可发生相互转换**</strong>。</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/d5e795f6c10a3d81.png" alt=""></p><p>stateCheck()用于在每一次执行存款和取款操作后<strong>根据余额来判断是否要进行状态转换并实现状态转换</strong>，相同的方法在不同的状态中可能会有不同的实现。</p><p>上面的例子通过<strong>具体状态类来实现状态的转换</strong>，在每一个具体状态类中都包含一个stateCheck()方法，在该方法内部实现状态的转换。</p><p>除此之外，我们还可以通过<strong>Context类来实现状态转换</strong>，Context类作为一个状态管理器，统一实现各种状态之间的转换操作</p><hr><h2 id="多个Context类共享-状态"><a href="#多个Context类共享-状态" class="headerlink" title="多个Context类共享 状态"></a>多个Context类共享 状态</h2><p>在有些情况下，<strong>多个</strong>Context可能需要<strong>共享同一个状态</strong></p><ul><li><p>如果希望在系统中实现多个Context共享一个或多个状态对象</p></li><li><p>则可以<strong>将这些State定义为Context的静态成员对象</strong>。</p><blockquote><p>即，想要共享状态，需要把每个状态都指定到静态的实例变量中，如果状态需要用到Context的方法或者实例变量，还必须在handler()方法中传入一个context的引用</p></blockquote></li></ul><hr><p>关于为什么定义为静态成员对象：</p><ul><li><p>属于类，<strong>独立于对象</strong>，即使未创建对象，也可以通过类调用静态的属性和方法</p></li><li><p>由于static成员<strong>为所有实例对象所共享</strong>，当业务需求出现<strong>某个成员需要被所有实例对象所需要</strong>时，应将其设为static，<strong>当类的任何对象访问它时，存取到的都是相同的值</strong></p><ul><li>某个成员：可以对应某个状态</li><li>被所有实例对象所需要：这个状态被多个Context共享</li></ul></li><li><p>static变量只会在类加载时被分配一次且一次空间，而实例对象会在每次创建新对象时都会为其分配一次新的空间</p></li></ul><ul><li><p><strong>static成员可以通过类名访问，也可以通过对象名访问</strong></p></li><li><p>static方法中只允许访问static属性或方法，不允许访问非static成员（因为非static成员在初次类加载时并未初始化）</p></li></ul><hr><p>例如：如果某系统要求两个开关对象（Context）要么<strong>都</strong>处于开的状态，要么都处于关的状态，在使用时它们的状态必须保持一致，开关可以由开转换到关，也可以由关转换到开。</p><p>分析：</p><ul><li>两个开关对象——两个Context</li><li>都处于开，都处于关——共享开状态和共享关状态</li><li>因此，需要把这两个state定义为context的静态成员对象</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】数据结构</title>
      <link href="/2022/03/22/2022-03-22-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/03/22/2022-03-22-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>链表</li><li>哈希表</li><li>并查集：在近乎<strong>O(1)</strong>的情况下，<ul><li>关键：p[N]初始化，find(int a)：返回a所在集合的编号</li><li><strong>合并 </strong>两集合 </li><li><strong>询问</strong> 两元素是否在同一集合</li></ul></li></ul></li></ul><span id="more"></span><h1 id="链表与邻接表"><a href="#链表与邻接表" class="headerlink" title="链表与邻接表"></a>链表与邻接表</h1><h2 id="数组模拟单链表（邻接表）"><a href="#数组模拟单链表（邻接表）" class="headerlink" title="数组模拟单链表（邻接表）"></a>数组模拟单链表（邻接表）</h2><ul><li>邻接表：常用于存储图和树</li></ul><h3 id="AcWing826-单链表（模板题）"><a href="#AcWing826-单链表（模板题）" class="headerlink" title="AcWing826 单链表（模板题）"></a>AcWing826 单链表（模板题）</h3><ul><li>一般来说，如果想删除链表第一个节点，会说“删除头结点”，如果想删除整个链表，会直接说“删除整个链表”~ head是指向头结点的指针，它本身是不存节点的，只是<strong>指向了整个链表的第一个节点</strong>。</li><li>初始化：head=-1；idx=0；</li><li>头插法：赋值、指向当前head的next、更新head，idx++</li><li>插到指定位置k后面：赋值，更新next</li><li>删除位置k的元素：将k的next指向k的next的next</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="comment">//head=头结点下标</span></span><br><span class="line"><span class="comment">//e[i]:节点i的值</span></span><br><span class="line"><span class="comment">//ne[i]:节点i的下一个的坐标</span></span><br><span class="line"><span class="comment">//idx:指向当前即将处理的点的坐标 </span></span><br><span class="line"><span class="keyword">int</span> head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">head=<span class="number">-1</span>;</span><br><span class="line">idx=<span class="number">0</span>;</span><br><span class="line">} </span><br><span class="line"><span class="comment">//将x插入到头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">e[idx]=x,ne[idx]=head,head=idx,idx++;</span><br><span class="line">} </span><br><span class="line"><span class="comment">//将x插到下标是k的点的后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">e[idx]=x,ne[idx]=ne[k],ne[k]=idx,idx++;</span><br><span class="line">} </span><br><span class="line"><span class="comment">//将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">ne[k]=ne[ne[k]];</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> m; cin&gt;&gt;m;</span><br><span class="line"><span class="built_in">init</span>(); <span class="comment">//!!!!!!!!别忘记初始化</span></span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> k,x;</span><br><span class="line"><span class="keyword">char</span> op; cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'H'</span>){</span><br><span class="line">cin&gt;&gt;x;<span class="built_in">add_to_head</span>(x);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'D'</span>){</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>) head=ne[head];</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">remove</span>(k<span class="number">-1</span>);</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">cin&gt;&gt;k&gt;&gt;x; <span class="built_in">add</span>(k<span class="number">-1</span>,x);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head;i!=<span class="number">-1</span>;i=ne[i]) cout&lt;&lt;e[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数组模拟双链表"><a href="#数组模拟双链表" class="headerlink" title="数组模拟双链表"></a>数组模拟双链表</h2><ul><li>双链表：用来优化某些题</li></ul><p><a href="https://www.acwing.com/problem/content/829/">827. 双链表 - AcWing题库</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> l[M],r[M],e[M],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">r[<span class="number">0</span>]=<span class="number">1</span>;l[<span class="number">1</span>]=<span class="number">0</span>;idx=<span class="number">2</span>; <span class="comment">//0左边界、1右边界</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>{<span class="comment">//第k个插入的数后面插入v</span></span><br><span class="line">e[idx]=v;</span><br><span class="line">l[idx]=k,r[idx]=r[k];</span><br><span class="line">l[r[k]]=idx,r[k]=idx;</span><br><span class="line">idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">l[r[k]]=l[k];</span><br><span class="line">r[l[k]]=r[k];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> m;cin&gt;&gt;m;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line">string s;<span class="keyword">int</span> k,x; cin&gt;&gt;s;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">"L"</span>){</span><br><span class="line">cin&gt;&gt;x; <span class="built_in">insert</span>(<span class="number">0</span>,x);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"R"</span>){</span><br><span class="line">cin&gt;&gt;x; <span class="built_in">insert</span>(l[<span class="number">1</span>],x);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"D"</span>){</span><br><span class="line">cin&gt;&gt;k; <span class="built_in">remove</span>(k+<span class="number">1</span>);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"IL"</span>){</span><br><span class="line">cin&gt;&gt;k&gt;&gt;x; <span class="built_in">insert</span>(l[k+<span class="number">1</span>],x);</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">cin&gt;&gt;k&gt;&gt;x; <span class="built_in">insert</span>(k+<span class="number">1</span>,x);  <span class="comment">//k-1+2</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=r[<span class="number">0</span>];i!=<span class="number">1</span>;i=r[i])  <span class="comment">//遍历</span></span><br><span class="line">cout&lt;&lt;e[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> st[N], top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--){</span><br><span class="line">        string s; cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"push"</span>){</span><br><span class="line">            <span class="keyword">int</span> a; cin &gt;&gt; a;</span><br><span class="line">            st[++top] = a;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"pop"</span>) top --;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"query"</span>) cout &lt;&lt; st[top] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"empty"</span>) cout &lt;&lt; (top == <span class="number">-1</span> ? <span class="string">"YES"</span> : <span class="string">"NO"</span>) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- ){</span><br><span class="line">        string op;</span><br><span class="line">        <span class="keyword">int</span> x; cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"push"</span>){</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            q[ ++ tt] = x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"pop"</span>) hh ++ ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"empty"</span>) cout &lt;&lt; (hh &lt;= tt ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; q[hh] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><a href="https://www.acwing.com/problem/content/832/">830. 单调栈 - AcWing题库</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;stk;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">while</span>(stk.<span class="built_in">size</span>()&amp;&amp;stk.<span class="built_in">top</span>()&gt;=x) stk.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(!stk.<span class="built_in">size</span>()) cout&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="string">' '</span>;</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">cout&lt;&lt;stk.<span class="built_in">top</span>()&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">stk.<span class="built_in">push</span>(x);</span><br><span class="line">}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>求滑动窗口的max、min</p><p><img src="https://s2.loli.net/2022/07/13/SVzKWucn3aB7kDs.png" alt="image.png" style="zoom:33%;"></p><p><a href="https://www.acwing.com/problem/content/156/">154. 滑动窗口 - AcWing题库</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],q[N];</span><br><span class="line"><span class="comment">//q存储的是下标不是值 </span></span><br><span class="line"><span class="keyword">int</span> hh,tt=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="comment">//min</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt&amp;&amp;i-k+<span class="number">1</span>&gt;q[hh]) hh++;</span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--;</span><br><span class="line">q[++tt]=i; </span><br><span class="line"><span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="string">' '</span>; </span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//max</span></span><br><span class="line">hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt&amp;&amp;i-k+<span class="number">1</span>&gt;q[hh]) hh++;</span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--;</span><br><span class="line">q[++tt]=i; </span><br><span class="line"><span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="string">' '</span>; </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>用到哈希表的情况：把一个大的空间<strong>映射</strong>到一个小的空间</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li>存储结构<ul><li><strong>开放寻址法</strong></li><li>拉链法：开一个一维数组，存储所有的哈希值</li></ul></li><li>字符串哈希方式</li></ul><p>离散化可以看成是一种特殊的哈希，之前的那个离散化要保证顺序</p><h2 id="AcWing-840-模拟散列表"><a href="#AcWing-840-模拟散列表" class="headerlink" title="AcWing 840 模拟散列表"></a>AcWing 840 模拟散列表</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>维护一个<strong>集合</strong>，支持下列操作：</p><ul><li>lx：  <strong>插入</strong>一个数</li><li>Qx：<strong>询问</strong>x是否在集合中出现过</li></ul><p>对于N次操作，输出询问结果</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>N行：N个操作，虽然<code>-10^9 &lt;= x &lt;= 10^9</code> 但是，N最大取到10^5，所以实际<strong>只涉及10^5个数</strong>；</p></li><li><p>题目操作<strong>只有插入和查询</strong>而已，没有说要插入到哪个位置，而只是插入到了一个无序的集合中，<strong>并且没有顺序</strong>要求。</p></li><li><p>对于插入操作，我们可以把要插入的每个数存到一个哈希表里里面</p></li><li><p>x mod 10^5 </p><ul><li>一般来说，取模的这个数要是<strong>质数</strong>，且离2的整数次幂远</li><li>因此确定数组大小后，首先找一个<strong>大于最大数据范围的一个质数</strong></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找第一个大于dest的质数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=dest;;i++){</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j*j&lt;=i;j++){</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>){</span><br><span class="line">            flag=<span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(flag){</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>冲突：把两个不一样的数映射成同一个数；处理冲突：开放寻址or拉链法</p></li><li><p>拉链法：开一个一维数组；每个位置可以看成一个槽，存储当前槽上已有的数；</p><ul><li>期望算法，每条链（单链表）的长度可以看成常数；一般哈希表的算法题<strong>只有添加和查找</strong>操作，没有删除操作；如果要实现删除，并不是真的删掉，而是打一个标记</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/01/42a9f53c1acb8955.png" style="zoom:33%;"></p></li></ul><h3 id="代码-拉链法"><a href="#代码-拉链法" class="headerlink" title="代码(拉链法)"></a>代码(拉链法)</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> k=(x%N+N)%N;<span class="comment">//保证余数是整数</span></span><br><span class="line">e[idx]=x,ne[idx]=h[k],h[k]=idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[k];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line"><span class="keyword">if</span>(e[i]==x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="comment">//要读如字符，但用的是scanf的话尽量读入的是一个字符串</span></span><br><span class="line"><span class="comment">//因为这样scanf会自动把空格、回车等给忽略掉 </span></span><br><span class="line"><span class="comment">//降低出错的概率 </span></span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,op,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(*op==<span class="string">'I'</span>) <span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="代码（开放寻址法比较nice）"><a href="#代码（开放寻址法比较nice）" class="headerlink" title="代码（开放寻址法比较nice）"></a>代码（开放寻址法比较nice）</h3><p>开放寻址法：只开一个一维数组，开到题目数据范围的<strong>2-3倍</strong>（首先要找到这个大于最大数据范围的一个质数）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200003</span>,null=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="comment">//将x映射到数组下标内 </span></span><br><span class="line"><span class="keyword">int</span> k=(x%N+N)%N;<span class="comment">//如果是负数 那取模也是负的 所以 加N 再 %N 就一定是一个正数</span></span><br><span class="line"><span class="comment">//如果不存在，则返回的是它应该存储的位置 </span></span><br><span class="line"><span class="keyword">while</span>(h[k]!=null&amp;&amp;h[k]!=x){</span><br><span class="line">        <span class="comment">//如果当前数组已经放了数据且数据不等于x</span></span><br><span class="line"><span class="comment">//就一直往后找 </span></span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">if</span>(k==N) k=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//如果x在哈希表中已经存在，则返回x所在的位置</span></span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];<span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,op,&amp;x);</span><br><span class="line"><span class="keyword">int</span> k=<span class="built_in">find</span>(x);</span><br><span class="line"><span class="keyword">if</span>(*op==<span class="string">'I'</span>){</span><br><span class="line">h[k]=x;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(h[k]!=null) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing-841-字符串哈希"><a href="#AcWing-841-字符串哈希" class="headerlink" title="AcWing 841 字符串哈希 "></a><a href="https://www.acwing.com/activity/content/problem/content/891/">AcWing 841 字符串哈希 </a></h2><ul><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】一些总结</title>
      <link href="/2022/03/18/2022-03-18-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/"/>
      <url>/2022/03/18/2022-03-18-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>没有主要的，全是次要的小东西</li></ul></li></ul><span id="more"></span><h1 id="多点测试的几种输入方式"><a href="#多点测试的几种输入方式" class="headerlink" title="多点测试的几种输入方式"></a>多点测试的几种输入方式</h1><ul><li><p>没有说明有多少数据需要读入时；<code>ctrl Z+Enter</code>结束</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) != EOF){}</span><br><span class="line"><span class="comment">//scanf返回：成功读入参数的个数；读入失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">gets</span>(str) != <span class="literal">NULL</span>){}<span class="comment">//谨此纪念因为把这个给忘了导致buaa机试爆零的惨痛教训QAQ</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>输入数据满足某个条件时停止输入</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b) != EOF){ </span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">    ... </span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b)!=EOF,a||b){ }</span><br></pre></td></tr></tbody></table></figure></li><li><p>给出测试数据的组数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(T--){}</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="常用头文件"><a href="#常用头文件" class="headerlink" title="常用头文件"></a>常用头文件</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">}  </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="cin读入加速"><a href="#cin读入加速" class="headerlink" title="cin读入加速"></a>cin读入加速</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//之前做过一道题，即使加速了仍然可能tle，数据真的较大的话还是用scanf和printf吧</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="int最大值最小值"><a href="#int最大值最小值" class="headerlink" title="int最大值最小值"></a>int最大值最小值</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maximum=INT_MAX;</span><br><span class="line"><span class="keyword">int</span> minimum=INT_MIN;</span><br></pre></td></tr></tbody></table></figure><h1 id="输出long-long"><a href="#输出long-long" class="headerlink" title="输出long long"></a>输出long long</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,x);</span><br></pre></td></tr></tbody></table></figure><p>long long的最大值最小值</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LONG_LONG_MAX</span><br><span class="line">LONG_LONG_MIN</span><br></pre></td></tr></tbody></table></figure><h1 id="scanf读单个字符"><a href="#scanf读单个字符" class="headerlink" title="scanf读单个字符"></a>scanf读单个字符</h1><p>如果直接读入char字符的话，scanf的%c可能会读入一些空格回车等莫名其妙的 东西，用%s的话就会自动忽略那些莫名其妙的空格回车</p><p>所以用scanf读字符的话，建议读成字符串的形式，过滤掉空格回车</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);<span class="comment">//a</span></span><br><span class="line">cout&lt;&lt;op[<span class="number">0</span>];   <span class="comment">//a</span></span><br></pre></td></tr></tbody></table></figure><h2 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h2><p>读入单个字符,包括换行</p><h1 id="读取一行字符串"><a href="#读取一行字符串" class="headerlink" title="读取一行字符串"></a>读取一行字符串</h1><h2 id="char"><a href="#char" class="headerlink" title="char[]"></a>char[]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">1001</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(s,<span class="number">1000</span>);<span class="comment">//第二个参数为 允许输入的最大长度</span></span><br></pre></td></tr></tbody></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin,s);</span><br></pre></td></tr></tbody></table></figure><p>当同时使用<code>cin&gt;&gt;</code>和<code>getline(cin,str)</code>的时候，在<code>cin&gt;&gt;</code>输入完成之后，<code>getline(cin,str)</code>(str是真正想要的串)之前，需要<strong>先</strong><code>getline(cin,str)</code>（这个str是一个打算用来存储回车符的串）；</p><p>将回车符从输入流缓存中清除</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;string line;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="built_in">getline</span>(cin,line);<span class="comment">//去掉换行</span></span><br><span class="line"><span class="built_in">getline</span>(cin,line);<span class="comment">//真正读取这一串字符</span></span><br></pre></td></tr></tbody></table></figure><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><h2 id="右对齐"><a href="#右对齐" class="headerlink" title="右对齐"></a>右对齐</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%5d"</span>,a);<span class="comment">//补空格</span></span><br><span class="line"><span class="comment">//输出:  123</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%05d"</span>,a);<span class="comment">//补0</span></span><br><span class="line"><span class="comment">//输出:00123</span></span><br></pre></td></tr></tbody></table></figure><h2 id="保留小数"><a href="#保留小数" class="headerlink" title="保留小数"></a>保留小数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d=<span class="number">12.3456</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1f"</span>,d);<span class="comment">//保留一位小数:采用"四舍六入五成双"规则</span></span><br><span class="line"><span class="comment">//输出:12.2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">round</span>(<span class="keyword">double</span> x) <span class="comment">//四舍五入,返回double类型</span></span><br></pre></td></tr></tbody></table></figure><h1 id="常用math函数"><a href="#常用math函数" class="headerlink" title="常用math函数"></a>常用math函数</h1><h2 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h2><p><code>fabs(double x)</code></p><h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><p><code>floor(double x)</code> 下取整,返回double类型</p><p><code>ceil(double x)</code>上取整,返回double类型</p><h2 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h2><p><code>pow(double r,double p)</code>: 返回$r^p$</p><h2 id="平方"><a href="#平方" class="headerlink" title="平方"></a>平方</h2><p><code>sqrt(double x)</code> 返回double类型</p><h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><p><code>log(double x)</code> ,求以<strong>自然对数</strong>为底的对数,  返回double类型</p><p>换地公式  $log_{a}b=log_{e}b/log_{e}a$</p><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sin</span>(<span class="keyword">double</span> x),<span class="built_in">cos</span>(<span class="keyword">double</span> x),<span class="built_in">tan</span>(<span class="keyword">double</span> x);<span class="comment">//弧度制,返回double</span></span><br><span class="line"><span class="built_in">asin</span>(<span class="keyword">double</span> x),<span class="built_in">acos</span>(<span class="keyword">double</span> x),<span class="built_in">atan</span>(<span class="keyword">double</span> x)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】数学知识</title>
      <link href="/2022/03/18/2022-03-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/03/18/2022-03-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li><strong>质数</strong>：判定、分解、线性筛</li><li>组合计数、高斯消元、简单博弈论</li></ul></li></ul><span id="more"></span><p><strong>算术基本定理</strong>：</p><script type="math/tex; mode=display">N=P_{1}^{a_{1}}· P_{2}^{a_{2}}...P_{k}^{a_{k}}</script><p>任意数字N都能分解成上面的这些形式，且Pi都是不同的质数，且a都大于0；</p><p>所以N能分解成<code>a1+a2+..ak</code>个质因子</p><h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><ul><li>定义（素数/质数）：在<strong>大于1</strong> 的整数中，如果只包含1和本身这两个约数</li></ul><h2 id="质数判定-试除法-O-√n"><a href="#质数判定-试除法-O-√n" class="headerlink" title="质数判定-试除法 O(√n)"></a>质数判定-试除法 O(√n)</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++) <span class="comment">//注意有等号，不建议写成i*i&lt;=n</span></span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="分解质因数-试除法-O-√n"><a href="#分解质因数-试除法-O-√n" class="headerlink" title="分解质因数-试除法 O(√n)"></a>分解质因数-试除法 O(√n)</h2><p>从小到大枚举所有数，</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="comment">//x中最多只有一个大于sqrt(x)的质因子 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++){</span><br><span class="line"><span class="comment">//如果i是x的因数 </span></span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>){</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>;<span class="comment">//i的个数</span></span><br><span class="line"><span class="comment">//x将i的因子除尽，下一轮的x的因子就不包含i </span></span><br><span class="line"><span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i,s++;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">' '</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">1</span>) cout&lt;&lt;x&lt;&lt;<span class="string">' '</span>&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="线性筛求质数O-n"><a href="#线性筛求质数O-n" class="headerlink" title="线性筛求质数O(n)"></a>线性筛求质数O(n)</h2><p><code>get_primes(int n)</code>：求出1到n的所有质数</p><p>质数定理：1到n当中有<code>n/lnn</code>个质数 </p><hr><p><strong>朴素做法</strong> 时间复杂度 <strong>O(nlogn)</strong></p><ul><li><p>遍历从2到n的数，如果没被筛过，说明是质数，存到primes里；</p></li><li><p>对于该质数，往后遍历所有它的倍数，它的倍数一定是合数，标记为筛过。</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N],cnt; <span class="comment">//prime[]存储1到n的所有质数，cnt所有质数的个数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];        <span class="comment">//st[i]：数字是否被筛过 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!st[i]) primes[cnt++]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>优化做法一：埃氏筛法</strong>：时间复杂度<strong>O(nloglogn)</strong></p><p>​    对于该质数，我们不需要把后面的每个它的倍数都筛掉，只需要筛掉<strong>质数的倍数</strong>就行</p><p>比如对于 <code>2 3 4 5 6 7 8 9 10 11</code>, </p><p>筛掉后是<font color="green">2 3</font> <strong>4</strong> <font color="green">5</font> <strong>6</strong> <font color="green">7</font> <strong>8</strong> <strong>9</strong> <strong>10</strong> <font color="green">11</font> </p><ul><li>比如筛剩下质数p = 11，对于2到p-1中的数，并不需要全部判断一下，只需要把其中的质数判断一下就可以了。</li><li>只要2到p-1的<strong>质数不是p的因数</strong>的话，那么p就是一个质数</li><li>所以筛的话，只需要<strong>筛掉质数的倍数</strong>就可以了 (因为合数一定是质数的倍数)</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N],cnt; <span class="comment">//prime[]存储1到n的所有质数，cnt所有质数的个数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];        <span class="comment">//st[i]：数字是否被筛过 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!st[i]){</span><br><span class="line">primes[cnt++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;</span><br><span class="line">        } </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>优化做法二：线性筛法</strong>：时间复杂度<strong>O(n)</strong>  </p><p>​    核心：把每个数只会被它的<strong>最小质因子筛掉</strong></p><ul><li><code>i%primes[j] == 0</code>：<ul><li>primes[j] 一定是 i 的最小质因子，primes[j] 一定是 primes[j] * i 的最小质因子</li></ul></li><li><code>i%primes[j] != 0</code>：<ul><li>。。。。</li></ul></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[N],cnt; <span class="comment">//prime[]存储1到n的所有质数，cnt所有质数的个数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];        <span class="comment">//st[i]：数字是否被筛过 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!st[i]) primes[cnt++]=i;</span><br><span class="line">        <span class="comment">//从小到大枚举所有的质数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;primes[j]&lt;=n/i;j++){</span><br><span class="line">            <span class="comment">//把当前质数(最小质因子）和i（最大因数）的乘积筛掉</span></span><br><span class="line"><span class="keyword">int</span> t=primes[j]*i;</span><br><span class="line">st[primes[j]*i]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//此时 primes[j]一定是i的最小质因子</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1292哥德巴赫猜想"><a href="#AcWing1292哥德巴赫猜想" class="headerlink" title="AcWing1292哥德巴赫猜想"></a>AcWing1292哥德巴赫猜想</h2><p>验证小于一百万的偶数是否满足哥德巴赫猜想：</p><p>任意一个大于4的偶数都能拆成两个奇素数之和。</p><p>对于每个数据，输出奇素数差值最大的一组</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> primes[N],cnt;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x;i++){</span><br><span class="line"><span class="keyword">if</span>(!st[i]) primes[cnt++]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;primes[j]*i&lt;=x;j++){</span><br><span class="line"><span class="keyword">int</span> t=i*primes[j];</span><br><span class="line">st[t]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">get_primes</span>(N);<span class="comment">//先找到100万以内的素数，</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line"><span class="keyword">int</span> x; cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++){</span><br><span class="line"><span class="keyword">if</span>(!st[x-primes[i]]){</span><br><span class="line">cout&lt;&lt;x&lt;&lt;<span class="string">" = "</span>&lt;&lt;primes[i]&lt;&lt;<span class="string">" + "</span>&lt;&lt;x-primes[i]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h1><h2 id="试除法求约数-O-sqrt-n"><a href="#试除法求约数-O-sqrt-n" class="headerlink" title="试除法求约数 O(sqrt(n))"></a>试除法求约数 O(sqrt(n))</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">get_divisors</span>(<span class="keyword">int</span> n){</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/i;i++){</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>){</span><br><span class="line">res.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span>(i!=n/i) res.<span class="built_in">push_back</span>(n/i);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h2><p>基于算术基本定理，<strong>约数个数=（α1+1)*(α2+1）…（αk+1）</strong></p><p>int范围内约数最多的一个整数的约数大概一千五六百的样子</p><h3 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a>模板题</h3><p>求给定N个数的乘积  <strong>的约数的个数</strong></p><ul><li>先分解质因数成算术基本定理的形式（分别分解每一个）</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span><span class="comment">//哈希表 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="comment">//定义一个哈希表存储所有的底数和指数</span></span><br><span class="line"><span class="comment">//第一个int：primes[i]中的i：底数 </span></span><br><span class="line"><span class="comment">//第二个int：primes[i]存放的值：指数 </span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;primes;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++){</span><br><span class="line"><span class="keyword">while</span>(x%i==<span class="number">0</span>){</span><br><span class="line">x/=i;</span><br><span class="line">primes[i]++;</span><br><span class="line">}</span><br><span class="line">}<span class="comment">//剩下一个它本身可能是它最大的质因数 </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">1</span>) primes[x]++;</span><br><span class="line">}</span><br><span class="line">LL res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> prime:primes){</span><br><span class="line">res=res*(prime.second+<span class="number">1</span>)%mod;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h2><p>基于算术基本定理，一个数的所有约数的和</p><script type="math/tex; mode=display">(P_{1}^{0}+P_{1}^{1}+P_{1}^{2}+...+P_{1}^{α1})*...*(P_{k}^{0}+P_{k}^{1}+P_{k}^{2}+...+P_{k}^{αk})</script><h3 id="模板题-1"><a href="#模板题-1" class="headerlink" title="模板题"></a>模板题</h3><p>求N个数的乘积  的约数之和，答案对1e9+7取模</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span><span class="comment">//哈希表 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="comment">//定义一个哈希表存储所有的底数和指数</span></span><br><span class="line"><span class="comment">//第一个int：primes[i]中的i：底数 </span></span><br><span class="line"><span class="comment">//第二个int：primes[i]存放的值：指数 </span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;primes;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++){</span><br><span class="line"><span class="keyword">while</span>(x%i==<span class="number">0</span>){</span><br><span class="line">x/=i;</span><br><span class="line">primes[i]++;</span><br><span class="line">}</span><br><span class="line">}<span class="comment">//剩下一个它本身可能是它最大的质因数 </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">1</span>) primes[x]++;</span><br><span class="line">}</span><br><span class="line">LL res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> prime:primes){</span><br><span class="line"><span class="keyword">int</span> p=prime.first,a=prime.second;</span><br><span class="line">LL t=<span class="number">1</span>,k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(a--){</span><br><span class="line">k=(k*p)%mod;t=(t+k)%mod;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//while(a--) t=(t*p+1)%mod ;</span></span><br><span class="line">res=res*t%mod;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="最大公约数（欧几里得算法）"><a href="#最大公约数（欧几里得算法）" class="headerlink" title="最大公约数（欧几里得算法）"></a>最大公约数（欧几里得算法）</h2><p>(辗转相除法)：如果d能整除a，d能整除b，那么d就能整除a+b</p><p>a和b的最大公约数 = b和a mod b的最大公约数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//STL里有： __gcd(int a,int b); 注意前面是两个下划线</span></span><br></pre></td></tr></tbody></table></figure><hr><h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>1到N中和N 互质的数 的个数</p><script type="math/tex; mode=display">Φ(N)=N(1-\frac{1}{P_{1}})(1-\frac{1}{P_{2}})...(1-\frac{1}{P_{k}})</script><h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><script type="math/tex; mode=display">|S_{1}\cup S_{2}\cup S_{3}|=|S_{1}|+|S_{2}|+|S_{3}|-|S_{1}\cap S_{2}|-|S_{1}\cap S_{3}|-|S_{2}\cap S_{3}|+|S_{1}\cap S_{2}\cap S_{3}|</script><ul><li>依次类推</li><li></li></ul><h1 id="简单博弈论"><a href="#简单博弈论" class="headerlink" title="简单博弈论"></a>简单博弈论</h1><h1 id="其他题"><a href="#其他题" class="headerlink" title="其他题"></a>其他题</h1><p>求最大公约数，gcd(a,b)：欧几里得算法（辗转相除法）logn</p><p>gcd (a,b) = gcd (b,a mod b)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1246-等差数列"><a href="#AcWing1246-等差数列" class="headerlink" title="AcWing1246 等差数列"></a>AcWing1246 等差数列</h2><p>所有相邻的两个数的公差必然是2的倍数，即找公差的最大公约数</p><p>0和任何数的最大公约数就是那个任何数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);</span><br><span class="line"><span class="keyword">int</span> d=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) d=<span class="built_in">gcd</span>(d,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(!d) cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;(a[n<span class="number">-1</span>]-a[<span class="number">0</span>])/d+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>线性筛求素数：在On的复杂度内求出1-n的所有质数以及每个数的最小质因子</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[N],cnt;<span class="comment">//存所有的质数，cnt表示个数</span></span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//当前这个数有没有被筛过 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性筛 O(n) </span></span><br><span class="line"><span class="comment">//对于每一个数（无论质数合数）x，筛掉所有小于x最小质因子的质数乘以x的数。</span></span><br><span class="line"><span class="comment">//比如对于77,它分解质因数是7*11，那么筛掉所有小于7的质数*77，筛掉2*77、3*77、5*77。 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_primes</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line"><span class="comment">//如果当前数没有被筛过的话就说明是个质因子 </span></span><br><span class="line"><span class="keyword">if</span>(!st[i]) primes[cnt++]=i;</span><br><span class="line"><span class="comment">//从小到大枚举所有的质数，把这个质数的i倍筛掉 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;primes[j]*i&lt;=n;j++){</span><br><span class="line">st[primes[j]*i]=<span class="literal">true</span>; <span class="comment">//筛掉的一定是合数 </span></span><br><span class="line"><span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_primes</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) cout&lt;&lt;primes[i]&lt;&lt;endl;;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1295"><a href="#AcWing1295" class="headerlink" title="AcWing1295"></a>AcWing1295</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>输入正整数 X，求 X的<strong>大于 1 的因子</strong>组成的满足任意<strong>前一项都能整除后一项</strong>的严格<strong>递增</strong>序列的<strong>最大</strong>长度，以及满足最大长度的序列的<strong>个数</strong>。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】模拟-枚举-排序</title>
      <link href="/2022/03/15/2022-03-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A8%A1%E6%8B%9F-%E6%9E%9A%E4%B8%BE-%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/03/15/2022-03-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A8%A1%E6%8B%9F-%E6%9E%9A%E4%B8%BE-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>一些题…</li></ul></li></ul><span id="more"></span><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><h2 id="AcWing1210-连号区间数量"><a href="#AcWing1210-连号区间数量" class="headerlink" title="AcWing1210 连号区间数量"></a>AcWing1210 连号区间数量</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/1212/">1210. 连号区间数 - AcWing题库</a></p><p>概括：给定排列的数组 求连号区间的个数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>首先，有个概念：<strong>排列</strong>，一般地，从n个<strong>不同元素</strong>中取出m（m≤n）个元素，按照一定的顺序排成一列，叫做从n个元素中取出m个元素的一个排列。</li><li>既然从a[L]到a[R]数组内的元素如果排序后严格逐个递增，那么必有<strong>max-min=R-L</strong>；题目已经说了是排列，所以不可能有相同的多个元素</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">int</span> maxx=a[i],minn=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++){</span><br><span class="line">maxx = <span class="built_in">max</span>(maxx,a[j]);</span><br><span class="line">minn = <span class="built_in">min</span>(minn,a[j]);</span><br><span class="line"><span class="keyword">if</span>(maxx-minn == j-i) ans++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1236-递增三元组"><a href="#AcWing1236-递增三元组" class="headerlink" title="AcWing1236 递增三元组"></a>AcWing1236 递增三元组</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/1238/">1236. 递增三元组 - AcWing题库</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>首先考虑暴力求解，但至少三重循环，不太行，考虑如何优化：</li><li>根据数据范围 1e5 反推，时间复杂度最多时nlogn的，并且至少会有一层遍历n，所有考虑logn的算法</li><li>所以 可以循环遍历Bi，然后在A中找小于Bi的，在C中找大于Bi的；考虑用 <strong>前缀和</strong> 或者 <strong>二分</strong>的方法<ul><li>要求的是满足条件的三元组个数，则只需要 找到A中小于Bi个数，C中大于Bi的个数，相乘即可</li></ul></li><li><strong>细节</strong>：<ul><li></li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],c[N],sa[N],sc[N],s[N],cnt[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),a[i]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]),b[i]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c[i]),c[i]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[a[i]]++;  <span class="comment">//sa[i]: 数组a中值等于i的个数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++) s[i]=s[i<span class="number">-1</span>]+cnt[i];  <span class="comment">//s[i]:数组中的值 小于等于i 的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sa[i]=s[b[i]<span class="number">-1</span>] ;<span class="comment">//a[i]表示 小于b[i]的个数 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span> s);</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[c[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++) s[i]=s[i<span class="number">-1</span>]+cnt[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sc[i]=s[N<span class="number">-1</span>]-s[b[i]];</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">ans=ans+(LL)sa[i]*sc[i];</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1204-错误票据"><a href="#AcWing1204-错误票据" class="headerlink" title="AcWing1204 错误票据"></a>AcWing1204 错误票据</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/1206/">1204. 错误票据 - AcWing题库</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目很简单，主要是复习一下输入流</p><p><font color="red">getline（）</font>的用法：接受一个字符串，可以接受空格并输出</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str; </span><br><span class="line"><span class="built_in">getline</span>(cin,str); <span class="comment">//输入：ss ss ss</span></span><br><span class="line">cout&lt;&lt;str&lt;&lt;endl;  <span class="comment">//输出：ss ss ss</span></span><br></pre></td></tr></tbody></table></figure><p>当同时使用<code>cin&gt;&gt;</code>和<code>getline(cin,str)</code>的时候，在<code>cin&gt;&gt;</code>输入完成之后，<code>getline(cin,str)</code>(str是真正想要的串)之前，需要<strong>先</strong><code>getline(cin,str)</code>（这个str是一个打算用来存储回车符的串）；将回车符从输入流缓存中清除</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">string line;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">getline</span>(cin,line);</span><br><span class="line"><span class="built_in">getline</span>(cin,line);</span><br></pre></td></tr></tbody></table></figure><p><font color="red">stringstream</font>的用法：主要用于将一个string串分割</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">stringstream ss;<span class="comment">//先定义一个stringstream</span></span><br><span class="line"><span class="keyword">int</span> a b c;</span><br><span class="line"><span class="built_in">getline</span>(cin,s);</span><br><span class="line">ss.<span class="built_in">clear</span>();  <span class="comment">//将ss清空</span></span><br><span class="line">ss.<span class="built_in">str</span>(s);   <span class="comment">//传入一个string，将其按照空格分割,返回值是分割的串的个数</span></span><br><span class="line">ss&gt;&gt;a&gt;&gt;b&gt;&gt;c;  <span class="comment">//分割的内容输入到a b c 中</span></span><br><span class="line">ss.<span class="built_in">fail</span>(); <span class="comment">//读完，返回值true；</span></span><br></pre></td></tr></tbody></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,n;</span><br><span class="line"><span class="keyword">int</span> a[N*N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;cnt;</span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(cin,line);<span class="comment">//因为之前有cin，这里要把换行符读走</span></span><br><span class="line"><span class="keyword">while</span>(cnt--){</span><br><span class="line"><span class="built_in">getline</span>(cin,line);<span class="comment">//真正的一行</span></span><br><span class="line">stringstream ss;</span><br><span class="line">ss.<span class="built_in">str</span>(line);  <span class="comment">//13和14行可以合并成stringstream ss(line);</span></span><br><span class="line"><span class="keyword">while</span>(ss&gt;&gt;a[n]) n++; <span class="comment">// </span></span><br><span class="line">} </span><br><span class="line"><span class="built_in">sort</span>(a,a+n);</span><br><span class="line"><span class="keyword">int</span> res0,res1;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>]) res0=a[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>]+<span class="number">2</span>) res1=a[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;res1&lt;&lt;<span class="string">' '</span>&lt;&lt;res0&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing466-回文日期"><a href="#AcWing466-回文日期" class="headerlink" title="AcWing466 回文日期"></a>AcWing466 回文日期</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>水题</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>简单，但要复习一下之前忘记的东西</p><ul><li><p>从一个名为str的string中截取部分</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.<span class="built_in">substr</span>(起始下标，截取个数);</span><br><span class="line"><span class="comment">//例如 str.substr(2,2) //从下标为2（第三个字符）开始，截取2个；即是第三个和第四个字符组成的串</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>string 转char[]</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s</span><br><span class="line">a=s.<span class="built_in">c_str</span>();</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>string类型转int</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="built_in">atoi</span>(str.<span class="built_in">c_str</span>())；</span><br></pre></td></tr></tbody></table></figure></li><li><p>闰年（2月有29天）判断：非整百年份能被4整除，整百年份能被400整除</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((y%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;y%<span class="number">100</span>!=<span class="number">0</span> )|| (y%<span class="number">400</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>自己直接模拟的，比较冗余；看了下y总的思路：因为只有8位数字，所以只需要枚举左半边一万个数，然后生成右半边对称的数，针对每个数判断是否合法以及是否在范围内即可</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span>{</span></span><br><span class="line"><span class="keyword">int</span> year,month,day;</span><br><span class="line">};</span><br><span class="line"><span class="function">D <span class="title">getDate</span><span class="params">(string a)</span></span>{</span><br><span class="line"><span class="keyword">int</span> year=<span class="built_in">atoi</span>(a.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">4</span>).<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">int</span> month=<span class="built_in">atoi</span>(a.<span class="built_in">substr</span>(<span class="number">4</span>,<span class="number">2</span>).<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">int</span> day = <span class="built_in">atoi</span>(a.<span class="built_in">substr</span>(<span class="number">6</span>,<span class="number">2</span>).<span class="built_in">c_str</span>()); </span><br><span class="line">D date={year,month,day};</span><br><span class="line"><span class="keyword">return</span> date;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//闰年2月29天 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> y)</span></span>{</span><br><span class="line"><span class="keyword">if</span>((y%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;y%<span class="number">400</span>!=<span class="number">0</span> )|| (y%<span class="number">400</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断日期的合法性 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> d)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(m&lt;=<span class="number">0</span>||m&gt;=<span class="number">13</span>||d&lt;=<span class="number">0</span>||d&gt;<span class="number">31</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">4</span>||m==<span class="number">6</span>||m==<span class="number">9</span>||m==<span class="number">11</span>){</span><br><span class="line"><span class="keyword">if</span>(d&gt;<span class="number">30</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">2</span>){</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isLeapYear</span>(y)&amp;&amp;d&gt;<span class="number">29</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((!<span class="built_in">isLeapYear</span>(y))&amp;&amp;(d&gt;<span class="number">28</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> ay,am,ad;</span><br><span class="line"><span class="keyword">int</span> by,bm,bd;</span><br><span class="line">string a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="comment">//判断开始日期和结束日期 </span></span><br><span class="line">ay=<span class="built_in">getDate</span>(a).year;</span><br><span class="line">am=<span class="built_in">getDate</span>(a).month;</span><br><span class="line">ad=<span class="built_in">getDate</span>(a).day;</span><br><span class="line"></span><br><span class="line">by=<span class="built_in">getDate</span>(b).year;</span><br><span class="line">bm=<span class="built_in">getDate</span>(b).month;</span><br><span class="line">bd=<span class="built_in">getDate</span>(b).day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m=(ay%<span class="number">10</span>)*<span class="number">10</span>+(ay/<span class="number">10</span>%<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> d=(ay/<span class="number">100</span>%<span class="number">10</span>)*<span class="number">10</span>+ay/<span class="number">1000</span>%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isValid</span>(ay,m,d)){</span><br><span class="line"><span class="keyword">if</span>(m&gt;am) ans++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(m==am&amp;&amp;d&gt;=ad) ans++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">m=(by%<span class="number">10</span>)*<span class="number">10</span>+(by/<span class="number">10</span>%<span class="number">10</span>);</span><br><span class="line">d=(by/<span class="number">100</span>%<span class="number">10</span>)*<span class="number">10</span>+by/<span class="number">1000</span>%<span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isValid</span>(by,m,d)){</span><br><span class="line"><span class="keyword">if</span>(m&gt;bm) ans++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(m==bm&amp;&amp;d&gt;=bd&amp;&amp;(a!=b)) ans++;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断中间日期 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> year=ay+<span class="number">1</span>;year&lt;=by<span class="number">-1</span>;year++){</span><br><span class="line"><span class="keyword">int</span> month=(year%<span class="number">10</span>)*<span class="number">10</span>+(year/<span class="number">10</span>%<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> day=(year/<span class="number">100</span>%<span class="number">10</span>)*<span class="number">10</span>+year/<span class="number">1000</span>%<span class="number">10</span>;</span><br><span class="line">ans+=<span class="built_in">isValid</span>(year,month,day);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1229-日期问题"><a href="#AcWing1229-日期问题" class="headerlink" title="AcWing1229 日期问题"></a>AcWing1229 日期问题</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>直接暴力求解，对字符串处理判断，需要考虑重复和排序的问题</p><p>y总的思路很好：<strong>枚举从起始到终止</strong>，判断是否等于输入的日期，就可以避免排序和重复问题</p><p>水题，但是复习一下：</p><ul><li>日期的格式化输入输出 采用scanf printf比cin和cout方便</li><li>数据输出最低两位，<strong>不足的高位补0输出</strong></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%02d"</span>,<span class="number">3</span>); <span class="comment">//输出：03</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%2d"</span>,<span class="number">312312</span>);<span class="comment">//输出最低两位：12</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>正确的日期格式判断</strong></li></ul><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> days[<span class="number">13</span>]={<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>};</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> m,<span class="keyword">int</span> d)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>||m&gt;<span class="number">12</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(d==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(m!=<span class="number">2</span>){</span><br><span class="line"><span class="keyword">if</span>(d&gt;days[m]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">int</span> leap=(y%<span class="number">100</span>!=<span class="number">0</span>&amp;&amp;y%<span class="number">4</span>==<span class="number">0</span>)||(y%<span class="number">400</span>==<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(d&gt;<span class="number">28</span>+leap) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d/%d/%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> date=<span class="number">19600101</span>;date&lt;=<span class="number">20591231</span>;date++){</span><br><span class="line"><span class="keyword">int</span> y=date/<span class="number">10000</span>,m=date%<span class="number">10000</span>/<span class="number">100</span>,d=date%<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(y,m,d)){</span><br><span class="line"><span class="keyword">if</span>(y%<span class="number">100</span>==a&amp;&amp;m==b&amp;&amp;d==c||</span><br><span class="line">m==a&amp;&amp;d==b&amp;&amp;y%<span class="number">100</span>==c||</span><br><span class="line">d==a&amp;&amp;m==b&amp;&amp;y%<span class="number">100</span>==c</span><br><span class="line">)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d-%02d-%02d\n"</span>,y,m,d);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1231-航班时间"><a href="#AcWing1231-航班时间" class="headerlink" title="AcWing1231 航班时间"></a>AcWing1231 航班时间</h2><ul><li><strong>string的back()和front()</strong></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string a=<span class="string">"abcd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>获取字符串最后一个字符</span><br><span class="line"><span class="keyword">auto</span> b=a.<span class="built_in">back</span>(); <span class="comment">//结果为 b='d';</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>修改字符串最后一个字符</span><br><span class="line">a.<span class="built_in">back</span>()=<span class="string">'!'</span>; <span class="comment">//结果为 a="abc!";</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>获取字符串第一个字符</span><br><span class="line"><span class="keyword">auto</span> b=a.<span class="built_in">front</span>(); <span class="comment">//结果为 b='a';</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>修改字符串第一个字符</span><br><span class="line">a.<span class="built_in">front</span>()=<span class="string">'!'</span>; <span class="comment">//结果为 a="!bcd";</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>sscanf</strong></p><p>从<strong>一个字符串中读进于指定格式</strong>相符的数据。利用它可以从字符串中取出整数、浮点数和字符串。</p><p>sscanf和scanf的区别：scanf是以键盘作为输入源，sscanf是以字符串作为输入源。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format,......)</span></span>;</span><br><span class="line"><span class="comment">//将str按format格式读入到指定参数中；成功：返回参数个数，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比如</span></span><br><span class="line"><span class="built_in">sscanf</span>(line.<span class="built_in">c_str</span>(),<span class="string">"%d:%d:%d %d:%d:%d (+%d)"</span>,&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2,&amp;d);</span><br></pre></td></tr></tbody></table></figure></li><li><p>去乘起飞时间+航行时间+时差=去乘降落时间<br>回程起飞时间+航行时间-时差=回程降落时间<br>航行时间 = (去乘降落时间-去乘起飞时间+回程降落时间-回程起飞时间)/2</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//我焯 这个题的数据处理也太会搞了吧,学废了学废了 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_seconds</span><span class="params">(<span class="keyword">int</span> h,<span class="keyword">int</span> m,<span class="keyword">int</span> s)</span></span>{</span><br><span class="line"><span class="keyword">return</span> h*<span class="number">3600</span>+m*<span class="number">60</span>+s; </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_time</span><span class="params">()</span></span>{</span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(cin,line);</span><br><span class="line"><span class="keyword">if</span>(line.<span class="built_in">back</span>()!=<span class="string">')'</span>) line+=<span class="string">"(+0)"</span>;</span><br><span class="line"><span class="keyword">int</span> h1,m1,s1,h2,m2,s2,d;</span><br><span class="line"><span class="built_in">sscanf</span>(line.<span class="built_in">c_str</span>(),<span class="string">"%d:%d:%d %d:%d:%d (+%d)"</span>,&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2,&amp;d);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get_seconds</span>(h2,m2,s2)-<span class="built_in">get_seconds</span>(h1,m1,s1)+d*<span class="number">24</span>*<span class="number">3600</span>;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> g;cin&gt;&gt;g;</span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(cin,line);<span class="comment">//读去cin后的回车 </span></span><br><span class="line"><span class="keyword">while</span>(g--){</span><br><span class="line"><span class="keyword">int</span> time=(<span class="built_in">get_time</span>()+<span class="built_in">get_time</span>())&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> h=time/<span class="number">3600</span>,m=time%<span class="number">3600</span>/<span class="number">60</span>,s=time%<span class="number">60</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d\n"</span>,h,m,s);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing446-字符串处理"><a href="#AcWing446-字符串处理" class="headerlink" title="AcWing446 字符串处理"></a>AcWing446 字符串处理</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/448/">446. 统计单词数 - AcWing题库</a></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">string a,b;</span><br><span class="line"><span class="built_in">getline</span>(cin,a);<span class="built_in">getline</span>(cin,b);</span><br><span class="line"><span class="built_in">transform</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),a.<span class="built_in">begin</span>(),::tolower);</span><br><span class="line"><span class="built_in">transform</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>(),::tolower);</span><br><span class="line">a=<span class="string">" "</span>+a+<span class="string">" "</span>; <span class="comment">//判别单词 </span></span><br><span class="line">b=<span class="string">" "</span>+b+<span class="string">" "</span>; <span class="comment">//当a是第一个和最后一个 </span></span><br><span class="line"><span class="keyword">int</span> pos=b.<span class="built_in">find</span>(a);</span><br><span class="line"><span class="keyword">int</span> idx=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(pos!=<span class="number">-1</span>){</span><br><span class="line">idx=pos;</span><br><span class="line"><span class="keyword">while</span>(pos!=<span class="number">-1</span>){</span><br><span class="line">res++;</span><br><span class="line">pos=b.<span class="built_in">find</span>(a,pos+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;res&lt;&lt;<span class="string">' '</span>&lt;&lt;idx&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>sort（）数据量大时采用快排,分段递归排序,一旦分段后的数据量小于某个门槛,为避免快排的递归调用带来过大的额外负荷,就改用插入排序。如果递归层次过深,还会改用堆排序，时间复杂度$nlog_{2}n$</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line">    <span class="comment">//1、递归结束条件</span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//2、分治,将小于x的分到左边，大于x的分到右边</span></span><br><span class="line"><span class="keyword">int</span> i=l<span class="number">-1</span>,j=r+<span class="number">1</span>,x=q[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(i&lt;j){</span><br><span class="line"><span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);<span class="comment">//while(q[++i]&lt;x);</span></span><br><span class="line"><span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);<span class="comment">//while(q[--j]&gt;x);</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">}</span><br><span class="line">    <span class="comment">//3、递归处理左右两段</span></span><br><span class="line"><span class="built_in">quick_sort</span>(q,l,j),<span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q[N],tmp[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line">    <span class="comment">//1、递归终止</span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//2、分解，归并排序左右两部分</span></span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(l,mid),<span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="comment">//3、合并左右排好序的两部分</span></span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r){</span><br><span class="line"><span class="keyword">if</span>(q[i]&lt;=q[j]) tmp[k++]=q[i++];</span><br><span class="line"><span class="keyword">else</span> tmp[k++]=q[j++];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++)</span><br><span class="line">q[i]=tmp[j];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】树状数组和线段树</title>
      <link href="/2022/03/15/2022-03-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2022/03/15/2022-03-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>它俩下标都<strong>从1开始</strong></li><li><strong>树状数组</strong>：<ul><li>动态快速求前缀和，<strong>单点修改</strong>（某个位置上加上一个数），<strong>区间查询</strong>（前缀和）</li><li>时间复杂度：<strong>O(logN)</strong></li><li><code>lowbit()</code>，<code>add(int x,int v)</code>：原数组的下标x的值加上v，<code>query(int x)</code>：查询原数组下标1到x的前缀和</li></ul></li><li><strong>线段树</strong>：<ul><li>能处理的范围更大，包含树状数组，比树状数组慢；单点修改，区间查询</li><li>一个长度为n的区间，线段树节点总个数<strong>小于等于4n</strong>；定义每个节点（左边界、右边界、某个属性）</li><li><code>pushup</code>：用子结点信息 <strong>更新</strong> 当前节点的信息；<code>build</code>：在一段区间上<strong>初始化</strong>线段树<br>；<code>modify</code>：<strong>修改</strong>；<code>query</code>：<strong>查询</strong></li></ul></li></ul></li></ul><span id="more"></span><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><ul><li>可以<strong>动态地、快速 求前缀和</strong> ； logN<ul><li>给某个位置的数 <strong>加上</strong> 一个数<strong>（单点修改）</strong></li><li>求某一个前缀和 <strong>（区间查询）</strong></li></ul></li><li>它<strong>只能</strong>解上述单点修改和区间查询问题，其他问题要<strong>转换成</strong>这种类型的才可以解</li><li>数组下标<strong>从1开始</strong></li><li>树状数组相当于一个辅助数组，<strong>不要把树状数组和原数组混淆</strong>，我们要求的是原数组的前缀和 要求的是在原数组加上某个数，<strong>然后</strong>借用一个树状数组进行操作，而不是在原数组上操作</li></ul><blockquote><p>下图来源：<a href="https://www.acwing.com/solution/content/7526/">AcWing 1264. 动态求连续区间和 - AcWing</a></p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/03/c0f519a47e871e3c.png" style="zoom:60%;"></p><ul><li><code>lowbit(x) = x &amp; -x = 2^k</code>：其中k：x末尾0的个数</li></ul><h2 id="AcWing1264-动态求连续区间和（树状数组求解）"><a href="#AcWing1264-动态求连续区间和（树状数组求解）" class="headerlink" title="AcWing1264 动态求连续区间和（树状数组求解）"></a>AcWing1264 动态求连续区间和（树状数组求解）</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="comment">//a原数组，tr树状数组 </span></span><br><span class="line"><span class="keyword">int</span> a[N],tr[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值= 2^k，其中k等于x二进制末尾0的个数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//在原数组第x个数上加上v ，对应的树状数组发生改变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用树状数组，返回原数组第1个数加到第x个数的前缀和 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i)) res+=tr[i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">add</span>(i,a[i]);</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> k,x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;k,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">query</span>(y)-<span class="built_in">query</span>(x<span class="number">-1</span>));</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="built_in">add</span>(x,y);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1265-数星星"><a href="#AcWing1265-数星星" class="headerlink" title="AcWing1265 数星星"></a>AcWing1265 数星星</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/1267/">1265. 数星星 - AcWing题库</a></p><p>概括：给定 N 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>动态输入每个点的坐标的时候，对于当前刚输入的点的坐标，它的<strong>左下方的坐标</strong>存在的星星数量刚好是 当前输入点<strong>x方向 左方</strong>的所有坐标存在的星星数量</li><li>因此，只需要求出<strong>当前x坐标的左边</strong>，即：从坐标1到x上的星星 个数总和即可；即可转换成求<strong>前缀和</strong>；</li><li>由于<strong>每输入一个</strong>星星坐标，对于前缀和数组，该星星后面的前缀和数组的值都会<strong>+1</strong>，所以可以看成一个<strong>动态区间求前缀和</strong>的 问题，因此完全可以转换成<strong>树状数组</strong>来求解</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">32005</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> tr[N],a[N];</span><br><span class="line"><span class="comment">//a[i]:等级为i的星星的个数 </span></span><br><span class="line"><span class="comment">//假设树状数组tr[N]所处理的原数组是b[N]，b[i]表示横坐标为i的星星的数量 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">return</span> x&amp;-x;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=N;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=v;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//查询原数组从坐标1到x的前缀和：即是位于坐标1到x上所有星星的数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i)) ans+=tr[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> temp_n=n;</span><br><span class="line"><span class="keyword">while</span>(temp_n--){</span><br><span class="line"><span class="keyword">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),++x,++y;</span><br><span class="line"><span class="built_in">add</span>(x,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">tot=<span class="built_in">query</span>(x);</span><br><span class="line">a[tot]++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a[i]);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1215-小朋友排队"><a href="#AcWing1215-小朋友排队" class="headerlink" title="AcWing1215 小朋友排队"></a>AcWing1215 小朋友排队</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个数组，要求从<strong>小到大</strong>排序，每次只能<strong>交换相邻</strong>位置。定义一个sum</p><p>当原数组的第i个数总共被交换了k次，<code>sum+=(1+k)*k/2</code></p><p>求<strong>最小的sum</strong></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li><p>从小到大，交换相邻：冒泡排序，但是数据范围1≤n≤100000，冒泡里面再加一层for的话会爆</p><blockquote><p>n≤100000推出算法复杂度最多是O(nlogn) =&gt; 截止写这个题解之前本fw学过的可能有<strong>各种sort</strong>，<strong>线段树、树状数组</strong>、<strong>二分</strong>…..</p></blockquote></li><li><p>比如给定一个数组：<code>3 4 2 1 4</code>；对于2前面的数来说，只要比2大，必然会被交换一次；对于2后面的数来说，只要比2小，也必然会被交换依次；</p></li><li><p>可以推出，<strong>对于第i个数</strong>，被交换的次数就是<code>k1+k2</code>；</p><ul><li><p>故关键在于，<strong>对于第i个数，求出它前面比它大的数的个数k1 ,求出它后面比它小的数的个数k2</strong></p></li><li><p>针对一个k1或者k2会被计算两次，故，求总的交换次数是<strong>所有k之和除以2</strong></p></li></ul></li><li><p><strong>假设</strong>存在一个数组b[i]（树状数组的原数组）：<strong>存放身高==i的小朋友个数</strong>，（关键在于是：个数！！）</p></li><li><p>对于<strong>k1</strong>：对于一组已知的小朋友的身高，我们可以一个个处理，比如，<strong>当处理到第x个小朋友</strong>的身高时（此时并<strong>不理会x后面</strong>的小朋友的身高），在此前，将<strong>前面的x-1小朋友</strong>的<strong>身高</strong>就可以<strong>存在b[i]</strong>（身高=i 的个数） 中，这个b[i]其实用一个<strong>树状数组</strong>来维护（因此不需要表示出b这个数组）</p><ul><li><code>query(int a)</code>则表示求出 身高在 1到a 之间的小朋友的<strong>个数</strong></li><li>若要<strong>求</strong>前面x-1个小朋友<strong>身高大于</strong>第x个小朋友身高(假设为hh）的<strong>个数</strong>，即<code>query(N)-query(hh-1)</code></li><li>即是当前，身高在1到N之间小朋友的个数 <strong>减去</strong> 身高≤hh的小朋友个数</li></ul></li><li><p>同理可得k2</p></li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N],tr[N],c[N]; </span><br><span class="line"><span class="comment">//c[i],第i个小朋友被交换的次数 </span></span><br><span class="line"><span class="comment">//a[i]：输入的数组，第i个小朋友的身高 </span></span><br><span class="line"><span class="comment">//假设树状数组tr[i]处理的原数组b[i],b[i]表示：当前身高==i的小朋友个数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">return</span> x&amp;-x;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=N;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=v;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//身高在1到x之间的小朋友个数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i)) ans+=tr[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="comment">//一旦要使用树状数组，要保证树状数组的原数组下标从1开始 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),a[i]++;</span><br><span class="line"><span class="comment">//对于每个a[i],先找它前面比它大的数的个数，</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="comment">//动态地处理,和上道数星星的题类似</span></span><br><span class="line"> <span class="built_in">add</span>(a[i],<span class="number">1</span>);</span><br><span class="line"> c[i]=<span class="built_in">query</span>(N)-<span class="built_in">query</span>(a[i]); </span><br><span class="line">}</span><br><span class="line"><span class="comment">//记得清空一次数组 </span></span><br><span class="line"><span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="keyword">sizeof</span> tr);</span><br><span class="line"><span class="comment">//对于每个a[i],找它后面比它小的数的个数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line"><span class="built_in">add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">c[i]+=<span class="built_in">query</span>(a[i]<span class="number">-1</span>); </span><br><span class="line">}</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">ans+=(<span class="built_in">LL</span>(<span class="number">1</span>+c[i])*c[i])/<span class="number">2</span>;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><ul><li>线段树能处理的范围包含树状数组</li><li>代码短、常数小</li><li>求区间最大值，面积，长度</li><li>对于一个长度为n的区间，线段树节点总个数<strong>小于等于4n</strong></li><li>存储到<strong>数组里面</strong>，对于<strong>下标x</strong> <ul><li><strong>父节点</strong> x/2 (下取整)，即是 <code>x&gt;&gt;1</code></li><li><strong>左子结点</strong>：2x ,即是 <code>x&lt;&lt;1</code></li><li><strong>右子结点：</strong>2x+1，即是 <code>x&lt;&lt;1|1</code></li></ul></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/30/7343b456185b338c.png" alt=""></p><ul><li>比如对于上述维护总和的操作有<ul><li><strong>单点修改</strong></li><li><strong>区间查询 O(logN</strong>)</li></ul></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pushup:用子结点信息 更新 当前节点的信息；可能有时候比较简单，直接写到别的函数内部去</span></span><br><span class="line"><span class="comment">//build：在一段区间上初始化线段树</span></span><br><span class="line"><span class="comment">//modify：修改操作</span></span><br><span class="line"><span class="comment">//query：查询操作</span></span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1264-动态求连续区间和（线段树求解）"><a href="#AcWing1264-动态求连续区间和（线段树求解）" class="headerlink" title="AcWing1264 动态求连续区间和（线段树求解）"></a>AcWing1264 动态求连续区间和（线段树求解）</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定一个数组，多个操作：<strong>修改某个元素</strong>，求子数组的<strong>连续和</strong></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>设计区间的单点修改和查询，考虑线段树</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line"><span class="keyword">int</span> l,r;<span class="comment">//左右边界 </span></span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line">}tr[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新当前节点u的信息 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">tr[u].sum=tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//u当前节点编号 l r左右边界 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(l==r) tr[u]={l,r,w[r]}; </span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">tr[u]={l,r};</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="comment">//加法的优先级高于移位 </span></span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//从u根节点编号开始查，l r要查询区间的左右边界 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line"><span class="comment">//lr已经将整个该节点包含在该lr区间内 </span></span><br><span class="line"><span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//否则，计算下当前节点内的中点 </span></span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//如果区间左边界在mid的左边,查询左子节点，注意这里都还是lr区间 </span></span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid)  sum=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r); </span><br><span class="line"><span class="comment">//如果区间有边界在mid的右边 </span></span><br><span class="line"><span class="keyword">if</span>(r&gt;mid)  sum+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">return</span> sum; </span><br><span class="line">}</span><br><span class="line"><span class="comment">//u当前的根节点编号 在x的位置加上v </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(tr[u].l==tr[u].r) tr[u].sum+=v;</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>,x,v);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">modify</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,x,v);</span><br><span class="line"><span class="built_in">pushup</span>(u);<span class="comment">//上面对u的子结点进行操作完毕后要更新u</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);<span class="comment">//记得要先建立线段树</span></span><br><span class="line"><span class="keyword">int</span> k,a,b;</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line">cin&gt;&gt;k&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>) cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,a,b)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">1</span>,a,b);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1270-数列区间求最大值"><a href="#AcWing1270-数列区间求最大值" class="headerlink" title="AcWing1270 数列区间求最大值"></a>AcWing1270 数列区间求最大值</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>一个数组，M个询问，每次查询第X到Y个数字的这个区间中的最大值</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>因为1≤N≤1e5，1≤M≤1e6，如果直接暴力，有M个询问，对于每个询问，遍历一遍x到y之间的数据，双重循环显然会爆，</li><li>但它涉及到对一个<strong>区间的查询</strong>，且根据数据范围可知时间复杂度最多<strong>为nlogn</strong>，所以考虑使用线段树</li></ul><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">int</span> zd;</span><br><span class="line">}tr[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">tr[u].zd=<span class="built_in">max</span>(tr[u&lt;&lt;<span class="number">1</span>].zd,tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].zd);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(l==r) tr[u]={l,r,w[r]};</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">tr[u]={l,r};<span class="comment">//当前节点u的左右边界是lr ！！</span></span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="comment">//建树的过程</span></span><br><span class="line">        <span class="comment">//建立左右子树</span></span><br><span class="line"><span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="comment">//更新节点</span></span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//从节点u开始，查询边界lr </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line"><span class="keyword">int</span> maxnum=INT_MIN;</span><br><span class="line"><span class="comment">//如果节点u包含在边界lr里面，意思是lr的范围比u的范围还大</span></span><br><span class="line"><span class="comment">//u从1开始，等价于返回值整个数组的最大值 </span></span><br><span class="line"><span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r) <span class="keyword">return</span> tr[u].zd;</span><br><span class="line"><span class="keyword">int</span> mid=tr[u].l+tr[u].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) maxnum=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line"><span class="keyword">if</span>(mid&lt;r) maxnum=<span class="built_in">max</span>(maxnum,<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r));</span><br><span class="line"><span class="keyword">return</span> maxnum;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">query</span>(<span class="number">1</span>,x,y));</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】动态规划</title>
      <link href="/2022/03/12/2022-03-12-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2022/03/12/2022-03-12-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容：<ul><li><strong>背包问题</strong><ul><li>01背包：每个物品只能<strong>选一次</strong>，二维优化成一维，第二层for<strong>逆序</strong>遍历；</li><li>完全背包：每种物品<strong>无限个</strong>，无限量选取，和01背包的不同–&gt;第二层for<strong>顺序</strong>遍历</li><li>多重背包：每种物品<strong>有限个</strong>，小数据：增加一层遍历个数的循环；大数据：<strong>二进制优化</strong>成01背包</li><li>分组背包：</li></ul></li><li>线性DP、区间DP</li></ul></li></ul><span id="more"></span><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/ceb293ff41829c0a.png" style="zoom:50%;"></p><ul><li><strong>动态规划</strong><ul><li><strong>状态表示</strong>：f（i，j）<ul><li>表示的集合是啥<ul><li>01背包里面表示的所有满足条件选法的集合</li><li>满足的条件<ul><li>只从前 i 个物品选</li><li>选出来的物品的总体积≤ j</li></ul></li></ul></li><li>表示的集合属性：<strong>最大值</strong>、最小值、数量<ul><li>01背包：f（i，j）的值是集合里面所有选法的总价值的最大值</li></ul></li></ul></li><li><strong>状态计算</strong>：集合的划分<ul><li>选法中不含第 i 个物品 f（ i - 1，j ）， 选法中含第 i 个物品（先把所有选法中 的第i个物品去掉，f（ i - 1，j - vi ）+ wi ，再加上；最终的f（i，j）== 二者中的最大者</li><li>原则：不重 （不一定非要满足） 不漏</li></ul></li></ul></li><li><strong>优化</strong><ul><li>一般都是对动态规划的代码（方程）做一个等价变形</li><li>所以先考虑基本的形式，再做优化</li></ul></li></ul><hr><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>N个物品，容量是V的背包</li><li>每个物品：体积v，价值w； 每个物品<strong>最多只能用一次</strong></li><li>从这N个物品挑几个使得 ：总体积≤V 且价值max</li><li><a href="https://www.bilibili.com/video/BV1Cf4y1R7Zz?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click">参考视频：0/1背包问题-动态规划 bilibili</a></li></ul><hr><h3 id="AcWing2-01背包问题（模板题）"><a href="#AcWing2-01背包问题（模板题）" class="headerlink" title="AcWing2 01背包问题（模板题）"></a>AcWing2 01背包问题（模板题）</h3><p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题 - AcWing题库</a></p><h4 id="代码（二维）"><a href="#代码（二维）" class="headerlink" title="代码（二维）"></a>代码（二维）</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> v[N],w[N]</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="comment">//状态表示：从前i个物品选出来价值不超过j的方案集合 </span></span><br><span class="line"><span class="comment">//属性：集合中价值最大值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line"><span class="comment">//初始化:dp[0~n][0]=0,dp[0][0~n]=0;这里可省略</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  <span class="comment">//放前i个物品 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){  <span class="comment">//体积不超过j </span></span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j]; <span class="comment">//一定可以不妨第i个物品</span></span><br><span class="line"><span class="comment">//如果要放第i个物品，必须当前物品体积小于j，说明能够放进去</span></span><br><span class="line"><span class="comment">//所以选择 不放进该物品 和 放进该物品 中取较大者 </span></span><br><span class="line"><span class="keyword">if</span>(j-v[i]&gt;=<span class="number">0</span>) dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>如果要知道哪几个背包放进去</strong>：</p><ul><li>用数组x[N]存是否放进去</li><li>参考视频：<a href="https://www.bilibili.com/video/BV1jT4y1o71J?spm_id_from=333.337.search-card.all.click">【动态规划秘籍】01背包、一维数组优化、完全背包bilibili</a><img src="https://i.bmp.ovh/imgs/2022/03/a2a62e99dbe531ac.png" style="zoom:40%;"></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j=m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line"><span class="keyword">if</span>(dp[i][j]&gt;dp[i<span class="number">-1</span>][j]){</span><br><span class="line">x[i]=<span class="number">1</span>;j=j-v[i];</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">x[i]=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">cout&lt;&lt;x[i]&lt;&lt;<span class="string">' '</span>;</span><br></pre></td></tr></tbody></table></figure><h4 id="代码（优化成一维）"><a href="#代码（优化成一维）" class="headerlink" title="代码（优化成一维）"></a>代码（优化成一维）</h4><ul><li>因为当前dp[i] [j]只依赖于该行前面的值和上一行的值，j严格递增，所以可以采用滚动数组，覆盖旧值</li><li>如果是j的遍历是顺序的话，那么之后的某个值的更新就用到的是新的值，而不是之前的旧值；<strong>所以要逆序</strong></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/cfb0e6853cd99acc.png" style="zoom:33%;"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  <span class="comment">//放前i个物品 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=v[i];j--){ <span class="comment">//放前i个物品的容量=j ;倒序</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    }</span><br><span class="line">cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br></pre></td></tr></tbody></table></figure><h3 id="AcWing3174-砝码称重"><a href="#AcWing3174-砝码称重" class="headerlink" title="AcWing3174 砝码称重"></a>AcWing3174 砝码称重</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>N个数中任意选择，每次选择出来的数字之和一共有多少种</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>有限个数的选择——&gt; 01背包问题</p><p><img src="https://i.bmp.ovh/imgs/2022/04/02/77c025a5b23ace54.png" style="zoom: 40%;"></p><ul><li>砝码可以放入左边或者右边，设所有砝码的总重量为m。说明重量 j 的取值范围为[ -m,m]</li><li>由于下标不能为负数，所以给所有j都加上一共偏移量N；大于N的j即为实际重量大于0的数</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">2</span>*N];</span><br><span class="line"><span class="keyword">bool</span> dp[<span class="number">105</span>][<span class="number">2</span>*N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n,m=<span class="number">0</span>;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">cin&gt;&gt;w[i];m+=w[i];</span><br><span class="line">} </span><br><span class="line"><span class="comment">//假设放在左边 砝码重量为负，放在右边为整数 </span></span><br><span class="line"><span class="comment">//dp[i][j]从前i个砝码中选出的重量为j的方案数量，值：是否存在 </span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>+N]=<span class="literal">true</span>;<span class="comment">//啥不选的方案存在 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=-m;j&lt;=m;j++){</span><br><span class="line">dp[i][j+N]=dp[i<span class="number">-1</span>][j+N];<span class="comment">//不选当前第i个砝码</span></span><br><span class="line"><span class="comment">//选当前第i个砝码</span></span><br><span class="line"><span class="comment">//选左边</span></span><br><span class="line"><span class="keyword">if</span>(j-(-w[i])&lt;=m) dp[i][j+N]|=dp[i<span class="number">-1</span>][j-(-w[i])+N];</span><br><span class="line"><span class="comment">//选右边,</span></span><br><span class="line"><span class="keyword">if</span>(j-w[i]&gt;=-m) dp[i][j+N]|=dp[i<span class="number">-1</span>][j-w[i]+N]; </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(dp[n][j+N]) ans++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="AcWing1234-倍数区间（再做一遍我也不会"><a href="#AcWing1234-倍数区间（再做一遍我也不会" class="headerlink" title="AcWing1234 倍数区间（再做一遍我也不会"></a>AcWing1234 倍数区间（再做一遍我也不会</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>给出的<strong>n个数中找3个数</strong>，使得这3个数的和是K的倍数，且这个和最大</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><font color="red">背包问题实质上就是：组合问题求最优解</font><p><strong>给定一堆元素，从中选出一些物品，在满足某种要求的前提（限制条件）下，得到一个最优值</strong></p><p><strong>限制条件</strong>：3个数，K的倍数</p><p>状态表示里面，一般<strong>一个限制就是一维</strong></p><p><img src="https://i.bmp.ovh/imgs/2022/04/03/be558933e09481dd.png" style="zoom:50%;"></p><ul><li>优化：对于( a + b + c )%k；求出数组里面每个数模k的余数，余数相同的为一组，每组取最大的三个数据</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ul><li><p><strong>如果该题的数据范围不那么大</strong>的话(一般思路，虽然过不了)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">10</span>,M=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">5</span>][M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="comment">//从前i个数选0个数模k等于0的方案是存在的，且值=0;</span></span><br><span class="line"><span class="comment">//而...不等于0的方案是不合法的，不能让它等于0</span></span><br><span class="line"><span class="comment">//因此，赋为最小值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++){</span><br><span class="line">dp[i][j][k]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][k],</span><br><span class="line">dp[i<span class="number">-1</span>][j<span class="number">-1</span>][((k-a[i])%m+m)%m]+a[i]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans,dp[i][<span class="number">3</span>][<span class="number">0</span>]);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>但是这个题的数据范围就是很大，上面dp过不了 所以要优化一下</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//放弃了，这道题解没看懂woc，以后再写</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><font color="red">总结：对比完全背包和01背包的区别</font><ul><li>二维</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);<span class="comment">//01背包</span></span><br><span class="line"></span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j],f[i][j-v[i]]+w[i]);<span class="comment">//完全背包问题</span></span><br></pre></td></tr></tbody></table></figure><ul><li>一维：只有第二层for循环的顺序不同；01背包是逆序，完全背包是正序</li></ul><p><strong>完全背包的特点</strong>：</p><ul><li>每种物品有<strong>无限个</strong></li><li>一般思路：<a href="https://www.acwing.com/solution/content/5345/">图片来源</a><img src="https://i.bmp.ovh/imgs/2022/03/c6822f5a883c96fa.png" style="zoom:50%;"></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){<span class="comment">//从前i种物品选择</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++){<span class="comment">//总体积不大于j</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k*v[i]&lt;=j;k++)<span class="comment">//每种物品可以选k个</span></span><br><span class="line">     dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br></pre></td></tr></tbody></table></figure><ul><li>优化一下：</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/cf17394aaa99fae9.png" style="zoom:50%;"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++){</span><br><span class="line">        dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line"><span class="keyword">if</span>(v[i]&lt;=j){</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>再优化成一维</li><li>理解对比和01背包的遍历顺序：<ul><li>01背包问题中，在j - v[i]体积的情况下，里面不能存在v[i]这个物品，也就是说在求状态dp[j]的时候，dp[j -v[i]]还不能被更新过（<strong>后面的计算要用到前面的变量，所以在更新后面的时候，前面的数据不能变，所以从后往前</strong>），所以dp[j -v[i]]要放在dp[j]后更新，用递减循环的方式实现这个功能。</li><li>若内层循环顺序进行的话，就代表了在j-v[i]体积的情况下，里面还存有v[i]这个物品，对于同一件物品，会计算多次，直到有其他物品加入满足最优解 大于一件被计算多次后的值为止。–&gt; 完全背包</li></ul></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j = v[i] ; j&lt;=m ;j++)<span class="comment">//注意了，这里的j是从小到大枚举，和01背包的唯一不一样</span></span><br><span class="line">   {</span><br><span class="line">           f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="多重背包的特点"><a href="#多重背包的特点" class="headerlink" title="多重背包的特点"></a><strong>多重背包的特点</strong></h4><ul><li>每种物品有<strong>有限个</strong></li></ul><hr><h4 id="小数据的简单做法"><a href="#小数据的简单做法" class="headerlink" title="小数据的简单做法"></a>小数据的简单做法</h4><ul><li>dp[ i ] [ j ]: 选前i种物品且总体积为 j 的方案的集合；方案的数量</li><li>状态转移，第i种物品选0，1，2 . . . .s[i]个 </li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s[i]&amp;&amp;k*s[i]&lt;=j;k++){</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-v[i]*k]+w[i]*k);</span><br></pre></td></tr></tbody></table></figure><hr><h4 id="二进制优化版：二进制分组-01背包"><a href="#二进制优化版：二进制分组-01背包" class="headerlink" title="二进制优化版：二进制分组+01背包"></a><strong>二进制优化版</strong>：<font color="red">二进制分组+01背包</font></h4><ul><li><p>第  i  种物品有s个，就可以把<strong>这 s 个物品拆分成 logs 组物品</strong>，每组有k个，对每组进行组合能够拼出所有0-s的任意数字</p></li><li><p>每组物品只能用一次；转换成<strong>01背包问题</strong>，<strong>注意状态数量的大小 N*logS</strong></p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;<span class="comment">//原来的N=1000 * logS=12 </span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> s[N],v[N],w[N];</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//二进制分完组后，每个值都只能选一个，cnt记录一共有多少个可选 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,s;cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">1</span>;<span class="comment">//将某个数量s分组，k=1,2,4,8,16...</span></span><br><span class="line"><span class="keyword">while</span>(k&lt;=s){</span><br><span class="line">cnt++;</span><br><span class="line">v[cnt]=a*k; <span class="comment">//体积</span></span><br><span class="line">w[cnt]=b*k; <span class="comment">//价值</span></span><br><span class="line">s-=k;</span><br><span class="line">k*=<span class="number">2</span>; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(s&gt;<span class="number">0</span>){</span><br><span class="line">cnt++;v[cnt]=a*s;w[cnt]=b*s;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line"><span class="keyword">if</span>(j-v[i]&gt;=<span class="number">0</span>)</span><br><span class="line">dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><ul><li>物品N组，每组物品有<strong>若干个</strong>，每组里面<strong>最多选一个</strong></li><li>关于这几种背包，写<code>dp[i][j]=max(dp[i][j],dp[i-1][j-xx]+yy)</code>，如果括号里面后者当<strong>某个下标==0 能够包含不选第i种物品的情况</strong>，可以直接就这么写，如果不能包含，就要先加一句<code>dp[i][j]=dp[i-1][j]</code>然后再<code>if xxx</code>，<code>dp[i][j]=max(dp[i][j],dp[i-1][j-xx]+yy)</code></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> s[N];<span class="comment">//存储每组物品的数量</span></span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N],dp[N][N];</span><br><span class="line"><span class="comment">//v[i][j]:第i组第j个物品的体积 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">cin&gt;&gt;s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)</span><br><span class="line">cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//遍历,从前i组物品中选 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s[i];k++)<span class="comment">//从这组物品里选一个 </span></span><br><span class="line"> <span class="comment">//if不能放在上面的for里面，不然会直接break掉，</span></span><br><span class="line"> <span class="comment">//导致不会++ 就不会遍历该组后面的物品，</span></span><br><span class="line"> <span class="comment">//然而该组后面的物品的体积可能小于等于j是能够满足条件的</span></span><br><span class="line"><span class="keyword">if</span>(j-v[i][k]&gt;=<span class="number">0</span>)</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="数字三角形模型"><a href="#数字三角形模型" class="headerlink" title="数字三角形模型"></a>数字三角形模型</h1><h2 id="AcWing898-数字三角形"><a href="#AcWing898-数字三角形" class="headerlink" title="AcWing898 数字三角形"></a>AcWing898 数字三角形</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/900/">898. 数字三角形 - AcWing题库</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>整个过程中在不断做决策，到达某一点时，它要么从左上方来到该点，要么从右上方来到该点；注意考虑边缘的情况，初始化dp数组为最小值；注意dp数组的含义，达到路径之和最大并不是一定会走到dp[ N ] [ M ]整个点，而是在最后一行中取最大值</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],dp[N][N];</span><br><span class="line"><span class="comment">//dp(i,j)：走到i，j的路径的集合；值为走到i,j的路径之和最大值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) cin&gt;&gt;a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i+<span class="number">1</span>;j++)</span><br><span class="line">dp[i][j]=-INF;</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+a[i][j];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> res=-INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">res=<span class="built_in">max</span>(res,dp[n][j]);</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1015-摘花生"><a href="#AcWing1015-摘花生" class="headerlink" title="AcWing1015 摘花生"></a>AcWing1015 摘花生</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/0f3b1eda54789be3.png" style="zoom:30%;"></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> t,R,C,dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--){</span><br><span class="line">cin&gt;&gt;R&gt;&gt;C;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=R;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=C;j++){</span><br><span class="line">cin&gt;&gt; dp[i][j];</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+dp[i][j];</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[R][C]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1027-方格取数"><a href="#AcWing1027-方格取数" class="headerlink" title="AcWing1027 方格取数"></a>AcWing1027 方格取数</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>NxN的方格，<strong>从左上走到右下</strong>，可以取走方格里的数，取走了数就变成0，能<strong>走两次</strong>。求走两次取得的数字之和最大值</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ul><li><p>走两次，可以看成同时走，<code>dp[i1,j1,i2,j2]</code>：从（1，1）走到（i1，j1）以及同时从（1，1）走到（i2，j2）的取的数字总和最大值</p></li><li><p>因为同一个格子可能走两次，数字被取两次，而只有当i1+j1==i2+j2 的时候，才可能走到同一个各自，所以四维可以优化成三维<code>dp[k,i1,i2]</code>；</p></li><li><p>k用来表示：走到（i1,k-i1) (i2,k-i2)；即横纵坐标之和，取值为[2,n+n];</p><p><img src="https://i.bmp.ovh/imgs/2022/04/08/4b8d5a420acf6bd1.png" style="zoom: 67%;"></p></li></ul><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> w[N][N],dp[<span class="number">2</span>*N][N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> r,c,v;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;r&gt;&gt;c&gt;&gt;v,r||c||v) w[r][c]=v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n+n;k++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i1=<span class="number">1</span>;i1&lt;=n;i1++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i2=<span class="number">1</span>;i2&lt;=n;i2++){</span><br><span class="line"><span class="keyword">int</span> j1=k-i1,j2=k-i2;</span><br><span class="line"><span class="keyword">if</span>(j1&gt;=<span class="number">1</span>&amp;&amp;j1&lt;=n&amp;&amp;j2&gt;=<span class="number">1</span>&amp;&amp;j2&lt;=n){</span><br><span class="line"><span class="keyword">int</span> t=w[i1][j1];</span><br><span class="line"><span class="keyword">if</span>(i1!=i2) t+=w[i2][j2];</span><br><span class="line"><span class="keyword">int</span>&amp; d=dp[k][i1][i2];</span><br><span class="line">d=<span class="built_in">max</span>(d,dp[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2<span class="number">-1</span>]+t);<span class="comment">//下下 </span></span><br><span class="line">d=<span class="built_in">max</span>(d,dp[k<span class="number">-1</span>][i1][i2]+t); <span class="comment">//右右</span></span><br><span class="line">d=<span class="built_in">max</span>(d,dp[k<span class="number">-1</span>][i1][i2<span class="number">-1</span>]+t); <span class="comment">//右下 </span></span><br><span class="line">d=<span class="built_in">max</span>(d,dp[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2]+t);<span class="comment">//下右 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[n+n][n][n]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing275传纸条"><a href="#AcWing275传纸条" class="headerlink" title="AcWing275传纸条"></a>AcWing275传纸条</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>NxN的方格，每个方格里有个数，一条路径从左上到右下，另一条路径从右下到走上。求走两次取得的数字之和最大值</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ul><li>一条路径从左上到右下，另一条路径从右下到走上；完全可以等价于从左上到右下走两次，</li></ul><p><a href="https://www.acwing.com/solution/content/51293/">AcWing 275. 传纸条【附详细证明】 - AcWing</a></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把方格取数那道题改改就好</span></span><br></pre></td></tr></tbody></table></figure><hr><h1 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h1><ul><li>DP的时间复杂度一般等于 <strong>状态数量 乘以 转移的计算量</strong></li><li><a href="https://www.acwing.com/solution/content/10499/">下图来源</a><img src="https://i.bmp.ovh/imgs/2022/03/042685e65e6af425.png" alt=""></li></ul><h2 id="AcWing-902-最短编辑距离"><a href="#AcWing-902-最短编辑距离" class="headerlink" title="AcWing 902 最短编辑距离"></a>AcWing 902 最短编辑距离</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/904/">902. 最短编辑距离 - AcWing题库</a></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><ul><li>将字符串A变成B有三种操作，每次都会选一种（决策），想知道不同决策的最优结果</li><li>dp[i] [j] 表示：<strong>将A的前i个字符变成B的前j个字符的</strong>操作集合；注意dp数组的初始化<ul><li>插入<code>dp[i][j-1]+1</code><ul><li>插入之后a[i]与b[j]完全匹配，所以插入的就是b[j] ，那插入之前a[1~i]和b[1~(j-1)]匹配</li></ul></li><li>删除<code>dp[i-1][j]+1</code><ul><li>删除a的第i个字符，那么前一个状态就是dp[i-1] [j] ,然后+1</li></ul></li><li>替换<code>dp[i-1][j-1]+1</code></li><li>如果<code>a[i]==b[j]</code>，啥也不干</li></ul></li></ul><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];<span class="comment">//dp[i][j]将A的前i个字母变成B的前j个字母的操作次数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a+<span class="number">1</span>;<span class="comment">//使得a从下标1开始存储 </span></span><br><span class="line">cin&gt;&gt;m&gt;&gt;b+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[<span class="number">0</span>][i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="comment">//删除or删除 </span></span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//or替换</span></span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>,dp[i][j]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1212-地宫寻宝"><a href="#AcWing1212-地宫寻宝" class="headerlink" title="AcWing1212 地宫寻宝"></a>AcWing1212 地宫寻宝</h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/1214/">1212. 地宫取宝 - AcWing题库</a></p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><blockquote><p>今天看到了橙子哥大佬的ppt上面的话，搬下来就是：</p><p> “    <strong>动态规划=分治+记录子问题答案</strong>以避免重复解决子问题带来的巨大开销。<br>      按照我的理解，对于<strong>一件要做 n 个决策</strong>的事情，我们想知道不同决策的最优结果（或不同决策的方案数）。如果枚举每个决策的不同选择，根据乘法原理，这样的方案数很大。而如果不同的决策能够到达的局面数较小，那么我们选择不去记录如何决策，而去<strong>记录到达某一个局面时的状态</strong>，以及思考当前这个局面，做了某个决策后<strong>会到达哪些局面</strong>。<br>     这样来看，动态规划并不是一种算法，而是一种能够解决一类问题的方法。   ”</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2022/03/8f0d3f67eec0b63f.png" style="zoom:35%;"></p><ul><li>回归正题，在这个题的过程中，要不断<strong>做决策</strong>——》 往下走or往右走 ，选当前宝贝or不选 ， 可以往动态规划的方向上思考</li><li>题目最终要求的是走到(n,m)，且选了k件宝贝，并且最大价值为c的方案数；</li><li>或许可以根据题目最终要达到的目的 来设置状态数组<code>dp[i][j][u][v]</code>:当走到(i,j)时,已选了u件且当前最大价值时 v 的方案数量 </li><li><strong>细节：</strong>物品的<strong>价值可以是0</strong>，在初始化时，对于在(1,1)位置，为了用0描述不选第一件物品，可以对所有物品价值做+1处理；如果方案数大于MOD，多于3个MOD相加会爆int，所以每两个方案数相加的时候都要模上MOD</li><li>对于<code>dp[i][j][u][v]</code>的状态转移<ul><li>走到（i，j）时，并没有选当前位置上的物品：<ul><li>从上往下 走到（i，j）：<code>dp[i-1][j][u][v]</code></li><li>从左往右 走到（i，j）:<code>dp[i][j-1][u][v]</code></li></ul></li><li>走到（i，j）时，<strong>若能够选上</strong>当前位置上的物品。说明在到（i，j）之前的最大价值c‘ 必须＜v，同时该物品的价值<code>v == w[i][j]</code>：<ul><li>从上往下 走到（i，j）：<code>dp[i-1][j][u-1][c']</code></li><li>从左往右 走到（i，j）:<code>dp[i][j-1][u-1][c']</code></li></ul></li></ul></li><li>最后对所有走到(n,m)，且选了k件宝贝，并且最大价值为1到C+1的方案数求和</li></ul><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">55</span>,M=<span class="number">15</span>,MOD=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,dp[N][N][M][M],w[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line">cin&gt;&gt;w[i][j]; w[i][j]++;</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;  <span class="comment">//不选第一件</span></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][w[<span class="number">1</span>][<span class="number">1</span>]]=<span class="number">1</span>; <span class="comment">//选第一件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;=k;u++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;M;v++){</span><br><span class="line">dp[i][j][u][v]=(dp[i][j][u][v]+dp[i<span class="number">-1</span>][j][u][v])%MOD;</span><br><span class="line">dp[i][j][u][v]=(dp[i][j][u][v]+dp[i][j<span class="number">-1</span>][u][v])%MOD;</span><br><span class="line"><span class="keyword">if</span>(v==w[i][j]&amp;&amp;u&gt;<span class="number">0</span>){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;w[i][j];c++){</span><br><span class="line">dp[i][j][u][v]=(dp[i][j][u][v]+dp[i<span class="number">-1</span>][j][u<span class="number">-1</span>][c])%MOD;</span><br><span class="line">dp[i][j][u][v]=(dp[i][j][u][v]+dp[i][j<span class="number">-1</span>][u<span class="number">-1</span>][c])%MOD;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;M;i++) ans=(ans+dp[n][m][k][i])%MOD;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1214-波动数列"><a href="#AcWing1214-波动数列" class="headerlink" title="AcWing1214 波动数列"></a>AcWing1214 波动数列</h2><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/1216/">1214. 波动数列 - AcWing题库</a></p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><ul><li><p><strong>首先知道一下同余式</strong>：</p><ul><li><p>设m是给定的一个正整数，a、b是整数：</p></li><li><p><strong>a和b被m除时有相同的余数</strong>：记为a≡b(mod m)，或记为a≡b(m)。这个式子称为模m的同余式</p></li><li><p>同余式一边的数可以移到另一边，只要改变符号就可以了。若</p><script type="math/tex; mode=display">a+b ≡ c (mod\quad m)</script><p> 则</p><script type="math/tex; mode=display">a≡c-b (mod\quad m)</script></li></ul></li><li><p>根据题意，假设数列第一个数是x，则依次有<code>x</code>，<code>x+d1</code>，<code>x+d1+d2</code>… … <code>x+d1+d2+...+d(n-1)</code> 之和 等于s，将其变换处理一下</p><script type="math/tex; mode=display">nx+(n-1)d_{1}+(n-2)d_{2}+(n-3)d_{3}+...+d_{n-1} = s</script><p>因为x可以是任意数，将其分离出来可得：</p><script type="math/tex; mode=display">x=\frac{s-((n-1)d_{1}+(n-2)d_{2}+(n-3)d_{3}+...+d_{n-1})}{n}</script><p>所以，只要<code>s%n</code> (已知)与<code>后面那坨%n</code> 同余即可</p><script type="math/tex; mode=display">s\%n == ((n-1)d_{1}+(n-2)d_{2}+(n-3)d_{3}+...+d_{n-1}) \%n</script></li><li><p>故就演变成了：给定n-1个<code>di</code>  ，取值只能是<code>+a</code> 或者<code>-b</code>，求如何选取这<code>n-1</code>个数 使得满足条件（就是一个组合问题，很像背包问题对叭对）</p></li><li><p>设 <code>dp[ i ][ j ]</code> 表示选了前i个数<code>di</code>（就是确定了对应每个位置是该+a还是-b），使得<code>i * di</code>之和 %n的余数等于 j  的方案数</p><blockquote><p>题目最终要求：选了n-1个di，使得<code>i * di</code> 之和%n的余数 等于s%n</p></blockquote></li><li><p>状态转移： <code>dp[ i ][ j ]</code> 已经选了  i - 1 个数，再选第 i 个数使得之和 %n的余数为 j 的：</p><ul><li>若确定当前要选的第i个数为 +a：<code>dp[i-1][?]</code></li><li>若确定当前要选的第i个数为 -b ：<code>dp[i-1][??]</code></li></ul></li><li><p>要确定？和？？，首先设选完前 i-1 个数 的和为 C，一共有n-1个数</p><ul><li>若第i个数为+a<ul><li><code>j ≡ C + (n-i)*a (mod n)</code> （同余式：左边和右边模上n有相同的余数</li><li>所以，<code>C ≡ j-(n-i)*a (mod n)</code> ; 同理可以分析-b的情况</li></ul></li></ul></li><li><p>总结<img src="https://i.bmp.ovh/imgs/2022/03/6f1cfb0567a79d94.png" style="zoom:25%;"></p></li></ul><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">100000007</span>;</span><br><span class="line"><span class="keyword">int</span> n,s,a,b,dp[<span class="number">1005</span>][<span class="number">1005</span>]; </span><br><span class="line"><span class="comment">//x%y要取正的余数 因为j=[1,n-1] </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMod</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line"><span class="keyword">return</span> (x%y+y)%y;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="comment">//dp[i][j]：前i项之和模n的余数 等于j的方案 数量</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//什么都不选是一种方案 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){  <span class="comment">//注意边界，i有n-1个</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){  <span class="comment">//余数 0~n-1</span></span><br><span class="line">dp[i][j]=(dp[i<span class="number">-1</span>][<span class="built_in">getMod</span>(j-(n-i)*a,n)]+dp[i<span class="number">-1</span>][<span class="built_in">getMod</span>(j+(n-i)*b,n)])%MOD;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[n<span class="number">-1</span>][<span class="built_in">getMod</span>(s,n)]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing899-编辑距离"><a href="#AcWing899-编辑距离" class="headerlink" title="AcWing899 编辑距离"></a>AcWing899 编辑距离</h2><h3 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h3><p><strong>n个</strong>长度不超过10的<strong>字符串</strong>，每次询问给出一个字符串和一个操作次数上限</p><p>针对每次询问，求这n个字符串中<strong>有多少个</strong> 字符<strong>串</strong>在上限操作次数内经过操作<strong>变成</strong>询问给出的字符串</p><p>操作：单个字符<strong>插入、删除、替换</strong></p><p>询问m次</p><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><ul><li>状态表示的是某一个区间</li></ul><h2 id="AcWing282-石子合并"><a href="#AcWing282-石子合并" class="headerlink" title="AcWing282 石子合并"></a>AcWing282 石子合并</h2><h3 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/284/">282. 石子合并 - AcWing题库</a></p><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><ul><li>将第1到N堆石子合并再一起，最后一步一定是将两堆合并在一起<ul><li>设<strong>dp[i] [j]</strong>：把第i到j堆合并在一起，那么最后的步骤是将<strong>第i到k堆和第k+1到 j 堆</strong>合并在一起，然后加上合并这两堆的代价（用前缀和求出）。</li></ul></li><li>区间遍历通常是：<strong>遍历区间长度+左端点</strong></li><li>将数组赋值最大<code>memset(a,0x3f,sizeof a);</code></li></ul><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> INF=<span class="number">1e9</span>; </span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="comment">//dp[i][j]:将第i到j堆合并的方案集合 </span></span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">cin&gt;&gt;s[i];s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">} </span><br><span class="line"><span class="comment">//for(int i=0;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//for(int j=0;j&lt;=n;j++) dp[i][j]=INF;</span></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][i]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//第一层遍历的是区间大小,“将一堆合并”并不需要代价 人家本来就是一堆 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++){  <span class="comment">//第二层遍历左端点 </span></span><br><span class="line"><span class="keyword">int</span> r=l+len<span class="number">-1</span>;  <span class="comment">//根据区间大小得到右端点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=r<span class="number">-1</span>;k++){  <span class="comment">//区间内遍历  </span></span><br><span class="line">dp[l][r]=<span class="built_in">min</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h1><h1 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h1><h1 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h1>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 数学 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】基础算法汇总</title>
      <link href="/2022/03/10/2022-03-10-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
      <url>/2022/03/10/2022-03-10-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>二分、前缀和、差分 、双指针、位运算、离散化、区间合并、归并排序</li></ul></li></ul><span id="more"></span><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><blockquote><p><em>22-03-10: 今天想起写个题,发现自己连二分都写得磕磕绊绊的,我焯, 是大煞笔</em></p></blockquote><ul><li><p>确定一个<strong>左闭右闭</strong>区间<code>[l,r]</code>，使得目标值在区间里面</p></li><li><p>找一个性质 ，满足两点</p><ul><li>性质 具有<strong>二段性</strong>（所有二分 都要成立</li><li>答案 一定是二段性的分界点</li></ul></li></ul><p>首先通过题目背景和check(mid)函数的逻辑，如果<code>if (check(mid))</code>条件成立，判断答案在左区间还是右区间</p><ul><li>如果答案在<strong>左区间</strong>并且mid也可能是答案👉第一种</li><li>如果答案在<strong>右区间</strong>并且mid也可能是答案👉第二种</li></ul><p>🔴<strong>第一种：</strong></p><ul><li>区间划分：<code>[l, mid] + [mid+1, r]</code></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; r){</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></tbody></table></figure><p>🔴第二种：</p><ul><li>区间划分：<code>[l, mid-1] + [mid, r]</code></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; r){</span><br><span class="line">    <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> l;</span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>整数二分的总结</strong></p><blockquote><p><em>y总说按这种写法可以完美避掉所有坑 //o//</em>:</p><p>首先通过题目背景和check(mid)函数的逻辑，判断答案落在左半区间还是右半区间。</p></blockquote><ul><li>找一个<strong>区间[L,R]</strong>使得答案一定在该区间中</li><li>找一个<strong>判断条件</strong>,使得该判断条件具有<strong>二段性</strong>,并且答案一定是该二段行的分界点</li><li>分析中点M在该判断条件下<strong>是否成立</strong>,如果成立or不成立,考虑答案在<strong>哪个区间</strong></li><li><font color="red">如果更新方式**R=Mid**,则**不用做任何处理**</font></li><li><font color="red">如果更新方式**L=Mid**,则需要在计算Mid时**先加上1**</font></li></ul></li><li><p>浮点二分，例如，<a href="https://www.acwing.com/problem/content/792/">AcWing 790. 求一个浮点数的三次方根 AcWing题库</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> l=<span class="number">-10000</span>,r=<span class="number">10000</span>,mid=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;<span class="number">1e-8</span>){</span><br><span class="line">    mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid*mid*mid&lt;n) l=mid;</span><br><span class="line">    <span class="keyword">else</span> r=mid;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.6f\n"</span>,r);</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="lower-bound-和-upper-bound-🔴"><a href="#lower-bound-和-upper-bound-🔴" class="headerlink" title="lower_bound() 和 upper_bound() 🔴"></a>lower_bound() 和 upper_bound() 🔴</h2><blockquote><p>利用二分查找方法在一个<strong>排好序的数组</strong>中进行查找，$O(logn)$</p></blockquote><p><code>lower_bound( begin, end, num)</code>：</p><ul><li>从数组下标<code>begin</code>到下标<code>end-1</code>位置二分查<strong>找第一个大于或等于num</strong>的数字</li><li>返回：该数字的<strong>地址</strong>，不存在则返回end。</li><li>例如：<code>int position=lower_bound(array,array+size,target)-array;</code></li></ul><p><code>upper_bound( begin, end, num)</code>：</p><ul><li><p>从数组下标<code>begin</code>到下标<code>end-1</code>位置二分查找<strong>第一个大于num</strong>的数字</p></li><li><p>返回：该数字的<strong>地址</strong>，不存在则返回end。</p></li></ul><p><code>lower_bound( begin, end, num, greater&lt;type&gt;() )</code>:</p><ul><li>从数组下标<code>begin</code>到下标<code>end-1</code>位置二分查找<strong>第一个小于或等于num</strong>的数字</li><li>例如：<code>int position=lower_bound(array,array+size,target,greater&lt;int&gt;())-array;</code></li></ul><p><code>upper_bound( begin, end, num, greater&lt;type&gt;() )</code></p><ul><li>从数组下标<code>begin</code>到下标<code>end-1</code>位置二分查找<strong>第一个小于num</strong>的数字</li></ul><h2 id="AcWing789-数的范围（模板题）"><a href="#AcWing789-数的范围（模板题）" class="headerlink" title="AcWing789 数的范围（模板题）"></a>AcWing789 数的范围（模板题）</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q--){</span><br><span class="line"><span class="keyword">int</span> k;<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>,R=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(L&lt;R){ <span class="comment">// 找第一个≥k 的数 </span></span><br><span class="line"><span class="keyword">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid]&gt;=k) R=mid;</span><br><span class="line"><span class="keyword">else</span> L=mid+<span class="number">1</span>;  </span><br><span class="line">}</span><br><span class="line"><span class="comment">//最终L==R,判断条件这里写RL都行 </span></span><br><span class="line"><span class="keyword">if</span>(a[R]==k){</span><br><span class="line">cout&lt;&lt;R&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">R=n<span class="number">-1</span>; </span><br><span class="line"><span class="comment">//找第一个≤k的数 </span></span><br><span class="line"><span class="keyword">while</span>(L&lt;R){</span><br><span class="line"><span class="keyword">int</span> mid=(L+R+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid]&lt;=k) L=mid; <span class="comment">//如果a[mid]≤k,说明 必然在[Mid,R]之间 </span></span><br><span class="line"><span class="keyword">else</span> R= mid<span class="number">-1</span>; <span class="comment">//R往右挪,所以- </span></span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;L&lt;&lt;endl;  </span><br><span class="line">}<span class="keyword">else</span> cout&lt;&lt;<span class="string">"-1 -1"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1227-分巧克力"><a href="#AcWing1227-分巧克力" class="headerlink" title="AcWing1227 分巧克力"></a>AcWing1227 分巧克力</h2><ul><li><a href="https://www.acwing.com/problem/content/1229/">1227. 分巧克力 - AcWing题库</a></li></ul><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>N个Hi乘Wi的方格组成的长方形，划分出K个大小相同且最大的正方形</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>一个HxW的长方形，分割成边长为x的正方形的块数：</p><script type="math/tex; mode=display">\lfloor\frac{H}{x}\rfloor\times\lfloor\frac{W}{x}\rfloor</script></li><li><p>随着x的增大，分割出的块数 减小，故 一定存在当x增大到值时，分割出的块数==K； 故可以采用二分<img src="https://i.bmp.ovh/imgs/2022/03/88a1d02c8e12586f.png" style="zoom:33%;"></p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// check=true是满足条件的，从0到x之间的部分，所以后面写的是l=mid</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> m)</span></span>{</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">sum+=(a[i][<span class="number">0</span>]/m)*(a[i][<span class="number">1</span>]/m);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(sum&gt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i][<span class="number">0</span>],&amp;a[i][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=N;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r){</span><br><span class="line"><span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(l==r) cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing730-机器人跳跃问题"><a href="#AcWing730-机器人跳跃问题" class="headerlink" title="AcWing730 机器人跳跃问题"></a>AcWing730 机器人跳跃问题</h2><p><a href="https://www.acwing.com/problem/content/732/">730. 机器人跳跃问题 - AcWing题库</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>N+1座建筑，第i座的高度H(i)，当在第k座时能量为E，跳到第k+1座后能量为E=2*E-H(k)；整个过程能力不能为负值，求最初能量最少是多少。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>对于某些题目提到求“最值”的问题，可以首先往二分的角度想一想=V=</li><li>设最初能量为e，随着e从小到大增加，一定能找到一个E，<ul><li>当初值＜E时，跳跃过程中存在能量值＜0 的情况；</li><li>当初值=E时，<strong>刚好 </strong>不存在能力值小于0的情况；</li><li>当初值＞E，同样也一定 不存在能力值＜0的情况，</li><li>当在中间的某一时刻能量值≥1e5的话后面必然不会存在＜0的情况，防止爆掉int，所以这里要判断一下</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//check==true：初始值为m 不会存在小于0的情况 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> m)</span></span>{</span><br><span class="line"><span class="keyword">int</span> e=m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">e=e*<span class="number">2</span>-a[i];</span><br><span class="line"><span class="keyword">if</span>(e&gt;N) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(e&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=N;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r){</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//求满足条件的最小值 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1221-四平方和"><a href="#AcWing1221-四平方和" class="headerlink" title="AcWing1221 四平方和"></a>AcWing1221 四平方和</h2><p><a href="https://www.acwing.com/problem/content/1223/">1221. 四平方和 - AcWing题库</a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><blockquote><p>参考：<a href="https://www.acwing.com/solution/content/31631/">AcWing 1221. 四平方和 + 自定义排序（重载&lt;）+二分 - AcWing</a></p></blockquote><h4 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h4><ul><li><p>重载运算符</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x：任意名字，node：结构体的名字</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;x) <span class="keyword">const</span>{</span><br><span class="line">    <span class="comment">//排序规则</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>比如下面结构体中的s,c,d</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Sum &amp;t) <span class="keyword">const</span>{</span><br><span class="line">    <span class="keyword">if</span>(s!=t.s) <span class="keyword">return</span> s&lt;t.s;</span><br><span class="line">    <span class="keyword">if</span>(c!=t.c) <span class="keyword">return</span> c&lt;t.c;</span><br><span class="line">    <span class="keyword">return</span> d&lt;t.d;</span><br><span class="line">}<span class="comment">//先比较s，如果s不同，则s小的结构体小；如果s相同但c不同，则c较小的结构体小....</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>sort自定义排序</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>{</span></span><br><span class="line">    <span class="keyword">int</span> s,c,d;</span><br><span class="line">}sum[<span class="number">2500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Sum a,Sum b)</span></span>{<span class="comment">//自定义函数排序,Sum是结构体名</span></span><br><span class="line">    <span class="keyword">if</span>(a.s==b.s) <span class="keyword">return</span> a.c&lt;b.c;</span><br><span class="line">    <span class="keyword">if</span>(a.c==b.c) <span class="keyword">return</span> a.d&lt;b.d;</span><br><span class="line">    <span class="keyword">return</span> a.s&lt;b.s;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);<span class="comment">//默认下标0~n-1升序</span></span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);<span class="comment">//默认下标1~n升序</span></span><br><span class="line"><span class="built_in">sort</span>(a,a+n,greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//降序</span></span><br><span class="line"><span class="built_in">sort</span>(a,a+n,cmp);<span class="comment">//自定义函数排序,重写cmp</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>把正整数n写成a,b,c,d这4个数平方和的形式，输出字典序最小的abcd升序排列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>如果暴力的话<ul><li>直接枚举abc（但会爆掉</li></ul></li><li>考虑空间换时间<ul><li>最先想的是先枚举ab保存下来再枚举cd，发现这样的话大小顺序有问题；</li><li>所以，先枚举cd，用结构体数组保存每一组s=c^2+d^2，c，d；升序排序</li><li>再枚举ab，a和b从小到大枚举，对于每一对ab，通过计算t = n-a <em> a-b </em> b，然后再通过<strong>二分</strong>从结构体数组中找第一个满足条件且cd最小的数</li></ul></li><li>说明<ul><li>首先枚举一定能保证a＜=b，c＜=d</li><li>是如何保证b＜=c的？<ul><li>假设存在答案a,b,c,d ，使得a＜b&gt;c＜d；那么一定有 a×a+b×b&gt;a×a+c×c，因此a,c应当比a,b先出现，枚举一定是先枚举出的ac而不是ab，与假设矛盾，故假设不成立（弄个例子画一下就理解了）</li></ul></li></ul></li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2500010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,t;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="keyword">int</span> s, c, d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Sum &amp;t)<span class="keyword">const</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (s != t.s) <span class="keyword">return</span> s &lt; t.s;</span><br><span class="line">        <span class="keyword">if</span> (c != t.c) <span class="keyword">return</span> c &lt; t.c;</span><br><span class="line">        <span class="keyword">return</span> d &lt; t.d;</span><br><span class="line">    }</span><br><span class="line">}sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(c=<span class="number">0</span>;c*c&lt;=n;c++){</span><br><span class="line"><span class="keyword">for</span>(d=c;d*d+c*c&lt;=n;d++){</span><br><span class="line">sum[cnt++]={c*c+d*d,c,d};</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">sort</span>(sum,sum+cnt);</span><br><span class="line"><span class="keyword">for</span>(a=<span class="number">0</span>;a*a&lt;=n;a++){</span><br><span class="line"><span class="keyword">for</span>(b=a;a*a+b*b&lt;=n;b++){</span><br><span class="line">t = n-a*a-b*b;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r = cnt<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r){</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//找满足性质的最小值</span></span><br><span class="line"><span class="keyword">if</span>(sum[mid].s&gt;=t) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(sum[l].s==t){</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>,a,b,sum[l].c,sum[l].d);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><ul><li>只能处理<strong>静态</strong>数组：<strong>只能查询</strong>不能修改</li><li>线状数组和树状数组可以修改</li></ul><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><h3 id="Acwing795-前缀和（模板题）"><a href="#Acwing795-前缀和（模板题）" class="headerlink" title="Acwing795 前缀和（模板题）"></a>Acwing795 前缀和（模板题）</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//给一个整数序列，求第l到第r个数的和</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> l,r; <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="AcWing1230-K倍区间"><a href="#AcWing1230-K倍区间" class="headerlink" title="AcWing1230 K倍区间"></a>AcWing1230 K倍区间</h3><p><a href="https://www.acwing.com/problem/content/1232/">1230. K倍区间 - AcWing题库</a></p><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>给定一组数列，求有多少个子序列的和 是k的倍数</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>首先想到的是双重循环+前缀和，时间复杂度n²，但是10^10会爆</li><li>然后考虑如何优化：<ul><li>假设用<code>S[i]</code>来表示前缀和数组，易知<code>Ai到Aj</code>的和为<code>S[R]-S[L-1]</code>  (L-1&lt;=R)</li><li><strong>关键</strong>：<code>(S[R] - S[L-1])%k==0</code> 等价于<code>(S[R]%k == S[L-1]%k)</code></li><li>所以可以考虑：<ul><li>遍历，对于一个当前时刻固定的R，计算该S[R]%k的值，看在该R之前的前缀和 有谁%k的值（即余数）与之相等</li><li>若相等，答案个数+1；设cnt[i]表示余数为i的个数</li><li>但是，并不是所有子序列都需要两个前缀和来获得，对于<code>S[R]%k==0</code> 的情况，它本身也满足条件，也该加进答案里面，所以这里一定要将<strong>cnt[0] = 1</strong>;</li><li>数据范围大，求和可能会爆int，所以<strong>用long long</strong></li></ul></li></ul></li></ul><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">LL s[N],cnt[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 2 3 4 5  原数字 </span></span><br><span class="line"><span class="comment">1 3 6 10 15  前缀和数组 </span></span><br><span class="line"><span class="comment">1 1 0 0  1   模k=2以后的余数数组  cnt[i]余数=i的个数 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i]+=s[i<span class="number">-1</span>]; </span><br><span class="line"></span><br><span class="line">LL ans=<span class="number">0</span>; cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">ans+=cnt[s[i]%k] ; <span class="comment">//这里理解下：对于当前第i个前缀和，它的余数是t=s[i]%k,cnt[t]则表示，在第i个前缀和之前的 余数也==t的个数；最初i=1，对于余数＞0的cnt[i]个数为0，随着循环更新增加 </span></span><br><span class="line">cnt[s[i]%k]++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><ul><li><p>前缀和矩阵的计算：</p><script type="math/tex; mode=display">S_{xy}=S_{x-1,y}+S_{x,y-1}-S_{x-1,y-1}+a_{x,y}</script></li><li><p>利用前缀和矩阵计算某个子矩阵（左上角(x1,y1) 到右下角(x2,y2)的和：</p><script type="math/tex; mode=display">S_{x_{2},y_{2}}-S_{x_{2},y_{1}-1}-S_{x_{1}-1,y_{2}}+S_{x_{1}-1,y_{1}-1}</script></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/858f026d6e85a7e3.png" style="zoom:50%;"></p><h3 id="AcWing796-子矩阵的和（模板题）"><a href="#AcWing796-子矩阵的和（模板题）" class="headerlink" title="AcWing796 子矩阵的和（模板题）"></a>AcWing796 子矩阵的和（模板题）</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//给定矩阵，求(x1,y1)到(x2,y2)的子矩阵的和</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q,a[N][N],s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);  <span class="comment">//前缀和矩阵</span></span><br><span class="line">s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(q--){</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s[x2][y2]-s[x1<span class="number">-1</span>][y2]-s[x2][y1<span class="number">-1</span>]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="AcWing99-激光炸弹"><a href="#AcWing99-激光炸弹" class="headerlink" title="AcWing99 激光炸弹"></a>AcWing99 激光炸弹</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p><a href="https://www.acwing.com/problem/content/101/">99. 激光炸弹 - AcWing题库</a></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>很明显是个二维前缀和的问题</li><li>一些注意点（内存限制所以这道题看起来简单<strong>但是细节好多aaaa</strong>（预判一波或许隔段时间再做也会做错QAQ）<ul><li>R的取值范围＞N的取值范围，当R超过N的取值范围，就相当于直接求矩阵的和</li><li>因为题目取值范围从0开始，为了方便，让坐标都+1，避免考虑边界问题</li><li>注意这道题的内存空间限制168M，所以只能开一个数组，5000*5000的数组已经占了95.36M</li><li>遍历的不是原矩阵的每个点，而是用r*r的正方形去遍历，框住那些点</li><li>……..</li></ul></li></ul><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5005</span>; </span><br><span class="line"><span class="keyword">int</span> n,r,s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;r);</span><br><span class="line">r=<span class="built_in">min</span>(<span class="number">5001</span>,r); <span class="comment">//这里只能是5001，因为正方形边长最大是5000，</span></span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="keyword">int</span> x,y,w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">x++,y++;  <span class="comment">//使所有坐标从1开始，避免考虑边界问题 </span></span><br><span class="line">s[x][y]+=w;  <span class="comment">//不同目标可以在同一个位置</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5001</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5001</span>;j++){</span><br><span class="line">s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+s[i][j];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&lt;=<span class="number">5001</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=r;j&lt;=<span class="number">5001</span>;j++){</span><br><span class="line"><span class="keyword">int</span> t=s[i][j]-s[i-r][j]-s[i][j-r]+s[i-r][j-r];</span><br><span class="line">ans=<span class="built_in">max</span>(ans,t);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>把原数组<strong>看称某个数组的前缀和</strong>，这个所谓的某个数组就是<strong>差分数组</strong></p><p>一般使用场景：</p><p><strong>给出 n 个数，再给出 m 个询问，每个询问给出 l，r，x，要求你在 l 到 r 上每一个值都加上 x，而只给你 O(n) 的时间范围</strong></p><p>它是对一个<strong>区间的操作</strong>，并非单点修改or区间查询</p><p>数组下标一般<strong>从1 开始</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">比如给定数组a <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">构造差分数组b <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">（下标从<span class="number">1</span>开始）要在a[<span class="number">2</span>]到a[<span class="number">4</span>]中加上<span class="number">2</span>:变成<span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line">    即对差分数组操作即可，</span><br><span class="line">    对b[<span class="number">2</span>]+=<span class="number">2</span>；注意是b[<span class="number">2</span>]不是b[<span class="number">1</span>]</span><br><span class="line">    然后对b[<span class="number">4</span>+<span class="number">1</span>]-=<span class="number">2</span>；得到 <span class="number">1</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">-1</span>；</span><br><span class="line">    最后求差分数组的前缀和：<span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">5</span>；</span><br></pre></td></tr></tbody></table></figure><h2 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h2><h3 id="AcWing797-差分（模板题）"><a href="#AcWing797-差分（模板题）" class="headerlink" title="AcWing797 差分（模板题）"></a>AcWing797 差分（模板题）</h3><ul><li>关于差分数组b的构造（代码18行），也可以写成<code>insert(i,i,a[i])</code>：可以把初始原数组a看成全0，那么差分数组b也是全0，给数组赋初值等效于n次插入操作</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="comment">//关键方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">b[l]+=c;</span><br><span class="line">b[r+<span class="number">1</span>]-=c;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">b[i]=a[i]-a[i<span class="number">-1</span>];   <span class="comment">//构造差分数组</span></span><br><span class="line">} </span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> l,r,c;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line"><span class="built_in">insert</span>(l,r,c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">a[i]=a[i<span class="number">-1</span>]+b[i];</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h2><h3 id="AcWing798-差分矩阵（模板题）"><a href="#AcWing798-差分矩阵（模板题）" class="headerlink" title="AcWing798 差分矩阵（模板题）"></a>AcWing798 差分矩阵（模板题）</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">b[x1][y1]+=c;</span><br><span class="line">b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line"><span class="comment">//b[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]; </span></span><br><span class="line"><span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(q--){</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2,c;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;</span><br><span class="line"><span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line">a[i][j]=a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[i][j];</span><br><span class="line">cout&lt;&lt;a[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>在利用双指针算法解题时,<strong>考虑原问题如何用暴力算法</strong>解出,观察<strong>是否可构成单调性</strong>,若可以,就可采用<strong>双指针算法优化</strong>；注意分析哪个是快指针，哪个是慢指针</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">while</span>(j&lt;x&amp;&amp;<span class="built_in">check</span>(i,j)) j++;</span><br><span class="line">    <span class="comment">//每道题的具体逻辑</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>核心思想：每个指针的移动次数不超过n，算法复杂度O(N)</li><li>例如，分割每个单词<code>abc def ghi</code></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">gets</span>(s);</span><br><span class="line"><span class="keyword">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> j=i;</span><br><span class="line"><span class="keyword">while</span>(j&lt;n&amp;&amp;s[j]!=<span class="string">' '</span>)j++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++) cout&lt;&lt;s[k];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">i=j;</span><br><span class="line">}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing799-最长连续不重复子序列"><a href="#AcWing799-最长连续不重复子序列" class="headerlink" title="AcWing799 最长连续不重复子序列"></a>AcWing799 最长连续不重复子序列</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给定一个长度为 n的整数序列，请找出<strong>最长的不包含重复的数</strong>的<strong>连续</strong>区间，输出它的<strong>长度</strong>。</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ul><li>例如对于<code>1 4 2 3 2 5</code>，初始i和j都指向1，j向右移动，同时用一个计数数组count[]记录ij指向的区间内的数字出现的次数</li><li>当j移动到a[4]时，发现2出现了两次，所以<strong>此时i要向右移动到第一个2出现位置的右边</strong>；</li><li>由于count[]记录了<strong>区间ij</strong>之间各个数字出现的次数，每当i向右移动，区间ij发生变化。</li><li>比如当前i指向a[0]，接下来i打算右移，则a[0]不在ij区间内了，所以对应count数组中存放的该值的个数-1，当移动到第一个2时，同样-1，i后移，这时2的个数=1，那么刚好此时i指向的就是第一个2后面的第一个位置</li></ul><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> a[N],cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,i=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">cnt[a[j]]++;</span><br><span class="line"><span class="keyword">while</span>(cnt[a[j]]&gt;<span class="number">1</span>){</span><br><span class="line">cnt[a[i]]--;</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">ans=<span class="built_in">max</span>(ans,j-i+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing800-数组元素的和"><a href="#AcWing800-数组元素的和" class="headerlink" title="AcWing800 数组元素的和"></a>AcWing800 数组元素的和</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>两个升序数组，求a[i]+b[j]==x的坐标（i，j）</p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,x;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) cin&gt;&gt;b[j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=m<span class="number">-1</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;a[i]+b[j]&gt;x) j--;</span><br><span class="line"><span class="keyword">if</span>(a[i]+b[j]==x){</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">' '</span>&lt;&lt;j;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1238-日志统计"><a href="#AcWing1238-日志统计" class="headerlink" title="AcWing1238 日志统计"></a>AcWing1238 日志统计</h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line">PII a[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">int</span> n,d,k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;d,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);</span><br><span class="line"><span class="comment">//i遍历时间 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">cnt[a[i].y]++;</span><br><span class="line"><span class="keyword">while</span>(a[i].x-a[j].x&gt;=d){</span><br><span class="line">cnt[a[j].y]--;</span><br><span class="line">j++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(cnt[a[i].y]&gt;=k) st[a[i].y]=<span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++){</span><br><span class="line"><span class="keyword">if</span>(st[i]) cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1240-完全二叉树的权值"><a href="#AcWing1240-完全二叉树的权值" class="headerlink" title="AcWing1240 完全二叉树的权值"></a>AcWing1240 完全二叉树的权值</h2><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line">LL maxx=LONG_MIN,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">1</span>,i=<span class="number">1</span>;i&lt;=n;i=i*<span class="number">2</span>,d++){</span><br><span class="line">LL s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+(<span class="number">1</span>&lt;&lt;d<span class="number">-1</span>)&amp;&amp;j&lt;=n;j++)</span><br><span class="line">s+=w[j];</span><br><span class="line"><span class="keyword">if</span>(s&gt;maxx){</span><br><span class="line">maxx=s;</span><br><span class="line">ans=d;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="n的二进制表示中第k位数字是啥"><a href="#n的二进制表示中第k位数字是啥" class="headerlink" title="n的二进制表示中第k位数字是啥"></a>n的二进制表示中第k位数字是啥</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">15</span> = 二级制：<span class="number">1111</span></span><br><span class="line"><span class="comment">//先把n(十进制）的第k位(二进制）数字右移到最后一位 n&gt;&gt;k</span></span><br><span class="line"><span class="comment">//此时的最后一位是几：x&amp;1</span></span><br><span class="line">    </span><br><span class="line">n&gt;&gt;k&amp;<span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="lowbit-树状数组的一个基本操作"><a href="#lowbit-树状数组的一个基本操作" class="headerlink" title="lowbit()树状数组的一个基本操作"></a>lowbit()树状数组的一个基本操作</h2><ul><li>返回的是一个<strong>二进制</strong>，这个二进制是x二级制<strong>从右往左的第一个1及其后面的0</strong></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1010</span>;<span class="built_in">lowbit</span>(x)=<span class="number">10</span>;</span><br><span class="line">x = <span class="number">101000</span>;<span class="built_in">lowbit</span>(x)=<span class="number">1000</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>实现</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(x)</span></span>{</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>应用：可以<strong>统计x里面1的个数</strong></li></ul><hr><h2 id="AcWing801-二进制中1的个数"><a href="#AcWing801-二进制中1的个数" class="headerlink" title="AcWing801 二进制中1的个数"></a>AcWing801 二进制中1的个数</h2><h3 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h3><p>给定一个数组，求每个数组元素的二进制表示中1的个数</p><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">x=10101,lowbit(x)=1</span></span><br><span class="line"><span class="comment">x-lowbit(x)=10100,lowbit(x)=100</span></span><br><span class="line"><span class="comment">x-lowbit(x)=10000,lowbit(x)=10000</span></span><br><span class="line"><span class="comment">x-lowbit(x)=0;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x){</span><br><span class="line">x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">res++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing90-64位整数乘法"><a href="#AcWing90-64位整数乘法" class="headerlink" title="AcWing90 64位整数乘法"></a>AcWing90 64位整数乘法</h2><h3 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h3><p>求a*b mod c ;其中a，b&lt;=1e18</p><h3 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h3><ul><li>直接算会long long</li></ul><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><hr><h1 id="离散化-整数"><a href="#离散化-整数" class="headerlink" title="离散化(整数)"></a>离散化(整数)</h1><ul><li><p>序列（值域）<strong>范围很大</strong>，但实际数的<strong>个数很少</strong>，（有些题目我们可能要以这些数为下标来做</p><blockquote><p>比如数的范围是０－１０＾９，但只有很少的数，比如２，４５４３，３２１３１２３.．．</p></blockquote></li><li><p>所以我们可能将这些数 <strong>映射到从0开始的连续自然数</strong></p></li><li><p>又举一个栗子，比如<strong>有序</strong>数组<code>a[]={1,3,100,2000,500000}</code>，我们可以把它<strong>映射</strong>到<code>0 1 2 3 4</code></p></li><li><p>离散化的本质就是<strong>映射</strong>，<font color="red">将间隔很大的点，映射到相邻的数组元素中，减少对空间的需求和计算量</font></p></li><li><p>问题</p><ul><li>a中可能有重复元素——<font color="red">去重</font></li><li>如何算出a中某个值x <strong>离散化后的值</strong>是多少——<font color="red">二分</font></li></ul></li></ul><p><strong>去重代码</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls;<span class="comment">//存储所有待离散化的值（坐标）</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls,<span class="built_in">end</span>()); <span class="comment">//将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>( <span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()) , alls.<span class="built_in">end</span>() ) <span class="comment">//去掉重复元素</span></span><br></pre></td></tr></tbody></table></figure><p><strong>二分代码</strong>：求出坐标x对应的<strong>离散化后的值</strong>：即找到<strong>第一个＞=x</strong>的位置（坐标）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r){</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( alls[mid] &gt;= x ) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>;<span class="comment">//+1:映射到1到n；不加：0到n</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing802-区间和"><a href="#AcWing802-区间和" class="headerlink" title="AcWing802 区间和"></a>AcWing802 区间和</h2><h3 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h3><p>给定<strong>无限长</strong>的数轴，所有点初始（该坐标点上面的值）=0（其实数据范围规定从（即数轴坐标）-10^9-10^9)</p><p>n个操作，每次操作选择一个下标，把上面的数<strong>加上c</strong></p><p>m次询问，区间lr之间的<strong>所有数</strong>的和</p><h3 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h3><p><a href="https://www.acwing.com/solution/content/2321/">参考题解</a></p><ul><li><p>如果数据范围比较小，就可以用<strong>前缀和</strong></p></li><li><p>但是数据范围<strong>跨度很大</strong>，而涉及到（<strong>所用到）数的个数很少</strong>，绝大部分坐标没有用到</p></li><li><p>因为<strong>下标很大，且存在负值</strong>，直接开数组很不现实</p></li><li><p>故：先<strong>离散化</strong>，把所有用到的下标把它们<strong>映射</strong>到从<strong>1开始</strong>（因为后面要用到前缀和计算区间和，所以从1开始）的自然数</p></li><li><p>针对<strong>m次加法</strong>（涉及1个坐标）和<strong>n次查询</strong>（涉及2个坐标），n和m的数据范围在10^5以内，所以可能涉及到的<strong>最多</strong>的坐标个数为<strong>3*10^5</strong>；由此确定映射数组的大小—-&gt;所以先要把这些坐标都下来，离散化之后，根据对应操作进行处理</p></li></ul><h3 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],s[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls;</span><br><span class="line"><span class="comment">//alls 存放原本的数轴上的坐标 </span></span><br><span class="line">vector&lt;PII&gt;add,query;</span><br><span class="line"><span class="comment">//add 暂时存放加操作；query暂时存放查询操作 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r){</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(alls[mid]&gt;=x) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> r+<span class="number">1</span>;<span class="comment">//将原坐标x映射到1-alls.size()的里面的某个坐标 </span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> x,c;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;c;</span><br><span class="line">add.<span class="built_in">push_back</span>({x,c});<span class="comment">//存储加法操作 </span></span><br><span class="line">alls.<span class="built_in">push_back</span>(x); <span class="comment">//存储原坐标 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">query.<span class="built_in">push_back</span>({l,r}); <span class="comment">//存储查询操作 </span></span><br><span class="line">alls.<span class="built_in">push_back</span>(l);<span class="comment">//存储原坐标 </span></span><br><span class="line">alls.<span class="built_in">push_back</span>(r); <span class="comment">//存储原坐标 </span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//在存储坐标时，可能会有重复的，所以首先去重：先排序 </span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//排完序后，unique把alls的无重复数字放在alls数组里的前面，</span></span><br><span class="line"><span class="comment">//重复的放在数组里的后面，unique返回的是这个分界点的指针</span></span><br><span class="line"><span class="comment">//erase去除重复的元素；最终可以确定实际操作的坐标的个数 </span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//对vector从头遍历（当然也可以用普通的for循环） </span></span><br><span class="line"><span class="comment">//加法： </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> item:add){</span><br><span class="line"><span class="keyword">int</span> x=<span class="built_in">find</span>(item.first);<span class="comment">//将坐标进行映射 </span></span><br><span class="line">a[x]+=item.second;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++) s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> item:query){</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">find</span>(item.first),r=<span class="built_in">find</span>(item.second);</span><br><span class="line">cout&lt;&lt;s[r]-s[l<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><h2 id="AcWing803-区间合并"><a href="#AcWing803-区间合并" class="headerlink" title="AcWing803 区间合并"></a>AcWing803 区间合并</h2><h3 id="题意-12"><a href="#题意-12" class="headerlink" title="题意"></a>题意</h3><p>给定多个区间，如果两个区间<strong>有交集</strong>的话，就把它<strong>合并</strong>成同一个区间；（合并所有有交集单点区间），端点相交也算；求合并完后区间的数量</p><h3 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h3><ul><li>所有区间按照左端点排序</li><li>扫描过程中，将所有有交集的区间合并</li></ul><h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>分治：确定<strong>分界</strong>点mid=l+r&gt;&gt;1划分成两个子区间、<strong>递归</strong>排序左右、<strong>合并</strong>左右</p><p>归并排序是稳定的，时间复杂度nlogn</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,q[N],tmp[N];</span><br><span class="line"><span class="comment">//分界+递归+归并 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line"><span class="comment">//cout&lt;&lt;"in"&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;<span class="comment">//结束状态</span></span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(q,l,mid),<span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r){</span><br><span class="line"><span class="keyword">if</span>(q[i]&lt;=q[j]) tmp[k++]=q[i++];</span><br><span class="line"><span class="keyword">else</span> tmp[k++]=q[j++];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line"><span class="comment">//注意是把数组q的l到r排序，注意i的循环范围 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q[i]);</span><br><span class="line"><span class="built_in">merge_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,q[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing788-逆序对的数量"><a href="#AcWing788-逆序对的数量" class="headerlink" title="AcWing788 逆序对的数量"></a>AcWing788 逆序对的数量</h2><h3 id="题意-13"><a href="#题意-13" class="headerlink" title="题意"></a>题意</h3><p>求给定数组逆序对的数量，数组元素的取值[0,1e9]</p><h3 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h3><p>最先开始想的是用之前学过的树状数组做，确实，如果元素的取值范围没那么大的话是可以过的；</p><p>所以再复习了一遍归并排序的做法</p><p>将逆序对分为三大类：两个数同时出现再左半边；两个数同时出现再右半边；一个数在左，一个数在右</p><p>假设归并排序能将整个区间<strong>排好序</strong>并且<strong>返回每个区间内部逆序对</strong>的个数</p><p>因此所有逆序对的数目就是三类逆序对个数之和</p><p><img src="https://i.bmp.ovh/imgs/2022/04/04/512964478b395eda.png" style="zoom:50%;"></p><p>对于一个在左，一个在右的这种情况：对于右半边的每个元素，去找左半边有多少个元素大于它</p><p>左右部分都<strong>排好序</strong>之后，在归并的时候，假设左半边指针i，右半边指针j；当i大于j的时候，对于在右半边j指向的元素x，在左半边就有mid-i+1个数大于它，即找到</p><h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N],tmp[N];</span><br><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">LL res=<span class="built_in">merge_sort</span>(l,mid)+<span class="built_in">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="comment">//此时左右两边已经排好序 </span></span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r){</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;=a[j]) tmp[k++]=a[i++];</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">tmp[k++]=a[j++];</span><br><span class="line">res+=mid-i+<span class="number">1</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid) tmp[k++]=a[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r)tmp[k++]=a[j++];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) a[i]=tmp[j];</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">cout&lt;&lt;<span class="built_in">merge_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二分 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 差分 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【题解】递推（几道翻转类题目）</title>
      <link href="/2022/03/09/2022-02-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E9%80%92%E6%8E%A8%EF%BC%88%E5%87%A0%E9%81%93%E7%BF%BB%E8%BD%AC%E7%B1%BB%E9%A2%98%E7%9B%AE%EF%BC%89/"/>
      <url>/2022/03/09/2022-02-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E9%80%92%E6%8E%A8%EF%BC%88%E5%87%A0%E9%81%93%E7%BF%BB%E8%BD%AC%E7%B1%BB%E9%A2%98%E7%9B%AE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-116-飞行员兄弟"><a href="#AcWing-116-飞行员兄弟" class="headerlink" title="AcWing 116 飞行员兄弟"></a>AcWing 116 飞行员兄弟</h1><p><a href="https://www.acwing.com/problem/content/description/118/">题目链接</a></p><h2 id="大意"><a href="#大意" class="headerlink" title="大意:"></a>大意:</h2><ul><li>4 x 4 翻转一个元素的话，顺带着所在行和列全跟着翻转；求全部翻转过来的步数和步骤</li></ul><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>如果枚举的话，2&lt;&lt;16次，复杂度还能够接受，可以枚举</li><li>枚举每个操作opt，每个操作opt的值转换成16位二进制，<ul><li>对于每个opt，要移位16次，每次右移取最低位 ,当==1表示翻转</li><li>注意翻转i行j列的时候，(i,j)被翻转了两次，记得恢复</li><li>储存符合条件的操作的位置，用vector存</li></ul></li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li><p>vector</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义： vector&lt;元素类型&gt; 名称；例如： vector&lt;PII&gt; vec;</span><br><span class="line">翻转： <span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">大小： vec.<span class="built_in">size</span>();</span><br><span class="line">清空： vec.<span class="built_in">clear</span>();</span><br><span class="line">插入： vec.<span class="built_in">push_back</span>(pi);</span><br></pre></td></tr></tbody></table></figure></li><li><p>for区间遍历 (C++11)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:vec){</span><br><span class="line">    cout&lt;&lt;i.x&lt;&lt;<span class="string">' '</span>&lt;&lt;i.y&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>pair</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second 方便</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">PII pi; pi.first, pi.second</span><br></pre></td></tr></tbody></table></figure></li><li><p>memcpy</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *str1, <span class="keyword">const</span> <span class="keyword">void</span> *str2, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">str1：目的 str2：源 n：字节数</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>二进制数i的第k位是否==1</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i&gt;&gt;k&amp;<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="简洁版代码"><a href="#简洁版代码" class="headerlink" title="简洁版代码"></a>简洁版代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> ch[N][N],backup[N][N]; </span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; vec; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++){</span><br><span class="line"><span class="keyword">if</span>(backup[i][k]==<span class="string">'+'</span>) backup[i][k]=<span class="string">'-'</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][k]=<span class="string">'+'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(backup[k][j]==<span class="string">'+'</span>) backup[k][j]=<span class="string">'-'</span>;</span><br><span class="line"><span class="keyword">else</span> backup[k][j]=<span class="string">'+'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">'+'</span>) backup[i][j]=<span class="string">'-'</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][j]=<span class="string">'+'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</span><br><span class="line">cin&gt;&gt;ch[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> opt=<span class="number">0</span>;opt&lt;(<span class="number">2</span>&lt;&lt;<span class="number">16</span>);opt++){</span><br><span class="line"><span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(backup,ch,<span class="keyword">sizeof</span> ch);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++){</span><br><span class="line"> <span class="keyword">if</span>(opt&gt;&gt;i&amp;<span class="number">1</span>){</span><br><span class="line"><span class="keyword">int</span> row=(<span class="number">16</span>-i<span class="number">-1</span>)/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> col= <span class="number">4</span>-i%<span class="number">4</span>;</span><br><span class="line"><span class="built_in">turn</span>(row,col);</span><br><span class="line"> step++;</span><br><span class="line"> PII pi; pi.first=row;pi.second=col;</span><br><span class="line"> vec.<span class="built_in">push_back</span>(pi);</span><br><span class="line"> } </span><br><span class="line"> } </span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++){</span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">'+'</span>){</span><br><span class="line">flag=<span class="literal">false</span>; vec.<span class="built_in">clear</span>();</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(flag){</span><br><span class="line">cout&lt;&lt;step&lt;&lt;endl;</span><br><span class="line"><span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>()); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">cout&lt;&lt;vec[i].first&lt;&lt;<span class="string">' '</span>&lt;&lt;vec[i].second&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="废话版代码"><a href="#废话版代码" class="headerlink" title="废话版代码"></a>废话版代码</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">最初想到的思路，参照“费解的开关”这道题</span></span><br><span class="line"><span class="comment">枚举，16个位置 有2^16种情况</span></span><br><span class="line"><span class="comment">枚举二进制 0到2^16-1</span></span><br><span class="line"><span class="comment">对于每种情况，对原状态数组进行操作 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> ch[N][N],backup[N][N]; </span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII; <span class="comment">//pair的用法；又是一个被我遗忘的东西，笑嘻</span></span><br><span class="line">vector&lt;PII&gt; vec; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++){</span><br><span class="line"><span class="keyword">if</span>(backup[i][k]==<span class="string">'+'</span>) backup[i][k]=<span class="string">'-'</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][k]=<span class="string">'+'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(backup[k][j]==<span class="string">'+'</span>) backup[k][j]=<span class="string">'-'</span>;</span><br><span class="line"><span class="keyword">else</span> backup[k][j]=<span class="string">'+'</span>;</span><br><span class="line">}   <span class="comment">//当时写的时候，就差点忘记(i,j)的位置翻转了两次，所以下面要再翻回去</span></span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">'+'</span>) backup[i][j]=<span class="string">'-'</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][j]=<span class="string">'+'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</span><br><span class="line">cin&gt;&gt;ch[i][j];</span><br><span class="line"></span><br><span class="line"><span class="comment">//一共有2&lt;&lt;16次操作，枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> opt=<span class="number">0</span>;opt&lt;(<span class="number">2</span>&lt;&lt;<span class="number">16</span>);opt++){</span><br><span class="line"><span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//memcpy复制数组，不用写双重循环 </span></span><br><span class="line"><span class="built_in">memcpy</span>(backup,ch,<span class="keyword">sizeof</span> ch);</span><br><span class="line"><span class="comment">//for(int kk=1;kk&lt;=4;kk++)</span></span><br><span class="line"><span class="comment">//for(int jj=1;jj&lt;=4;jj++)</span></span><br><span class="line"><span class="comment">//backup[kk][jj]=ch[kk][jj];</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"> <span class="comment">//对于每个opt，移位16位 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++){</span><br><span class="line"> <span class="keyword">if</span>(opt&gt;&gt;i&amp;<span class="number">1</span>){ <span class="comment">//取最低位 ,如果==1的话就翻转；</span></span><br><span class="line"> <span class="comment">//例如：0000 0000 0000 0001；最先是1，</span></span><br><span class="line"> <span class="comment">//第0个对应(4,4) 第1个对应(4,3)</span></span><br><span class="line"><span class="keyword">int</span> row=(<span class="number">16</span>-i<span class="number">-1</span>)/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> col= <span class="number">4</span>-i%<span class="number">4</span>;</span><br><span class="line"><span class="built_in">turn</span>(row,col);</span><br><span class="line"> step++;</span><br><span class="line"> PII pi; pi.first=row;pi.second=col;</span><br><span class="line"> vec.<span class="built_in">push_back</span>(pi);</span><br><span class="line">                <span class="comment">//试了一下样例</span></span><br><span class="line"><span class="comment">// if(opt==45067){</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;"step== "&lt;&lt;step&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// for(int i=1;i&lt;=4;i++){</span></span><br><span class="line"><span class="comment">//for(int j=1;j&lt;=4;j++)</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;backup[i][j];</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;endl; </span></span><br><span class="line"><span class="comment">//}</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"> } </span><br><span class="line"> } </span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++){</span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">'+'</span>){</span><br><span class="line">flag=<span class="literal">false</span>; vec.<span class="built_in">clear</span>(); <span class="comment">//清空vector;</span></span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag){</span><br><span class="line">cout&lt;&lt;step&lt;&lt;endl;</span><br><span class="line"><span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());   <span class="comment">//vector的用法忘了，用重新复习下下</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">cout&lt;&lt;vec[i].first&lt;&lt;<span class="string">' '</span>&lt;&lt;vec[i].second&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 递推 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语老师Lee的每日听力练习笔记</title>
      <link href="/2022/03/09/2022-03-09-%E8%8B%B1%E8%AF%AD%E8%80%81%E5%B8%88Lee%E7%9A%84%E5%90%AC%E5%8A%9B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/09/2022-03-09-%E8%8B%B1%E8%AF%AD%E8%80%81%E5%B8%88Lee%E7%9A%84%E5%90%AC%E5%8A%9B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>主要内容</strong><ul><li>每天十分钟的听力练习笔记</li><li>只是<strong>谨防自己三分钟热度</strong>所以敦促自己每天听的手段QAQ，随便记记而已</li></ul></li></ul><span id="more"></span><h1 id="22-03-09"><a href="#22-03-09" class="headerlink" title="22-03-09"></a>22-03-09</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/a29c5982022c9b64.png" style="zoom: 50%;"></p><ul><li>单词<ul><li>scooter ：小摩托车</li><li>eyepatch：眼罩</li><li>pink eye：红眼，急性结膜炎</li><li><strong>greasy </strong>  <ul><li>含义：沾油脂的，油污的；含脂肪的，<strong>油腻的</strong>；油性的；滑的；<strong>圆滑的，虚情假意的</strong></li><li>可以用来形容食物 、头发</li></ul></li></ul></li><li>发音<ul><li>your –》 yer</li><li>lot of –》 lotta</li></ul></li></ul><h1 id="22-03-10"><a href="#22-03-10" class="headerlink" title="22-03-10"></a>22-03-10</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/388e55c499064533.png" style="zoom:40%;"></p><ul><li>单词<ul><li>drug trial 药物实验</li><li>guinea pig<ul><li>豚鼠</li><li>a person used in medical or other experiments <strong>实验对象</strong></li></ul></li><li><strong>roll the side effects dice :冒着副作用的风险</strong><ul><li><strong>roll the dice</strong>：掷骰子， 可以引申为孤注一掷</li></ul></li><li><strong>hallucination</strong>：幻觉<ul><li>[həˌluːsɪˈneɪʃn]</li><li>A hallucination is a fact, not an error; what is erroneous is a judgment based upon it.</li></ul></li></ul></li></ul><h1 id="22-03-11"><a href="#22-03-11" class="headerlink" title="22-03-11"></a>22-03-11</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/6a1c902edfa52be8.png" style="zoom:50%;"></p><ul><li>单词<ul><li>take advantage of<ul><li>之前经常 +sth 当作“充分利用”的正面词汇，类似还有比如take advantage of sb：占某人便宜</li></ul></li></ul></li></ul><h1 id="22-03-12"><a href="#22-03-12" class="headerlink" title="22-03-12"></a>22-03-12</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/668ebb46963226bf.png" style="zoom:45%;"></p><ul><li>单词<ul><li>benefit<ul><li><strong>慈善晚会</strong></li><li>benefit concert 慈善音乐会</li></ul></li><li>up for：愿意参与某活动<ul><li>It`s exciting because it is very much <strong>up for grabs</strong><ul><li>工作、奖金、机会等 等待你去<strong>争取，赢取</strong></li></ul></li></ul></li><li>reprise：重复、重演、重奏、<strong>重现</strong><ul><li>A study which I now reprise for you now from a 2001 article</li></ul></li></ul></li></ul><h1 id="22-03-13"><a href="#22-03-13" class="headerlink" title="22-03-13"></a>22-03-13</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/8579559b6e1fed1b.png" style="zoom:50%;"></p><ul><li><strong>unwind</strong><ul><li>== relax</li></ul></li><li>a full day off：一整个休息日<ul><li>take a day off</li></ul></li><li><strong>of late:</strong> 最近，近来<ul><li>Religious oppression is another big issue that we`ve seen <strong>of late</strong></li><li>你最近都在忙什么：what`s been taken up your day as of late</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语听力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIP-1-数字图像基础</title>
      <link href="/2022/03/06/2022-03-06-DIP-1-%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/06/2022-03-06-DIP-1-%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>【主要内容】</p><ul><li>数字图像的概念及表示</li><li>图像获取</li><li>图像数字化(Digitization)</li><li>不同类型的数字图像</li><li>图像基本性质<ul><li>图像平均值Image Mean .</li><li>图像对比度Image Contrast</li><li>图像直方图Image Histogram</li><li>图像的熵Image Entropy</li><li>自适应直方图Adaptive Histogram</li></ul></li><li>直方图的应用</li></ul><span id="more"></span><h1 id="数字图像的概念及表示"><a href="#数字图像的概念及表示" class="headerlink" title="数字图像的概念及表示"></a>数字图像的概念及表示</h1><ul><li><strong>图像</strong>：三维场景 到 二维平面的一个投影<ul><li>表示一幅图像：二维函数f（x,y)<ul><li>任意一对空间坐标（<strong>x，y</strong>）处的<strong>幅值  f</strong> ：图像在该点的 强度或灰度</li></ul></li></ul></li><li><strong>数字图像</strong>：x 和 y 和 f 都是 <strong>有限的离散量</strong><ul><li>由有限数量的像素组成  —–》每个像素对应 一个（x，y）和一个f</li></ul></li><li><strong>数字图像的表示</strong>：二维矩阵  <img src="https://i.bmp.ovh/imgs/2022/03/91bd075dd44a0604.png" style="zoom: 33%;"></li></ul><h1 id="图像获取"><a href="#图像获取" class="headerlink" title="图像获取"></a>图像获取</h1><h1 id="图像数字化（Digitization）"><a href="#图像数字化（Digitization）" class="headerlink" title="图像数字化（Digitization）"></a>图像数字化（Digitization）</h1><ul><li><p>数字化的两个过程<strong>：取样 + 量化</strong></p></li><li><p><strong>取样</strong></p><ul><li><p>即：对空间坐标<strong>x 和 y</strong>进行数字化</p></li><li><p>取样间隔必须满足 <strong>Nyquist条件</strong>：x和y方向的<font color="green">取样频率</font>必须 <strong>大于</strong>图像在 x 和 y 方向 <font color="green">最高频率</font>的两倍</p><ul><li><p>为什么要满足：确保取样以后的信号能<font color="orange">完全恢复</font>出原来的连续信号</p></li><li><p>低于这个条件，会产生<strong>混叠</strong>（Aliasing）</p><blockquote><p>什么是混叠？</p></blockquote></li></ul></li></ul></li><li><p><strong>量化</strong></p><ul><li>对<strong>灰度值 f</strong> 进行数字化</li></ul></li></ul><h1 id="不同类型的数字图像"><a href="#不同类型的数字图像" class="headerlink" title="不同类型的数字图像"></a>不同类型的数字图像</h1><p>暂略…</p><h1 id="图像基本性质"><a href="#图像基本性质" class="headerlink" title="图像基本性质"></a>图像基本性质</h1><h2 id="图像平均值-Image-Mean"><a href="#图像平均值-Image-Mean" class="headerlink" title="图像平均值 Image Mean"></a>图像平均值 Image Mean</h2><ul><li>图像平均值 = 像素之和 / 像素总个数 ，图像平均值 ↑ 👉图像亮度 ↑</li><li>公式如下：</li></ul><script type="math/tex; mode=display">I_{av} = \frac{\sum_{i} \sum_{j}I(i,j)}{\sum_i\sum_j1}</script><h2 id="图像对比度-Image-Contrast"><a href="#图像对比度-Image-Contrast" class="headerlink" title="图像对比度 Image Contrast"></a>图像对比度 Image Contrast</h2><ul><li><p>对比度是 图像复杂度的一种体现</p></li><li><p>首先，引入对比度的<strong>度量方式</strong>：</p><ul><li><p><strong>全局定义方式</strong>（统计学角度）：</p><p>（灰度）最大偏差</p><script type="math/tex; mode=display">max \left\{I(x,y) \right\} - min\left\{I(x,y)\right\}</script><p>（灰度）方差：</p><script type="math/tex; mode=display">var\left\{I(x,y)\right\}=mean\left\{(I(x,y)-I_{av})_{}^{2}\right\}</script><p>（灰度）标准差</p><script type="math/tex; mode=display">std\left\{I(x,y)\right\}=\sqrt{var\left\{I(x,y)\right\}}</script><p>   全局定义方式的<strong>缺点</strong>：不能感知局部结构，没有体现人类的视觉敏感性</p></li><li><p>（韦伯）<strong>局部对比度</strong></p><ul><li>．图像点的局部对比度表示<strong>该图像点(point)的 强度</strong> 与其 <strong>邻域(neihborhood) 强度</strong>之间的(相对)差:<script type="math/tex; mode=display">C=|\frac{I_{p}-I_{n}}{I_{n}}|</script></li></ul></li></ul></li></ul><h2 id="图像直方图-Image-Histogram"><a href="#图像直方图-Image-Histogram" class="headerlink" title="图像直方图 Image Histogram"></a>图像直方图 Image Histogram</h2><ul><li>直方图：用来表达一幅图像灰度级分布情况的统计表</li><li>横坐标→ 灰度级r； 纵坐标 ↑ 灰度值为r的像素个数n或者出现的概率p（r）</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/3829be80550cf6d6.png" style="zoom:50%;"></p><ul><li><p>直方图<strong>不是一对一</strong>的映射关系  —&gt; 图像的直方图不能完全代表图像</p><ul><li>因此：直方图只能体现数据的统计特性，没有结构特点。</li><li>比如：将一张图的像素随机扰乱，直方图仍然是不变的<img src="https://i.bmp.ovh/imgs/2022/03/aa18aac1c82e01a2.png" style="zoom:50%;"></li></ul></li><li><p>直方图的<strong>用处</strong>：分析图像对比度的好坏</p><ul><li><strong>给定图像，算出图像平均值和标准差</strong><img src="https://i.bmp.ovh/imgs/2022/03/05bad86faafba1d7.png" style="zoom:65%;"></li></ul></li></ul><h2 id="图像的-熵-Image-Entropy"><a href="#图像的-熵-Image-Entropy" class="headerlink" title="图像的 熵 Image Entropy"></a>图像的 熵 Image Entropy</h2><ul><li><p>图像的熵的公式 (它是大于0的):</p><script type="math/tex; mode=display">Entropy(I) = -\sum_{k}P(k)logP(k)</script><ul><li>图像的熵表示图像值 的<strong>不确定性</strong></li><li>均匀分布：<strong>熵max</strong>；集中分布在某一处：<strong>熵min</strong></li><li>不频繁的事件比频繁的事件提供更多的信息</li><li>熵 是 直方图 <strong>离散度 </strong>的度量</li></ul></li></ul><h2 id="自适应直方图-Adaptive-Histogram"><a href="#自适应直方图-Adaptive-Histogram" class="headerlink" title="自适应直方图 Adaptive Histogram"></a>自适应直方图 Adaptive Histogram</h2><ul><li>在许多情况下，图像中的<strong>局部</strong>区域需要直方图<ul><li>比如:：模式检测、自适应增强、自适应阈值</li></ul></li><li>图像模糊<strong>不改变图像平均值</strong><ul><li>而是会<strong>减小方差、减小熵</strong></li></ul></li></ul><h1 id="直方图的应用"><a href="#直方图的应用" class="headerlink" title="直方图的应用"></a>直方图的应用</h1><ul><li><p>应用</p><ul><li>测量图像特性:平均值、方差、熵、对比度、区域(对于给定的灰度范围)</li><li><strong>阈值选择</strong> <strong>Threshold selection</strong></li><li>图像的距离</li><li>图像增强<ul><li><strong>直方图均衡化</strong></li><li><strong>直方图拉伸</strong></li><li><strong>直方图匹配</strong></li></ul></li></ul></li><li><p>阈值<strong>分割</strong>：</p><ul><li><p>阈值选取的基本规律：两个峰之间的谷底</p><p><img src="https://i.bmp.ovh/imgs/2022/03/7575a89fe2de9213.png" style="zoom:50%;"></p></li></ul></li><li><p>图像的<strong>距离</strong></p><ul><li><p>问题:给定两幅图像A和B，其(归一化)直方图为Pa和Pb，定义图像之间的距离D(A,B)。</p><ul><li><strong>Minkowski距离</strong>： 存在的问题：距离可能 <strong>不能反映感知到的差异</strong></li></ul><script type="math/tex; mode=display">D_{p}(A,B)=[\sum_{k}|P_{A}(k)-P_{B}(k)|]^{1/p}</script><ul><li><strong>KL距离（散度）</strong>：非对称，同样面临Minkowski距离的缺点</li></ul><script type="math/tex; mode=display">D_{KL}(A||B)=\sum_{k}P_{A}(k)log\frac{P_{A}(k)}{P_{B}(k)}</script></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理Digital Image Processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小世界网络</title>
      <link href="/2022/02/26/2022-02-26-%E5%B0%8F%E4%B8%96%E7%95%8C%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/02/26/2022-02-26-%E5%B0%8F%E4%B8%96%E7%95%8C%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<ul><li>关于小世界网络—— 一种特殊的<strong>复杂网络</strong></li><li>随机性<strong>介于</strong> 随机网络和规则耦合网络<strong>之间</strong></li><li>适合模拟<strong>真实</strong>网络系统</li><li>其概念, 简单说是描述这样的一个事实:<ul><li>尽管一些网络系统有<strong>很大</strong>的尺寸, 但其中<strong>任意两个节点</strong>之间却有一个<strong>相对小</strong>的距离。</li></ul></li><li>小世界特征：比较<strong>短</strong>的<strong>平均距离</strong> + 相对较<strong>大</strong>的<strong>集聚系数</strong></li></ul><span id="more"></span><h1 id="两种常见的小世界网络"><a href="#两种常见的小世界网络" class="headerlink" title="两种常见的小世界网络"></a>两种常见的小世界网络</h1><h2 id="NW小世界网络"><a href="#NW小世界网络" class="headerlink" title="NW小世界网络"></a>NW小世界网络</h2><ul><li><strong>实现方式</strong>：<strong>规则耦合网络 </strong>上进行 <strong>随机加边</strong></li></ul><h2 id="WS小世界网络"><a href="#WS小世界网络" class="headerlink" title="WS小世界网络"></a>WS小世界网络</h2><ul><li><strong>实现方式</strong>：<strong>规则耦合网络</strong>上进行<strong>随机重连</strong></li></ul><blockquote><p>参考文献：</p><p><a href="">[1]赵小林,徐浩,薛静峰,宋天凌,胡晶晶,闫怀志.基于复杂网络的网络系统脆弱点发现方法研究[J].信息安全学报,2019,4(01):39-52.DOI:10.19363/J.cnki.cn10-1380/tn.2019.01.04.</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 信安赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复杂网络 </tag>
            
            <tag> 文献笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂网络中重要节点、脆弱节点的检查、挖掘方法</title>
      <link href="/2022/02/25/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E3%80%81%E8%84%86%E5%BC%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%A3%80%E6%9F%A5%E3%80%81%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/"/>
      <url>/2022/02/25/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E3%80%81%E8%84%86%E5%BC%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%A3%80%E6%9F%A5%E3%80%81%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>针对区块链网络和分布式系统的，网络脆弱节点的挖掘检测：</p><p>​    给定一个<strong>区块链网络</strong>，里边有很多节点，不同的<strong>配置、位置、算力</strong>，如何找到哪个节点是<strong>更重要</strong>、<strong>更脆弱</strong>。</p></blockquote><ul><li><p>从<strong>攻</strong>的角度，那就可以作为<strong>攻击目标</strong>。</p><blockquote><p>对节点的攻击：1. 随机攻击 2.蓄意攻击</p><p>随机攻击–&gt;即使很多节点失效崩溃，但整个网络仍可保持连通</p><p>蓄意攻击–&gt;针对度很大的节点，网络就变得脆弱，可能崩溃</p></blockquote></li><li><p>从<strong>防</strong>的角度，就是需要加强<strong>保护和完善</strong>的脆弱点</p></li></ul><span id="more"></span><h1 id="复杂网络中重要性节点发掘综述"><a href="#复杂网络中重要性节点发掘综述" class="headerlink" title="复杂网络中重要性节点发掘综述"></a>复杂网络中重要性节点发掘综述</h1><blockquote><p>阅读文献来源：</p><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2007&amp;filename=JSJA200712003&amp;uniplatform=NZKPT&amp;v=4M8fbSr9Jag8kRTp3gVwrqO7hkHjgcLxJ-HaeSp7dV_5lHNIpjut1rRC0PRykSht">复杂网络中重要性节点发掘综述 - 中国知网 (cnki.net)</a></p></blockquote><ul><li><p>该篇论文解决的问题：</p><p>复杂网络环境下几个领域中发掘重要性节点的方法</p></li></ul><h2 id="发掘复杂网络重要节点的三种方法"><a href="#发掘复杂网络重要节点的三种方法" class="headerlink" title="发掘复杂网络重要节点的三种方法"></a>发掘复杂网络重要节点的三种方法</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><hr><h1 id="基于复杂网络的网络系统脆弱点发现研究方法"><a href="#基于复杂网络的网络系统脆弱点发现研究方法" class="headerlink" title="基于复杂网络的网络系统脆弱点发现研究方法"></a>基于复杂网络的网络系统脆弱点发现研究方法</h1><blockquote><p>阅读文献来源：</p><p><a href="">[1]赵小林,徐浩,薛静峰,宋天凌,胡晶晶,闫怀志.基于复杂网络的网络系统脆弱点发现方法研究[J].信息安全学报,2019,4(01):39-52.DOI:10.19363/J.cnki.cn10-1380/tn.2019.01.04.</a></p></blockquote><ul><li><p>该篇论文解决的问题：</p><ul><li>大量节点 加大了攻击图 的计算量 ，产生<strong>状态爆炸</strong>问题，限制了攻击图技术现实应用</li><li>因此，兼顾准确性&amp;&amp;<strong>减少计算量</strong>&amp;&amp;利用复杂网络的拓扑统计性质  <ul><li>寻找 脆弱点—&gt;达到目的：寻找<strong>更大规模</strong>（1000/10000以上）网络的脆弱点 </li></ul></li><li>提出了  对节点删除法的<strong>改进</strong></li></ul><hr></li></ul><ul><li><p>复杂网络 —&gt; 节点的集合 —&gt; 拥有自己的<strong>独立特征</strong>&amp;&amp;与其他个体有<strong>相互连接</strong>关系的节点</p></li><li><p>什么是脆弱节点?</p><ul><li><p><strong>受攻击</strong>后能引起网络性能<strong>大幅度下降</strong>的节点</p><ul><li><p>什么是网络性能?</p><ul><li>网络的<strong>连通性</strong>（网络能否正常工作）、平均最短路径（网络执行效率）等</li></ul></li></ul></li></ul></li></ul><h2 id="寻找脆弱节点的两种思路"><a href="#寻找脆弱节点的两种思路" class="headerlink" title="寻找脆弱节点的两种思路"></a>寻找脆弱节点的两种思路</h2><h3 id="思路一：网络中心性反映脆弱性"><a href="#思路一：网络中心性反映脆弱性" class="headerlink" title="思路一：网络中心性反映脆弱性"></a>思路一：网络中心性反映脆弱性</h3><ul><li><p><strong>中心性指标</strong></p><ul><li><p><strong>度中心性</strong></p><ul><li><p>归一化度值 <strong>越大，节点越重要</strong></p></li><li><script type="math/tex; mode=display">归一化度值=\frac{节点的度(与节点相连的其他节点个数)}{最大可能的度(N-1)}</script></li></ul></li></ul></li></ul><ul><li><p><strong>介数中心性</strong></p><ul><li><p>介数中心性 反映–&gt;节点在网络中的<strong>枢纽</strong>地位；通过该节点最短路径<strong>越多，节点越重要</strong></p><script type="math/tex; mode=display">介数=\frac{经过该节点的最短路径 条数}{所有最短路径 条数}</script></li><li><script type="math/tex; mode=display">介数中心性=\frac{某节点介数}{介数最大值}</script></li></ul></li></ul><ul><li><p><strong>接近度中心性</strong></p><ul><li>接近度：节点到其他节点 最短路径之和的倒数；<strong>越小越重要</strong></li><li>接近度中心性 = 某节点接近度  * （N-1）<ul><li>反映–&gt;节点通过网络到其他节点的<strong>影响能力</strong></li></ul></li></ul></li><li><p><strong>特征向量中心性</strong></p><ul><li>反映了节点间的<strong>相互影响</strong></li><li>反映了重要性和 <strong>连接的边数目</strong>有关、和<strong>连接的节点的重要性</strong>有关、连接重要的节点可<strong>提升</strong>自身节点的重要性</li></ul></li></ul><hr><h3 id="思路二：节点脆弱性-删除节点后对网络系统的破坏性"><a href="#思路二：节点脆弱性-删除节点后对网络系统的破坏性" class="headerlink" title="思路二：节点脆弱性 == 删除节点后对网络系统的破坏性"></a>思路二：节点脆弱性 == 删除节点后对网络系统的破坏性</h3><p> “核与核度”理论：</p><ul><li><p><strong>系统的“核”</strong>：</p><ul><li>给定的系统，若<strong>去掉or破坏</strong>其中若干个主要素，对系统<strong>破坏性最大</strong>的 这若干个主要素</li><li>—&gt; 可以：研究<strong>删除节点</strong>后对网络的<strong>破坏性</strong>来确定—&gt; 脆弱节点</li></ul></li><li><p><strong>如何“删除节点”？</strong></p><ul><li><p><strong>方法一</strong>：将节点对之间<strong>距离的倒数</strong>作为权数，对所有<strong>产生的</strong>不连通节点加权求和  以此度量破坏程度</p><blockquote><ul><li><p>参考文献：</p><p><a href="">[1]李鹏翔,任玉晴,席酉民.网络节点(集)重要性的一种度量指标[J].系统工程,2004(04):13-20.</a></p></li></ul></blockquote></li><li><p><strong>方法二：</strong></p><blockquote><ul><li><p>参考文献：</p><p><a href="">[1]刘浪,邓伟,采峰,陈玲. 节点重要度计算的新方法——优先等级法[C]//第九届中国管理科学学术年会论文集.[出版者不详],2007:168-171.</a></p></li></ul></blockquote></li></ul></li></ul><h3 id="该文献的思路"><a href="#该文献的思路" class="headerlink" title="该文献的思路"></a>该文献的思路</h3><ul><li>本文对<strong>节点删除法的改进 </strong>：针对网络攻防中 <strong>网络拓扑</strong>可能因为脆弱点 受到攻击而<strong>变化</strong>，寻找<strong>更符合网络实际情况</strong>的脆弱点<ul><li>通过计算 删除节点后对网络<strong>平均最短路径</strong>的影响 来 模拟当网络中节点 <strong>受到攻击 导致节点不可用</strong>时 对网络整体性质的影响</li></ul></li></ul><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ul><li><p>本文认为：主要影响的网络性质：<strong>平均最短路径</strong> &amp; <strong>连通节点对</strong>的变化</p><blockquote><p>删除节点后，可能<strong>产生</strong>一个or多个连通分支 ，可能<strong>改变</strong>某些节点对的最短路径</p></blockquote></li></ul><ol><li><p>首先考虑对平均最短路径的影响</p><ul><li><p>将<strong>不连通的节点对</strong> 间的距离设为 <strong>图的直径大小</strong></p><p><img src="https://i.bmp.ovh/imgs/2022/03/0662fb6717a810d5.png" style="zoom:50%;"></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 信安赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复杂网络 </tag>
            
            <tag> 文献笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链和复杂网络</title>
      <link href="/2022/02/15/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/"/>
      <url>/2022/02/15/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>区块链，什么是，有什么技术架构、特点、应用场景、优缺点</li><li>复杂网络（complex network），弄明白什么是复杂网络（区块链网络就是一个例子）</li></ul></li></ul><span id="more"></span><h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><blockquote><p>一条链，链上很多区块，区块里的数据不能改</p></blockquote><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul><li><p>​    一种在<strong>对等网络环境</strong>下，通过透明和可信<strong>规则</strong>，构建不可伪造、不可篡改、可追溯的<strong>块链式数据结构</strong>，实现和<strong>管理事务处理</strong>的模式。</p></li><li><p>​    区块链本质上是一个去中心化的分布式账本数据库（在与比特币相关的区块链应用中可使用这一术语，但区块链技术可能并不包含“账本”, 其本身是一串使用<strong>密码学相关联所产生的数据块</strong>，每一个数据块中包含了多次比特币网络交易有效确认的信息。)</p></li><li>每个区块按照 <strong>时间</strong> 线性顺序推进 </li></ul><blockquote><p>？对等网络环境：</p><ul><li><p>Peer-to-peer network （P2P）</p></li><li><p>彼此连接的多台计算机之间都处于对等的地位 有相同的功能，无主从之分，一台计算机既可作为服务器，设定共享资源供网络中其他计算机所使用，又可以作为工作站，整个网络一般来说不依赖专用的集中服务器，也没有专用的工作站</p></li><li>P2P一个重要特点是改变互联网现在的以太网站为中心的状态、重返“非中心化”，并把权力交还给用户</li></ul><p>？理解：特殊的分布式数据库→ </p><p>​                每个网络上的节点共享数据，通过共识算法，保证整个区块链网络的一致性和安全性</p></blockquote><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><h3 id="密码学技术"><a href="#密码学技术" class="headerlink" title="密码学技术"></a>密码学技术</h3><ul><li>哈希算法</li><li>非对称加密技术</li><li>数字签名</li></ul><h3 id="区块结构-链式结构"><a href="#区块结构-链式结构" class="headerlink" title="区块结构+链式结构"></a>区块结构+链式结构</h3><h3 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h3><h3 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h3><h3 id="挖矿与共识"><a href="#挖矿与共识" class="headerlink" title="挖矿与共识"></a>挖矿与共识</h3><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>略</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>略</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>分布式的去中心化</strong><ul><li>去中心化：每个节点对等，基于<strong>P2P</strong></li></ul></li><li><strong>无须信任系统</strong><ul><li><strong>密码学+共识算法</strong> –&gt; 信任从第三方机构转移到区块链网络</li></ul></li><li><strong>不可篡改</strong><ul><li>每个区块的产生所需付出的<strong>算力成本高</strong></li></ul></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p><strong>交易账本必须公开</strong></p></li><li><p><strong>延迟性</strong></p><ul><li>每隔<strong>一定时间</strong>将自上一个区块以后的交易<strong>打包生成新</strong>的区块</li></ul></li><li><p><strong>浪费能源</strong></p></li><li><p><strong>占用空间</strong></p><ul><li>每个节点可存储共享一份<strong>全网的账本数据</strong></li></ul></li><li><p><strong>修复时间长</strong></p><ul><li><p>出现代码漏洞需修复时，<strong>每个节点</strong>都采取措施更新才能最终完成漏洞修复。</p></li><li><p>从发布漏洞补丁到每个节点都完成修复耗时长，且不保证每个节点都被及时修复。</p><blockquote><ul><li>中心化的网络则可以通过同步下发给所有子节点进行快速修复。</li></ul></blockquote></li></ul></li></ul><h1 id="复杂网络"><a href="#复杂网络" class="headerlink" title="复杂网络"></a>复杂网络</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>典型的网络：节点+连接节点的边<ul><li>节点：代表真实系统中不同的<strong>个体</strong></li><li>边：代表个体之间的<strong>关系</strong></li><li>eg：神经网络、计算机网络、电力网络、社会关系网络</li></ul></li><li>网络的拓扑性质<ul><li>网络<strong>不依赖</strong>于节点的 <em>具体位置</em> 和 边的 <em>具体形态</em> 就能表现出来的性质</li><li>性质相应的结构：网络的拓扑结构</li></ul></li></ul><h3 id="复杂网络-1"><a href="#复杂网络-1" class="headerlink" title="复杂网络"></a>复杂网络</h3><ul><li><p>钱学森给出的严的定义：具有<strong>自组织、自相似、吸引子、小世界、无标度</strong>中 <strong>部分或全部</strong>性质 的网络</p></li><li><p>言外之意，复杂网络就是指一种呈现<strong>高度复杂性</strong>的网络</p></li><li><blockquote><blockquote><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2007&amp;filename=JSJA200712003&amp;uniplatform=NZKPT&amp;v=4M8fbSr9Jag8kRTp3gVwrqO7hkHjgcLxJ-HaeSp7dV8RwFv4B21WmBjH1CFMYSVH">[1]赫南,李德毅,淦文燕,朱熙.复杂网络中重要性节点发掘综述[J].计算机科学,2007(12):1-5+17.</a></p></blockquote></blockquote></li><li><p>上文献中认为：复杂网络没有精确严格的定义</p><ul><li><p>可以<strong>看作大量真实复杂系统的拓扑抽象</strong>。</p><blockquote><p>既不是规则网络，也不是随机网络</p><p>现实世界中的复杂网络比如：社会关系网络、论文引用网络、软件类网络…</p></blockquote></li></ul></li></ul><h4 id="特性1：小世界"><a href="#特性1：小世界" class="headerlink" title="特性1：小世界"></a><strong>特性1：小世界</strong></h4><ul><li><p>社交网络中的任何一个成员和任何一个陌生人之间所间隔的人<strong><font color="green">不会超过六个</font></strong> (六度空间理论）</p></li><li><p>小世界网络有 规则网络类似的<font color="green">聚集性 </font>+ 随机网络类似的较小的<font color="green">平均路径长度</font></p></li><li><p><strong>衡量网络的两个特征</strong></p><ul><li><p><code>特征路径长度（characteristic path length）</code>：在网络中，任选两个节点，<strong>连通</strong>这两节点的<strong>最少</strong>边数，定义为这两个节点的路径长度，网络中<strong>所有节点对的路径长度的平均值</strong>，定义为网络的特征路径长度。</p><ul><li>网络的全局特征。</li></ul></li><li><p><code>聚合系数(clustering coefficient)</code>：假设某节点有k条边，则这k条边连接的节点（k个）之间最多可能存在的边的条数为k(k−1)/2</p><ul><li><p>节点的聚合系数：用<strong>实际存在的边数</strong>除以<strong>最多可能存在的边数</strong>得到的分数值</p></li><li><p><strong>所有节点的聚合系数的均值</strong>定义为网络的聚合系数。</p></li><li><p>聚合系数是网络的局部特征，反映了相邻两个人之间朋友圈子的<strong>重合度</strong>，即该节点的朋友之间也是朋友的程度。</p></li><li><p>对于规则网络，任意两个点（个体）之间的特征路径长度长（通过多少个体联系在一起），但聚合系数高（你是朋友的朋友的朋友的几率高）。</p><blockquote><p>规则网络：用一种固定的规则的结构表示：如二维平面上的欧几里得网格</p></blockquote></li><li><p>对于随机网络，任意两个点之间的特征路径长度短，但聚合系数低。而小世界网络，点之间特征路径长度小，接近随机网络，而聚合系数依旧相当高，接近规则网络。</p><blockquote><p>随机网络：节点之间的边不再是确定的，而是用一个概率决定</p></blockquote></li></ul></li></ul></li><li><p>实际的社会、生态、等网络都是小世界网络：</p><ul><li>信息传递速度快，并且少量改变几个连接，就可以剧烈地改变网络的性能，<ul><li>如对已存在的网络进行调整，如蜂窝电话网，改动很少几条线路，就可以显著提高性能。</li></ul></li></ul></li></ul><h4 id="特性2：无标度（Scale-free）"><a href="#特性2：无标度（Scale-free）" class="headerlink" title="特性2：无标度（Scale-free）"></a>特性2：无标度（Scale-free）</h4><ul><li><p>现实世界的网络大部分都不是随机网络，<strong>少数的节点往往拥有大量的连接，而大部分节点却很少</strong>，节点度数分布符合<strong>幂律分布</strong>—&gt;网络的无标度特性。度分布符合<strong>幂律分布</strong>的复杂网络—&gt;无标度网络。</p><blockquote><p>幂律分布：指某个具有分布性质的变量，且其分布密度函数是幂函数（由于分布密度函数必然满足“归一律”，所以这里的幂函数，一般规定小于负1）的分布</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2022/03/81fea0f2e904600c.png" style="zoom:33%;"></p></li><li><p>无标度特性反映：复杂网络具有严重的<strong>异质性</strong>，其各节点之间的连接状况<strong>（度数）具有严重的不均匀分布性</strong></p><ul><li>网络中<strong>少数</strong>称之为<strong>Hub点</strong>的节点拥有<strong>极其多</strong>的连接，</li><li>而<strong>大多数</strong>节点只有很<strong>少量</strong>的连接。</li><li>少数Hub点对无标度网络的运行起着<strong>主导</strong>的作用。</li><li>从广义上说，无标度网络的无标度性是描述大量复杂系统<strong>整体上严重不均匀分布</strong>的一种内在性质。</li></ul></li><li><p>其实复杂网络的无标度特性与<strong>网络的鲁棒性分析</strong>具有密切的关系。</p><ul><li><p>无标度网络中<strong>幂律分布特性</strong>的存在极大地提高了<strong>高度数节点存在</strong>的可能性，因此，无标度网络同时显现出<strong>针对随机故障的鲁棒性和针对蓄意攻击的脆弱性</strong>。这种鲁棒且脆弱性对网络容错和抗攻击能力有很大影响。</p><blockquote><p>鲁棒性：在异常和危险情况下系统生存的能力</p></blockquote></li><li><p>无标度网络具有很强的容错性，但是对基于节点度值的选择性攻击而言，其<strong>抗攻击能力相当差</strong>，高度数节点的存在极大地削弱了网络的鲁棒性，一个恶意攻击者只需选择攻击网络很少的一部分高度数节点，就能使网络迅速瘫痪</p></li></ul></li></ul><h1 id="参考文献-博客出处"><a href="#参考文献-博客出处" class="headerlink" title="参考文献/博客出处"></a>参考文献/博客出处</h1><blockquote><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2007&amp;filename=JSJA200712003&amp;uniplatform=NZKPT&amp;v=4M8fbSr9Jag8kRTp3gVwrqO7hkHjgcLxJ-HaeSp7dV8RwFv4B21WmBjH1CFMYSVH">[1]赫南,李德毅,淦文燕,朱熙.复杂网络中重要性节点发掘综述[J].计算机科学,2007(12):1-5+17.</a></p><p><a href="https://www.cnblogs.com/maybe2030/p/4665847.html#_labelTop">[Network Analysis] 复杂网络分析总结 - Poll的笔记 - 博客园 (cnblogs.com)</a></p><p><a href="https://shuwoom.com/?p=403">区块链快速入门 - shuwoom的博客</a></p><p>[1]周涛,柏文洁,汪秉宏,刘之景,严钢.复杂网络研究概述[J].物理,2005(01):31-36.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 信安赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复杂网络 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test1</title>
      <link href="/2022/01/21/test1/"/>
      <url>/2022/01/21/test1/</url>
      
        <content type="html"><![CDATA[<p>这是一个拿来测试的捏<br><span id="more"></span><br></p><div class="note info">            <p>现在该说点什么呢</p>          </div><p></p><p>其中，note 后面的class_name 可以是以下列表中的一个值：</p><ul><li>default</li><li>primary</li><li>success</li><li>info</li><li>warning</li><li>danger</li></ul>]]></content>
      
      
      <categories>
          
          <category> 部署测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/20/hello-world/"/>
      <url>/2022/01/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
