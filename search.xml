<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数学和简单DP</title>
      <link href="/2022/03/12/2022-03-12-%E6%95%B0%E5%AD%A6%E5%92%8C%E7%AE%80%E5%8D%95DP/"/>
      <url>/2022/03/12/2022-03-12-%E6%95%B0%E5%AD%A6%E5%92%8C%E7%AE%80%E5%8D%95DP/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>几道数学类的题目</li><li>简单的几道dp</li></ul></li></ul><span id="more"></span><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul><li>下取整：<script type="math/tex; mode=display">\lceil \frac{a}{b} \rceil=\lfloor\frac{a+b-1}{b}\rfloor</script></li></ul><h1 id="简单DP"><a href="#简单DP" class="headerlink" title="简单DP"></a>简单DP</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><ul><li>N个物品，容量是V的背包</li><li>每个物品：体积v，价值w； 每个物品最多只能用一次</li><li>从这N个物品挑几个使得 ：总体积≤V 且价值max</li></ul><h2 id="AcWing2-01背包问题"><a href="#AcWing2-01背包问题" class="headerlink" title="AcWing2 01背包问题"></a>AcWing2 01背包问题</h2><p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题 - AcWing题库</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 数学 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分和前缀和</title>
      <link href="/2022/03/10/2022-03-10-%E4%BA%8C%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2022/03/10/2022-03-10-%E4%BA%8C%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>二分</li><li>前缀和</li></ul></li></ul><span id="more"></span><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><blockquote><p><em>22-03-10: 今天想起写个题,发现自己连二分都写得磕磕绊绊的,我焯,zyl大煞笔</em></p></blockquote><ul><li><p>确定一个区间，使得目标值在区间里面</p></li><li><p>找一个性质 ，满足两点</p><ul><li>性质 具有二段性（所有二分 都要成立<ul><li>前半段满足，后半段不满足，中间没有缺失的地方<img src="https://i.bmp.ovh/imgs/2022/03/20c5859b35eb05a8.png" style="zoom:50%;" /></li></ul></li><li>答案是二段性的分界点</li></ul></li><li><p><strong>整数二分</strong></p><ul><li><p>第一类：目标值是红色区间的右端点</p><blockquote><p>中点mid属于右半区间，则左半区间是[l, mid-1]，右半区间是[mid, r]，更新方式是r = mid - 1;或者 l = mid;</p></blockquote><ul><li>将[L,R] 分成 [L,M-1] ,[M,R]</li><li>if M是红色的, ans在[M,R]之间<ul><li>else ans 仍然在[L,M-1]</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">    M=(L+R+<span class="number">1</span>)/<span class="number">2</span>;   <span class="comment">//关键+1 ,上取整</span></span><br><span class="line">    <span class="keyword">if</span> M红 then L=M;  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span> R=M<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二类：目标值是绿色区间的左端点</p><blockquote><p>中点mid属于左半区间，则左半区间是[l, mid]，右半区间是[mid+1, r]，更新方式是r = mid;或者 l = mid + 1;</p></blockquote><ul><li>将[L,R]分成[L,M]和[M+1,R]</li></ul></li><li><p>if M绿色 ans在[L,M]之间</p><ul><li>else ans在[M+1,R]</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">M=(L+R)/<span class="number">2</span>;        <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> M绿 then R=M  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span> L=M+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>整数二分的总结</strong></p><blockquote><p><em>y总说按这种写法可以完美避掉所有坑 //o//</em>:</p><p>首先通过题目背景和check(mid)函数的逻辑，判断答案落在左半区间还是右半区间。</p></blockquote><ul><li>找一个<strong>区间[L,R]</strong>使得答案一定在该区间中</li><li>找一个<strong>判断条件</strong>,使得该判断条件具有<strong>二段性</strong>,并且答案一定是该二段行的分界点</li><li>分析中点M在该判断条件下<strong>是否成立</strong>,如果成立or不成立,考虑答案在<strong>哪个区间</strong></li><li><font color="red">如果更新方式**R=Mid**,则**不用做任何处理**</font></li><li><font color="red">如果更新方式**L=Mid**,则需要在计算Mid时**先加上1**</font></li></ul></li><li><p>实数二分</p><ul><li>while（ R-L &gt;某个数） 1e-6 , 1e-8</li><li>if ans在[M,R] L=M</li><li>else ans在[L,M]  </li></ul></li></ul><h2 id="AcWing789-数的范围（模板题）"><a href="#AcWing789-数的范围（模板题）" class="headerlink" title="AcWing789 数的范围（模板题）"></a>AcWing789 数的范围（模板题）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="keyword">int</span> k;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>,R=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line"><span class="comment">//从左到右找第一个≥k 的数 (符合性质的第一个点,第一个！！！！！左区间的右端点</span></span><br><span class="line"><span class="comment">//[L,Mid],[Mid+1,R] </span></span><br><span class="line"><span class="comment">// 1 2 2 3    3 4</span></span><br><span class="line"><span class="keyword">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="comment">//如果a[mid]≥k，说明第一个≥k的数必然在此时的[L,Mid]之间 </span></span><br><span class="line"><span class="keyword">if</span>(a[mid]&gt;=k) R=mid;</span><br><span class="line"><span class="keyword">else</span> L=mid+<span class="number">1</span>;  <span class="comment">//L 往左挪,所以+ </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终L==R,判断条件这里写RL都行 </span></span><br><span class="line"><span class="keyword">if</span>(a[R]==k)&#123;</span><br><span class="line">cout&lt;&lt;R&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">//第一个数确定后，第二个数在R到n-1之间;</span></span><br><span class="line">R=n<span class="number">-1</span>; </span><br><span class="line"><span class="comment">//从右往左找第一个≤k的数 （右区间的左端点</span></span><br><span class="line"><span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(L+R+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>; <span class="comment">// 因为先通过写L=Mid最后判断要+1 </span></span><br><span class="line"><span class="comment">//如果a[mid]≤k,说明 必然在[Mid,R]之间 </span></span><br><span class="line"><span class="keyword">if</span>(a[mid]&lt;=k) L=mid;</span><br><span class="line"><span class="keyword">else</span> R= mid<span class="number">-1</span>; <span class="comment">//R往右挪,所以- </span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;L&lt;&lt;endl;  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//补充:莫名其妙被上面的部分小东西给绕着了，还是自己写比较能理解自己</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(L+R)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;k) L=mid+<span class="number">1</span>;   <span class="comment">//对于我这种笨比,觉得还是把上面这里调换一下顺序更好理解</span></span><br><span class="line">        <span class="keyword">else</span> R=mid;  <span class="comment">//＜k，说明在mid+1到R之间 L继续往后挪（L向 k靠近</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[R]==k)&#123;</span><br><span class="line">        cout&lt;&lt;R&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        R=n<span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(L+R+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid]&gt;k) R=mid<span class="number">-1</span>;   <span class="comment">//大于k，说明在L到mid-1之间，R继续往右挪（R向k靠近</span></span><br><span class="line">            <span class="keyword">else</span> L=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;L&lt;&lt;endl;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing1227-分巧克力"><a href="#AcWing1227-分巧克力" class="headerlink" title="AcWing1227 分巧克力"></a>AcWing1227 分巧克力</h2><ul><li><a href="https://www.acwing.com/problem/content/1229/">1227. 分巧克力 - AcWing题库</a></li></ul><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>N个Hi乘Wi的方格组成的长方形，划分出K个大小相同且最大的正方形</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>一个HxW的长方形，分割成边长为x的正方形的块数：</p><script type="math/tex; mode=display">\lfloor\frac{H}{x}\rfloor\times\lfloor\frac{W}{x}\rfloor</script></li><li><p>随着x的增大，分割出的块数 减小，故 一定存在当x增大到值时，分割出的块数==K； 故可以采用二分<img src="https://i.bmp.ovh/imgs/2022/03/88a1d02c8e12586f.png" style="zoom:33%;" /></p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// check=true是满足条件的，从0到x之间的部分，所以后面写的是l=mid</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">sum+=(a[i][<span class="number">0</span>]/m)*(a[i][<span class="number">1</span>]/m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i][<span class="number">0</span>],&amp;a[i][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=N;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l==r) cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing730-机器人跳跃问题"><a href="#AcWing730-机器人跳跃问题" class="headerlink" title="AcWing730 机器人跳跃问题"></a>AcWing730 机器人跳跃问题</h2><p><a href="https://www.acwing.com/problem/content/732/">730. 机器人跳跃问题 - AcWing题库</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>N+1座建筑，第i座的高度H(i)，当在第k座时能量为E，跳到第k+1座后能量为E=2*E-H(k)；整个过程能力不能为负值，求最初能量最少是多少。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>对于某些题目提到求“最值”的问题，可以首先往二分的角度想一想=V=</li><li>设最初能量为e，随着e从小到大增加，一定能找到一个E，<ul><li>当初值＜E时，跳跃过程中存在能量值＜0 的情况；</li><li>当初值=E时，<strong>刚好 </strong>不存在能力值小于0的情况；</li><li>当初值＞E，同样也一定 不存在能力值＜0的情况，</li><li>当在中间的某一时刻能量值≥1e5的话后面必然不会存在＜0的情况，防止爆掉int，所以这里要判断一下</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//check==true：初始值为m 不会存在小于0的情况 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> e=m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">e=e*<span class="number">2</span>-a[i];</span><br><span class="line"><span class="keyword">if</span>(e&gt;N) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(e&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=N;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//求满足条件的最小值 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing1221-四平方和"><a href="#AcWing1221-四平方和" class="headerlink" title="AcWing1221 四平方和"></a>AcWing1221 四平方和</h2><p><a href="https://www.acwing.com/problem/content/1223/">1221. 四平方和 - AcWing题库</a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><blockquote><p>参考：<a href="https://www.acwing.com/solution/content/31631/">AcWing 1221. 四平方和 + 自定义排序（重载&lt;）+二分 - AcWing</a></p></blockquote><h4 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h4><ul><li><p>重载运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x：任意名字，node：结构体的名字</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;x) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">//排序规则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如下面结构体中的s,c,d</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Sum &amp;t) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s!=t.s) <span class="keyword">return</span> s&lt;t.s;</span><br><span class="line">    <span class="keyword">if</span>(c!=t.c) <span class="keyword">return</span> c&lt;t.c;</span><br><span class="line">    <span class="keyword">return</span> d&lt;t.d;</span><br><span class="line">&#125;<span class="comment">//先比较s，如果s不同，则s小的结构体小；如果s相同但c不同，则c较小的结构体小....</span></span><br></pre></td></tr></table></figure></li><li><p>sort自定义排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,c,d;</span><br><span class="line">&#125;sum[<span class="number">2500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Sum a,Sum b)</span></span>&#123;<span class="comment">//自定义函数排序,Sum是结构体名</span></span><br><span class="line">    <span class="keyword">if</span>(a.s==b.s) <span class="keyword">return</span> a.c&lt;b.c;</span><br><span class="line">    <span class="keyword">if</span>(a.c==b.c) <span class="keyword">return</span> a.d&lt;b.d;</span><br><span class="line">    <span class="keyword">return</span> a.s&lt;b.s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);<span class="comment">//默认下标0~n-1升序</span></span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);<span class="comment">//默认下标1~n升序</span></span><br><span class="line"><span class="built_in">sort</span>(a,a+n,greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//降序</span></span><br><span class="line"><span class="built_in">sort</span>(a,a+n,cmp);<span class="comment">//自定义函数排序,重写cmp</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>把正整数n写成a,b,c,d这4个数平方和的形式，输出字典序最小的abcd升序排列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>如果暴力的话<ul><li>直接枚举abc（但会爆掉</li></ul></li><li>考虑空间换时间<ul><li>最先想的是先枚举ab保存下来再枚举cd，发现这样的话大小顺序有问题；</li><li>所以，先枚举cd，用结构体数组保存每一组s=c^2+d^2，c，d；升序排序</li><li>再枚举ab，a和b从小到大枚举，对于每一对ab，通过计算t = n-a <em> a-b </em> b，然后再通过<strong>二分</strong>从结构体数组中找第一个满足条件且cd最小的数</li></ul></li><li>说明<ul><li>首先枚举一定能保证a＜=b，c＜=d</li><li>是如何保证b＜=c的？<ul><li>假设存在答案a,b,c,d ，使得a＜b&gt;c＜d；那么一定有 a×a+b×b&gt;a×a+c×c，因此a,c应当比a,b先出现，枚举一定是先枚举出的ac而不是ab，与假设矛盾，故假设不成立（弄个例子画一下就理解了）</li></ul></li></ul></li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2500010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,t;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, c, d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Sum &amp;t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s != t.s) <span class="keyword">return</span> s &lt; t.s;</span><br><span class="line">        <span class="keyword">if</span> (c != t.c) <span class="keyword">return</span> c &lt; t.c;</span><br><span class="line">        <span class="keyword">return</span> d &lt; t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(c=<span class="number">0</span>;c*c&lt;=n;c++)&#123;</span><br><span class="line"><span class="keyword">for</span>(d=c;d*d+c*c&lt;=n;d++)&#123;</span><br><span class="line">sum[cnt++]=&#123;c*c+d*d,c,d&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(sum,sum+cnt);</span><br><span class="line"><span class="keyword">for</span>(a=<span class="number">0</span>;a*a&lt;=n;a++)&#123;</span><br><span class="line"><span class="keyword">for</span>(b=a;a*a+b*b&lt;=n;b++)&#123;</span><br><span class="line">t = n-a*a-b*b;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r = cnt<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//找满足性质的最小值</span></span><br><span class="line"><span class="keyword">if</span>(sum[mid].s&gt;=t) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum[l].s==t)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,a,b,sum[l].c,sum[l].d);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><ul><li>只能处理静态数组：只能查询不能修改</li><li>线状数组和树状数组可以修改</li></ul><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><h3 id="Acwing795-前缀和（模板题）"><a href="#Acwing795-前缀和（模板题）" class="headerlink" title="Acwing795 前缀和（模板题）"></a>Acwing795 前缀和（模板题）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//给一个整数序列，求第l到第r个数的和</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> l,r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><ul><li><p>前缀和矩阵的计算：</p><script type="math/tex; mode=display">S_{xy}=S_{x-1,y}+S_{x,y-1}-S_{x-1,y-1}+a_{x,y}</script></li><li><p>利用前缀和矩阵计算某个子矩阵（左上角(x1,y1) 到右下角(x2,y2)的和：</p><script type="math/tex; mode=display">S_{x_{2},y_{2}}-S_{x_{2},y_{1}-1}-S_{x_{1}-1,y_{2}}+S_{x_{1}-1,y_{1}-1}</script></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/858f026d6e85a7e3.png" style="zoom:50%;" /></p><h3 id="AcWing796-子矩阵的和（模板题）"><a href="#AcWing796-子矩阵的和（模板题）" class="headerlink" title="AcWing796 子矩阵的和（模板题）"></a>AcWing796 子矩阵的和（模板题）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//给定矩阵，求(x1,y1)到(x2,y2)的子矩阵的和</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q,a[N][N],s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);  <span class="comment">//前缀和矩阵</span></span><br><span class="line">s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x1<span class="number">-1</span>][y2]-s[x2][y1<span class="number">-1</span>]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 二分 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递推（几道翻转类题目）</title>
      <link href="/2022/03/09/2022-02-15-%E9%80%92%E6%8E%A8%EF%BC%88%E5%87%A0%E9%81%93%E7%BF%BB%E8%BD%AC%E7%B1%BB%E9%A2%98%E7%9B%AE%EF%BC%89/"/>
      <url>/2022/03/09/2022-02-15-%E9%80%92%E6%8E%A8%EF%BC%88%E5%87%A0%E9%81%93%E7%BF%BB%E8%BD%AC%E7%B1%BB%E9%A2%98%E7%9B%AE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="AcWing-116-飞行员兄弟"><a href="#AcWing-116-飞行员兄弟" class="headerlink" title="AcWing 116 飞行员兄弟"></a>AcWing 116 飞行员兄弟</h1><p><a href="https://www.acwing.com/problem/content/description/118/">题目链接</a></p><h2 id="大意"><a href="#大意" class="headerlink" title="大意:"></a>大意:</h2><ul><li>4 x 4 翻转一个元素的话，顺带着所在行和列全跟着翻转；求全部翻转过来的步数和步骤</li></ul><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>如果枚举的话，2&lt;&lt;16次，复杂度还能够接受，可以枚举</li><li>枚举每个操作opt，每个操作opt的值转换成16位二进制，<ul><li>对于每个opt，要移位16次，每次右移取最低位 ,当==1表示翻转</li><li>注意翻转i行j列的时候，(i,j)被翻转了两次，记得恢复</li><li>储存符合条件的操作的位置，用vector存</li></ul></li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li><p>vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义： vector&lt;元素类型&gt; 名称；例如： vector&lt;PII&gt; vec;</span><br><span class="line">翻转： <span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">大小： vec.<span class="built_in">size</span>();</span><br><span class="line">清空： vec.<span class="built_in">clear</span>();</span><br><span class="line">插入： vec.<span class="built_in">push_back</span>(pi);</span><br></pre></td></tr></table></figure></li><li><p>for区间遍历 (C++11)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)&#123;</span><br><span class="line">    cout&lt;&lt;i.x&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;i.y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pair</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second 方便</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">PII pi; pi.first, pi.second</span><br></pre></td></tr></table></figure></li><li><p>memcpy</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *str1, <span class="keyword">const</span> <span class="keyword">void</span> *str2, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">str1：目的 str2：源 n：字节数</span></span><br></pre></td></tr></table></figure></li><li><p>二进制数i的第k位是否==1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i&gt;&gt;k&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="简洁版代码"><a href="#简洁版代码" class="headerlink" title="简洁版代码"></a>简洁版代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> ch[N][N],backup[N][N]; </span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; vec; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(backup[i][k]==<span class="string">&#x27;+&#x27;</span>) backup[i][k]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][k]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(backup[k][j]==<span class="string">&#x27;+&#x27;</span>) backup[k][j]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[k][j]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">&#x27;+&#x27;</span>) backup[i][j]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][j]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</span><br><span class="line">cin&gt;&gt;ch[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> opt=<span class="number">0</span>;opt&lt;(<span class="number">2</span>&lt;&lt;<span class="number">16</span>);opt++)&#123;</span><br><span class="line"><span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(backup,ch,<span class="keyword">sizeof</span> ch);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(opt&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> row=(<span class="number">16</span>-i<span class="number">-1</span>)/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> col= <span class="number">4</span>-i%<span class="number">4</span>;</span><br><span class="line"><span class="built_in">turn</span>(row,col);</span><br><span class="line"> step++;</span><br><span class="line"> PII pi; pi.first=row;pi.second=col;</span><br><span class="line"> vec.<span class="built_in">push_back</span>(pi);</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">flag=<span class="literal">false</span>; vec.<span class="built_in">clear</span>();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">cout&lt;&lt;step&lt;&lt;endl;</span><br><span class="line"><span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>()); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">cout&lt;&lt;vec[i].first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;vec[i].second&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="废话版代码"><a href="#废话版代码" class="headerlink" title="废话版代码"></a>废话版代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">最初想到的思路，参照“费解的开关”这道题</span></span><br><span class="line"><span class="comment">枚举，16个位置 有2^16种情况</span></span><br><span class="line"><span class="comment">枚举二进制 0到2^16-1</span></span><br><span class="line"><span class="comment">对于每种情况，对原状态数组进行操作 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> ch[N][N],backup[N][N]; </span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII; <span class="comment">//pair的用法；又是一个被我遗忘的东西，笑嘻</span></span><br><span class="line">vector&lt;PII&gt; vec; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(backup[i][k]==<span class="string">&#x27;+&#x27;</span>) backup[i][k]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][k]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(backup[k][j]==<span class="string">&#x27;+&#x27;</span>) backup[k][j]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[k][j]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;   <span class="comment">//当时写的时候，就差点忘记(i,j)的位置翻转了两次，所以下面要再翻回去</span></span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">&#x27;+&#x27;</span>) backup[i][j]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][j]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</span><br><span class="line">cin&gt;&gt;ch[i][j];</span><br><span class="line"></span><br><span class="line"><span class="comment">//一共有2&lt;&lt;16次操作，枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> opt=<span class="number">0</span>;opt&lt;(<span class="number">2</span>&lt;&lt;<span class="number">16</span>);opt++)&#123;</span><br><span class="line"><span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//memcpy复制数组，不用写双重循环 </span></span><br><span class="line"><span class="built_in">memcpy</span>(backup,ch,<span class="keyword">sizeof</span> ch);</span><br><span class="line"><span class="comment">//for(int kk=1;kk&lt;=4;kk++)</span></span><br><span class="line"><span class="comment">//for(int jj=1;jj&lt;=4;jj++)</span></span><br><span class="line"><span class="comment">//backup[kk][jj]=ch[kk][jj];</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"> <span class="comment">//对于每个opt，移位16位 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(opt&gt;&gt;i&amp;<span class="number">1</span>)&#123; <span class="comment">//取最低位 ,如果==1的话就翻转；</span></span><br><span class="line"> <span class="comment">//例如：0000 0000 0000 0001；最先是1，</span></span><br><span class="line"> <span class="comment">//第0个对应(4,4) 第1个对应(4,3)</span></span><br><span class="line"><span class="keyword">int</span> row=(<span class="number">16</span>-i<span class="number">-1</span>)/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> col= <span class="number">4</span>-i%<span class="number">4</span>;</span><br><span class="line"><span class="built_in">turn</span>(row,col);</span><br><span class="line"> step++;</span><br><span class="line"> PII pi; pi.first=row;pi.second=col;</span><br><span class="line"> vec.<span class="built_in">push_back</span>(pi);</span><br><span class="line">                <span class="comment">//试了一下样例</span></span><br><span class="line"><span class="comment">// if(opt==45067)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;&quot;step== &quot;&lt;&lt;step&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// for(int i=1;i&lt;=4;i++)&#123;</span></span><br><span class="line"><span class="comment">//for(int j=1;j&lt;=4;j++)</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;backup[i][j];</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;endl; </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">flag=<span class="literal">false</span>; vec.<span class="built_in">clear</span>(); <span class="comment">//清空vector;</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">cout&lt;&lt;step&lt;&lt;endl;</span><br><span class="line"><span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());   <span class="comment">//vector的用法忘了，用重新复习下下</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">cout&lt;&lt;vec[i].first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;vec[i].second&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题废物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AcWing </tag>
            
            <tag> 递推 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语老师Lee的每日听力练习笔记</title>
      <link href="/2022/03/09/2022-03-09-%E8%8B%B1%E8%AF%AD%E8%80%81%E5%B8%88Lee%E7%9A%84%E5%90%AC%E5%8A%9B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/09/2022-03-09-%E8%8B%B1%E8%AF%AD%E8%80%81%E5%B8%88Lee%E7%9A%84%E5%90%AC%E5%8A%9B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>主要内容</strong><ul><li>每天十分钟的听力练习笔记</li><li>只是<strong>谨防自己三分钟热度</strong>所以敦促自己每天听的手段QAQ，随便记记而已</li></ul></li></ul><span id="more"></span><h1 id="22-03-09"><a href="#22-03-09" class="headerlink" title="22-03-09"></a>22-03-09</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/a29c5982022c9b64.png" style="zoom: 50%;" /></p><ul><li>单词<ul><li>scooter ：小摩托车</li><li>eyepatch：眼罩</li><li>pink eye：红眼，急性结膜炎</li><li><strong>greasy </strong>  <ul><li>含义：沾油脂的，油污的；含脂肪的，<strong>油腻的</strong>；油性的；滑的；<strong>圆滑的，虚情假意的</strong></li><li>可以用来形容食物 、头发</li></ul></li></ul></li><li>发音<ul><li>your –》 yer</li><li>lot of –》 lotta</li></ul></li></ul><h1 id="22-03-10"><a href="#22-03-10" class="headerlink" title="22-03-10"></a>22-03-10</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/388e55c499064533.png" style="zoom:40%;" /></p><ul><li>单词<ul><li>drug trial 药物实验</li><li>guinea pig<ul><li>豚鼠</li><li>a person used in medical or other experiments <strong>实验对象</strong></li></ul></li><li><strong>roll the side effects dice :冒着副作用的风险</strong><ul><li><strong>roll the dice</strong>：掷骰子， 可以引申为孤注一掷</li></ul></li><li><strong>hallucination</strong>：幻觉<ul><li>[həˌluːsɪˈneɪʃn]</li><li>A hallucination is a fact, not an error; what is erroneous is a judgment based upon it.</li></ul></li></ul></li></ul><h1 id="22-03-11"><a href="#22-03-11" class="headerlink" title="22-03-11"></a>22-03-11</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/6a1c902edfa52be8.png" style="zoom:50%;" /></p><ul><li>单词<ul><li>take advantage of<ul><li>之前经常 +sth 当作“充分利用”的正面词汇，类似还有比如take advantage of sb：占某人便宜</li></ul></li></ul></li></ul><h1 id="22-03-12"><a href="#22-03-12" class="headerlink" title="22-03-12"></a>22-03-12</h1><p><img src="C:\Users\周周周同学\AppData\Roaming\Typora\typora-user-images\image-20220312203129355.png" alt="image-20220312203129355" style="zoom:40%;" /></p><ul><li>单词<ul><li>benefit<ul><li><strong>慈善晚会</strong></li><li>benefit concert 慈善音乐会</li></ul></li><li>up for：愿意参与某活动<ul><li>It`s exciting because it is very much <strong>up for grabs</strong><ul><li>工作、奖金、机会等 等待你去<strong>争取，赢取</strong></li></ul></li></ul></li><li>reprise：重复、重演、重奏、<strong>重现</strong><ul><li>A study which I now reprise for you now from a 2001 article</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语听力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIP-1-数字图像基础</title>
      <link href="/2022/03/06/2022-03-06-DIP-1-%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/06/2022-03-06-DIP-1-%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>【主要内容】</p><ul><li>数字图像的概念及表示</li><li>图像获取</li><li>图像数字化(Digitization)</li><li>不同类型的数字图像</li><li>图像基本性质<ul><li>图像平均值Image Mean .</li><li>图像对比度Image Contrast</li><li>图像直方图Image Histogram</li><li>图像的熵Image Entropy</li><li>自适应直方图Adaptive Histogram</li></ul></li><li>直方图的应用</li></ul><span id="more"></span><h1 id="数字图像的概念及表示"><a href="#数字图像的概念及表示" class="headerlink" title="数字图像的概念及表示"></a>数字图像的概念及表示</h1><ul><li><strong>图像</strong>：三维场景 到 二维平面的一个投影<ul><li>表示一幅图像：二维函数f（x,y)<ul><li>任意一对空间坐标（<strong>x，y</strong>）处的<strong>幅值  f</strong> ：图像在该点的 强度或灰度</li></ul></li></ul></li><li><strong>数字图像</strong>：x 和 y 和 f 都是 <strong>有限的离散量</strong><ul><li>由有限数量的像素组成  —–》每个像素对应 一个（x，y）和一个f</li></ul></li><li><strong>数字图像的表示</strong>：二维矩阵  <img src="https://i.bmp.ovh/imgs/2022/03/91bd075dd44a0604.png" style="zoom: 33%;" /></li></ul><h1 id="图像获取"><a href="#图像获取" class="headerlink" title="图像获取"></a>图像获取</h1><h1 id="图像数字化（Digitization）"><a href="#图像数字化（Digitization）" class="headerlink" title="图像数字化（Digitization）"></a>图像数字化（Digitization）</h1><ul><li><p>数字化的两个过程<strong>：取样 + 量化</strong></p></li><li><p><strong>取样</strong></p><ul><li><p>即：对空间坐标<strong>x 和 y</strong>进行数字化</p></li><li><p>取样间隔必须满足 <strong>Nyquist条件</strong>：x和y方向的<font color="green">取样频率</font>必须 <strong>大于</strong>图像在 x 和 y 方向 <font color="green">最高频率</font>的两倍</p><ul><li><p>为什么要满足：确保取样以后的信号能<font color="orange">完全恢复</font>出原来的连续信号</p></li><li><p>低于这个条件，会产生<strong>混叠</strong>（Aliasing）</p><blockquote><p>什么是混叠？</p></blockquote></li></ul></li></ul></li><li><p><strong>量化</strong></p><ul><li>对<strong>灰度值 f</strong> 进行数字化</li></ul></li></ul><h1 id="不同类型的数字图像"><a href="#不同类型的数字图像" class="headerlink" title="不同类型的数字图像"></a>不同类型的数字图像</h1><p>暂略…</p><h1 id="图像基本性质"><a href="#图像基本性质" class="headerlink" title="图像基本性质"></a>图像基本性质</h1><h2 id="图像平均值-Image-Mean"><a href="#图像平均值-Image-Mean" class="headerlink" title="图像平均值 Image Mean"></a>图像平均值 Image Mean</h2><ul><li>图像平均值 = 像素之和 / 像素总个数 ，图像平均值 ↑ 👉图像亮度 ↑</li><li>公式如下：</li></ul><script type="math/tex; mode=display">I_{av} = \frac{\sum_{i} \sum_{j}I(i,j)}{\sum_i\sum_j1}</script><h2 id="图像对比度-Image-Contrast"><a href="#图像对比度-Image-Contrast" class="headerlink" title="图像对比度 Image Contrast"></a>图像对比度 Image Contrast</h2><ul><li><p>对比度是 图像复杂度的一种体现</p></li><li><p>首先，引入对比度的<strong>度量方式</strong>：</p><ul><li><p><strong>全局定义方式</strong>（统计学角度）：</p><p>（灰度）最大偏差</p><script type="math/tex; mode=display">max \left\{I(x,y) \right\} - min\left\{I(x,y)\right\}</script><p>（灰度）方差：</p><script type="math/tex; mode=display">var\left\{I(x,y)\right\}=mean\left\{(I(x,y)-I_{av})_{}^{2}\right\}</script><p>（灰度）标准差</p><script type="math/tex; mode=display">std\left\{I(x,y)\right\}=\sqrt{var\left\{I(x,y)\right\}}</script><p>   全局定义方式的<strong>缺点</strong>：不能感知局部结构，没有体现人类的视觉敏感性</p></li><li><p>（韦伯）<strong>局部对比度</strong></p><ul><li>．图像点的局部对比度表示<strong>该图像点(point)的 强度</strong> 与其 <strong>邻域(neihborhood) 强度</strong>之间的(相对)差:<script type="math/tex; mode=display">C=|\frac{I_{p}-I_{n}}{I_{n}}|</script></li></ul></li></ul></li></ul><h2 id="图像直方图-Image-Histogram"><a href="#图像直方图-Image-Histogram" class="headerlink" title="图像直方图 Image Histogram"></a>图像直方图 Image Histogram</h2><ul><li>直方图：用来表达一幅图像灰度级分布情况的统计表</li><li>横坐标→ 灰度级r； 纵坐标 ↑ 灰度值为r的像素个数n或者出现的概率p（r）</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/3829be80550cf6d6.png" style="zoom:50%;" /></p><ul><li><p>直方图<strong>不是一对一</strong>的映射关系  —&gt; 图像的直方图不能完全代表图像</p><ul><li>因此：直方图只能体现数据的统计特性，没有结构特点。</li><li>比如：将一张图的像素随机扰乱，直方图仍然是不变的<img src="https://i.bmp.ovh/imgs/2022/03/aa18aac1c82e01a2.png" style="zoom:50%;" /></li></ul></li><li><p>直方图的<strong>用处</strong>：分析图像对比度的好坏</p><ul><li><strong>给定图像，算出图像平均值和标准差</strong><img src="https://i.bmp.ovh/imgs/2022/03/05bad86faafba1d7.png" style="zoom:65%;" /></li></ul></li></ul><h2 id="图像的-熵-Image-Entropy"><a href="#图像的-熵-Image-Entropy" class="headerlink" title="图像的 熵 Image Entropy"></a>图像的 熵 Image Entropy</h2><ul><li><p>图像的熵的公式 (它是大于0的):</p><script type="math/tex; mode=display">Entropy(I) = -\sum_{k}P(k)logP(k)</script><ul><li>图像的熵表示图像值 的<strong>不确定性</strong></li><li>均匀分布：<strong>熵max</strong>；集中分布在某一处：<strong>熵min</strong></li><li>不频繁的事件比频繁的事件提供更多的信息</li><li>熵 是 直方图 <strong>离散度 </strong>的度量</li></ul></li></ul><h2 id="自适应直方图-Adaptive-Histogram"><a href="#自适应直方图-Adaptive-Histogram" class="headerlink" title="自适应直方图 Adaptive Histogram"></a>自适应直方图 Adaptive Histogram</h2><ul><li>在许多情况下，图像中的<strong>局部</strong>区域需要直方图<ul><li>比如:：模式检测、自适应增强、自适应阈值</li></ul></li><li>图像模糊<strong>不改变图像平均值</strong><ul><li>而是会<strong>减小方差、减小熵</strong></li></ul></li></ul><h1 id="直方图的应用"><a href="#直方图的应用" class="headerlink" title="直方图的应用"></a>直方图的应用</h1><ul><li><p>应用</p><ul><li>测量图像特性:平均值、方差、熵、对比度、区域(对于给定的灰度范围)</li><li><strong>阈值选择</strong> <strong>Threshold selection</strong></li><li>图像的距离</li><li>图像增强<ul><li><strong>直方图均衡化</strong></li><li><strong>直方图拉伸</strong></li><li><strong>直方图匹配</strong></li></ul></li></ul></li><li><p>阈值<strong>分割</strong>：</p><ul><li><p>阈值选取的基本规律：两个峰之间的谷底</p><p><img src="https://i.bmp.ovh/imgs/2022/03/7575a89fe2de9213.png" style="zoom:50%;" /></p></li></ul></li><li><p>图像的<strong>距离</strong></p><ul><li><p>问题:给定两幅图像A和B，其(归一化)直方图为Pa和Pb，定义图像之间的距离D(A,B)。</p><ul><li><strong>Minkowski距离</strong>： 存在的问题：距离可能 <strong>不能反映感知到的差异</strong></li></ul><script type="math/tex; mode=display">D_{p}(A,B)=[\sum_{k}|P_{A}(k)-P_{B}(k)|]^{1/p}</script><ul><li><strong>KL距离（散度）</strong>：非对称，同样面临Minkowski距离的缺点</li></ul><script type="math/tex; mode=display">D_{KL}(A||B)=\sum_{k}P_{A}(k)log\frac{P_{A}(k)}{P_{B}(k)}</script></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理Digital Image Processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIP-2-基本运算</title>
      <link href="/2022/03/06/2022-03-06-DIP-2-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/"/>
      <url>/2022/03/06/2022-03-06-DIP-2-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>暂无</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字图像处理Digital Image Processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小世界网络</title>
      <link href="/2022/02/26/2022-02-26-%E5%B0%8F%E4%B8%96%E7%95%8C%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/02/26/2022-02-26-%E5%B0%8F%E4%B8%96%E7%95%8C%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<ul><li>关于小世界网络—— 一种特殊的<strong>复杂网络</strong></li><li>随机性<strong>介于</strong> 随机网络和规则耦合网络<strong>之间</strong></li><li>适合模拟<strong>真实</strong>网络系统</li><li>其概念, 简单说是描述这样的一个事实:<ul><li>尽管一些网络系统有<strong>很大</strong>的尺寸, 但其中<strong>任意两个节点</strong>之间却有一个<strong>相对小</strong>的距离。</li></ul></li><li>小世界特征：比较<strong>短</strong>的<strong>平均距离</strong> + 相对较<strong>大</strong>的<strong>集聚系数</strong></li></ul><span id="more"></span><h1 id="两种常见的小世界网络"><a href="#两种常见的小世界网络" class="headerlink" title="两种常见的小世界网络"></a>两种常见的小世界网络</h1><h2 id="NW小世界网络"><a href="#NW小世界网络" class="headerlink" title="NW小世界网络"></a>NW小世界网络</h2><ul><li><strong>实现方式</strong>：<strong>规则耦合网络 </strong>上进行 <strong>随机加边</strong></li></ul><h2 id="WS小世界网络"><a href="#WS小世界网络" class="headerlink" title="WS小世界网络"></a>WS小世界网络</h2><ul><li><strong>实现方式</strong>：<strong>规则耦合网络</strong>上进行<strong>随机重连</strong></li></ul><blockquote><p>参考文献：</p><p><a href="">[1]赵小林,徐浩,薛静峰,宋天凌,胡晶晶,闫怀志.基于复杂网络的网络系统脆弱点发现方法研究[J].信息安全学报,2019,4(01):39-52.DOI:10.19363/J.cnki.cn10-1380/tn.2019.01.04.</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 信安赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复杂网络 </tag>
            
            <tag> 文献笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂网络中重要节点、脆弱节点的检查、挖掘方法</title>
      <link href="/2022/02/25/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E3%80%81%E8%84%86%E5%BC%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%A3%80%E6%9F%A5%E3%80%81%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/"/>
      <url>/2022/02/25/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E3%80%81%E8%84%86%E5%BC%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%A3%80%E6%9F%A5%E3%80%81%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>从<strong>防</strong>的角度，<strong>加强保护</strong>和<strong>完善</strong> 脆弱节点</p><span id="more"></span><h1 id="脆弱节点的检查、挖掘"><a href="#脆弱节点的检查、挖掘" class="headerlink" title="脆弱节点的检查、挖掘"></a>脆弱节点的检查、挖掘</h1><blockquote><p>参考文献：</p><p><a href="">[1]赵小林,徐浩,薛静峰,宋天凌,胡晶晶,闫怀志.基于复杂网络的网络系统脆弱点发现方法研究[J].信息安全学报,2019,4(01):39-52.DOI:10.19363/J.cnki.cn10-1380/tn.2019.01.04.</a></p></blockquote><ul><li><p>该篇论文解决的问题：</p><ul><li>大量节点 加大了攻击图 的计算量 ，产生<strong>状态爆炸</strong>问题，限制了攻击图技术现实应用</li><li>因此，兼顾准确性&amp;&amp;<strong>减少计算量</strong>&amp;&amp;利用复杂网络的拓扑统计性质  <ul><li>寻找 脆弱点—&gt;达到目的：寻找<strong>更大规模</strong>（1000/10000以上）网络的脆弱点 </li></ul></li><li>提出了  对节点删除法的<strong>改进</strong></li></ul><hr></li></ul><ul><li><p>复杂网络 —&gt; 节点的集合 —&gt; 拥有自己的<strong>独立特征</strong>&amp;&amp;与其他个体有<strong>相互连接</strong>关系的节点</p></li><li><p>什么是脆弱节点?</p><ul><li><p><strong>受攻击</strong>后能引起网络性能<strong>大幅度下降</strong>的节点</p><ul><li><p>什么是网络性能?</p><ul><li>网络的<strong>连通性</strong>（网络能否正常工作）、平均最短路径（网络执行效率）等</li></ul></li></ul></li></ul></li></ul><h2 id="寻找脆弱节点的两种思路"><a href="#寻找脆弱节点的两种思路" class="headerlink" title="寻找脆弱节点的两种思路"></a>寻找脆弱节点的两种思路</h2><h3 id="思路一：网络中心性反映脆弱性"><a href="#思路一：网络中心性反映脆弱性" class="headerlink" title="思路一：网络中心性反映脆弱性"></a>思路一：网络中心性反映脆弱性</h3><ul><li><p><strong>中心性指标</strong></p><ul><li><p><strong>度中心性</strong></p><ul><li><p>归一化度值 <strong>越大，节点越重要</strong></p></li><li><script type="math/tex; mode=display">归一化度值=\frac{节点的度(与节点相连的其他节点个数)}{最大可能的度(N-1)}</script></li></ul></li></ul></li></ul><ul><li><p><strong>介数中心性</strong></p><ul><li><p>介数中心性 反映–&gt;节点在网络中的<strong>枢纽</strong>地位；通过该节点最短路径<strong>越多，节点越重要</strong></p><script type="math/tex; mode=display">介数=\frac{经过该节点的最短路径 条数}{所有最短路径 条数}</script></li><li><script type="math/tex; mode=display">介数中心性=\frac{某节点介数}{介数最大值}</script></li></ul></li></ul><ul><li><p><strong>接近度中心性</strong></p><ul><li>接近度：节点到其他节点 最短路径之和的倒数；<strong>越小越重要</strong></li><li>接近度中心性 = 某节点接近度  * （N-1）<ul><li>反映–&gt;节点通过网络到其他节点的<strong>影响能力</strong></li></ul></li></ul></li><li><p><strong>特征向量中心性</strong></p><ul><li>反映了节点间的<strong>相互影响</strong></li><li>反映了重要性和 <strong>连接的边数目</strong>有关、和<strong>连接的节点的重要性</strong>有关、连接重要的节点可<strong>提升</strong>自身节点的重要性</li></ul></li></ul><hr><h3 id="思路二：节点脆弱性-删除节点后对网络系统的破坏性"><a href="#思路二：节点脆弱性-删除节点后对网络系统的破坏性" class="headerlink" title="思路二：节点脆弱性 == 删除节点后对网络系统的破坏性"></a>思路二：节点脆弱性 == 删除节点后对网络系统的破坏性</h3><p> “核与核度”理论：</p><ul><li><p><strong>系统的“核”</strong>：</p><ul><li>给定的系统，若<strong>去掉or破坏</strong>其中若干个主要素，对系统<strong>破坏性最大</strong>的 这若干个主要素</li><li>—&gt; 可以：研究<strong>删除节点</strong>后对网络的<strong>破坏性</strong>来确定—&gt; 脆弱节点</li></ul></li><li><p><strong>如何“删除节点”？</strong></p><ul><li><p><strong>方法一</strong>：将节点对之间<strong>距离的倒数</strong>作为权数，对所有<strong>产生的</strong>不连通节点加权求和  以此度量破坏程度</p><blockquote><ul><li><p>参考文献：</p><p><a href="">[1]李鹏翔,任玉晴,席酉民.网络节点(集)重要性的一种度量指标[J].系统工程,2004(04):13-20.</a></p></li></ul></blockquote></li><li><p><strong>方法二：</strong></p><blockquote><ul><li><p>参考文献：</p><p><a href="">[1]刘浪,邓伟,采峰,陈玲. 节点重要度计算的新方法——优先等级法[C]//第九届中国管理科学学术年会论文集.[出版者不详],2007:168-171.</a></p></li></ul></blockquote></li></ul></li></ul><h3 id="该文献的思路"><a href="#该文献的思路" class="headerlink" title="该文献的思路"></a>该文献的思路</h3><ul><li>本文对<strong>节点删除法的改进 </strong>：针对网络攻防中 <strong>网络拓扑</strong>可能因为脆弱点 受到攻击而<strong>变化</strong>，寻找<strong>更符合网络实际情况</strong>的脆弱点<ul><li>通过计算 删除节点后对网络<strong>平均最短路径</strong>的影响 来 模拟当网络中节点 <strong>受到攻击 导致节点不可用</strong>时 对网络整体性质的影响</li></ul></li></ul><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ul><li><p>本文认为：主要影响的网络性质：<strong>平均最短路径</strong> &amp; <strong>连通节点对</strong>的变化</p><blockquote><p>删除节点后，可能<strong>产生</strong>一个or多个连通分支 ，可能<strong>改变</strong>某些节点对的最短路径</p></blockquote></li></ul><ol><li><p>首先考虑对平均最短路径的影响</p><ul><li><p>将<strong>不连通的节点对</strong> 间的距离设为 <strong>图的直径大小</strong></p><p><img src="https://i.bmp.ovh/imgs/2022/03/0662fb6717a810d5.png" style="zoom:50%;" /></p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 信安赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复杂网络 </tag>
            
            <tag> 文献笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链</title>
      <link href="/2022/02/15/%E5%8C%BA%E5%9D%97%E9%93%BE+%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/02/15/%E5%8C%BA%E5%9D%97%E9%93%BE+%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<ul><li>主要内容<ul><li>区块链，什么是，有什么技术架构、特点、应用场景、优缺点</li><li>复杂网络（complex network），弄明白什么是复杂网络（区块链网络就是一个例子）</li><li>复杂网络中重要节点、脆弱节点的检测、挖掘方法。</li></ul></li></ul><span id="more"></span><blockquote><p>针对区块链网络和分布式系统的，网络脆弱节点的挖掘检测：给定一个区块链网络，里边有很多节点，不同的配置、位置、算力，如何找到哪个节点是更重要、更脆弱的。</p></blockquote><ul><li>从<strong>攻</strong>的角度，那就可以作为攻击目标。</li><li>从<strong>防</strong>的角度，就是需要加强保护和完善的脆弱点</li></ul><h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>​    一种在<strong>对等网络环境</strong>下，通过透明和可信<strong>规则</strong>，构建不可伪造、不可篡改、可追溯的<strong>块链式数据结构</strong>，实现和管理事务处理的模式。</p><blockquote><p>？对等网络环境：</p><ul><li><p>Peer-to-peer network （P2P）</p></li><li><p>彼此连接的多台计算机之间都处于对等的地位 有相同的功能，无主从之分，一台计算机既可作为服务器，设定共享资源供网络中其他计算机所使用，又可以作为工作站，整个网络一般来说不依赖专用的集中服务器，也没有专用的工作站</p></li><li>P2P一个重要特点是改变互联网现在的以太网站为中心的状态、重返“非中心化”，并把权力交还给用户</li></ul><p>？理解：特殊的分布式数据库→ </p><p>​                每个网络上的节点共享数据，通过共识算法，保证整个区块链网络的一致性和安全性</p></blockquote><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><h1 id="复杂网络"><a href="#复杂网络" class="headerlink" title="复杂网络"></a>复杂网络</h1><p>涉及参考文献：</p><blockquote><p>[1]周涛,柏文洁,汪秉宏,刘之景,严钢.复杂网络研究概述[J].物理,2005(01):31-36.</p><p><a href="https://www.cnblogs.com/maybe2030/p/4665847.html">[Network Analysis] 复杂网络分析总结 - Poll的笔记 - 博客园 (cnblogs.com)</a></p></blockquote><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>典型的网络：节点+连接节点的边<ul><li>节点：代表真实系统中不同的<strong>个体</strong></li><li>边：代表个体之间的<strong>关系</strong></li><li>eg：神经网络、计算机网络、电力网络、社会关系网络</li></ul></li><li>网络的拓扑性质<ul><li>网络<strong>不依赖</strong>于节点的 <em>具体位置</em> 和 边的 <em>具体形态</em> 就能表现出来的性质</li><li>性质相应的结构：网络的拓扑结构</li></ul></li></ul><h3 id="复杂网络-1"><a href="#复杂网络-1" class="headerlink" title="复杂网络"></a>复杂网络</h3><ul><li><p>钱学森对于复杂网络给出了一种严格的定义：具有<strong>自组织、自相似、吸引子、小世界、无标度</strong>中 <strong>部分或全部</strong>性质 的网络称之为复杂网络。</p></li><li><p>言外之意，复杂网络就是指一种呈现<strong>高度复杂性</strong>的网络</p></li><li><blockquote><blockquote><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2007&amp;filename=JSJA200712003&amp;uniplatform=NZKPT&amp;v=4M8fbSr9Jag8kRTp3gVwrqO7hkHjgcLxJ-HaeSp7dV8RwFv4B21WmBjH1CFMYSVH">[1]赫南,李德毅,淦文燕,朱熙.复杂网络中重要性节点发掘综述[J].计算机科学,2007(12):1-5+17.</a></p></blockquote></blockquote></li><li><p>上文献中认为：复杂网络没有精确严格的定义</p><ul><li>可以<strong>看作大量真实复杂系统的拓扑抽象</strong>，既不是规则网络，也不是随机网络。</li><li>现实世界中的复杂网络比如：社会关系网络、论文引用网络、软件类网络…</li></ul></li></ul><h4 id="特性1：小世界"><a href="#特性1：小世界" class="headerlink" title="特性1：小世界"></a><strong>特性1：小世界</strong></h4><ul><li><p>社交网络中的任何一个成员和任何一个陌生人之间所间隔的人<strong><font color="green">不会超过六个</font></strong> (六度空间理论）</p></li><li><p>小世界网络有 规则网络类似的<font color = "green">聚集性 </font>+ 随机网络类似的较小的<font color="green">平均路径长度</font></p></li><li><p>衡量网络的两个特征</p><ul><li><p><code>特征路径长度（characteristic path length）</code>：在网络中，任选两个节点，<strong>连通</strong>这两节点的<strong>最少</strong>边数，定义为这两个节点的路径长度，网络中<strong>所有节点对的路径长度的平均值</strong>，定义为网络的特征路径长度。</p><ul><li>网络的全局特征。</li></ul></li><li><p><code>聚合系数(clustering coefficient)</code>：假设某节点有k条边，则这k条边连接的节点（k个）之间最多可能存在的边的条数为k(k−1)/2</p><ul><li><p>节点的聚合系数：用<strong>实际存在的边数</strong>除以<strong>最多可能存在的边数</strong>得到的分数值</p></li><li><p><strong>所有节点的聚合系数的均值</strong>定义为网络的聚合系数。</p></li><li><p>聚合系数是网络的局部特征，反映了相邻两个人之间朋友圈子的<strong>重合度</strong>，即该节点的朋友之间也是朋友的程度。</p></li><li><p>对于规则网络，任意两个点（个体）之间的特征路径长度长（通过多少个体联系在一起），但聚合系数高（你是朋友的朋友的朋友的几率高）。</p><blockquote><p>规则网络：用一种固定的规则的结构表示：如二维平面上的欧几里得网格</p></blockquote></li><li><p>对于随机网络，任意两个点之间的特征路径长度短，但聚合系数低。而小世界网络，点之间特征路径长度小，接近随机网络，而聚合系数依旧相当高，接近规则网络。</p><blockquote><p>随机网络：节点之间的边不再是确定的，而是用一个概率决定</p></blockquote></li></ul></li></ul></li><li><p>实际的社会、生态、等网络都是小世界网络，在这样的系统里，<strong>信息传递速度快，并且少量改变几个连接，就可以剧烈地改变网络的性能</strong>，如对已存在的网络进行调整，如蜂窝电话网，改动很少几条线路，就可以显著提高性能。</p></li></ul><h4 id="无标度"><a href="#无标度" class="headerlink" title="无标度"></a>无标度</h4><ul><li><p>现实世界的网络大部分都不是随机网络，<strong>少数的节点往往拥有大量的连接，而大部分节点却很少</strong>，节点度数分布符合<strong>幂律分布</strong>—&gt;网络的无标度特性（Scale-free）。度分布符合<strong>幂律分布</strong>的复杂网络—&gt;无标度网络。</p><blockquote><p>幂律分布：指某个具有分布性质的变量，且其分布密度函数是幂函数（由于分布密度函数必然满足“归一律”，所以这里的幂函数，一般规定小于负1）的分布</p></blockquote></li><li><p>无标度特性反映了复杂网络具有严重的异质性，其各节点之间的连接状况<strong>（度数）具有严重的不均匀分布性</strong></p><ul><li>网络中少数称之为<strong>Hub点</strong>的节点拥有极其多的连接，而大多数节点只有很少量的连接。少数Hub点对无标度网络的运行起着<strong>主导</strong>的作用。</li><li>从广义上说，无标度网络的无标度性是描述大量复杂系统<strong>整体上严重不均匀分布</strong>的一种内在性质。</li></ul></li><li><p>其实复杂网络的无标度特性与<strong>网络的鲁棒性分析</strong>具有密切的关系。</p><ul><li><p>无标度网络中<strong>幂律分布特性</strong>的存在极大地提高了<strong>高度数节点存在</strong>的可能性，因此，无标度网络同时显现出<strong>针对随机故障的鲁棒性和针对蓄意攻击的脆弱性</strong>。这种鲁棒且脆弱性对网络容错和抗攻击能力有很大影响。</p><blockquote><p>鲁棒性：在异常和危险情况下系统生存的能力</p></blockquote></li><li><p>无标度网络具有很强的容错性，但是对基于节点度值的选择性攻击而言，其<strong>抗攻击能力相当差</strong>，高度数节点的存在极大地削弱了网络的鲁棒性，一个恶意攻击者只需选择攻击网络很少的一部分高度数节点，就能使网络迅速瘫痪</p></li></ul></li></ul><h2 id="重要节点、脆弱节点的检测、挖掘"><a href="#重要节点、脆弱节点的检测、挖掘" class="headerlink" title="重要节点、脆弱节点的检测、挖掘"></a>重要节点、脆弱节点的检测、挖掘</h2><p>涉及参考文献</p><blockquote><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2007&amp;filename=JSJA200712003&amp;uniplatform=NZKPT&amp;v=4M8fbSr9Jag8kRTp3gVwrqO7hkHjgcLxJ-HaeSp7dV8RwFv4B21WmBjH1CFMYSVH">[1]赫南,李德毅,淦文燕,朱熙.复杂网络中重要性节点发掘综述[J].计算机科学,2007(12):1-5+17.</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 信安赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复杂网络 </tag>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test1</title>
      <link href="/2022/01/21/test1/"/>
      <url>/2022/01/21/test1/</url>
      
        <content type="html"><![CDATA[<p>这是一个拿来测试的捏<br><span id="more"></span><br><div class="note info">            <p>现在该说点什么呢</p>          </div></p><p>其中，note 后面的class_name 可以是以下列表中的一个值：</p><ul><li>default</li><li>primary</li><li>success</li><li>info</li><li>warning</li><li>danger</li></ul>]]></content>
      
      
      <categories>
          
          <category> 部署测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/20/hello-world/"/>
      <url>/2022/01/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
