<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiaN</title>
  
  <subtitle>是一只废物捏</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-08T14:15:42.705Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>LiaN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【阅读笔记】在线社交网络方向相关</title>
    <link href="http://example.com/2022/08/08/2022-08-08-%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E5%9C%A8%E7%BA%BF%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E6%96%B9%E5%90%91%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2022/08/08/2022-08-08-%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E5%9C%A8%E7%BA%BF%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E6%96%B9%E5%90%91%E7%9B%B8%E5%85%B3/</id>
    <published>2022-08-08T01:55:34.000Z</published>
    <updated>2022-08-08T14:15:42.705Z</updated>
    
    
    
    
    <category term="阅读笔记" scheme="http://example.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="在线社交网络" scheme="http://example.com/tags/%E5%9C%A8%E7%BA%BF%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【SE】数学基础知识</title>
    <link href="http://example.com/2022/08/02/2022-08-02-%E3%80%90SE%E3%80%91%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/08/02/2022-08-02-%E3%80%90SE%E3%80%91%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-08-02T01:55:34.000Z</published>
    <updated>2022-08-11T13:48:17.212Z</updated>
    
    <content type="html"><![CDATA[<ul><li>高数、线代、概率论一些常用基础知识点复习</li></ul><span id="more"></span><h1 id="重点复习"><a href="#重点复习" class="headerlink" title="重点复习"></a>重点复习</h1><p><strong>高数部分</strong></p><ul><li>可导、可微、连续、可积之间的关系（一元函数+二元函数）。✅</li><li>三个中值定理的区别、联系和物理意义（罗尔、拉格朗日、柯西），微分中值定理是啥？</li><li>如何求梯度？梯度、方向导数与梯度。✅</li><li>定积分如何求？定积分的意义？</li><li>给你一个物体表面离散的一堆点，如何求任意表面的法向量？</li><li>凸函数的定义，凸函数的局部最优解一定是全局最优解吗，为什么呢？</li><li>什么是数列的极限，也就是说一个数列xn，收敛于a，你如何定义它？</li><li>用数学语言描述极限</li><li>一阶导，二阶导的物理意义，几何意义</li><li>傅里叶级数和傅里叶变换的关系</li></ul><p><strong>线代部分</strong></p><ul><li>矩阵中秩和迹是如何计算的，物理意义分别是什么？秩是什么？什么是矩阵满秩？怎么求矩阵的秩？</li><li>什么是线性变换？什么是线性空间？</li><li>什么是全等变换？</li><li>什么是极大无关组？</li><li>什么是矩阵相似？</li><li>正定矩阵是什么？</li><li>正交矩阵的定义</li><li>什么是矩阵合同</li><li>对称矩阵是什么？</li><li>特征值和特征向量几何含义？它们的意义以及之间的关系</li><li>矩阵可逆的条件？</li><li>子空间是什么？</li><li>描述一下特征值分解？</li><li>行列式的几何意义？</li><li>线代：如何理解矩阵的秩？简述向量组线性无关的含义？解释正定矩阵以及半正定矩阵？特征值的含义以及矩阵分解的物理意义？</li></ul><p><strong>概率论部分</strong></p><ul><li>解释什么是大数定理，有什么用，什么时候用？</li><li>解释什么是中心极限定理，有什么用，怎么用？数据如何处理？</li><li>全概率公式怎么写？</li><li>贝叶斯公式与应用？</li><li>介绍下正态分布，两个正态分布相加是不是还是正态分布</li><li>解释下相关系数、协方差。相关系数或协方差为0的时候能否说明两个分布无关？为什么？</li><li>极大似然估计</li></ul><p><strong>离散数学部分</strong></p><ul><li>偏序关系和等价关系</li><li>解释下等价关系和等价类</li><li>双射</li><li>什么是覆盖和划分、偏序集合、强弱连通图</li></ul><h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="可微、可导、可积、连续"><a href="#可微、可导、可积、连续" class="headerlink" title="可微、可导、可积、连续"></a>可微、可导、可积、连续</h3><blockquote><p><a href="https://blog.csdn.net/SP_FA/article/details/117473545?ops_request_misc=%7B%22request%5Fid%22%3A%22165969690516782350825991%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165969690516782350825991&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-117473545-null-null.nonecase&amp;utm_term=可导与连续的关系&amp;spm=1018.2226.3001.4450">参考阅读： 可微，可导，可积与连续的关系</a></p></blockquote><h4 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h4><p>🔴 $\textcolor{red}{连续}$</p><p>设$y=f(x)$在$x_{0}$的某一邻域内有定义，若$\lim_{x \to \infty}f(x)= f(x_{0})$，则称$f(x)$在点$x_{0}$处连续</p><ul><li><strong>三个条件</strong><ul><li>函数在该点<strong>有定义</strong></li><li>函数在该点极限$\lim_{x \to \infty}f(x)$<strong>存在</strong></li><li><strong>极限值 =  函数值</strong>：$\lim_{x \to \infty}f(x)= f(x_{0})$</li></ul></li></ul><p>🔴 $\textcolor{red}{可导}$</p><p>设$y=f(x)$在$x_{0}$的某一邻域$U(x_{0})$内有定义，当自变量$x$在$x_{0}$取得增量$\Delta x(x\neq 0) $，且$x_0 +\Delta x \in U(x_0)$时，相应的函数增量 $ \Delta y=f(x_0+\Delta x)-f(x_0)$，若极限</p><script type="math/tex; mode=display">\lim _{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}=\lim _{\Delta x \rightarrow 0} \frac{f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)}{\Delta x}</script><p>存在，则称函数在$x_0$处可导，并称这个极限值为函数在该点处的导数</p><p>🔴 $\textcolor{red}{可微}$</p><blockquote><p>参考阅读：<a href="https://zhuanlan.zhihu.com/p/38967869">如何通俗理解全微分 - 知乎 (zhihu.com)</a></p></blockquote><p>设函数$y=f(x)$ 在区间内有定义，$x_{0}$及$x_{0}+\Delta x$在区间内：</p><ul><li>若增量 $ \Delta y=f(x_0+\Delta x)-f(x_0)$可表示为$\Delta y=A\Delta x+o(\Delta x)$</li><li>其中$A$是不依赖于$\Delta x$的常数，那么称函数$y=f(x)$ 在点$x_0$处可微。</li><li>$A\Delta x$ 叫做函数$y=f(x)$在点 $x_0$处相应于$\Delta x$的微分，记作$ \mathrm dy$</li></ul><p>🔴 $\textcolor{red}{可积}$</p><ul><li>$f(x)$在区间$[a,b]$上<strong>连续</strong>，则在$[a,b]$上可积</li><li>$f(x)$在区间$[a,b]$上<strong>有界，且只有有限个间断点</strong>，则在$[a,b]$上可积</li></ul><h4 id="联系【一元函数】"><a href="#联系【一元函数】" class="headerlink" title="联系【一元函数】"></a>联系【一元函数】</h4><p>⭕ <strong>可导 必然 连续，连续 不一定 可导</strong></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/64324578">证明：连续性和可导性</a></p><p>例子：魏尔施特拉斯函数：<strong>处处连续而处处不可导</strong>：</p></blockquote><p><img src="https://s2.loli.net/2022/08/05/QLWHksud7xAlJjU.png" alt="image.png" style="zoom: 50%;"></p><p>⭕ <strong>可导 和 可微 等价</strong></p><blockquote><p><a href="https://www.zhihu.com/question/319299307#:~:text=一元函数可导，表示曲线可作切线，表示曲线光滑。. （这个没有理解难度吧！. ）. 可导表示可作切线. 一元函数可微，表示曲线段的Y增量可以用直线段的Y增量代替。. 可微表示允许以直代曲.,曲线段PC的X增量是 ，直线段PB的X增量是 。. 两者相等. 曲线段PC的Y增量是 ，直线段PB的Y增量是 。.">一元函数和二元函数，可微和可导有什么区别？ - 知乎 (zhihu.com)</a></p></blockquote><p>⭕ <strong>连续必然可积，可积不一定连续</strong></p><blockquote><p>想想可积和连续的几何意义就理解了</p></blockquote><p>⭕ <strong>可导必然可积，可积不一定可导</strong></p><blockquote><p>可导👉连续👉可积，所以可导必可积。</p><p>可积不一定连续👉不一定可导，所以可积不一定可导。</p></blockquote><h4 id="联系【多元函数】"><a href="#联系【多元函数】" class="headerlink" title="联系【多元函数】"></a>联系【多元函数】</h4><p>🔺 <strong>可导不一定连续，连续不一定可导</strong></p><blockquote><p>可导指的是<strong>可偏导</strong>，所以<strong>并不能推出在所有方向上函数连续</strong></p></blockquote><p>🔺 <strong>可微必然可导，可导不一定可微</strong></p><blockquote><p>一元函数👉可导：存在导数，可微：存在微分。</p><p>多元函数👉可导：存在<strong>偏导数</strong>，可微：存在<strong>全微分</strong>。</p></blockquote><p>🔺<strong>可微必然连续，连续不一定可微</strong></p><p>🔺<strong>偏导数连续必然可微，可微不一定偏导数连续</strong></p><blockquote><p>一个形象的角度理解：<a href="https://zhuanlan.zhihu.com/p/42504140">多元函数可微、可导、连续的关系 - 知乎 (zhihu.com)</a></p><p><strong>连续</strong>：在定义范围内曲面上没有窟窿、断崖（但可以有尖点，有折痕）</p><p><strong>(偏)导函数存在，即可导</strong>：曲面和某个切面相交的那条切线是光滑的（但是偏导函数可以在这点不连续，即极限存在但无定义)</p><p><strong>可微</strong>：曲面是光滑的(想象一个穹顶)</p></blockquote><hr><h3 id="偏导数、方向导数、梯度"><a href="#偏导数、方向导数、梯度" class="headerlink" title="偏导数、方向导数、梯度"></a>偏导数、方向导数、梯度</h3><blockquote><p>参考阅读：</p><p><a href="https://www.cnblogs.com/shine-lee/p/11715033.html">直观理解梯度，以及偏导数、方向导数和法向量等 - shine-lee - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/CSDN_SUSAN/article/details/90166474">导数，偏导数，方向导数，梯度的理解—-微积分数学基础SUSAN的博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/488961148">通俗理解方向导数与梯度 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/31942912">多元函数的偏导数、方向导数、梯度以及微分之间的关系思考 - 知乎 (zhihu.com)</a></p></blockquote><p>🔴 $\textcolor{red}{偏导数}$</p><p>对于多元函数，求导数其实也是要求一个切线的斜率，但是由于曲面上的一个点的切线有<strong>无数条</strong>，那么取那条切线的斜率？引入： <strong>偏导数</strong>。</p><p><strong>偏导数</strong>：可以理解成<strong>多元函数“退化”成一元函数时的导数</strong> ；“退化”：固定其他变量的值，只保留一个变量，依次保留每个变量，则$N$元函数有$N$个偏导数。</p><ul><li><strong>几何意义</strong>：也是切线斜率， 由于曲面上一点的切线有无数条（所有切线组成一个<strong>切面</strong>），偏导数选取的是<font color="red">垂直于各坐标轴</font>的几条特殊切线的<strong>斜率</strong>。</li><li><strong>物理意义</strong>：表示函数沿着<font color="red">某个坐标轴方向上</font>的<strong>变化率</strong></li></ul><p>以二元函数$z=f(x,y)$为例，求$(x_0,y_0,z_0)$的偏导数：</p><ul><li>对$x$的偏导数：过点$(x_0,y_0,z_0)$且垂直于$y$轴的曲线（相当于固定$y$值），在该点切线的斜率</li><li>对$y$的偏导数：过点$(x_0,y_0,z_0)$且垂直于$x$轴的曲线（相当于固定$x$值），在该点切线的斜率</li></ul><p><img src="https://s2.loli.net/2022/08/05/rkE4F6G1TfhS38i.png" alt="image.png" style="zoom:40%;"></p><p>🔴 $\textcolor{red}{方向导数}$</p><p>偏导数计算的是垂直于各坐标轴的几条特殊切线的斜率，某点的切线沿着不同方向有无数条 👉想求某点沿着<font color="red">任意方向</font>的切线斜率？引入：<strong>方向导数</strong>（补充：既然切线都分布在一个平面上，并且每一条切线都代表着函数朝着某一方向的变化率，那么在这个平面上就<strong>必定会存在唯一的一条切线的方向导数最大</strong>。（梯度为0的情况除外）</p><p>以二元函数$z=f(x,y)$为例，求$(x_0,y_0,z_0)$的某方向导数：（<a href="https://www.geogebra.org/m/Bx8nFMNc">下图动态演示地址</a>）</p><ul><li>$x$轴和$y$轴决定的平面上选择某一个方向向量（图中斜着的红色箭头），该方向所在的这个黄色平面 与 蓝色曲面相交 决定了一条过$(x_0,y_0,z_0)$的曲线（隐隐约约的红色细线描出来的部分），点在该曲线上的这条黑色切线斜率即为方向导数</li></ul><p><img src="https://s2.loli.net/2022/08/05/uRhCXbatP98DTxe.png" alt="image.png" style="zoom:33%;"></p><ul><li>设一个方向向量为$\overrightarrow{\mathrm{u}}=(\cos \alpha, \sin \alpha)$ （$\alpha$和$\beta$分别为该方向向量与$x$轴和$y$轴的夹角），则方向导数定义如下，它是个标量：<script type="math/tex; mode=display">\mathrm{D}_{\mathrm{u}} \mathrm{f}(\mathrm{x}, \mathrm{y})=\mathrm{f}_{\mathrm{x}}(\mathrm{x}, \mathrm{y}) \cos \alpha+\mathrm{f}_{\mathrm{y}}(\mathrm{x}, \mathrm{y}) \sin \alpha</script>进一步地，设偏导向量$\overrightarrow{\mathrm{A}}=\left(\mathrm{f}_{\mathrm{x}}(\mathrm{x}, \mathrm{y}), \mathrm{f}_{\mathrm{y}}(\mathrm{x}, \mathrm{y})\right)$，则上述方向导数可以改写为：<script type="math/tex; mode=display">\mathrm{D}_{\mathrm{u}} \mathrm{f}(\mathrm{x}, \mathrm{y})=\overrightarrow{\mathrm{A}} * \overrightarrow{\mathrm{u}}=|\overrightarrow{\mathrm{A}}| *|\overrightarrow{\mathrm{u}}| * \cos (\theta)</script>$ \theta$ 是偏导向量和方向向量之间的夹角。当$\theta=0$即二者同向时，方向导数$D_{u} f(x, y)$取得<strong>正</strong>最大值。反向时，则<strong>负</strong>最大值。</li></ul><p>🔴 $\textcolor{red}{梯度}$</p><p><strong>梯度：</strong>是一个矢量，函数在某点 无数个变化方向中 <strong>变化最快</strong>的 <u><strong>那个方向</strong></u></p><blockquote><p>即：偏导数构成的向量；由此：方向导数 = 梯度 * 方向向量</p></blockquote><p>函数只要<strong>每一个变量</strong>都沿着关于这个变量的<strong>偏导所指定的方向</strong>来变化，函数的整体变化就能达到最快（变化的绝对值最大）</p><p><strong>梯度的几何意义</strong>：</p><ol><li>当前位置的<strong>梯度方向</strong>，为函数在该位置处<strong>方向导数最大的方向</strong>，也是函数值<strong>上升最快的方向</strong>，反方向为下降最快的方向；</li><li>当前位置的<strong>梯度长度（模）</strong>，为最大方向导数的值</li><li>梯度（下降）的方向与<strong>等高线的切线方向垂直</strong></li></ol><p>以二元函数$z=f(x,y)$为例，其方向导数定义如下：</p><script type="math/tex; mode=display">\nabla f\left(x_{0}, y_{0}\right)=\left.\left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\right)\right|_{\left(x_{0}, y_{0}\right)}</script><hr><h2 id="微积分基础"><a href="#微积分基础" class="headerlink" title="微积分基础"></a>微积分基础</h2><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/BV1U94y1R71P?p=11&amp;spm_id_from=pageDriver&amp;vd_source=29f5937d4c8dc6b894a81d48deba4d66">3-定积分_哔哩哔哩_bilibili</a></p></blockquote><p>🔴 $\textcolor{red}{区分\Delta y和dy}$</p><p><img src="https://s2.loli.net/2022/08/06/1PtNzyeOvaKbkRV.png" alt="image.png" style="zoom:50%;"></p><h3 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h3><p>🔴 $\textcolor{red}{定义}$</p><p><img src="https://s2.loli.net/2022/08/06/O7ZjLAptkUSNln3.png" alt="image.png" style="zoom: 50%;"></p><p>🔴 $\textcolor{red}{积分上限函数}$</p><p>函数$f(x)$在区间$[a,b]$上连续，对于定积分$\int_{a}^{x} f(x) d x$每一个取值$x$都有一个对应的定积分值，记作$\Phi(x)= \int_{a}^{x} f(t) dt$</p><p>若函数$f(x)$在区间$[a,b]$上连续，则积分上限函数就是$f(x)$在$[a,b]$上的原函数</p><h3 id="两大积分中值定理"><a href="#两大积分中值定理" class="headerlink" title="两大积分中值定理"></a>两大积分中值定理</h3><p>🔴 $\textcolor{red}{第一中值定理}$</p><p>如果函数$f(x)$在闭区间$[a,b]$上连续，则在积分区间$[a,b]$上，至少存在一个点$\xi$，使$\int_{a}^{b} f(x) d x=f(\xi)(b-a) . \quad(a \leq \xi \leq b)$</p><p><img src="https://s2.loli.net/2022/08/06/7iEsOulChydFNkU.png" alt="image.png" style="zoom:50%;"></p><p>🔴 $\textcolor{red}{第二中值定理}$</p><h3 id="三大微分中值定理"><a href="#三大微分中值定理" class="headerlink" title="三大微分中值定理"></a>三大微分中值定理</h3><h3 id="牛顿-莱布尼兹公式"><a href="#牛顿-莱布尼兹公式" class="headerlink" title="牛顿-莱布尼兹公式"></a>牛顿-莱布尼兹公式</h3><p>🔴 $\textcolor{red}{定义}$</p><p>如果$F(x)$是连续函数$f(x)$在区间$[a,b]$上的一个原函数，则$\int_{a}^{b} f(x) d x=F(a)-F(b)$。</p><blockquote><p>即：一个连续函数在区间$[a,b]$上的定积分等于它的任意一个原函数在区间$[a,b]$上的增量</p></blockquote><p>🔴 $\textcolor{red}{几何解释}$</p><p>可得：$f(b)-f(a)=\sum dy$，由于$dy=f’(x)dx$，$f(b)-f(a)=\sum f’(x)dx= \int_{a}^{b}f’(x)dx $</p><p><img src="https://s2.loli.net/2022/08/06/R1O8iWub7dXer62.png" alt="image.png" style="zoom:40%;"></p><hr><h2 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h2><blockquote><p>用简单的熟悉的多项式来近似代替复杂的函数</p></blockquote><p>🔴 $\textcolor{red}{泰勒多项式}$</p><p>$f(x)$在$x_0$关于$(x-x_0)$的n阶泰勒多项式：</p><script type="math/tex; mode=display">\begin{array}{l}P_{n}(x)=f\left(x_{0}\right)+f^{\prime}\left(x_{0}\right)\left(x-x_{0}\right)+\frac{f^{\prime \prime}\left(x_{0}\right)}{2 !}\left(x-x_{0}\right)^{2}+ \cdots \quad+\frac{f^{(n)}\left(x_{0}\right)}{n !}\left(x-x_{0}\right)^{n}\end{array}</script><p>🔴 $\textcolor{red}{麦克劳林公式}$</p><p>令$x_0=0$：</p><script type="math/tex; mode=display">\begin{aligned}f(x)=& f(0)+f^{\prime}(0) x+\frac{f^{\prime \prime}(0)}{2 !} x^{2}+\cdots+\frac{f^{(n)}(0)}{n !} x^{n}+\frac{f^{(n+1)}(\theta x)}{(n+1) !} x^{n+1}(0<\theta<1)\end{aligned}</script><p>🔴 $\textcolor{red}{泰勒多项式中 阶数的作用}$</p><ul><li>阶数越高，增长速度越快；越高次项在越偏右侧影响越大</li><li>对于一个复杂函数，低阶项能更好地描述当前点附近，对于之后的走势就越来越依靠高阶项</li></ul><hr><h2 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h2><h2 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h2><blockquote><p>寻找变量受一个或多个条件限制的多元函数的极值</p><p>参考阅读：<a href="https://www.zhihu.com/question/38586401">如何理解拉格朗日乘子法？ - 知乎 (zhihu.com)</a></p></blockquote><p><img src="https://s2.loli.net/2022/08/06/JqrMlxpIzNFVwRS.png" alt="image.png" style="zoom: 30%;"></p><p>例如对于一个二元函数函数：$z=f(x,y)$在条件$\varphi(x, y)=0$下的极值，构造函数$F(x,y)=f(x,y)+\lambda \varphi(x, y)$，其中$\lambda$为拉格朗日乘数，构造下列函数求得极值点坐标：</p><script type="math/tex; mode=display">\left\{\begin{array}{c}f_{x}(x, y)+\lambda \varphi_{x}(x, y)=0 \\f_{y}(x, y)+\lambda \varphi_{y}(x, y)=0 \\\varphi(x, y)=0\end{array}\right.</script><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><blockquote><p>参考阅读：</p><p><a href="https://zhuanlan.zhihu.com/p/327042762">矩阵乘法核心思想（1）：列空间 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>🔴 $\textcolor{red}{线性变换}$</p><script type="math/tex; mode=display">\begin{array}{c}L(\overrightarrow{\mathbf{v}}+\overrightarrow{\mathbf{w}})=L(\overrightarrow{\mathbf{v}})+L(\overrightarrow{\mathbf{w}}) \\L(c \overrightarrow{\mathbf{v}})=c L(\overrightarrow{\mathbf{v}})\end{array}</script><p><strong>几何角度理解</strong>：它是网格线保持平行且等距分布的变换（1）直线在变换后仍保持直线，不弯曲 （2）原点必须固定</p><p>一种矩阵相乘的几何理解方式👉<strong>线性变换作用于给定向量</strong>：把矩阵的列看作<strong>变换后的基向量</strong>，矩阵向量乘法看作它们的线性组合</p><p><img src="https://s2.loli.net/2022/08/07/AiGpU7y1XshJtE4.png" alt="image.png" style="zoom:33%;"></p><h2 id="线性相关和线性无关"><a href="#线性相关和线性无关" class="headerlink" title="线性相关和线性无关"></a>线性相关和线性无关</h2><p>🔴 $\textcolor{red}{张成空间}$</p><p>所有可以表示为给定向量 线性组合 的向量的集合，被称为给定向量的张成空间</p><blockquote><p>仅通过向量加法和数乘，所能获得的可能向量的集合</p></blockquote><p>🔴 $\textcolor{red}{线性组合}$</p><p>m个n维向量$\alpha_{1},\alpha_{2},…,\alpha_{m}$，及m个数$k_{1},k_{2},…,k_{m}$，则向量$k_{1}\alpha_{1}+k_{2}\alpha_{2}+…+k_{m}\alpha_{m}$称为向量$\alpha_{1},\alpha_{2},…,\alpha_{m}$的一个线性组合</p><blockquote><p>多个数乘向量的和</p><p><strong>线性</strong>是指向量乘以一个标量，沿着向量的方向缩放，方向不变；<strong>组合</strong>是把多个向量加起来</p></blockquote><p>🔴 $\textcolor{red}{线性相关和线性无关}$</p><p>对m个n维向量$\alpha_{1},\alpha_{2},…,\alpha_{m}$，若<strong>存在不全为0</strong>的数$k_{1},k_{2},…,k_{m}$，使得$k_{1}\alpha_{1}+k_{2}\alpha_{2}+…+k_{m}\alpha_{m}=0$成立，则称$\alpha_{1},\alpha_{2},…,\alpha_{m}$<strong>线性相关</strong>，否则称线性无关</p><blockquote><p>或者说，一个向量可以表示为其他向量的线性组合，那么这些向量线性相关</p></blockquote><p><strong>几何角度理解</strong>：</p><ul><li><p><strong>线性相关</strong>：一组向量中至少有一个是<strong>多余</strong>的，没有对张成空间做出贡献，可以移除其中一个而不减小张成空间</p></li><li><p><strong>线性无关</strong>：一组向量中的所有向量都给张成空间<strong>增添了新的维度</strong></p><blockquote><p>比如对于$\vec a$ 和$\vec b$ 张成的二维平面，若$\vec c$  刚好落在该平面中，那么$\vec c$ 的加入对张成空间没有任何贡献，仍然是一个二维平面，说明它们三个是线性相关的；如果$\vec c$ 没有落在那个二维平面，而使得张成空间变成一个三维空间了，说明它们三个是线性无关的</p></blockquote></li><li><p><strong>或者说</strong>：一组矢量的线性相关性本质上，是描述他们所张成的<strong>广义平行四边形体积是否为零</strong>。N个向量线性无关👉他们所张成的N维体的体积不为零。于是有：<strong>线性无关矢量</strong>组成的矩阵的<strong>行列式不为零</strong>；线性相关矢量组成的矩阵的行列式必为零。</p></li></ul><p>🔴 $\textcolor{red}{空间中的一组基}$</p><p>向量空间中的一组基是<strong>张成该空间</strong>的一个<strong>线性无关</strong>的<strong>向量集合</strong></p><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>🔴 $\textcolor{red}{行列式的几何意义}$</p><p>可以理解为<strong>线性变换的比例</strong>，如果是负数，说明变换后的<strong>空间定向</strong>发生改变</p><blockquote><p>例如，一个线性变换作用于一个2x2矩阵，该线性变换的行列式是1/2，那么变换后的区域的面积变成了原来的1/2（三维则是体积的缩放）；</p></blockquote><p>若一个二维线性变换的<strong>行列式为0</strong>，说明它将整个平面<strong>压缩到一条线，甚至一个点</strong>上，👉根据行列式是否=0，就能知道这个矩阵所代表的变换是否将空间压缩到更小的维度上</p><blockquote><p>或者理解为：<strong>向量围成空间的面积或体积</strong>；行列式就是在给定一组基下，N个向量张成的一个N维广义四边形的体积。2阶行列式代表的是平面内的面积；3阶行列式自然而然就是3维空间内的体积；4阶行列式是4维空间里的超体积</p></blockquote><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>🔴 $\textcolor{red}{逆矩阵}$</p><p><strong>理论定义</strong>：</p><p><strong>理解</strong>：$Ax=v $  ⇨ $A^{-1}Ax=A^{-1}v$  ⇨ $x=A^{-1}v$</p><p>寻找一个向量$x$，使得它在经过线性变换$A$ 之后与 $v$ 重合：$Ax=v$</p><ul><li>若行列式$|A|=0$，说明线性变换$A$ 将<strong>空间压缩</strong>到了<strong>更低</strong>维度→ <strong>不存在</strong>$A^{-1}$</li><li>若$|A|\neq 0$（<strong>← 矩阵可逆的充要条件</strong>），说明原来的空间<strong>没被挤压</strong>，在这种情况下，有且仅有一个向量$x$在变换后与$v$重合</li></ul><p>即便不存在$A^{-1}$，<strong>解仍然可能存在</strong>：$A$将空间压缩为一条直线，而原本的$v$也刚好落在这条直线上</p><p>🔴 $\textcolor{red}{秩}$</p><p><strong>理论定义</strong>：</p><p><strong>几何角度理解</strong>：代表<strong>变换后的维数</strong></p><blockquote><p>若一个线性变换作用的结果是一维的，则这个变换的秩是1，二维的则是2… </p><p>一个3x3的矩阵，秩=2，说明空间被压缩</p></blockquote><p>🔴 $\textcolor{red}{列空间}$</p><p>所有可能的输出向量$Av$构成的集合称作$A$的列空间（矩阵的列所张成的空间）；</p><p>更精确地讲，秩是列空间的维数</p><blockquote><p>用于线性变换的矩阵的列 可以看作 变换后的基向量，这些变换后的基向量张成的空间就是所有可能的变换结果</p></blockquote><p>🔴 $\textcolor{red}{满秩}$</p><p>对于一个满秩变换：唯一能在变换后落在原来的点就是零向量本身；</p><p>对于非满秩变换，它将空间压缩到一个更低的维度上⇨ 会有一系列在变换后称为零向量</p><blockquote><p>一个二维线性变换将空间压缩到一条直线上，那么沿着某个不同于该直线的方向的所有向量都被压缩到原点</p></blockquote><p><strong>零空间</strong>（核）：变换后会落在原点的向量的集合；对于$Ax=0$，零空间给出了这个向量方程所有可能的解</p><h3 id="各种矩阵"><a href="#各种矩阵" class="headerlink" title="各种矩阵"></a>各种矩阵</h3><p>🔴 $\textcolor{red}{正定矩阵}$</p><p>🔴 $\textcolor{red}{正交矩阵}$</p><p>🔴 $\textcolor{red}{对称矩阵}$</p><p>🔴 $\textcolor{red}{矩阵合同}$</p><p>🔴 $\textcolor{red}{相似矩阵}$</p><h2 id="内积和外积"><a href="#内积和外积" class="headerlink" title="内积和外积"></a>内积和外积</h2><blockquote><p>点积（点乘），叉积（叉乘）</p></blockquote><h3 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h3><p>🔴 $\textcolor{red}{定义}$</p><p>设有$n$维向量，$x=\begin{pmatrix}x_1\\ x_2\\ \vdots\\ x_n\end{pmatrix}$，$y=\begin{pmatrix}y_1 \\y_2\\ \vdots \\y_n\end{pmatrix}$，$x$和$y$的内积 $x  \bullet y$ 如下：</p><script type="math/tex; mode=display">x^{T} y=\left(x_{1}, x_{2}, \cdots, x_{n}\right)\left(\begin{array}{c}y_{1} \\y_{2} \\\vdots \\y_{n}\end{array}\right)=x_1y_1+x_2y_2+...+x_ny_n</script><p>🔴 $\textcolor{red}{几何意义}$</p><p>$v\cdot w$的结果：$w$在$v$上的投影长度 乘 $v$的长度： $|w||v|cos \theta$</p><p><img src="https://s2.loli.net/2022/08/07/IaBn9Uf7jOD3PFV.png" alt="image.png" style="zoom: 33%;"></p><h3 id="外积"><a href="#外积" class="headerlink" title="外积"></a>外积</h3><p>外积的结果是<strong>一个向量</strong>，并非一个数 </p><p>以二维为例，结果就是两个向量围成的平行四边形的<strong>面积</strong></p><p><img src="https://s2.loli.net/2022/08/07/QUa8VjlWvgfxrZO.png" alt="image.png" style="zoom:33%;"></p><p>面积的计算可以考虑行列式、$|v\times w| =|v||w|sin\theta$</p><p>方向的确定（基向量的确定就是定向的基础）：</p><p><img src="https://s2.loli.net/2022/08/07/pHjM3ktqFQcrzKa.png" alt="image.png" style="zoom:33%;"></p><font color="red">真正的叉积是两个三维向量生成一个新的三维向量</font><p>方向的确定（右手定则）：</p><p><img src="https://s2.loli.net/2022/08/07/Gow7FAyfa5RbxHi.png" alt="image.png" style="zoom:33%;"></p><p>计算：</p><p><img src="https://s2.loli.net/2022/08/07/K7Bk1T4mO8gcPsi.png" alt="image.png" style="zoom:33%;"></p><h2 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h2><p>🔴 $\textcolor{red}{定义}$</p><p>给定一个矩阵$A$，寻找一个常数$\lambda$和一个非零向量$x$ ，使得向量$x$被矩阵$A$作用后所得到的向量$Ax$ 与 原向量$x$ 平行，并且满足$Ax = \lambda x$ 。那么，$\lambda$：特征值，$x$：特征向量。</p><p><strong>求特征向量</strong>：$Ax=\lambda Ix$ （$I$是单位对角阵），$(A-\lambda I)x=0$，$x$是非零向量，因为当且仅当矩阵代表的变换将空间压缩到更低维度时，才会存在一个非零向量，使得矩阵和它的乘积为0，所以最终就是求行列式$|A-\lambda I|=0$</p><p>🔴 $\textcolor{red}{理解}$</p><p><strong>几何角度理解</strong>：</p><ul><li>将一个线性变换施加在一个基上，线性变换后<strong>仍然留在</strong>原来的基所张成的空间里的向量，就是这个线性变换的特征向量，任何其他向量在变换中都有或多或少的旋转→离开它原来张成的那条直线。</li><li>每个特征向量都有一个所属的值：特征值，它是用来衡量特征向量在线性变换中拉伸或压缩比例的因子。</li></ul><blockquote><p>例如某特征向量的特征值是-1/2，意味着原向量被反向且压缩为原来的1/2，但它仍然留在原来张成的直线上，并为发生旋转。</p><p>考虑一个三维空间的旋转，若能找到这个旋转的特征向量，也就相当于找到了它的旋转轴，这种情况下，相应的特征值=1：旋转不缩放任何一个向量</p></blockquote><p><strong>特征值越大</strong>，我们可以认为<strong>对应的特征向量越重要</strong>。既然特征值表达了重要程度且和特征向量所对应，那么特征值大的就是主要信息，基于这点我们可以提取各种有价值的信息。</p><p>🔴 $\textcolor{red}{特征空间}$</p><p>特征空间包含了所有的特征向量</p><p>🔴 $\textcolor{red}{基变换}$</p><p>数据与第一个基做内积运算，结果为第一个新的坐标分量，依次类推，例如数据$(3,2)$映射到给定的一个基上的坐标：</p><script type="math/tex; mode=display">\begin{pmatrix}1/\sqrt2  &1/\sqrt2 \\-1/\sqrt2  &1/\sqrt2\end{pmatrix}\begin{pmatrix}3 \\2\end{pmatrix}=\begin{pmatrix}5/\sqrt[]{2}   \\-1/\sqrt[]{2} \end{pmatrix}</script><h2 id="特征值分解"><a href="#特征值分解" class="headerlink" title="特征值分解"></a>特征值分解</h2><hr><h1 id="概率论与梳理统计"><a href="#概率论与梳理统计" class="headerlink" title="概率论与梳理统计"></a>概率论与梳理统计</h1><h2 id="大数定律和中心极限定理"><a href="#大数定律和中心极限定理" class="headerlink" title="大数定律和中心极限定理"></a>大数定律和中心极限定理</h2><p>中心极限定理是说<font color="red">无论抽样分布如何 均值服从正态分布 </font>，而大数定律根本和正态分布无关 是说样本大了抽样分布近似总体分布</p><blockquote><p>参考阅读：</p><p><a href="https://blog.csdn.net/haoso2/article/details/85290720?ops_request_misc=%7B%22request%5Fid%22%3A%22165976780516782395311447%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165976780516782395311447&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-85290720-null-null.nonecase&amp;utm_term=大数定理&amp;spm=1018.2226.3001.4450"> 大数定理的通俗理解_haso的博客-CSDN博客</a></p><p><a href="https://www.zhihu.com/question/22913867">怎样理解和区分中心极限定理与大数定律？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/question/19911209/answer/245487255">大数定律具体是个什么概念？ - 知乎 (zhihu.com)</a></p></blockquote><h3 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h3><p>🔴 $\textcolor{red}{关键理解}$</p><ul><li><p>小数定律：如果统计数据很少，那么事件就表现为各种极端情况，而这些情况都是偶然事件，跟它的期望值一点关系都没有</p></li><li><p>大数定律：在试验不变的条件下，重复试验多次，那么随机事件出现的<strong>频率</strong>就能无限接近它的<strong>期望值（概率）</strong>。因此我们可以用样本均值来估计总体的期望。</p></li></ul><p>🔴 $\textcolor{red}{切比雪夫大数定律(一般情形)}$</p><p>设$ X_{1}, X_{2}, \ldots, X_{n}, \ldots $是由两两不相关（或两两独立）的随机变量所构成的序列, 分别具有 数学期望$E\left(X_{1}\right), E\left(X_{2}\right), \ldots, E\left(X_{n}\right), \ldots $和方差$D\left(X_{1}\right), D\left(X_{2}\right), \ldots D\left(X_{n}\right), \ldots ,$ 并且方差 有公共上界, 即存在正数  $M$ , 使得 $D\left(X_{n}\right) \leq M, n=1,2, \ldots ,$则对于任意给定的正数 $\varepsilon$ 总有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|\frac{1}{n} \sum_{k=1}^{n} X_{k}-\frac{1}{n} \sum_{k=1}^{n} E X_{k}\right|<\varepsilon\right\}=1</script><blockquote><p>这些变量的均值 依概率收敛为 这些期望的均值</p></blockquote><p>🔴 $\textcolor{red}{独立同分布的切比雪夫大数定律(特殊情形)}$</p><p>设随机变量$X_{1}, X_{2}, \ldots, X_{n}, \ldots$<strong>相互独立, 服从相同的分布</strong>, 具有数学期望$E\left(X_{n}\right)=\mu$ 和 方差$D\left(X_{n}\right)=\sigma^{2}(n=1,2, \ldots)$，则对于任意给定的正数$\varepsilon$，总有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|\frac{1}{n} \sum_{k=1}^{n} X_{k}-\mu\right|<\varepsilon\right\}=1,即随机变量序列  \overline{X_{n}}=\frac{1}{n} \sum_{k=1}^{n} X_{k} \stackrel{P}{\longrightarrow} \mu .</script><p>🔴 $\textcolor{red}{辛钦大数定律}$</p><p>设随机变量$X_{1}, X_{2}, \ldots, X_{n}, \ldots$<strong>相互独立, 服从相同的分布</strong>，具有数学期望$E\left(X_{n}\right)=\mu (n=1,2, \ldots)$，则对于任意给定的正数$\varepsilon$，总有</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|\frac{1}{n} \sum_{k=1}^{n} X_{k}-\mu\right|<\varepsilon\right\}=1</script><p>🔴 $\textcolor{red}{伯努利大数定律}$</p><blockquote><p>它的直观表达就是只要做的试验够多，出现的次数 除以 总次数的结果 接近 统计概率p</p></blockquote><p>设在每次实验中$A$发生的概率$P(A)=p$，在$n$次独立重复实验中，事件$A$发生的频率为$f_n(A)$，则对任意正数$\varepsilon$，总有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|f_n(A)-p\right|<\varepsilon\right\}=1</script><h3 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h3><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/BV1ah411q7tp/?spm_id_from=333.788&amp;vd_source=29f5937d4c8dc6b894a81d48deba4d66">中心极限定理的直观理解_哔哩哔哩_bilibili</a></p></blockquote><p>🔴 $\textcolor{red}{关键理解}$</p><ul><li><p>中心极限定理告诉我们，当样本量足够大时<strong>，样本均值的抽样分布</strong>慢慢趋近于<strong>正态分布</strong></p></li><li><p>不管总体是什么分布，任意一个<strong>总体的样本</strong>平均值都会围绕在<strong>总体的整体平均值</strong>周围，并且呈正态分布</p></li></ul><p>🔴 $\textcolor{red}{棣莫弗-拉普拉斯中心极限定理}$</p><p>设随机变量$X_n$服从参数$n$和$p$的二项分布，即$X_n\sim B(n,p)(0&lt;p&lt;1,n=1,2,\dots)$，则对于任意实数$x$，有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\frac{X_{n}-n p}{\sqrt{n p(1-p)}} \leq x\right\}=\Phi(x)</script><p>$\Phi(x)$为标准正态分布的分布函数</p><p>🔴 $\textcolor{red}{列维-林德伯格中心极限定理}$</p><p>设随机变量$X_{1}, X_{2}, \ldots, X_{n}, \ldots$<strong>相互独立, 服从相同的分布</strong>, 具有数学期望$E\left(X_{n}\right)=\mu$ 和 方差$D\left(X_{n}\right)=\sigma^{2}(n=1,2, \ldots)$，则对于任意实数$x$，有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\frac{\sum_{k=1}^{n} X_{k}-n \mu}{\sqrt{n} \sigma} \leq x\right\}=\Phi(x)</script><p>$\Phi(x)$为标准正态分布的分布函数</p><h2 id="全概率公式和贝叶斯公式"><a href="#全概率公式和贝叶斯公式" class="headerlink" title="全概率公式和贝叶斯公式"></a>全概率公式和贝叶斯公式</h2><h2 id="各种分布"><a href="#各种分布" class="headerlink" title="各种分布"></a>各种分布</h2><h2 id="协方差和相关系数"><a href="#协方差和相关系数" class="headerlink" title="协方差和相关系数"></a>协方差和相关系数</h2><h1 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h1><h2 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h2><blockquote><p>参考阅读：</p><p><a href="https://zhuanlan.zhihu.com/p/376118280">【群论入门】(2)：模算术 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/377775196">【群论入门】(3): 群的定义 - 知乎 (zhihu.com)</a></p><p><a href="https://www.bilibili.com/video/BV1qf4y1m7K1?spm_id_from=333.337.search-card.all.click&amp;vd_source=29f5937d4c8dc6b894a81d48deba4d66">【近代应用数学-南京大学】给非数学系的基础入门款 群论/实变/点集拓扑/泛函_哔哩哔哩_bilibili</a></p></blockquote><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>🔴 $\textcolor{red}{代数运算}$</p><p>设$A$非空集合，引入一个法则，使得$A$中任意两个元素与$A$中另一个元素唯一对应，那么可以把这个法则称为$A$上的一个代数运算</p><blockquote><p>例如：A是实数集合$\mathbb{R}$，法则→加法$+$；$\forall x,y\in \mathbb{R}$，$x+y\in \mathbb{R}$。</p><p>又如：向量的内积就不是一个代数运算，$\vec a,\vec b\in V$，$\vec a \cdot \vec b \in \mathbb{R}$，也就是说$V\cdot V\to \mathbb{R}$</p></blockquote><p>🔴 $\textcolor{red}{半群}$</p><p>设$(S，∗)$ 是一个代数系统，“∗”是非空集合S上的一个代数运算。若</p><p>​    （1）“∗”具有<strong>封闭性</strong>，即∗是S上的闭运算；    （2）“∗”满足<strong>结合律</strong>。</p><p>则称(S，∗)是一个半群。</p><blockquote><p>比如，G={2，4，6，8，…}，（G,+)就是一个半群，只满足结合律，没有幺元<u>0</u>，也没有逆元<u>负数</u></p></blockquote><p>🔴 $\textcolor{red}{幺元}$</p><p>设$(S，∗)$是一个代数系统，      </p><p>（1）若存在$e_右∈S$，使得对于任意的$x∈S$，有$x∗e_右=x$，则称$e_右$是<strong>右幺元</strong>。      </p><p>（2）若存在$e_左∈S$，使得对于任意的$x∈S$，有$e_左∗x=x$，则称$e_ 左$是<strong>左幺元</strong>。     </p><p>（3）若存在一个元素e∈S，它<strong>既是左幺元，又是右幺元</strong>，则称e是<strong>幺元（又称单位元）</strong>。</p><p><strong>若有幺元，则幺元唯一</strong>。    </p><blockquote><p> 证明：设$e_左，e_右∈S$分别是左幺元和右幺元，则有$e_左=e_左∗e_右=e_右$</p><p> 若有$e_1，e_2∈S$，且均是幺元，则有$e_1=e_1∗e_2=e_2$通常用$e$表示么元</p></blockquote><p>🔴 $\textcolor{red}{含幺半群}$</p><p>称含有<strong>幺元的半群</strong>为含幺半群。     </p><blockquote><p>比如 0是半群$(N，+)$的幺元，而1是半群$(N，×)$的幺元。$(N，+)$和$(N，×)$都是含幺半群</p></blockquote><p><strong>子半群</strong>：设$(S，∗)$是一个半群，$∅≠A⊆S$，若$(A，∗)$<strong>本身是一个半群</strong>，则称$(A，∗)$是$(S，∗)$的子半群</p><blockquote><p>比如：G={0，2，4，6，8，…}，（G,+)就是一个幺半群，满足结合律，<strong>有</strong>幺元<u>0</u>，也没有逆元<u>负数</u></p><p>若，G={0，±1，±2，…}，(G,+)就是一个群；</p><p>最小的群：（G,$\circ$) = {e}</p></blockquote><p>🔴 $\textcolor{red}{逆元}$</p><p>设$(S，∗)$是一个代数系统，$e∈S$是<strong>幺元</strong>，$a∈S$。     </p><p>（1）若存在$b∈S$，使得$a∗b=e$，则称$b$是$a$的<strong>右逆元</strong>；     </p><p>（2）若存在$d∈S$，使得$d∗a=e$，则称$d$是$a$的<strong>左逆元</strong>；     </p><p>（3）若存在$a^′∈S$，使得$a^′$既是$ a$的<strong>左逆元</strong>，又是$a$的<strong>右逆元</strong>，则称$a^′$是$a$的逆元。</p><blockquote><p>设(S，∗)是一个代数系统，∗满足结合律，e∈S是幺元，a∈S是任意的元素，则     </p><p>（1）若a既有左逆元，又有右逆元，则a的<strong>左逆元等于右逆元</strong>，即为a的逆元。    </p><p>（2）a的逆元<strong>若存在，则唯一</strong>。</p></blockquote><p>🔴 $\textcolor{red}{群的定义}$</p><p>$(S，∗)$是一个代数系统，若$(S，∗)$满足以下四条：       </p><p>（1）”∗”是$S$上的<strong>闭运算</strong>；       </p><p>（2）”∗”适合<strong>结合律</strong>；       </p><p>（3）存在<strong>幺元</strong>$e∈S$（又称之为单位元）；       </p><p>（4）对于$S$中的任意元素$a$，存在<strong>逆元</strong>$a^{−1}∈S$。</p><p>则称$(S，∗)$是一个群。</p><p><strong>半群</strong>：(1)+(2)；<strong>幺半群</strong>：(1)+(2)+(3)</p><p>🔴 $\textcolor{red}{左右消去律}$</p><p>设$(S，∙)$是一个代数系统。若对于任意的$x，y，z∈S$，满足       </p><p>如果$x∙y=x∙z$，那么$y=z$，则称“$∙$”运算满足左消去律；        </p><p>如果$y∙x=z∙x$，那么$y=z$，则称“$∙$”运算满足右消去律。 </p><p>设$(G，∙)$是一个群，则“$∙$”运算分别满足左、右消去律</p><p>🔴 $\textcolor{red}{群的性质}$</p><p>🔸 群$(G,\circ)$，若$a,b\in G$，$b\circ a=e$，则$a\circ b=e$</p><p>🔸 群$(G,\circ)$，$e$，$\forall a\in G$，$e\circ a=a\circ e =a$</p><p>🔸 群$(G,\circ)$ 的幺元 $e$ 是唯一的</p><p>🔸 群$(G,\circ)$ ，$\forall a\in G$，$a$ 的逆元是唯一的</p><p>🔴 $\textcolor{red}{幂}$</p><p>$a\in G,n\in \mathbb{N},a^n=a…a,\quad a^0=e,a^{-1}=a的逆元，(a^{-1})^n = a^{-n}$</p><p>∴ $a^{m+n}=a^m \circ a^n,m、n\in \mathbb{Z}$</p><p>∴ $(a^n)^m = a^{nm}$</p><p>🔴 $\textcolor{red}{阶}$</p><p>群$(G,\circ)$，$a\in G$，$a^m=e$的最小的$m\in \mathbb{N}$，$m$称为$a$的阶，若找不到$m\in \mathbb{N}$，称$a$的阶为0</p><h3 id="群的同态和同构"><a href="#群的同态和同构" class="headerlink" title="群的同态和同构"></a>群的同态和同构</h3><p>🔴 $\textcolor{red}{同态和同构}$</p><p>设$(S_1，∗)$，$(S_2，∙)$是两个代数系统，“∗” 是$S_1$上的一个二元运算，“∙” 是$S_2$上的一个二元运算。设$f$是$S_1$到$S_2$的一个映射，即$f：S_1→S_2$。若对于$S_1$中的任意两个元素$x_1，x_2$，有$f(x_1∗x_2)=f(x_1)∙f(x_2)$，则称映射$f$是$S_1到S_2$的一个同态映射。      </p><ul><li>若$f$是单射，则称$f$是一个单一同态映射；     </li><li>若$f$是满射，则称$f$是一个满同态映射；      </li><li>若$f$是<strong>双射</strong>，则称$f$是一个<strong>同构映射</strong>。 </li></ul><p>若两个代数系统之间存在一个同构映射，则称这两个代数系统是同构的。</p><p>群的同构作为群的关系，是一个等价关系：满足自反性、对称性、传递性</p><p>🔴 $\textcolor{red}{例子}$</p><p><img src="https://s2.loli.net/2022/08/08/rnCjQweYhBoMd1a.png" alt="image.png" style="zoom: 43%;"></p><p><img src="https://s2.loli.net/2022/08/08/ljGVHB5L9Xe2kAv.png" alt="image.png" style="zoom:33%;"></p><p><img src="https://s2.loli.net/2022/08/08/XRTjeDCtJnuImdL.png" alt="image.png" style="zoom: 33%;"></p><h3 id="无限群和有限群"><a href="#无限群和有限群" class="headerlink" title="无限群和有限群"></a>无限群和有限群</h3><p>🔴 $\textcolor{red}{定义}$</p><p>设$(G，∙)$是一个群，     </p><p>若$G$是<strong>无限集</strong>，则称$(G，∙)$是无限群。      </p><p>若$G$是<strong>有限集</strong>，且$|G|=n$，则称$(G，∙)$是$n$阶有限群。      </p><p>🔴 $\textcolor{red}{阶}$</p><p><img src="https://s2.loli.net/2022/08/08/G14mgtHl9iCP6XW.png" alt="image.png" style="zoom:40%;"></p><blockquote><p> 比如：在整数加群$(Z，+$)中，对于任意的$a∈Z(a≠0)$，因为对于任意的正整数n，有$a+a+⋯+a(n个a)=na≠0$      所以，$o(a)=∞$</p></blockquote><p>设$(G，∙)$是一个交换群，对于任意的$ a，b∈G$，有$(a∙b)^n=a^n∙b^n$。</p><h3 id="交换群（阿贝尔群）"><a href="#交换群（阿贝尔群）" class="headerlink" title="交换群（阿贝尔群）"></a>交换群（阿贝尔群）</h3><p>对于$G$中任意两个元素$a，b∈G$，若满足交换律$，a∙b=b∙a$，则称$(G，∙)$是<strong>交换群</strong>，又称阿贝尔（Abel）群</p><h3 id="变换群-置换群-循环群"><a href="#变换群-置换群-循环群" class="headerlink" title="变换群 置换群 循环群"></a>变换群 置换群 循环群</h3><p>🔴 $\textcolor{red}{集合的变换}$</p><p>$A$非空集合，称由$A$到<strong>自身的映射</strong>$\tau：A\to A$ 称为集合上的一个变换，记为：$a\in A\to \tau(a)\in A$</p><p>满变换、单变换、一一变换</p><p>把集合$A$上的全体变换作成集合$S=\{\tau,\lambda,\mu,\dots\}$，规定$S$上的一个代数运算$\circ$，$\forall \tau,\lambda\in  S，\tau :a\to\tau(a);\lambda:a\to\lambda(a)$， 将$\lambda \circ \tau$定义为：$a\to \lambda(\tau(a))$。（也就是两个变换的复合）</p><p>这个“乘法“满足结合律：$\forall \tau,\lambda,\mu\in S，\tau(\lambda\mu)=(\tau\lambda)\mu $</p><p>🔴 $\textcolor{red}{变换群}$</p><p>设$A$是一个非空集合，$G$是由$A$到$A$的<strong>一些映射构成的集合</strong>，若$G$是关于运算“$∘$”构成的一个群，则称$(G，∘)$是集合$A$上的一个<strong>变换群</strong>。</p><p>🔴 $\textcolor{red}{Cayley定理}$</p><p>任何一个群都与一个变换群同构</p><p>🔴 $\textcolor{red}{置换群}$</p><p>设$A$是一个非空有限集，则    </p><p>（1）称$A$上的一个变换群为$A$上的一个置换群。    </p><p>（2）对于任意的$f∈∪(A^A)$，称$f$为集合$A$上的一个置换。     </p><p>🔴 $\textcolor{red}{循环群}$</p><p>设$(G，∙)$是一个群，$g∈G$。若$G$中每一个元素都是$g$的<strong>乘方</strong>，则称$G$为<strong>循环群</strong>，称$g$为<strong>生成元</strong>，并且用符号$G=(g)$表示，即$G=(g)={g^n│n∈Z}$。</p><blockquote><p>设$(G，∙)$是一个群，$g∈G$ ，</p><p>显然有$g^2∈G，g^3∈G，⋯$，即对于任意的正整数$n$，有$g^n∈G$；      </p><p>显然有$g^{−1}∈G，g^{−2}∈G，⋯$，即对于任意的正整数$n$，有$g^−n∈G$；      </p><p>规定$g^0∈G$是$G$中幺元。 </p><p>综上所述，对于任意整数$n∈Z，g^n∈G$。     显然，$({g^n│n∈Z}，∙)$是一个群。</p></blockquote><p>设$G=(g)$是一个循环群，如果$o(g)=n$，则$|G|=n$，且$G=(g)=\{g^0=e，g，g^2，⋯，g^{n−1}\}$</p><p>（1）若$o(g)=n$，则称$G$是$n$阶<strong>有限循环群</strong>。     （2）若$o(g)=∞$，则称$G$是<strong>无限循环群</strong></p><h3 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h3><p>🔴 $\textcolor{red}{子群定义}$</p><p>设$(G，∙)$是一个群，$∅≠A⊆G$，若$(A，∙)$也是一个群，则称$(A，∙)$$是(G，∙)$的子群。</p><h3 id="子群的陪集"><a href="#子群的陪集" class="headerlink" title="子群的陪集"></a>子群的陪集</h3><p>🔴 $\textcolor{red}{右陪集}$</p><p>设$(G，∙)$是一个群，$(H，∙)$是$(G，∙)$的一个子群，$a∈G$。称$H∙a=\{ℎ∙a|ℎ∈H\}$为子群$H$的<strong>右陪集</strong></p><p>🔴 $\textcolor{red}{左陪集}$</p><p>设$(G，∙)$是一个群，$(H，∙)$是$(G，∙)$的一个子群，$a∈G$。称$a∙H=\{a∙h|ℎ∈H\}$为子群$H$的<strong>左陪集</strong></p><h3 id="正规子群和商群"><a href="#正规子群和商群" class="headerlink" title="正规子群和商群"></a>正规子群和商群</h3><p>🔴 $\textcolor{red}{正规子群}$</p><p>设$G$是一个群，$H$是$G$的一个子群。若对于<strong>任意</strong>一个$a∈G$，有$a∙H=H∙a$即$a$关于$H$的<strong>左陪集等于右陪集</strong>，则称$H$是$G$的<strong>正规子群</strong>，或者称为不变子群</p><p>🔴 $\textcolor{red}{商群}$</p><p>设$G$是一个群，$H$是$G$的正规子群，$G/H=\{aH|a∈G\}$，对于任意的$aH$，$bH∈G/H$，$(aH)⊙(bH)=(ab)H$。则$(G/H，⊙)$是一个群。该群称为$G$的<strong>商群</strong>。</p><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;高数、线代、概率论一些常用基础知识点复习&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】并查集</title>
    <link href="http://example.com/2022/08/02/2022-08-02-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://example.com/2022/08/02/2022-08-02-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2022-08-02T01:55:34.000Z</published>
    <updated>2022-08-03T02:22:53.917Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容：并查集</li></ul><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>用于（近乎$O(1)$）快速地：</p><ol><li>将两个集合<strong>合并</strong></li><li><strong>询问</strong>两个元素是否在一个集合当中</li></ol><p><strong>基本原理</strong>：</p><ul><li>每个集合用一颗<strong>树</strong>维护，每棵树<strong>的根节点</strong>的编号即当前集合的编号</li><li>对于每个点，都存储<strong>它的父节点</strong>是谁 ：p[x]表示x的父节点</li><li>当要找某个点是否属于某个集合时，就<strong>往上找</strong>到根节点</li></ul><p><strong>如何判断树根：</strong></p><ul><li><code>if(p[x]==x)</code></li></ul><p><strong>如何求x的集合编号</strong></p><ul><li><code>while(p[x]!=x) x=p[x]</code>;</li><li>复杂度优化（路径压缩）：当x往上找的时候，一旦找到根节点，就把这条路径上的所有节点的父节点都指向根节点；基本上就能看成O（1）</li></ul><p><strong>如何合并两个集合</strong></p><ul><li>p[x]是x的集合编号，p[y]是y的集合编号：<code>p[x]=y</code></li></ul><hr><h1 id="AcWing836-合并集合（模板题）"><a href="#AcWing836-合并集合（模板题）" class="headerlink" title="AcWing836 合并集合（模板题）"></a>AcWing836 合并集合（模板题）</h1><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>进行 m个操作，操作有两种：</p><ol><li><code>M a b</code>，将编号为 a和 b的两个数所在的集合<strong>合并</strong>，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，<strong>询问</strong>编号为 a和 b 的两个数是否在<strong>同一个集合</strong>中；</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];<span class="comment">//p[i]:编号为i的节点的父节点 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关键方法find：返回x所在集合的编号（祖宗节点）+路径压缩 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="comment">//如果x不是祖宗节点的话，就让它的父节点=它父节点的祖宗节点：往上递归</span></span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]); </span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">char</span> op;<span class="keyword">int</span> a,b;cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'M'</span>) p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b); <span class="comment">//合并两个集合</span></span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"No"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="AcWing837-连通块中点的数量"><a href="#AcWing837-连通块中点的数量" class="headerlink" title="AcWing837 连通块中点的数量"></a>AcWing837 连通块中点的数量</h1><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个包含 n个点（编号为 1∼n1∼n）的<strong>无向</strong>图，初始时图中<strong>没有</strong>边。</p><p>进行 m 个操作，操作共有三种：</p><ol><li><code>C a b</code>，在点 a 和点 b间<strong>连一条边</strong>，a和 b 可能相等；</li><li><code>Q1 a b</code>，<strong>询问</strong>点 a 和点 b 是否在<strong>同一个</strong>连通块中，a和 b可能相等；</li><li><code>Q2 a</code>，询问点 a <strong>所在</strong>连通块中<strong>点的数量</strong>；</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>两个点之间连一条边==合并两个集合；</li><li>只是多了一个统计集合中点的数量的操作而已</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N],cnt[N];</span><br><span class="line"><span class="comment">//cnt[i]表示的是 根节点i 所在集合的大小 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">p[i]=i;</span><br><span class="line">cnt[i]=<span class="number">1</span>;</span><br><span class="line">} <span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line">string op;<span class="keyword">int</span> a,b;cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">"C"</span>){</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//下面这两行顺便别颠倒了 </span></span><br><span class="line">cnt[<span class="built_in">find</span>(b)]+=cnt[<span class="built_in">find</span>(a)]; </span><br><span class="line">p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"Q1"</span>){</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"No"</span>&lt;&lt;endl;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">cout&lt;&lt;cnt[<span class="built_in">find</span>(a)]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容：并查集&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【SE】数据库</title>
    <link href="http://example.com/2022/07/22/2022-07-22-%E3%80%90SE%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2022/07/22/2022-07-22-%E3%80%90SE%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-07-22T01:55:34.000Z</published>
    <updated>2022-08-08T08:35:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>依稀记得大二考数据库熬夜通宵复习完大早上直接去考试 结果只考了79分的痛QAQ</p><span id="more"></span><h1 id="面试重点"><a href="#面试重点" class="headerlink" title="面试重点"></a>面试重点</h1><blockquote><p>总结自网络</p><p>参考：</p></blockquote><ul><li><p>BC范式和第三范式区别</p></li><li><p>解释范式</p></li><li><p>数据库的四个特性是什么？（类似地：解释事务的隔离性？</p></li><li><p>DBS 和 DBMS 的区别</p></li><li><p>数据库的索引有哪些分类</p></li><li><p>数据库中的选择操作，什么时候应该用到索引？</p></li></ul><h1 id="SQL一些语法"><a href="#SQL一些语法" class="headerlink" title="SQL一些语法"></a>SQL一些语法</h1><p><strong>关系型数据库</strong>（RDBMS）：建立在关系模型基础上，由多张互相连接的<strong>二维表</strong>组成的数据库</p><ul><li>特点：使用表存储：格式统一；使用SQL语言操作：标准统一</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>DDL：数据<strong>定义</strong>（define）语言；定义数据库对象（数据库、表、字段）</li><li>DML：数据<strong>操作</strong>（manipulation）语言；对数据库表的<strong>数据进行增删改</strong></li><li>DQL：数据<strong>查询</strong>（query）语言；查询数据库表的<strong>记录</strong></li><li>DCL： 数据<strong>控制</strong>（control）语言；创建数据库用户、控制数据库访问权限</li></ul><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><p>(中括号代表可选)</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES; </span><br><span class="line"># 查询当前所处的数据库</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE(); </span><br><span class="line"># 创建,字符集建议用utf8mb4不用utf8</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名[<span class="keyword">DEFAULT</span> CHARSET 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br><span class="line"># 删除</span><br><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] 数据库名;</span><br><span class="line"># 使用；</span><br><span class="line">USE 数据库名;</span><br></pre></td></tr></tbody></table></figure><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 查询当前数据库的 所有表</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"># 查询表结构</span><br><span class="line"><span class="keyword">DESC</span> 表名;</span><br><span class="line"># 查询指定表的建表语句</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"></span><br><span class="line"># 创建表，最后一个字段没有逗号</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型[COMMENT 字段<span class="number">1</span>注释],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型[COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br><span class="line"></span><br><span class="line"># 修改表</span><br><span class="line"># 添加字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度) [COMMENT 注释][约束];</span><br><span class="line"></span><br><span class="line"># 修改字段</span><br><span class="line"># 修改：字段类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型(长度);</span><br><span class="line"># 修改：字段名 和 字段类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束];</span><br><span class="line"></span><br><span class="line"># 删除字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名;</span><br><span class="line"></span><br><span class="line"># 删除表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>[IF <span class="keyword">EXISTS</span>]表名;</span><br><span class="line"># 删除指定表，并重新创建该表：清除了数据，只剩下表jie</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></tbody></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>char 和 varchar</strong>：</p><ul><li>char性能比varchar好</li><li>char定长，varchar变长</li></ul><p><strong>日期类型</strong>：</p><ul><li>DATE、TIME、YEAR、DATETIME、TIMESTAMP</li></ul><h1 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h1><p>指 DBMS应该保证数据库：<strong>免受非法、非授权用户的使用、泄露、更改和破坏</strong></p><h2 id="DBMS的安全机制分类"><a href="#DBMS的安全机制分类" class="headerlink" title="DBMS的安全机制分类"></a>DBMS的安全机制分类</h2><ul><li><strong>自主</strong>安全性机制：存取控制<ul><li>通过权限在用户之间的传递，使用户自主管理数据库安全性</li></ul></li><li><strong>强制</strong>安全性机制<ul><li>通过对数据和用户强制分类，使得不同类别用户能访问不同类别的数据</li></ul></li><li><strong>推断</strong>控制机制<ul><li>防止通过历史信息，推断出不该被其知道的信息</li><li>防止通过历史信息推断出私密信息，通常在一些由个体数据构成的公共数据库中此问题尤为重要</li></ul></li><li>数据加密存储机制<ul><li>加解密保护数据</li></ul></li></ul><h2 id="自主安全性机制"><a href="#自主安全性机制" class="headerlink" title="自主安全性机制"></a>自主安全性机制</h2><h3 id="通过授权机制实现"><a href="#通过授权机制实现" class="headerlink" title="通过授权机制实现"></a>通过<strong>授权机制</strong>实现</h3><ul><li>授权者：决定用户权利的人；授权：授予用户访问的权利</li></ul><blockquote><p>用户使用DB前，必须由DBA处获得一个账户，由DBA授予该账户一定权限；</p><p>该账户用户也可将所拥有的权限转授给其他用户，实现权限在用户间的传播和控制</p></blockquote><p>🛑 $\textcolor{red}{DBMS如何自动实现自主安全性？}$</p><ul><li>DBMS允许用户定义一些<strong>安全性控制规则</strong>（DCL）</li><li>当有DB访问操作时，DBMS<strong>自动</strong>按照安全性控制规则进行<strong>检查</strong>（安全性控制程序），检查通过则允许访问。</li></ul><p>🛑 $\textcolor{red}{自主安全性访问规则}$</p><blockquote><p>DBMS将权利和用户结合，形成一个访问规则表，依据该规则表实现对DB的安全性控制</p></blockquote><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S这个用户对O这个访问对象，在满足在P这个条件下拥有的访问权利t：</span><br><span class="line">    <span class="attr">AcessRule</span> ::= (S, O, t, P)</span><br><span class="line">        S：访问主体（用户）：用户多时，可按用户组建立访问规则</span><br><span class="line">        O：访问对象：可大可小，属性/字段、记录/元组、关系、数据库</span><br><span class="line">        t：访问权利：创建、增删改查等</span><br><span class="line">        P：谓词：拥有权利需满足的条件</span><br></pre></td></tr></tbody></table></figure><p><code>{AcessRule}</code>存放在数据字典 或称系统目录中，构成所有用户对DB的访问控制</p><p>🛑 $\textcolor{red}{下面是一个例子}$</p><p>对一个员工管理数据库<code>Employee(Pno, Pname, Page, Psex, Psalary, Dno, HEAD)</code>有如下安全性访问要求：</p><div class="table-container"><table><thead><tr><th style="text-align:center">S</th><th style="text-align:center">O</th><th style="text-align:center">t</th><th style="text-align:center">P</th></tr></thead><tbody><tr><td style="text-align:center">员工管理人员</td><td style="text-align:center">Employee</td><td style="text-align:center">读、删、插、改</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">收发人员</td><td style="text-align:center">Employee（Pname，Dno）</td><td style="text-align:center">读</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">每个员工</td><td style="text-align:center">Employee</td><td style="text-align:center">读</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">部门领导</td><td style="text-align:center">Employee</td><td style="text-align:center">读</td><td style="text-align:center">Pno=UserId</td></tr><tr><td style="text-align:center">高级领导</td><td style="text-align:center">Employee</td><td style="text-align:center">读</td><td style="text-align:center">Head=UserId</td></tr></tbody></table></div><p>🛑 $\textcolor{red}{按名控制安全性的实现方式}$</p><p><strong>实现方式一：存储矩阵</strong></p><p><img src="https://s2.loli.net/2022/08/05/1d37qUwLjeMXGrE.png" alt="image.png"></p><p><strong>实现方式二：视图</strong></p><ul><li><p>给不同用户用不同视图，就是相当于给与了不同的数据访问范围，相比矩阵更省空间</p></li><li><p>通过视图限制用户对关系中某些数据项的存取，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">视图1：create view EmpV1 as select * from Employee</span><br><span class="line">视图2：create view EmpV2 as select Pname,Dno from Employee</span><br></pre></td></tr></tbody></table></figure></li><li><p>通过视图 可将数据访问对象和谓词结合起来，限制用户对关系中某些元组的存取，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">视图1：create view EmpV3 as select * from Employee where Pno=:UserId</span><br></pre></td></tr></tbody></table></figure></li><li><p>用户定义视图后，视图便成为一新的对象，参与到存储矩阵与能力表中进行描述</p></li></ul><h3 id="用户与权利"><a href="#用户与权利" class="headerlink" title="用户与权利"></a>用户与权利</h3><p>🛑 $\textcolor{red}{SQL语言将用户分为三个级别}$</p><ul><li>超级用户（DBA）</li><li>账户级别（程序员用户）</li><li>关系级别（普通用户）</li></ul><p>🛑 $\textcolor{red}{SQL语言将权利分级}$</p><p>级别更高的权利自动包含级别低的权利；在有些DBMS中，将级别3的权利称为账户级别的权利，1和2称为关系级别的权利</p><ul><li>（级别1）<code>Select</code>：读（DB，Table，Record，Attribute…）</li><li>（级别2）<code>Modify</code>：更新<ul><li><code>Insert</code>、<code>Update</code>、<code>Delete</code></li></ul></li><li>（级别3）<code>Create</code>：创建（表空间、模式、表、索引、视图等）<ul><li><code>Create</code>、<code>Alter</code>、<code>Drop</code></li></ul></li></ul><h3 id="DCL授权命令"><a href="#DCL授权命令" class="headerlink" title="DCL授权命令"></a>DCL授权命令</h3><p>🛑 $\textcolor{red}{授权：grant}$</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT {all PRIVILEGES | privilege {,privilege..}} </span><br><span class="line">ON [TABLE] tablename | viewname</span><br><span class="line">TO {public | user-id {, user-id...}}</span><br><span class="line">[WITH GRANT OPTION];</span><br></pre></td></tr></tbody></table></figure><ul><li><code>user-id</code>：某一个用户账户，由DBA创建的合法账户</li><li><code>public</code>：允许所有有效用户使用授予的权利</li><li><code>privilege</code>：这些权利：<code>Select、Insert、Update、Delete、All privileges</code></li><li><code>with grant option</code>：允许被授权者在传播这些权利</li></ul><p>❗ 授予视图访问的权利，并不意味着授予基本表的访问权利（两个级别：关系级别和视图级别）</p><p>🛑 $\textcolor{red}{收回授权：revoke}$</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REVOKE {all privilEges | priv {, priv..}} ON tablename | viewname</span><br><span class="line">FROM {public | user {, user..} };</span><br></pre></td></tr></tbody></table></figure><p>🛑$\textcolor{red}{授权过程}$</p><ul><li>DBA创建DB，并为每个用户创建一个账户</li><li>DBA授予某用户账户级别的权利</li><li>具有账户级别的用户可以创建基本表或视图，他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问权利</li><li>拥有属主账户的用户可以将其中的部分权利授权给另外的用户，该用户也可将权利进一步授权给其他用户</li></ul><h2 id="强制安全性机制"><a href="#强制安全性机制" class="headerlink" title="强制安全性机制"></a>强制安全性机制</h2><p>🛑$\textcolor{red}{原理}$</p><ul><li>通过对数据对象进行安全性分级<ul><li>绝密(Top Secret)、机密(Secret)、可信(Confidential)、无分类(Unclassified)</li></ul></li><li>同时对用户也进行上述安全性分级</li><li>从而强制实现不同级别用户访问不同级别数据的一种机制</li></ul><p>🛑$\textcolor{red}{访问规则}$</p><ul><li>高级别用户 可以访问 低级别数据对象：<ul><li>用户S，不能读取数据对象O，除非<code>Level(S) &gt;= Level(D)</code></li></ul></li><li>高级别用户 不可以修改 低级别数据对象<ul><li>用户S，不能写数据对象O，除非<code>Level(S) &lt;= Level(O)</code></li></ul></li></ul><h1 id="嵌入式SQL语言"><a href="#嵌入式SQL语言" class="headerlink" title="嵌入式SQL语言"></a>嵌入式SQL语言</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>特别复杂的检索结果难以用一条交互式SQL语句完成,此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理</p><p>将SQL语言嵌入到某种高级语言中使用，如C/C++, Java, PowerBuilder等,又称宿主语言(Host Language)</p></blockquote><p><img src="https://s2.loli.net/2022/08/05/8SrCF41tNLgWdb6.png" alt="image.png" style="zoom: 50%;"></p><h2 id="SQL执行的提交和撤销-事务"><a href="#SQL执行的提交和撤销-事务" class="headerlink" title="SQL执行的提交和撤销+事务"></a>SQL执行的提交和撤销+事务</h2><p>SQL执行过程中，必须有<strong>提交和撤销</strong>语句才能确认其操作结果</p><p>🛑$\textcolor{red}{事务}$</p><p><strong>概念</strong>：（从应用程序员角度），事务是一个存取或改变数据库内容的程序的一次执行；或者说<strong>一条或多条SQL语句的一次执行</strong>被看作一个事务</p><p>由应用程序员提出，有开始和结束，结束前需要提交或撤销</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>概念</strong>：（从DBMS角度），事务是DBMS提供的控制数据操作的一种手段，通过这种手段，应用程序将<strong>一系列数据库操作组合</strong>在一起<strong>作为一个整体进行操作和控制</strong>，以便DBMS能提供移植性状态转换的保证。</p><p>🛑$\textcolor{red}{事务的特性：ACID}$</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p><strong>静态SQL</strong>: SQL语句在程序中已经按要求写好,只需要把一些参数通过变量传送给嵌入式SQL语句即可</p><p><strong>动态SQL</strong>: SQL语句可以<strong>在程序中动态构造</strong>，形成一个<strong>字符串</strong> ，然后再交给DBMS执行，交给DBMS执行时仍可以传递变量</p><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><p>🛑$\textcolor{red}{概念}$</p><p>又称系统目录（目录表、系统视图），是系统维护的一些表或视图的集合，这些表或视图存储了数据库中<strong>各类对象的定义信息</strong>，这些对象包括用create定义的表、列、索引、视图、权限、约束等。这些信息又称为数据库的<strong>元信息</strong>（关于数据的数据；即 模式本身的信息）</p><p>🛑$\textcolor{red}{数据字典的内容构成}$</p><ul><li>与关系相关的信息<ul><li>关系名字、每个关系的属性名及类型、视图名字及定义、完整性约束</li></ul></li><li>用户与账户信息，包括密码</li><li>统计和描述性数据：比如每个关系中的元组数目</li><li>物理文件组织信息<ul><li>关系如何存储（顺序、无序、散列）</li><li>关系的物理位置</li></ul></li><li>索引相关的信息</li></ul><h2 id="ODBC-和-JDBC"><a href="#ODBC-和-JDBC" class="headerlink" title="ODBC 和 JDBC"></a>ODBC 和 JDBC</h2><p>🛑$\textcolor{red}{ODBC}$</p><p>ODBC（open database connectivit开放式数据库连接）是一种 不同语言的语应用程序和不同数据库服务器之间<strong>通讯的标准</strong>，包含：</p><ul><li>一组API，支持<strong>应用程序和数据库服务器</strong>的交互</li><li>应用程序通过调用 ODBC API，实现<ul><li>与数据库服务器的连接</li><li>向数据库服务器发送SQL命令</li><li>逐条提取数据库检索结果中的元组传递给应用程序的变量</li></ul></li><li>具体的DBMS提供一套<strong>驱动程序</strong>（Driver库函数），供ODBC调用，以便实现数据库和应用程序的连接</li></ul><blockquote><p>⭕ 当应用程序调用<strong>ODBC API</strong>时，ODBC API会<strong>调用具体DBMS Driver库函数</strong>，DBMS Driver库函数 <strong>与 数据库服务器通信</strong>，执行相应的请求动作并返回检索结果</p></blockquote><p>🛑$\textcolor{red}{JDBC}$</p><blockquote><p>简单了解，反正会用jiu’x🤣真想深入学就去看专门讲JDBC运用的视频</p></blockquote><p>JDBC是一组Java版的应用程序接口API ，提供了<strong>Java应用程序与数据库服务</strong><br><strong>器</strong>的连接和通讯能力。</p><p><strong>概念性的基本过程</strong>：打开一个连接，创建“Statement”对象，并设置查询语句，使用Statement对象执行查询，发送查询给数据库服务器，返回结果给应用程序；处理错误的例外机制</p><p><strong>具体实施过程</strong> ：</p><ul><li><p>传一个Driver给DriverManager，<strong>加载数据库驱动</strong>。<code>Class.forName()</code></p></li><li><p>通过URL得到一个Connection对象，<strong>建立数据库连接</strong></p><p><code>DriverManager.getConnection(sDBUrI)</code></p><p><code>DriverManager.getConnection(sDBUrl,sDBUserlD,sDBPassword)</code></p></li><li><p>接着<strong>创建一个Statement对 象</strong>(PreparedStatement或CallableStatement)，用来查询或者修改数据库。<code>Statement stmt=con.createStatement()</code></p></li><li><p>查询<strong>返回</strong>一个ResultSet.<code>ResultSet rs =stmt.executeQuery(sSQL)</code></p></li></ul><h1 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h1><blockquote><p>包含：数据依赖理论、关系范式理论、模式分解理论</p></blockquote><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><blockquote><p>FD：Functional Dependence</p><p>参考书籍：《数据库系统基础教程》Jeffrey.D Ullman Jennifer Widom著</p><p>参考文章：</p><p><a href="https://blog.csdn.net/Jeremy_Tsang/article/details/108949656">完全/部分/函数依赖【通俗易懂，博主会讲人话】Jeremy_Tsang的博客</a></p><p><a href="https://blog.csdn.net/shuaishuai__/article/details/106076537?ops_request_misc=%7B%22request%5Fid%22%3A%22165979845916782391847571%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165979845916782391847571&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-106076537-null-null.nonecase&amp;utm_term=数据库闭包&amp;spm=1018.2226.3001.4450">数据库中的闭包到底是什么？_三看的博客</a></p></blockquote><p>🛑$\textcolor{red}{函数依赖的定义}$</p><p>设$R(U)$是属性集合$U=\{A_1,A_2,\dots,A_n\}$上的一个关系模式，$X$，$Y$是$U$上的两个子集，若对$R(U)$的任意一个可能的关系$r$，$r$中<font color="red">不可能有两个元组</font>满足在$X$中的属性值相等而在$Y$中的属性值不等（即：$X$中的每一个属性值，$Y$都有唯一值与之对应），则称 “$X$函数决定$Y$”  或者 ” $Y$ 函数依赖于$X$“，记作$X \rightarrow Y$。$X$为决定因素</p><blockquote><p>两个属性(集)之间的取值关系，对于R(U)，X、Y为属性集，t1、t2为R的元组，若t1[X]＝t2[X]，则t1[Y]＝t2[Y]</p></blockquote><p><img src="https://s2.loli.net/2022/08/06/CaA3EhOpzT4eQ9M.png" alt="image.png" style="zoom:50%;"></p><ul><li><p><strong>例如：</strong>U = {学号，姓名，年龄，班号，班长，课号，成绩}；那么：学号 → { 姓名，年龄 } ：意思就是学号相同的话，那么姓名和年龄也一定相同；学号 决定 姓名+年龄 </p></li><li><p><strong>非平凡的函数依赖</strong>：对$X\rightarrow Y$，但$Y\not\subset X$，则称$X\rightarrow Y$为非平凡的函数依赖；反之，则是平凡的函数依赖</p><blockquote><p>说人话：Y不是X的子集</p></blockquote></li><li><p><strong>平凡的函数依赖</strong>：</p><blockquote><p>X 可以推导出自己或者自己的一部分</p></blockquote></li></ul><p><img src="https://s2.loli.net/2022/08/06/j3rwi94VoPHC6c1.png" alt="image.png" style="zoom: 50%;"></p><p>🛑$\textcolor{red}{完全函数依赖和部分函数依赖}$</p><p>在$R(U)$中，若$X\rightarrow Y$并且对于$X$的任何真子集$X’$都有$X’\nrightarrow Y$，则称$Y$<strong>完全函数依赖</strong>于$X$，记为$X \xrightarrow{f} Y $，否则称作Y<strong>部分函数</strong>依赖于X，记为$X \xrightarrow{p} Y $</p><blockquote><p>说人话：完全函数依赖就是必须由<strong>X中的全部属性值</strong> 才能确定唯一的Y的值，X属性集中缺少任何一个属性 都不能 确定唯一的Y；</p><p>比如，想知道某位学生的某门课成绩Grade，必须得同时知道他的学号Sno和课程号Cno。如果只知道部分信息，比如只知道Sno或者Cno，无法确定Grade！此时 称Y[Grade]<strong>完全函数依赖</strong>于X[Sno,Cno]。</p><p>而想知道某位学生姓名Sname，那知道他的学号Sno就可。也就是Y[Sname]只函数依赖于X[Sno,Cno]中的子集x[Sno]，此时称Y<strong>部分函数依赖</strong>于X</p></blockquote><p>🛑$\textcolor{red}{传递函数依赖}$</p><p> 在$R(U)$中，若$X\rightarrow Y,Y\rightarrow Z$ 且 $Y\not\subset X,Z\not\subset Y,Z \not\subset X,Y\nrightarrow X$，则称$Z$传递函数依赖于$X$</p><blockquote><p>例如：知道一个学生的学号Sno，就能知道他所在的系Sdept。那知道某一个系Sdept，就能知道这个系的系主任的姓名Mname。<br>也就是，我知道了一个学生的<u>学号</u>Sno，其实我就知道了他所在系的<u>系主任的姓名</u>Mname。但这个过程中，他们是<strong>不存在直接函数依赖</strong>的，我需要通过<strong>系名称</strong>Sdept<strong>作为一个桥梁</strong>去把二者联系起来。</p></blockquote><p>🛑$\textcolor{red}{函数依赖的几个重要概念}$</p><ul><li><p><font color="red">候选键</font>（Candidate Key）：设$K$为$R(U)$中的属性或属性集合，若$K \xrightarrow{f} U $，则称$K$为$R(U)$上的候选键（最小性+唯一性）</p><ul><li>可以任选一候选键作为<font color="red">主键</font>（Primary Key）</li><li><font color="red">主属性</font>：包含在任一候选键中的属性；其他称为<font color="red">非主属性</font></li><li><font color="red">超键</font>：若$K$是$R$的一个候选键，$S\supset K$，则称$S$是$R$的一个超键（即：一个包含键的属性集，没有最小性）</li></ul></li><li><p><font color="red">外键</font>（Foreign Key）：若$R(U)$中的属性或属性组合$X$<strong>并非</strong>$R$的候选键，但<strong>却是</strong>另一关系的候选键，则称$X$为$R$的外键</p></li><li><p><font color="red">逻辑蕴涵</font>：设$F$是关系模式$R(U)$中的一个<strong>函数依赖集合</strong>, $X, Y$是$R$的属性子集，如果从$F$ 中的函数依赖能够逻辑推导出$X \to Y$ ，则称$F$逻辑蕴涵$X \to Y$，或称$X \to Y$是$F$的逻辑蕴涵。记作$\mathbf{F} \models \mathbf{X} \rightarrow \mathbf{Y}$。</p><blockquote><p>由已给出的函数依赖集，推导出其他函数依赖。<strong>推导出来的函数依赖</strong>就称作F所逻辑蕴涵的函数依赖。<br>就好像是侦探破案，掌握了几条线索，然后根据这几条线索推出来另外的线索，这另外推出来的线索就是之前线索集的逻辑蕴涵的线索。</p></blockquote></li><li><p><font color="red">闭包</font>（Closure）：被$F$逻辑蕴含的所有函数依赖集合称为$F$的闭包，记作$F^{+}$</p><blockquote><p>即：<strong>F中能所有的</strong>函数依赖 以及 能<strong>推导出来的</strong>所有的函数依赖 在一起的集合就是 F的闭包</p><p>若$F^{+}=F$，则称$F$是一个<strong>全函数依赖</strong>（函数依赖完备集）</p></blockquote></li></ul><p>🛑$\textcolor{red}{函数依赖的Armstrong公理}$</p><p>设$R(U)$是属性集$U=\{A_1,A_2,\dots,A_n\}$上的一个关系模式，$F$为$R(U)$的一组函数依赖，记作$R(U,F)$，有如下规则成立：</p><ul><li>自反律：若$Y\subseteq X \subseteq U$，则$X \to Y$ 被 $F$ 逻辑蕴涵</li><li>增广律：若$X\to Y \in F$，且$Z\subseteq U$，则$XZ \to YZ$  被 $F$ 逻辑蕴涵</li><li>传递律：若$X\to Y\in F$，且$Y\to Z$，则$X\to Z$  被 $F$ 逻辑蕴涵</li></ul><p>由$Armstrong$公理可推出如下结论（定理）：</p><ul><li>合并律：若$X\to Y$且$X\to Z$，则$X\to YZ$</li><li>伪传递律：若$X\to Y$且$WY \to Z$，则 $XW \to Z$</li><li>分解律：若$X\to Y$且$Z\subseteq Y$，则$X\to Z$</li></ul><p>一个引理：</p><ul><li>若$A_1,A_2,\dots,A_n$是属性，则$X\to A_1,A_2,\dots,A_n$当且仅当每个$A_i$有$X\to A_i(1\leq i\leq n)$</li></ul><p>🛑$\textcolor{red}{覆盖和最小覆盖}$</p><p>覆盖：对$R(U)$上的两个函数依赖集合$F、G$，如果$F^{+}=G^{+}$，则称$F$ 和$G$ 是等价的，也称$F$ 覆盖$G$ 或者$G$ 覆盖$F$ 。</p><p><strong>最小覆盖</strong>：若$F$满足以下条件，则称$F$为最小覆盖或最小依赖集：</p><ul><li>$F$ 中的每个函数依赖 的右部都是单个属性</li><li>对任何 $X\to A\in F$，有$F-\{X\to A\}$不等价于$F$：指 每个函数依赖$X\to A$ 都是不可获取的</li><li>对任何 $X\to A\in F,Z\subset X$，有$(F-\{X\to A\})\cup \{Z\to A\}$不等价于$F$：也就是说$X$ 中没有多余的属性</li></ul><p><strong>定理</strong>：每个函数依赖集$F$ 都有等价的最小覆盖$F’$</p><p>🛑$\textcolor{red}{属性闭包的计算}$</p><p><strong>思想</strong>：从一个给定的属性集合出发，重复地扩展这个集合，只要某个FD<u>左边的属性 全部 包含在这个集合</u>中，就把此FD右边的属性也包含进去。反复使用这个方法，直到不再产生新的属性为止。最后的结果集合就是给定属性集合的闭包。</p><p><strong>算法：</strong></p><p><img src="https://s2.loli.net/2022/08/06/zWLhMkYqSVbCsl1.png" alt="image.png" style="zoom: 50%;"></p><hr><h2 id="关系范式"><a href="#关系范式" class="headerlink" title="关系范式"></a>关系范式</h2><blockquote><p>范式（数据库的设计范式）是<strong>符合某一种级别</strong>的<strong>关系模式的集合</strong>。<strong>构造数据库必须遵循一定的规则</strong>。在关系数据库中，这种规则就是范式。关系数据库中的关系必须满足一定的要求，即满足不同的范式</p></blockquote><h3 id="第一范式：1NF"><a href="#第一范式：1NF" class="headerlink" title="第一范式：1NF"></a>第一范式：1NF</h3><p>🛑$\textcolor{red}{定义}$</p><p>若关系模式$R(U)$中，关系的<strong>每个分量都是不可再分</strong>的数据项（值、原子），则称$R(U)$ 属于第一范式，记作$R(U)\in 1NF$</p><p><strong>例如</strong>：<code>Star(name, address(street, city))</code>就不属于第一范式，因为<code>address</code>包含两个属性，这个分量不是原子的，可以再分</p><p>🛑$\textcolor{red}{非1NF转换为1NF}$</p><ul><li>将<strong>复合</strong>属性处理为<strong>简单</strong>属性；将多值属性与关键字单独组成一新的关系</li><li>引入新的数据模型处理：面向对象的数据模型（封装）</li></ul><h3 id="第二范式：2NF"><a href="#第二范式：2NF" class="headerlink" title="第二范式：2NF"></a>第二范式：2NF</h3><p>🛑$\textcolor{red}{定义:1NF+消除非主属性对码的部分依赖}$</p><p>若$R(U)\in 1NF$ 且$U$中的每一<font color="red">非主属性</font>都<strong>完全函数依赖</strong>于候选键，则称$R(U)$属于第二范式，记作$R(U)\in 2NF$</p><blockquote><p>2NF要求数据库表的每个实例或行 <strong>必须可以被唯一地区分</strong>。不能存在仅依赖主关键字一部分的属性。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系</p></blockquote><p><img src="https://s2.loli.net/2022/08/07/sBloZvnj7qhCOVX.png" alt="image.png" style="zoom:50%;"></p><h3 id="第三范式：3NF"><a href="#第三范式：3NF" class="headerlink" title="第三范式：3NF"></a>第三范式：3NF</h3><p>🛑$\textcolor{red}{定义：2NF+消除非主属性对码的传递依赖}$</p><p>若$R(U,F)\in 2NF$且$R$ 中<strong>不存在这样的情况</strong>：候选键$X$，属性组$Y\subseteq U$和非主属性$A$，且$A\notin X, A\notin Y,Y\not\subset X,Y\not\to X$，使得$X\to Y,Y\to A$成立。满足上述条件的$R(U)$属于第三范式，记为$R(U)\in 3NF$</p><blockquote><p>3NF要求一个数据库表中 <strong>不包含</strong>   已在<strong>其它表中已包含的非主关键字</strong>信息。</p></blockquote><h3 id="Boyce-Codd范式"><a href="#Boyce-Codd范式" class="headerlink" title="Boyce-Codd范式"></a>Boyce-Codd范式</h3><p>🛑$\textcolor{red}{定义：3NF+消除主属性对码的部分和传递依赖}$<br>若$R(U,F)\in 1NF$，若对任何$X\to Y\in F$（或$X\to A\in F$），当$Y\not\subset X$（或$A\not\subset X$）时，$X$必含有候选键，则称$R(U)$属于BC范式，记为：$R(U)\in BCNF$</p><blockquote><p>每个非平凡函数依赖的左边都必须<strong>包含键</strong>（可以是超键，不一定要最小化）</p><p>有传递依赖的，或者说不满足3NF的，也一定不满足BCNF</p></blockquote><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><h2 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h2><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>🛑$\textcolor{red}{定义}$</p><p>索引是定义在存储表（Table）的基础上，有助于 无需检查所有记录而<strong>快速定位</strong>所需记录的 一种<strong>辅助存储结构</strong>。由一系列存储在磁盘上的<strong>索引项</strong>组成，每一索引项分成以下两部分：</p><ul><li><strong>索引字段</strong>：由Table中某些列中的值串接而成。索引中通常存储了索引字段的每一个值（也有不是这样的），类似于词典中的词条</li><li><strong>行指针</strong>：指向Table中包含索引字段值的<strong>记录在磁盘上的存储位置</strong>，类似于词典中的页码<br><img src="https://s2.loli.net/2022/08/07/nLqDUCgx7BpiFH1.png" alt="image.png" style="zoom: 50%;"></li></ul><p>索引文件：存储索引项的文件；主文件：存储表</p><blockquote><p>索引文件是一种辅助存储结构，存在与否不改变存储表的物理存储结构；存在就可以明显提高存储表的访问速度：索引文件比主文件<strong>小</strong>很多，可以<strong>全部装进</strong>内存</p><p>有索引时，更新操作必须<strong>同步更新</strong>索引文件和主文件</p></blockquote><p>排序码：对主文件进行排序存储的那些属性或属性组</p><p>索引码：即索引字段，不一定具有唯一性</p><p>搜索码：在主文件中查找记录的属性或属性集</p><p>🛑$\textcolor{red}{索引文件的组织方式}$</p><ul><li><strong>排序</strong>索引文件：按索引字段值的某一种<strong>顺序</strong>组织存储</li><li><strong>散列</strong>索引文件：依据索引字段值使用<strong>散列函数</strong>分配散列桶的方式存储</li></ul><h2 id="稠密索引和稀疏索引"><a href="#稠密索引和稀疏索引" class="headerlink" title="稠密索引和稀疏索引"></a>稠密索引和稀疏索引</h2><p>🛑$\textcolor{red}{定义}$</p><p><strong>稠密索引</strong>：对于主文件中的<strong>每一个记录</strong>，都有一个索引项与之对应，指明该记录所在位置</p><p><strong>稀疏索引</strong>：部分记录</p><blockquote><p>稠密索引文件中 包含了主文件对应字段的<strong>所有不同值</strong></p><p>稀疏索引的使用：要求主文件必须按对应索引字段属性排序存储</p></blockquote><h2 id="主索引和辅助索引"><a href="#主索引和辅助索引" class="headerlink" title="主索引和辅助索引"></a>主索引和辅助索引</h2><p>🛑$\textcolor{red}{主索引}$</p><p>通常是对每一<strong>存储块</strong>有一个素引项 ，索引项的总数和存储表所占的存储块数目相同，存储表的每一个存储块的第一条记录，又称为<strong>锚记录或简称为块锚</strong></p><blockquote><p>主索引的索引字段值为<strong>块锚</strong>的索引字段值，指针指向其所在的存储块。<br>主索引是按索引字段值进行排序的一个有序文件，通常建立在有序主文件的基于主码的排序字段上，即主索引的<strong>索引字段与主文件的排序码(主码)</strong>有对应关系</p><p>主索引 是稀疏索引</p></blockquote><p>🛑$\textcolor{red}{辅助索引}$</p><p>是定义在主文件的任一或多个非排序字段上的辅助存储结构</p><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>🛑$\textcolor{red}{聚簇索引}$</p><p>索引中<strong>邻近的记录</strong>在主文件中也是<strong>邻近存储</strong>的</p><p>🛑$\textcolor{red}{非聚簇索引}$</p><p>索引中<strong>邻近的记录</strong>在主文件中<strong>不一定是邻近存储</strong>的</p><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><blockquote><p>多级索引：对索引再建立索引</p></blockquote><p>🛑$\textcolor{red}{定义}$</p><p>B+树的每一个结点都是如下这样的存储块：</p><div class="table-container"><table><thead><tr><th>$P_1$</th><th>$K_1$</th><th>$P_2$</th><th>…</th><th>$P_{n-1}$</th><th>$K_{n-1}$</th><th>$P_{n}$</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><blockquote><p>$K_i$：索引字段值</p><p>$P_i$：指针，指向索引块或数据块或数据块中记录的指针</p></blockquote><ul><li>一个存储块中有$n-1$个索引项$<p_i,k_i>$ + $1$个指针$P_n$</p_i,k_i></li><li>索引字段值$x$，若$K_{i-1}\leq x\lt K_i$的由$P_i$ 指向；在$K_{i}\leq x\lt K_{i+1}$的由$P_{i+1}$指向</li><li>非叶结点：指针指向索引块</li><li>叶结点：指针指向主文件的数据库或数据记录（叶结点的最后一个指针始终指向其下一个数据块）</li></ul><p>🛑$\textcolor{red}{B+树的两个特性}$</p><ul><li>能自动保持与主文件大小相适应的树的层次</li><li>每个索引块的指针利用率都在50%-100%之间</li></ul><p>🛑$\textcolor{red}{B+树的存储约定}$</p><p><img src="https://s2.loli.net/2022/08/07/MSxj4rwPq3dV9eR.png" alt="image.png"></p><ul><li>索引字段值重复出现于叶结点和非叶结点</li><li>指向主文件的指针 仅出现在 叶结点</li><li>所有叶结点 即可覆盖所有键值的索引</li><li>索引字段值在叶结点中按顺序排列</li></ul><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是数据库的事务？"><a href="#什么是数据库的事务？" class="headerlink" title="什么是数据库的事务？"></a><font color="red">什么是数据库的事务？</font></h2><p>🔸 DB的<strong>事务</strong>是一个不可分割的数据库操作<strong>序列</strong>，也是DB并发控制的基本单位；这组逻辑上的操作要么都执行，要么都不执行；其执行的结果必须使DB从一种<strong>一致性状态</strong>变到<strong>另一种一致性</strong>状态。</p><blockquote><p>将一系列数据库操作组合在一起，作为一个整体进行操作和控制</p><p>从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行；或者说<strong>一条或多条SQL语句的一次执行</strong>被看作一个事务；由应用程序员提出，有开始和结束，结束前需要提交或撤销</p><p>在嵌入式SQL程序中,任何一条数据库操纵语句(如exec sql select等)都会引发一个新事务的开始，只要该程序当前没有正在处理的事务。而事务的结束是需要应用程序员通过commit或rollback确认的。因此Begin Transaction 和End Transaction两行语句是不需要的。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Begin Transaction</span><br><span class="line">exec sql...</span><br><span class="line">...</span><br><span class="line">exec sql...</span><br><span class="line">exec sql commit work | exec sql rollback work</span><br><span class="line">End Transaction</span><br></pre></td></tr></tbody></table></figure><h2 id="什么是数据库的四大特性ACID？"><a href="#什么是数据库的四大特性ACID？" class="headerlink" title="什么是数据库的四大特性ACID？"></a><font color="red">什么是数据库的四大特性ACID？</font></h2><p>🔸 <strong>原子性</strong>（Atomicity）：DBMS保证事务的一组<strong>更新操作</strong>是<strong>原子不可分</strong>的，确保操作要么全做，要么全不做</p><blockquote><p>事务中任何一个sql执行失败，那么执行成功的sql也必须撤销，数据库状态回退到执行事务之前的状态</p></blockquote><p>🔸 <strong>一致性</strong>（Consistency）：事务执行前后，所有数据都必须处于<strong>一致性状态</strong>，多个事务对同一个数据读取的结果是相同的</p><blockquote><p>比如：假设用户A和用户B的钱加起来一共5000，那不管A和B之间如何转账，转账几次，事务结束后两个用户的钱加起来应该还是5000，这就是事务的一致性。</p></blockquote><p>🔸 <strong>隔离性</strong>（Isolation）：DBMS保证<strong>并发执行的多个事务之间互相不受影响</strong>。</p><blockquote><p>一个事务<strong>内部的操作</strong>及<strong>正在操作的数据</strong> 对 其他并发执行的事务是隔离的。例如事务T1和T2即使并发执行，也相当于先执行T1，再执行T2（或者相反</p></blockquote><p>🔸 <strong>持久性</strong>（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p><h2 id="事务的并发会带来什么问题？如何解决？"><a href="#事务的并发会带来什么问题？如何解决？" class="headerlink" title="事务的并发会带来什么问题？如何解决？"></a><font color="red">事务的并发会带来什么问题？如何解决？</font></h2><p>🔸 <strong>脏读</strong>：一个事务读取到另一个事务更新但<strong>尚未提交的数据</strong>。 </p><blockquote><p>事务 A 读取事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</p><p>T1修改某个数据，并将其写回磁盘，T2读取之后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，导致T2读脏数据</p></blockquote><p>🔸 <strong>不可重复读</strong>：一个事务中<strong>两次读取</strong>的数据的<strong>内容不一致</strong></p><blockquote><p>T1读取数据后，T2执行更新操作，T1再次读取时，无法再读到之前的数据</p></blockquote><p>🔸<strong>幻读</strong>：一个事务中两次读取的<strong>数据量不一致</strong>。 事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据 </p><blockquote><p>当同一条查询在不同的时间产生不同的结果集</p></blockquote><p>🔸<strong>丢失更新</strong>：两个事务读入同一数据并修改，后一提交的事务会覆盖前一事务提交的结果，就会导致前一事务的修改被丢失。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;依稀记得大二考数据库熬夜通宵复习完大早上直接去考试 结果只考了79分的痛QAQ&lt;/p&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】最短路+最小生成树+二分图</title>
    <link href="http://example.com/2022/07/22/2022-07-22-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF+%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91+%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>http://example.com/2022/07/22/2022-07-22-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF+%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91+%E4%BA%8C%E5%88%86%E5%9B%BE/</id>
    <published>2022-07-22T01:55:34.000Z</published>
    <updated>2022-08-01T06:37:13.057Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>Content</strong><ul><li><strong>最短路</strong>：Dijkstra、Bellman-Ford、SPFA、Floyd</li><li><strong>最小生成树</strong>：Prim、Kruskal</li><li><strong>二分图</strong>：染色法、匈牙利算法</li></ul></li></ul><span id="more"></span><h1 id="1️⃣-最短路介绍"><a href="#1️⃣-最短路介绍" class="headerlink" title="1️⃣ 最短路介绍"></a>1️⃣ 最短路介绍</h1><p><strong>补充</strong>：稠密图和稀疏图的定义较模糊，邻接矩阵所需空间$O(n^2)$，邻接表所需空间$O(m)$，计算时间和空间复杂度，选择一个满足的即可。</p><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><p>求一个点到其他所有点的最短距离</p><p>​    分类：</p><ul><li><p><strong>所有边权都是正数</strong></p><ul><li>朴素Dijkstra算法：O(n^2)  （n点数，m边数）、稠密图；用邻接矩阵</li><li>堆优化版的Dijkstra算法：O(mlogn)、稀疏图；用邻接表</li></ul></li><li><p><strong>存在负权边</strong></p><ul><li>Bellman-Ford：O(nm)</li><li>SPFA：一般情况下O(m)，最坏O(nm)，也适合正权边；※但是：能用dijkstra的就别用spfa</li></ul></li></ul><h2 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h2><ul><li>Floyd算法：O(n^3)</li></ul><h1 id="Dijkstra-正权边"><a href="#Dijkstra-正权边" class="headerlink" title="Dijkstra - 正权边"></a>Dijkstra - 正权边</h1><p>从<strong>1号点到其他所有点</strong>的最短距离</p><h2 id="朴素版-稠密图-邻接矩阵"><a href="#朴素版-稠密图-邻接矩阵" class="headerlink" title="朴素版 - 稠密图 - 邻接矩阵"></a>朴素版 - 稠密图 - 邻接矩阵</h2><ul><li><strong>初始化距离</strong>：$dist[1] = 0, dist[i]= +∞$：1号点到起点的距离是1，其他所有点到起点的距离是+∞</li><li>集合S：当前<strong>已经确定</strong>的最短距离的点</li><li>for 迭代n次：<ul><li>找到不在S中的<strong>距离最近的点 t</strong></li><li>把t加入S</li><li>用t更新其他点的距离$dist[j]=min(dist[j],dist[t]+g[t][j]);$</li></ul></li></ul><blockquote><p>给定一个 n个点 m条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 1 号点到 n号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p></blockquote><p>注意：若要求任意点i到任意个点j的最短距离，只需修改dijkstra方法中的起源位置dist[i] = 0，以及返回为dist[j]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];<span class="comment">//dist[i]: 从第一个点到第i个点的最短距离 </span></span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//st[i]:标记第i个点是否在S中 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//迭代n次 </span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){<span class="comment">//找 不在S中距离的 到第一个点的距离最短的那个点 </span></span><br><span class="line"><span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[j]&lt;dist[t]))</span><br><span class="line">t=j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){ <span class="comment">//用这个点 去更新其他点到第一个点的距离 </span></span><br><span class="line">dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">}</span><br><span class="line">st[t]=<span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">g[a][b]=<span class="built_in">min</span>(g[a][b],c);<span class="comment">//处理重边 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">dijkstra</span>();</span><br><span class="line">cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="堆优化版-稀疏图-邻接表"><a href="#堆优化版-稀疏图-邻接表" class="headerlink" title="堆优化版 - 稀疏图 - 邻接表"></a>堆优化版 - 稀疏图 - 邻接表</h2><p>适合稀疏图，<code>邻接表</code>存储图</p><p>优化：用 <code>堆</code>来 存储距离：$mlogn$</p><ul><li><code>找 不在S中距离的 到源点的距离最短的那个点</code> 👉找一堆数中的最小数👉堆👉$O(1)$</li><li><code>用这个点 去更新其他点到第一个点的距离</code>👉堆中修改一个数👉$O(logn)$；</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">150005</span>,M=<span class="number">150005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>{</span><br><span class="line">e[idx]=y,ne[idx]=h[x],w[idx]=z,h[x]=idx,idx++;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap; <span class="comment">//小根堆</span></span><br><span class="line"><span class="comment">//heap维护的是 不在S中的点以及它们离起点的距离 </span></span><br><span class="line">heap.<span class="built_in">push</span>({<span class="number">0</span>,<span class="number">1</span>});<span class="comment">//dist=0 point=1；</span></span><br><span class="line"><span class="keyword">while</span>(heap.<span class="built_in">size</span>()){ </span><br><span class="line">PII k=heap.<span class="built_in">top</span>();   <span class="comment">//O(m) * O(1) -&gt; O(m)</span></span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> ver=k.second,distance=k.first;</span><br><span class="line"><span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver]=<span class="literal">true</span>;  <span class="comment">//O(m) * O(1) -&gt; O(m)</span></span><br><span class="line"><span class="comment">//用当前点更新其他点的距离 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;distance+w[i]){</span><br><span class="line">dist[j]=distance+w[i];</span><br><span class="line">heap.<span class="built_in">push</span>({dist[j],j});  <span class="comment">// 堆的插入操作时间复杂度是 O(log(n))</span></span><br><span class="line">                                         <span class="comment">// O(m) * O(log(n)) -&gt; O(mlog(n))</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="built_in">add</span>(x,y,z);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Bellman-Ford-负权边"><a href="#Bellman-Ford-负权边" class="headerlink" title="Bellman-Ford - 负权边"></a>Bellman-Ford - 负权边</h1><p><strong>思想</strong>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化源点到各顶点的路径距离。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 进行n - <span class="number">1</span>次遍历，每次遍历对 所有边 进行 “松弛操作”。</span><br><span class="line">   松弛操作：以a为起点，b为终点，ab边长度为w为例：</span><br><span class="line">    dist[a]代表 源点 到 a点 的路径长度，dist[b]代表源点s到b点的路径长度。</span><br><span class="line">    <span class="keyword">if</span>：dist[b] &gt; dist[a] + wthen：dist[b] = dist[a] + w。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> 遍历都结束后，若再进行一次遍历，还能得到s到某些节点更短的路径的话，则说明存在负权回路</span><br></pre></td></tr></tbody></table></figure><p><a href="https://blog.csdn.net/hahahahahaha5/article/details/119022511">参考阅读：Bellman——Ford算法</a></p><h2 id="AcWing-853-有边数限制的最短路-结构体"><a href="#AcWing-853-有边数限制的最短路-结构体" class="headerlink" title="AcWing 853 有边数限制的最短路 - 结构体"></a><a href="https://www.acwing.com/problem/content/855/">AcWing 853 有边数限制的最短路</a> - 结构体</h2><p>对所有边操作，可以直接采用一个<code>结构体</code>定义每条边</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代n次 <span class="comment">//这个n其实就是限制了从源点经过不超过n条边到达某些点</span></span><br><span class="line">    <span class="keyword">for</span> 所有m条边a-b：w</span><br><span class="line">        dist[b]=<span class="built_in">min</span>(dist[b],dist[a]+w);</span><br></pre></td></tr></tbody></table></figure><blockquote><p> n 个点 m 条边有向图，可能存在重边和自环， <strong>边权可能为负数</strong>。</p><p>求从 1 号点到 n 号点的<strong>最多经过 k 条边</strong>的最短距离</p><p>注意：图中可能 <strong>存在负权回路</strong> ，则不一定存在最短距离。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">505</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line"><span class="keyword">int</span> a,b,w;</span><br><span class="line">}edges[M]; </span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> last[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line"><span class="built_in">memcpy</span>(last,dist,<span class="keyword">sizeof</span> dist);  <span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line"><span class="keyword">auto</span> e = edges[j];</span><br><span class="line">dist[e.b] = <span class="built_in">min</span>(dist[e.b],last[e.a]+e.w); </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">edges[i] ={x,y,z};</span><br><span class="line">}</span><br><span class="line"><span class="built_in">bellman_ford</span>();</span><br><span class="line"><span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)  cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;dist[n]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="SPFA-正-负权"><a href="#SPFA-正-负权" class="headerlink" title="SPFA - 正/负权"></a>SPFA - 正/负权</h1><blockquote><p>Shortest Path Faster Algorithm</p></blockquote><p>思想：</p><ul><li>对Bellman-Ford算法的优化：<strong>队列</strong></li><li>Bellman_ford算法会遍历所有的边，但其实只有当一个点的<strong>前驱结点更新</strong>，该点才会更新；所以只需遍历那些<strong>到源点距离变小的点所连接的边</strong>即可👉创建一个队列存放每一次加入距离<strong>被更新（变小）的结点</strong></li></ul><h2 id="AcWing-851-spfa求最短路"><a href="#AcWing-851-spfa求最短路" class="headerlink" title="AcWing 851 spfa求最短路"></a><a href="https://www.acwing.com/activity/content/problem/content/920/">AcWing 851 spfa求最短路</a></h2><blockquote><p>1≤n,m≤$10^5$,用bellman-ford会TLE</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],w[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;<span class="comment">//存放距离变小的边 </span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">st[<span class="number">1</span>]=<span class="literal">true</span>; <span class="comment">//st：当前点是否在队列中，防止存重复点 </span></span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">st[t]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){<span class="comment">//t变小了，说明所有t的出边对应的点也会变小 </span></span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]){</span><br><span class="line">dist[j]=dist[t]+w[i];</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">st[j]=<span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="built_in">add</span>(a,b,c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">spfa</span>();</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing-852-spfa判断负环"><a href="#AcWing-852-spfa判断负环" class="headerlink" title="AcWing 852 spfa判断负环"></a><a href="https://www.acwing.com/activity/content/problem/content/921/">AcWing 852 spfa判断负环</a></h2><p>加一个cnt数组，<code>cnt[i]</code>记录到顶点<code>i</code>经过的最短路径条数，大于等于<code>n</code>说明存在负环</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],w[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">//关键是看dist有没有更新，值不重要</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>{</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">st[i]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line">}<span class="comment">//判断是否存在负环，而不是 是否存在从1开始到达的负环，所以要把所有点加进去，此时dist也不用初始化了</span></span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">st[t]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]){</span><br><span class="line">dist[j]=dist[t]+w[i];</span><br><span class="line">cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt[j]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line">st[j]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="built_in">add</span>(a,b,c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Floyd-任意两点之间"><a href="#Floyd-任意两点之间" class="headerlink" title="Floyd - 任意两点之间"></a>Floyd - 任意两点之间</h1><p>⭐<strong>一个踩坑点</strong>⭐：</p><p><code>ios::sync_with_stdio(false)</code> 取消cin的同步（就是iostream的缓冲跟stdio的同步） 取消后就<strong>cin就不能</strong>和scanf，sscanf, getchar, fgets，puts之类同时用，💔<strong>否则就可能导致输出和预期的不一样</strong>。</p><blockquote><p>刚开始取消同步，用puts输出impossible，发现顺序不对，还以为是代码问题QAQ，后来改成cout就AC了</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,M=<span class="number">20010</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> dist[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">dist[i][j]=<span class="built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line"><span class="keyword">if</span>(i==j) dist[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> dist[i][j]=INF;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">dist[x][y]=<span class="built_in">min</span>(dist[x][y],z);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">floyd</span>();</span><br><span class="line"><span class="keyword">while</span>(k--){</span><br><span class="line"><span class="keyword">int</span> x,y; cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(dist[x][y]&gt;INF/<span class="number">2</span>) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;dist[x][y]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="💦分层图💦：堆优化Dijkstra-建图"><a href="#💦分层图💦：堆优化Dijkstra-建图" class="headerlink" title="💦分层图💦：堆优化Dijkstra+建图"></a>💦分层图💦：堆优化Dijkstra+建图</h1><p><a href="https://blog.csdn.net/qq_40736036/article/details/85041838">参考阅读： 分层图</a></p><p>$n$ 个点 $m$ 条边构成一张<strong>带权</strong>无向连通图。现在可以从中选出 $k$ 条边，将<strong>边权变为零</strong>。求给定两点间<strong>最短路径</strong>。</p><blockquote><p>将点拆开，复制多层图，并利用特殊构造的边将各层相连的建图方法。</p><p>一般用于边或点有特殊限制的问题(如重复经过次数、多种价值可选等)。</p><p>需要保证拆开后的总点数规模可接受。</p></blockquote><ul><li><strong>空间复杂度及时间复杂度较高，（可以理解为2个点互连的有向图）</strong><ul><li>空间复杂度为$m\times (k+1)$，无向图在此基础上乘2</li></ul></li></ul><p>关键在<code>建图</code></p><ul><li><strong>两种方法解决：</strong><ol><li>建图时直接建成k+1层。</li><li>多开一维记录机会信息。</li></ol></li></ul><h2 id="P4568-飞行路线-洛谷"><a href="#P4568-飞行路线-洛谷" class="headerlink" title="P4568 飞行路线 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P4568">P4568 飞行路线 - 洛谷</a></h2><p><strong>题意</strong>： n 个城市，这些城市分别标记为 0 到 n-1，共 m种航线，每种航线连接两城市，航线有一定的价格。从一个城市沿着航线到达另一个城市，途中可进行转机。可免费在<strong>最多</strong> k种航线上搭乘飞机。问这次出行最少花费</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">5e4</span>+<span class="number">10</span>,K=<span class="number">50</span>; <span class="comment">//注意这里的数据范围，不然被TLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N*K],e[M*K&lt;&lt;<span class="number">1</span>],ne[M*K&lt;&lt;<span class="number">1</span>],w[M*K&lt;&lt;<span class="number">1</span>],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N*K];</span><br><span class="line"><span class="keyword">bool</span> st[N*K];</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规定顶点编号从1开始 </span></span><br><span class="line"><span class="comment">// 稀疏图，堆优化dijkstra </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[s]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;</span><br><span class="line">heap.<span class="built_in">push</span>({<span class="number">0</span>,s});</span><br><span class="line"><span class="keyword">while</span>(!heap.<span class="built_in">empty</span>()){</span><br><span class="line">PII k=heap.<span class="built_in">top</span>();</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> ver=k.second,distance=k.first;</span><br><span class="line"><span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;distance+w[i]){</span><br><span class="line">dist[j]=distance+w[i];</span><br><span class="line">heap.<span class="built_in">push</span>({dist[j],j});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;</span><br><span class="line">s++;t++;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">a++;b++;</span><br><span class="line"><span class="built_in">add</span>(a,b,c),<span class="built_in">add</span>(b,a,c);</span><br><span class="line"><span class="comment">//建立分层图</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++){</span><br><span class="line"><span class="built_in">add</span>(n*i+a,n*i+b,c);</span><br><span class="line"><span class="built_in">add</span>(n*i+b,n*i+a,c);</span><br><span class="line"><span class="comment">//两层之间建边</span></span><br><span class="line"><span class="built_in">add</span>(n*(i<span class="number">-1</span>)+a,n*i+b,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">add</span>(n*(i<span class="number">-1</span>)+b,n*i+a,<span class="number">0</span>); </span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//for(int i=1;i&lt;=k;i++) add(n*(i-1)+t,n*i+t,0);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dijkstra</span>();</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) ans=<span class="built_in">min</span>(ans,dist[t+i*n]);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同类题目：<a href="https://www.luogu.com.cn/problem/P4822">P4822 冻结 - 洛谷 </a></p><ul><li>修改一下起止点，两层之间建边的权值改为c/2 即可</li></ul><h1 id="2️⃣-最小生成树"><a href="#2️⃣-最小生成树" class="headerlink" title="2️⃣ 最小生成树"></a>2️⃣ 最小生成树</h1><ul><li><p>生成树：包含 <strong>所有顶点</strong>的 <strong>极小连通子图</strong> </p></li><li><p>最小生成树：带权连通无向图的  <strong>边的权值之和最小</strong>的那棵生成树</p></li></ul><h1 id="Prim-稠密图：-O-n-2"><a href="#Prim-稠密图：-O-n-2" class="headerlink" title="Prim-稠密图：$O(n^2)$"></a>Prim-稠密图：$O(n^2)$</h1><p>基于<strong>贪心</strong>：每次加入距离连通部分（已确定最小生成树的部分）的<strong>最近的点</strong>和<strong>对应边</strong>，连通部分逐渐扩大至整个图连通，且边权和最小。</p><p><a href="https://www.acwing.com/activity/content/code/content/48767/">参考阅读题解</a></p><ul><li><p>针对<strong>无向图</strong></p></li><li><p>先<strong>累加再更新</strong>，<strong>避免t有自环</strong>影响答案。</p><ul><li>后更新不会影响后面的结果：因为<code>dist[i]</code>为<code>i</code>到集合S的距离，当<code>t</code>放入S后，其<code>dist[t]</code>就已经没有意义，再更新也不会影响答案的正确性。</li></ul></li><li>特判一下第一次迭代，在没有做特殊处理时，第一次迭代中所有点到集合S的距离都为无穷大，且不会进行更新(也没有必要)，不需要将这条边 (第一次迭代时，找到的距离集合S最短的边) 累加到答案中，<strong>也不能认定为图不连通</strong>。</li><li>如果设置起点为i的话，在初始化<code>dist</code>数组之后，<code>dist[i] = 0</code>即可，省去每轮迭代中的两个<code>if</code>判断。</li></ul><h2 id="AcWing-858-Prim算法求最小生成树"><a href="#AcWing-858-Prim算法求最小生成树" class="headerlink" title="AcWing 858 Prim算法求最小生成树"></a><a href="https://www.acwing.com/activity/content/problem/content/924/">AcWing 858 Prim算法求最小生成树</a></h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N]; <span class="comment">//结点 i 到 j 的距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">//存储各个结点到已确定的生成树（顶点集S）的距离；区分dijkstra：到源点的距离 </span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 找剩余点到已确定生成树距离最近的点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line"><span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[j]&lt;dist[t]))</span><br><span class="line">t=j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(i&amp;&amp;dist[t]==INF) <span class="keyword">return</span> INF;<span class="comment">//图不连通</span></span><br><span class="line"><span class="keyword">if</span>(i) res+=dist[t];</span><br><span class="line">st[t]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)  <span class="comment">//更新剩余点到已确定的生成树的距离 </span></span><br><span class="line">dist[j]=<span class="built_in">min</span>(dist[j],g[t][j]); <span class="comment">//区分dijkstra：dist[t]+g[t][j] </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">g[a][b]= g[b][a]=<span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">prim</span>();</span><br><span class="line"><span class="keyword">if</span>(t==INF) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="堆优化Prim-稀疏图"><a href="#堆优化Prim-稀疏图" class="headerlink" title="堆优化Prim-稀疏图"></a>堆优化Prim-稀疏图</h1><p>$O(mlogn)$（不常用、略过，一般遇见稀疏图用下面的Kruskal）</p><h1 id="Kruskal-稀疏图：-O-mlogm"><a href="#Kruskal-稀疏图：-O-mlogm" class="headerlink" title="Kruskal-稀疏图：$O(mlogm)$"></a>Kruskal-稀疏图：$O(mlogm)$</h1><ul><li>主要对边进行操作，比如对边进行排序，考虑采用 <code>结构体</code> 建图</li><li>一条边依附的两个顶点在不同连通分量上：<code>并查集</code></li><li>prim算法需要更新其他点到集合的距离，用到边的权重，需要两条<br>但在kruskal用并差集维护，枚举的是边不是点，</li></ul><p><strong>思想</strong>：</p><ul><li>初始：n个顶点而无边 的非连通图，每个顶点自成一个连通分量 </li><li>按边的权值<strong>从小到大</strong>的顺序</li><li>不断选取当前<strong>未被选过且权值最小</strong>的边<ul><li>若该边 依附的两顶点落在T中不同的连通分量上，加入T </li><li>否则，舍弃此边，选择下一条权值最小的边；</li></ul></li><li>直到所有顶点都在一个连通分量上</li></ul><p><strong>结构体排序</strong>：</p><ul><li><p>结构体内部定义</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">const</span>&lt; (<span class="keyword">const</span> Edge&amp;W)<span class="keyword">const</span>{</span><br><span class="line">    <span class="keyword">return</span> w&lt;W.w</span><br><span class="line">} <span class="comment">// sort(edges,edges+m);</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>cmp外部函数定义</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct Edge A, struct Edge B)</span></span>{</span><br><span class="line"><span class="keyword">return</span> A.w &lt; B.w;</span><br><span class="line">} <span class="comment">// sort(edges,edges+m,cmp);</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>Lambda表达式</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(edges ,edges + m,[](<span class="keyword">auto</span> &amp; u,<span class="keyword">auto</span> &amp; v){<span class="keyword">return</span> u.w &lt; v.w ;});</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="AcWing-859-Kruskal算法求最小生成树"><a href="#AcWing-859-Kruskal算法求最小生成树" class="headerlink" title="AcWing 859 Kruskal算法求最小生成树 "></a><a href="https://www.acwing.com/activity/content/problem/content/925/">AcWing 859 Kruskal算法求最小生成树 </a></h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2</span>*N,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line"><span class="keyword">int</span> a,b,w;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge&amp;W)<span class="keyword">const</span>{</span><br><span class="line"><span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">}</span><br><span class="line">}edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a=edges[i].a, b=edges[i].b, w=edges[i].w;</span><br><span class="line">a=<span class="built_in">find</span>(a),b=<span class="built_in">find</span>(b);</span><br><span class="line"><span class="keyword">if</span>(a!=b){</span><br><span class="line">p[a]=b;</span><br><span class="line">res+=w;</span><br><span class="line">cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">edges[i]={a,b,c};</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">kruskal</span>();</span><br><span class="line"><span class="keyword">if</span>(t==INF) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3️⃣-二分图"><a href="#3️⃣-二分图" class="headerlink" title="3️⃣ 二分图"></a>3️⃣ 二分图</h1><p><a href="https://blog.csdn.net/u011815404/article/details/84260940">参考阅读：图论 —— 二分图</a></p><p><strong>概念</strong>：</p><p>⭕ <strong>二分图定义</strong>：设G=(V,E)是一个<strong>无向图</strong>，如果顶点集V 可分割为<strong>两个互不相交的子集</strong> $(A,B)$，并且图中的每条边$（i，j）$所关联的两个<strong>顶点</strong> $i$ 和 $j$ <strong>分别属于</strong>这两个不同的顶点集$(i \in A,j \in B)$，则称图G为一个二分图（二部图、偶图）</p><p>⭕ 完全二分图：集合A中的所有顶点都与集合B中的所有顶点相连的 二分图</p><p>⭕ 判定二分图的<strong>充要条件</strong>：<strong>图 G 中至少存在两个点，且图中所有回路的长度均为偶数</strong></p><h2 id="AcWing-860-判定二分图：染色法"><a href="#AcWing-860-判定二分图：染色法" class="headerlink" title="AcWing 860 判定二分图：染色法"></a><a href="https://www.acwing.com/activity/content/problem/content/926/">AcWing 860 判定二分图：染色法</a></h2><p>$O(m+n)$</p><p><strong>染色法思想</strong>：</p><ul><li><p>开始：对<strong>任意一个</strong>未染色的顶点染色。</p></li><li><p>判断其相邻的顶点中，若<strong>未染色</strong>，则将其<strong>染上</strong>和相邻顶点<strong>不同</strong>的颜色。</p></li><li><p>若<strong>已经染色</strong>且<strong>颜色和相邻顶点的颜色相同</strong>则说明不是二分图，若颜色不同则继续判断。</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">color[u]=c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(!color[j]){</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(color[j]==c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!color[i]){</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>)){</span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"No"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing-861-二分图的最大匹配：匈牙利算法"><a href="#AcWing-861-二分图的最大匹配：匈牙利算法" class="headerlink" title="AcWing 861 二分图的最大匹配：匈牙利算法"></a><a href="https://www.acwing.com/activity/content/problem/content/927/">AcWing 861 二分图的最大匹配：匈牙利算法</a></h2><p>最坏$O(mn)$，<strong>实际运行一般远小于它</strong></p><p><strong>二分图的匹配</strong>：</p><p>⭕ <strong>匹配</strong>：在给定一个二分图 G，在 G 的一个子图 M 中，若 <strong>M 的边集中的任意两条边都不依附于同一个顶点</strong>，则称 M 是一个匹配。</p><blockquote><p>匹配：一个二分图中边的集合，其中任意两条边都没有公共顶点</p><p>完美匹配：一个图的某个匹配中，所有的顶点都是匹配点</p><p>交替路：从一个<strong>未</strong>匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p><p>增广路：从一个<strong>未</strong>匹配点出发，走交替路，途径另一个未匹配点（出发的点不算）</p></blockquote><p>⭕ <strong>最大匹配</strong>：给定二分图 G 中的所有匹配，所含匹配<strong>边数最多</strong>的匹配</p><blockquote><p>st[ ]数组：可以理解为“预定数组”，比如：看成男女配对，即某一轮中某个女孩是不是被男生预定了。如果find函数 递归下去能够 帮心仪对象的对象找到备胎，那皆大欢喜；找不到备胎，预定姑娘就保持不动。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n1,n2,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> match[N]; <span class="comment">//match[j]=x：右边的j和左边的x配对</span></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line">st[j]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(match[j]==<span class="number">0</span>||<span class="built_in">find</span>(match[j])){</span><br><span class="line">match[j]=x;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="built_in">add</span>(u,v);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;i++){</span><br><span class="line"><span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(i)) ans++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="AcWing1224-交换瓶子"><a href="#AcWing1224-交换瓶子" class="headerlink" title="AcWing1224 交换瓶子"></a>AcWing1224 交换瓶子</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>N个随机排列的数字，编号1-N，<strong>每次交换任意两个数字</strong>，直到最后序号为1-N的升序，求最小交换次数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>把每个瓶子看成一个点，将每个瓶子向它应该在的位置的编号</p><p><img src="https://i.bmp.ovh/imgs/2022/04/03/194ca1fb2eaee9a7.png" style="zoom: 33%;"></p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        {</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; !st[j]; j = b[j])</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/174698/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></tbody></table></figure><p>另外，暴力出奇迹</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,cnt=<span class="number">0</span>;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]!=i){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line"><span class="keyword">if</span>(a[j]==i){</span><br><span class="line"><span class="built_in">swap</span>(a[i],a[j]);cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Content&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最短路&lt;/strong&gt;：Dijkstra、Bellman-Ford、SPFA、Floyd&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最小生成树&lt;/strong&gt;：Prim、Kruskal&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二分图&lt;/strong&gt;：染色法、匈牙利算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="图论" scheme="http://example.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【总结】数据结构（总结自《算法笔记》和《王道》）</title>
    <link href="http://example.com/2022/07/08/2022-07-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%80%BB%E7%BB%93%E8%87%AA%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%EF%BC%89/"/>
    <id>http://example.com/2022/07/08/2022-07-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%80%BB%E7%BB%93%E8%87%AA%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%EF%BC%89/</id>
    <published>2022-07-08T11:08:20.000Z</published>
    <updated>2022-07-27T05:42:00.785Z</updated>
    
    <content type="html"><![CDATA[<ul><li>随便记记</li></ul><span id="more"></span><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line">st.<span class="built_in">push</span>(i);<span class="comment">//O(1)</span></span><br><span class="line">st.<span class="built_in">top</span>();<span class="comment">//O(1) 取得栈顶元素</span></span><br><span class="line">st.<span class="built_in">pop</span>();<span class="comment">//O(1) 弹出栈顶元素</span></span><br></pre></td></tr></tbody></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;<span class="comment">//以下时间复杂度都是O(1)</span></span><br><span class="line">q.<span class="built_in">front</span>(); q.<span class="built_in">back</span>();</span><br><span class="line">q.<span class="built_in">push</span>();  q.<span class="built_in">pop</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="中缀转后缀-求后缀表达式"><a href="#中缀转后缀-求后缀表达式" class="headerlink" title="中缀转后缀,求后缀表达式"></a>中缀转后缀,求后缀表达式</h2><p><a href="http://codeup.hustoj.com/problem.php?cid=100000602&amp;pid=0">题目链接</a></p><p>《算法笔记》P249</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line"><span class="keyword">double</span> num;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">};</span><br><span class="line">string str;</span><br><span class="line">queue&lt;node&gt;q;<span class="comment">//后缀表达式 </span></span><br><span class="line">stack&lt;node&gt;s;<span class="comment">//符号栈 </span></span><br><span class="line">map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;op;</span><br><span class="line"><span class="comment">//中缀转后缀 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">double</span> num;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();){</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>){</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp.num=str[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span>(i&lt;str.<span class="built_in">length</span>()&amp;&amp;str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>){</span><br><span class="line">temp.num = temp.num*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">q.<span class="built_in">push</span>(temp); <span class="comment">//数字存入后缀表达式队列中</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">temp.flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;op[str[i]]&lt;=op[s.<span class="built_in">top</span>().op]){</span><br><span class="line">q.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">}<span class="comment">//如果优先级不大于栈顶符号,把栈顶符号弹出,压入到后缀表达式中</span></span><br><span class="line">temp.op=str[i];<span class="comment">//直到优先级大于栈顶符号时,压入符号栈中</span></span><br><span class="line">s.<span class="built_in">push</span>(temp);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()){<span class="comment">//符号栈剩余符号压入后缀表达式中</span></span><br><span class="line">q.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//计算后缀表达式 </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cal</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">double</span> temp1,temp2;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t.flag) s.<span class="built_in">push</span>(t);</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp2=s.<span class="built_in">top</span>().num; s.<span class="built_in">pop</span>();</span><br><span class="line">temp1=s.<span class="built_in">top</span>().num; s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t.op==<span class="string">'+'</span>) temp.num =temp1+temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t.op==<span class="string">'-'</span>) temp.num=temp1-temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t.op==<span class="string">'*'</span>) temp.num=temp1*temp2;</span><br><span class="line"><span class="keyword">else</span> temp.num=temp1/temp2;</span><br><span class="line">s.<span class="built_in">push</span>(temp);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">top</span>().num;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">op[<span class="string">'+'</span>]=op[<span class="string">'-'</span>]=<span class="number">1</span>;</span><br><span class="line">op[<span class="string">'/'</span>]=op[<span class="string">'*'</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin,str),str!=<span class="string">"0"</span>){</span><br><span class="line"><span class="keyword">for</span>(string::iterator it=str.<span class="built_in">end</span>();it!=str.<span class="built_in">begin</span>();it--){</span><br><span class="line"><span class="keyword">if</span>(*it==<span class="string">' '</span>) str.<span class="built_in">erase</span>(it);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">Change</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,<span class="built_in">Cal</span>());</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h2><p><a href="http://codeup.hustoj.com/problem.php?cid=100000605&amp;pid=1">题目链接</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">stack&lt;<span class="keyword">char</span>&gt;s;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++){</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'['</span>||str[i]==<span class="string">'('</span>||str[i]==<span class="string">'{'</span>) s.<span class="built_in">push</span>(str[i]);</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">']'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'['</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">')'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'('</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'}'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'{'</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(!flag||!s.<span class="built_in">empty</span>()) cout&lt;&lt;<span class="string">"no"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"yes"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><h2 id="图的邻接表转换为邻接矩阵存储"><a href="#图的邻接表转换为邻接矩阵存储" class="headerlink" title="图的邻接表转换为邻接矩阵存储"></a>图的邻接表转换为邻接矩阵存储</h2><p><strong>算法思想</strong>： 设图的顶点分别存储在数组<code>v[n]</code>中。首先初始化邻接矩阵。遍历邻接表，在依次遍历顶点<code>v[i]</code>的边链表时，修改邻接矩阵的第<code>i</code>行的元素值。若链表边结点的值为<code>j</code>，则置<code>arcs[i][j]=1</code>。无向、有向图均适用。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Convert</span><span class="params">(ALGraph &amp;G, <span class="keyword">int</span> arcs[M][N])</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">        p = (G -&gt; v[i]).firstarc;</span><br><span class="line">        <span class="keyword">while</span>(p != null){</span><br><span class="line">            arcs[i][p -&gt; data] = <span class="number">1</span>;</span><br><span class="line">            p = p -&gt;nextarc;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;随便记记&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】BFS &amp; DFS</title>
    <link href="http://example.com/2022/06/19/2022-06-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91BFS/"/>
    <id>http://example.com/2022/06/19/2022-06-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91BFS/</id>
    <published>2022-06-19T01:55:34.000Z</published>
    <updated>2022-07-31T03:11:12.259Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一些BFS</li></ul><span id="more"></span><h1 id="Easy-Part"><a href="#Easy-Part" class="headerlink" title="Easy Part"></a>Easy Part</h1><p>队列queue、O(2^h)、最短路(只有所有边权都是1 的时候才可以用BFS做最短路问题)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queue←初始</span><br><span class="line"><span class="keyword">while</span> queue非空{</span><br><span class="line">t←队头；扩展队头<span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcW-844-走迷宫"><a href="#AcW-844-走迷宫" class="headerlink" title="AcW-844. 走迷宫 "></a><a href="https://www.acwing.com/problem/content/846/">AcW-844. 走迷宫 </a></h2><p>给定地图，求左上走到右下的步数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>({<span class="number">1</span>,<span class="number">1</span>});</span><br><span class="line">d[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> temp=q.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">int</span> x=temp.first,y=temp.second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=m&amp;&amp;d[xx][yy]==<span class="number">-1</span>&amp;&amp;g[x][y]==<span class="number">0</span>){</span><br><span class="line">d[xx][yy]=d[x][y]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({xx,yy});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;d[n][m]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing843-n皇后问题"><a href="#AcWing843-n皇后问题" class="headerlink" title="AcWing843 n皇后问题"></a>AcWing843 n皇后问题</h2><ul><li><p>对于第r行第i列所在的对角线和反对角线</p><p><strong>对角线</strong> <code>dg[r+i]</code>，<strong>反对角线</strong><code>udg[n−r+i]</code>中的下标  <code>r+i</code>和  <code>n−r+i</code>  表示的是<strong>截距</strong></p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> dg[N],udg[N],col[N];</span><br><span class="line"><span class="comment">//dfs(r)在第r行上放皇后 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(r==n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">puts</span>(a[i]);<span class="comment">//cout&lt;&lt;a[i]&lt;&lt;endl; </span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>); <span class="comment">//换行 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//针对当前第r行，枚举 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!col[i] &amp;&amp; !dg[r + i] &amp;&amp; !udg[n - r + i]){</span><br><span class="line">a[r][i]=<span class="string">'Q'</span>;</span><br><span class="line">col[i] = dg[r + i] = udg[n - r + i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(r+<span class="number">1</span>);</span><br><span class="line">col[i] = dg[r + i] = udg[n - r + i] = <span class="literal">false</span>; </span><br><span class="line">a[r][i]=<span class="string">'.'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) a[i][j]=<span class="string">'.'</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1101-献给阿尔吉侬的花束"><a href="#AcWing1101-献给阿尔吉侬的花束" class="headerlink" title="AcWing1101 献给阿尔吉侬的花束"></a>AcWing1101 献给阿尔吉侬的花束</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n,r,c;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(PII st,PII ed)</span></span>{</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line">d[st.first][st.second]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;r&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;c&amp;&amp;g[x][y]!=<span class="string">'#'</span>&amp;&amp;d[x][y]==<span class="number">-1</span>){</span><br><span class="line">d[x][y]=d[t.first][t.second]+<span class="number">1</span>;</span><br><span class="line">PII xy={x,y};</span><br><span class="line"><span class="keyword">if</span>(xy==ed) <span class="keyword">return</span> d[x][y];</span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">PII st,ed;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++){</span><br><span class="line">cin&gt;&gt;g[i][j]; </span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'S'</span>) st={i,j};</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'E'</span>) ed={i,j};</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">int</span> ans=<span class="built_in">bfs</span>(st,ed);</span><br><span class="line"><span class="keyword">if</span>(ans!=<span class="number">-1</span>) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"oop!"</span>&lt;&lt;endl; </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1113-红与黑"><a href="#AcWing1113-红与黑" class="headerlink" title="AcWing1113 红与黑"></a>AcWing1113 红与黑</h2><h3 id="BFS写法"><a href="#BFS写法" class="headerlink" title="BFS写法"></a>BFS写法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> w,h;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(PII st)</span></span>{</span><br><span class="line">d[st.first][st.second]=<span class="number">1</span>;</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;h&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;w&amp;&amp;d[x][y]==<span class="number">-1</span>&amp;&amp;g[x][y]==<span class="string">'.'</span>){</span><br><span class="line">d[x][y]=<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">cin&gt;&gt;w&gt;&gt;h;<span class="keyword">if</span>(w==<span class="number">0</span>&amp;&amp;h==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">PII st;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w;j++){</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'@'</span>) st={i,j};</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">bfs</span>(st);</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w;j++){</span><br><span class="line"><span class="keyword">if</span>(d[i][j]==<span class="number">1</span>) cnt++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="DFS写法"><a href="#DFS写法" class="headerlink" title="DFS写法"></a>DFS写法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>},dy[]={<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">g[x][y]=<span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> a=x+dx[i],b=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;n&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;m&amp;&amp;g[a][b]==<span class="string">'.'</span>){</span><br><span class="line">res+=<span class="built_in">dfs</span>(a,b);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;m&gt;&gt;n,n||m){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;g[i];</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'@'</span>){</span><br><span class="line">x=i,y=j;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;<span class="built_in">dfs</span>(x,y)&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1096-地牢大师（三维）"><a href="#AcWing1096-地牢大师（三维）" class="headerlink" title="AcWing1096 地牢大师（三维）"></a>AcWing1096 地牢大师（三维）</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>发现有时候代码写不对注意检查：初始点的状态设置是否遗漏，bfs里面坐标的判断有无遗漏，标志数组是否遗漏</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Coo</span>{</span></span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">};<span class="comment">//存储xyz坐标 </span></span><br><span class="line"><span class="keyword">char</span> g[N][N][N]; <span class="comment">//xyz</span></span><br><span class="line"><span class="keyword">int</span> d[N][N][N];<span class="comment">//存储走到xyz的距离 </span></span><br><span class="line"><span class="keyword">int</span> l,r,c;</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},dy[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>},dz[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Coo st,Coo ed)</span></span>{</span><br><span class="line">d[st.x][st.y][st.z]=<span class="number">0</span>;</span><br><span class="line">queue&lt;Coo&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.x+dx[i],y=t.y+dy[i],z=t.z+dz[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;r&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;c&amp;&amp;z&gt;=<span class="number">0</span>&amp;&amp;z&lt;l){<span class="comment">//坐标合法 </span></span><br><span class="line"><span class="keyword">if</span>(d[x][y][z]==<span class="number">-1</span>&amp;&amp;g[x][y][z]!=<span class="string">'#'</span>){<span class="comment">//且没有被走过且可以走 </span></span><br><span class="line">d[x][y][z]=d[t.x][t.y][t.z]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({x,y,z});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(d[ed.x][ed.y][ed.z]!=<span class="number">-1</span>) cout&lt;&lt;<span class="string">"Escaped in "</span>&lt;&lt;d[ed.x][ed.y][ed.z]&lt;&lt;<span class="string">" minute(s)."</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"Trapped!"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">Coo st,ed;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;c);<span class="keyword">if</span>(l==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;r;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;c;k++){</span><br><span class="line">cin&gt;&gt;g[j][k][i];</span><br><span class="line"><span class="keyword">if</span>(g[j][k][i]==<span class="string">'S'</span>) st={j,k,i};</span><br><span class="line">i</span><br><span class="line">                        ed={j,k,i};</span><br><span class="line">} </span><br><span class="line"><span class="built_in">bfs</span>(st,ed); </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Flood-Fill算法"><a href="#Flood-Fill算法" class="headerlink" title="Flood Fill算法"></a>Flood Fill算法</h1><ul><li>针对网格图的题，找连通的块的数目</li><li>dfs，bfs；dfs有时候可能会有爆栈的风险；都能实现的话用dfs更加方便</li><li>bfs：</li></ul><hr><h2 id="AcWing1233-全球变暖"><a href="#AcWing1233-全球变暖" class="headerlink" title="AcWing1233 全球变暖"></a>AcWing1233 全球变暖</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>多少个连通块，遍历<ul><li>找连通块：遍历BFSorDFS 、或者 并查集</li></ul></li><li>多少个连通块会被淹没掉<ul><li>如何判断被淹没：一共有多少个单元totoal，多少个单元在边界bound上</li><li>等价于==》 total=bound</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];<span class="comment">//当前点是否被搜索过 </span></span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>},dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> sx,<span class="keyword">int</span> sy,<span class="keyword">int</span> &amp;total,<span class="keyword">int</span> &amp;bound)</span></span>{</span><br><span class="line">PII pi={sx,sy};</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(pi);</span><br><span class="line">st[sx][sy]=<span class="literal">true</span>;<span class="comment">//当前第一个点被遍历 记得要标记 </span></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">total++;</span><br><span class="line"><span class="keyword">int</span> is_bound=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//判断当前t是否临海 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line">            <span class="comment">//当前t周围的点的坐标合法，且岛屿没有被遍历过</span></span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n&amp;&amp;(!st[x][y])){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'.'</span>) is_bound=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'#'</span>){</span><br><span class="line">st[x][y]=<span class="literal">true</span>; q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">bound+=is_bound;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;g[i];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;<span class="comment">//被淹没的 岛屿的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line"><span class="keyword">if</span>(!st[i][j]&amp;&amp;g[i][j]==<span class="string">'#'</span>){</span><br><span class="line"><span class="keyword">int</span> total=<span class="number">0</span>,bound=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//从当前点开始，统计这个点所在的连通块 </span></span><br><span class="line"><span class="built_in">bfs</span>(i,j,total,bound);</span><br><span class="line"><span class="keyword">if</span>(total==bound) cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,cnt); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1097-池塘计数"><a href="#AcWing1097-池塘计数" class="headerlink" title="AcWing1097 池塘计数"></a>AcWing1097 池塘计数</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>dfs：遍历每个W，标记，从当前W开始八个方向深搜；每次从一个W搜完，与之相连的W都变成. </li><li>bfs：遍历每个W，标记，从当前W开始八个方向宽搜。。。。。</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">g[a][b]=<span class="string">'.'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=a+dx[i],y=b+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'W'</span>)</span><br><span class="line"><span class="built_in">dfs</span>(x,y);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//cin&gt;&gt;g[i];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) cin&gt;&gt;g[i][j];</span><br><span class="line">    <span class="comment">//连通块问题，从每个点开始bfs or dfs</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'W'</span>){</span><br><span class="line"><span class="built_in">dfs</span>(i,j);</span><br><span class="line">cnt++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p><strong>标记数组的位置很重要，一定要放在入队（q.push())之前</strong>，不然会T掉！<br>    在bfs中，如果对于之后的某个合法位置，应该入队，那么标记数组会有两种方法，第一种是在每次取队首元素的时候，标记已经遍历过当前点了，还有一种方法是在入队之前就马上标记。之前没太注意这个，但是是完全不一样的，对于8个方向，比如向<strong>左走一步是合法</strong>的，然后不马上标记的话，例如当前<strong>向下和向左</strong>都是合法的，那么当<strong>向下走时候(比如向下先入队了)，那么向左走还会被记录一次</strong>，这个很难debug出来，很奇怪的感觉</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">PII pi={a,b};</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(pi);</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//g[t.first][t.second]='.'; 不要在这个位置标记</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'W'</span>){</span><br><span class="line">                    g[x][y]=<span class="string">'.'</span>;<span class="comment">//要在这个位置标记！！！！！！！！！！！</span></span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'W'</span>){</span><br><span class="line"><span class="built_in">bfs</span>(i,j);</span><br><span class="line">cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="树与图的DFS"><a href="#树与图的DFS" class="headerlink" title="树与图的DFS"></a>树与图的DFS</h2><ul><li>有向图存储<ul><li>邻接矩阵（用的比较少，g[a] [b])，不能存储重边</li><li><strong>邻接表</strong>：每个节点开了一个表，存着<strong>这个点可以走到哪个点</strong>（内部点的存储次序无关紧要）</li></ul></li></ul><h3 id="AcW-846-树的重心"><a href="#AcW-846-树的重心" class="headerlink" title="AcW-846. 树的重心"></a><a href="https://www.acwing.com/activity/content/problem/content/909/">AcW-846. 树的重心</a></h3><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一颗树，包含 <strong>n个结点</strong>（编号 1∼n）和 n−1 条<strong>无向边</strong>。</p><p>找树的重心，并输出将重心删除后，<strong>剩余各个连通块中节点数</strong>的<strong>最大值</strong>。</p><p>重心定义：重心是指树中的一个结点，如果将这个点删除后，<strong>剩余各个连通块中点数的最大值最小</strong>，那么这个节点被称为树的重心。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>无向图：建立边的时候两个方向都要建边</li><li>枚举删掉每一个点剩余连通块的节点数量的最大值，从各个最大值中找到最小值</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> ans=N,n;</span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//标记是否被遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">idx=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//插入一条a到b的边：</span></span><br><span class="line"><span class="comment">//在a所对应的邻接表里面插入一个节点b(头插) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//从节点u深搜，返回size:以u为根的树中 点的数量 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">st[u]=<span class="literal">true</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> size=<span class="number">1</span>,res=<span class="number">0</span>;<span class="comment">//sum：删掉这个点的连通块大小的最大值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]){<span class="comment">//遍历u节点的子节点</span></span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line"><span class="keyword">int</span> s=<span class="built_in">dfs</span>(j);<span class="comment">//s：当前子树的大小 </span></span><br><span class="line">size+=s;<span class="comment">//</span></span><br><span class="line">res=<span class="built_in">max</span>(res,s);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//和删除该点后的父节点的连通块大小 比较 </span></span><br><span class="line">res=<span class="built_in">max</span>(res,n-size);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,res); </span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="树与图的BFS"><a href="#树与图的BFS" class="headerlink" title="树与图的BFS"></a>树与图的BFS</h2><h3 id="AcW-847-图中点的层次"><a href="#AcW-847-图中点的层次" class="headerlink" title="AcW-847. 图中点的层次 "></a><a href="https://www.acwing.com/activity/content/problem/content/910/">AcW-847. 图中点的层次 </a></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//d[i]存储1号点走到i号点的距离 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);<span class="comment">//-1标记没走过 </span></span><br><span class="line">d[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//初始化，然后入队 </span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//扩展 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];<span class="comment">//通过索引i找到t能到的节点编号 </span></span><br><span class="line"><span class="keyword">if</span>(d[j]==<span class="number">-1</span>){</span><br><span class="line">d[j]=d[t]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line">cout&lt;&lt;d[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="AcW-848-有向图的拓扑序列"><a href="#AcW-848-有向图的拓扑序列" class="headerlink" title="AcW-848. 有向图的拓扑序列"></a><a href="https://www.acwing.com/problem/content/850/">AcW-848. 有向图的拓扑序列</a></h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给定有向图（可能有重边和自环）</p><p>若存在拓扑序列，则输出；不存在则输出-1</p><p>若一个由图中<strong>所有点</strong>构成的序列 A满足：对于图中的每条边 <strong>(x,y)</strong>，x 在 序列A 中都出现在 y <strong>之前</strong>，则称 A 是该图的一个拓扑序列。（即：所有的边都是从前指向后的）</p><p><strong>有向无环图一定存在拓扑序列：拓扑图</strong></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>入度=0：<strong>没有任何一条边指向它</strong>，所以可以排在当前最前面的位置：将其<strong>入队</strong></li><li>宽搜，枚举所有出边，t→j ，删掉t→j：j的入度-1，</li><li>如果j的入度=0，说明j前面的都排好序了，所以j可以入队</li></ul><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;top;<span class="comment">//存放最终序列 </span></span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//入度 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span>{</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="comment">//把所有入度为0的点插入队列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!d[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">top.<span class="built_in">push</span>(t);</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];<span class="comment">//出边的点</span></span><br><span class="line">d[j]--; </span><br><span class="line"><span class="keyword">if</span>(d[j]==<span class="number">0</span>) q.<span class="built_in">push</span>(j);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断是否所有点都入队</span></span><br><span class="line"><span class="keyword">return</span> top.<span class="built_in">size</span>()==n;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b);</span><br><span class="line">d[b]++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">topsort</span>()){</span><br><span class="line"><span class="keyword">while</span>(!top.<span class="built_in">empty</span>()){</span><br><span class="line">cout&lt;&lt;top.<span class="built_in">front</span>()&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">top.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}<span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Medium-Part"><a href="#Medium-Part" class="headerlink" title="Medium Part"></a>Medium Part</h1><h2 id="最小步数模型：状态的转变"><a href="#最小步数模型：状态的转变" class="headerlink" title="最小步数模型：状态的转变"></a>最小步数模型：状态的转变</h2><p>区分最短路模型：从一个点到另一个点的最短距离（比如AcW-844走迷宫）</p><p>关键：</p><ol><li>状态的存储：<ul><li><code>queue&lt;状态&gt;</code></li><li><code>unordered_map&lt;状态，步数&gt;dist</code>：记录到达状态的距离</li><li><code>unordered_map&lt;状态，&lt;前一个状态,转移操作&gt;</code>：记录前驱，用于路径输出</li></ul></li><li>状态的切换<ul><li>根据题意;</li><li>（下标从0开始）二维到一维：<code>int x = index / row_length, y = index % col_length</code></li></ul></li><li>思路：<ul><li>将初始状态加入到队列，然后BFS扩展，直到找到目标状态为止</li></ul></li></ol><h3 id="AcW-845-八数码"><a href="#AcW-845-八数码" class="headerlink" title="AcW-845. 八数码"></a><a href="https://www.acwing.com/problem/content/description/847/">AcW-845. 八数码</a></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1、将每个3x3 理解成一个状态</span></span><br><span class="line"><span class="comment">2、从初始3x3到12345678x最小步数 -&gt; 从初始状态到目标状态 最短路</span></span><br><span class="line"><span class="comment">类比走迷宫那道题：从左上到右下的最小步数 </span></span><br><span class="line"><span class="comment">3、到达每个状态的对应一个步数：unordered_map&lt;string,int&gt;</span></span><br><span class="line"><span class="comment">4、unordered_map的count()用以统计key在unordered_map中出现的次数。</span></span><br><span class="line"><span class="comment">实际上，unordered_map不允许有重复的key。</span></span><br><span class="line"><span class="comment">因此，如果key存在，则count返回1，如果不存在，则count返回0. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(string start)</span></span>{</span><br><span class="line">queue&lt;string&gt;q;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt;d;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line">d[start]=<span class="number">0</span>;<span class="comment">//unordered_map[key]=value;</span></span><br><span class="line">string end=<span class="string">"12345678x"</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t==end) <span class="keyword">return</span> d[t];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx=t.<span class="built_in">find</span>(<span class="string">'x'</span>);</span><br><span class="line"><span class="keyword">int</span> x=idx/<span class="number">3</span>,y=idx%<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> dist=d[t];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;<span class="number">3</span>&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;<span class="number">3</span>){</span><br><span class="line"><span class="built_in">swap</span>(t[idx],t[xx*<span class="number">3</span>+yy]);</span><br><span class="line"><span class="keyword">if</span>(!d.<span class="built_in">count</span>(t)){</span><br><span class="line">d[t]=dist+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">swap</span>(t[idx],t[xx*<span class="number">3</span>+yy]);</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>];</span><br><span class="line">string start=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++){</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">start+=s[<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"><span class="comment">//cout&lt;&lt;start&lt;&lt;endl;</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">bfs</span>(start)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 2  3  4  1  5  x  7  6  8 </span></span><br></pre></td></tr></tbody></table></figure><h3 id="AcW-1107-魔板"><a href="#AcW-1107-魔板" class="headerlink" title="AcW-1107. 魔板 "></a><a href="https://www.acwing.com/problem/content/1109/">AcW-1107. 魔板 </a></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> temp[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//每个状态string，存储上一个状态string </span></span><br><span class="line"><span class="comment">//经过操作char到达 </span></span><br><span class="line">unordered_map&lt;string,pair&lt;string,<span class="keyword">char</span>&gt;&gt;pre;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt;d;<span class="comment">//存储步数 </span></span><br><span class="line"><span class="keyword">void</span> _set(string s){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) temp[<span class="number">0</span>][i]=s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">7</span>;i&lt;<span class="number">4</span>,j&gt;<span class="number">3</span>;i++,j--) temp[<span class="number">1</span>][i]=s[j];</span><br><span class="line">}</span><br><span class="line"><span class="function">string <span class="title">get</span><span class="params">()</span></span>{</span><br><span class="line">string res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) res+=temp[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--) res+=temp[<span class="number">1</span>][i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//A:交换上下 </span></span><br><span class="line"><span class="function">string <span class="title">move0</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"> <span class="built_in">swap</span>(temp[<span class="number">0</span>],temp[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//B: </span></span><br><span class="line"><span class="function">string <span class="title">move1</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"><span class="keyword">char</span> a=temp[<span class="number">0</span>][<span class="number">3</span>],b=temp[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">temp[<span class="number">0</span>][i]=temp[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">temp[<span class="number">1</span>][i]=temp[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">} </span><br><span class="line">temp[<span class="number">0</span>][<span class="number">0</span>]=a;</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">0</span>]=b;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//C: </span></span><br><span class="line"><span class="function">string <span class="title">move2</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"><span class="keyword">char</span> t=temp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">temp[<span class="number">0</span>][<span class="number">2</span>]=temp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">temp[<span class="number">0</span>][<span class="number">1</span>]=temp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">1</span>]=temp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">2</span>]=t;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(string start,string end)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(start==end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">queue&lt;string&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line">d[start]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">string state[<span class="number">3</span>];</span><br><span class="line">state[<span class="number">0</span>]=<span class="built_in">move0</span>(t);</span><br><span class="line">state[<span class="number">1</span>]=<span class="built_in">move1</span>(t);</span><br><span class="line">state[<span class="number">2</span>]=<span class="built_in">move2</span>(t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++){</span><br><span class="line"><span class="keyword">if</span>(!d.<span class="built_in">count</span>(state[i])){</span><br><span class="line">d[state[i]]=d[t]+<span class="number">1</span>;</span><br><span class="line">pre[state[i]]={t,<span class="string">'A'</span>+i};</span><br><span class="line">q.<span class="built_in">push</span>(state[i]); </span><br><span class="line"><span class="keyword">if</span>(state[i]==end){</span><br><span class="line"><span class="keyword">return</span> d[state[i]];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">string start=<span class="string">"12345678"</span>;</span><br><span class="line">string end=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">end+=<span class="built_in"><span class="keyword">char</span></span>(c+<span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="built_in">bfs</span>(start,end);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">string res;<span class="comment">//从end往前找前驱 </span></span><br><span class="line"><span class="keyword">while</span>(end!=start){</span><br><span class="line">res+=pre[end].second;</span><br><span class="line">end=pre[end].first;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(ans&gt;<span class="number">0</span>) cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;一些BFS&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="BFS" scheme="http://example.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>【生活】Days Counter</title>
    <link href="http://example.com/2022/06/17/DaysCounter/"/>
    <id>http://example.com/2022/06/17/DaysCounter/</id>
    <published>2022-06-17T01:55:34.000Z</published>
    <updated>2022-08-13T15:11:00.488Z</updated>
    
    <content type="html"><![CDATA[<p>一些碎碎念记录</p><span id="more"></span><h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><h2 id="June"><a href="#June" class="headerlink" title="June"></a>June</h2><h3 id="17th"><a href="#17th" class="headerlink" title="17th"></a>17th</h3><ul><li>上午去把川大夏令营的章盖了，然后划水一上午</li><li>下午把网页代码写了一点，然后划水一下午</li><li>水群的时候看到fdu的夏令营开奖了，计科两位大佬入营了，太牛了，还好我没报，不然就要收到人生第一封夏令营拒信了OvO</li><li>小脑斧点赞我朋友圈了呜呜，泪目</li></ul><h3 id="18th"><a href="#18th" class="headerlink" title="18th"></a>18th</h3><ul><li>写了半天的前端</li><li>剩下半天划水</li><li>在b站刷到了以前的一部剧，《爱情宝典》，看了两集，果然还是那个年代的人做电视剧细心啊，服化道和人物形象和语言都让人觉得舒服，剧情节奏紧凑。</li></ul><h3 id="19th"><a href="#19th" class="headerlink" title="19th"></a>19th</h3><ul><li>上午把buaa的材料交了</li><li>下午睡了半个下午，写了半个下午的文档</li><li>呜呜感觉自己效率真的好低 ，一天下来好像什么也没干，等把信安赛初赛作品交了我要全身心投入复习！！！不能再像最近几天这么摸鱼了，感觉自己有好多东西要看，数据结构没复习完，计网还没开始背，操作系统也没有看，但操作系统应该很快就能看完吧。acwing的基础课还没有刷完，之前卖的linux基础课也没看，项目还没有好好整理复习。救命，怎么会有这么多事情要做，感觉自己一样都没开始做好QAQ。</li></ul><h3 id="20th"><a href="#20th" class="headerlink" title="20th"></a>20th</h3><ul><li>嗯，有点烦躁的一天。嗯，怎么说呢，学好语文真的是太重要太重要了，尤其是对于理工科。</li><li>熬一熬，再熬一熬就可以全身心地开始复习专业课了啾咪啾咪</li><li>晚上把文档搞完了，九点多就回去躺着啦嘿嘿</li></ul><h3 id="21st"><a href="#21st" class="headerlink" title="21st"></a>21st</h3><ul><li>早上自然醒太早了，把闹钟关了睡了个回笼觉结果睡过头了，上午就看了一点点点二叉树</li><li>中午回去吃完饭睡个午觉一觉睡到了三点多，开空调也能被热醒QAQ，傍晚洗完头洗完澡舒服多了，晚上等温度降下来了然后出门转一转</li><li>等晚上回来再好好学习（希望如此，但是现在就是一个毫无动力的状态，没有ddl来push我学习效率真的是太低惹。</li><li>晚上并没有好好学习，不过解决了一件麻烦事，舒服了<span class="github-emoji"><span>💮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4ae.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>先给明天画个饼🤗：早起（8点之前？），看完计网第一章，复习os第二章，刷几道基础课的题<span class="github-emoji"><span>🔨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f528.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="22nd"><a href="#22nd" class="headerlink" title="22nd"></a>22nd</h3><ul><li><p>确实早起成功了，六点半自然醒，意识醒了但是眼睛 睁不开<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，勉强睡到七点半才下床</p></li><li><p>给未来几天画个大饼</p></li><li><p>晚上摸鱼去啦，去一号门外面买了点荔枝和山竹，荔枝还是得吃妃子笑，白糖荔真的垃圾，水分和甜度都比不上妃子笑，虽然看起来大个儿又好看，但是核太大了，一颗白糖荔半颗核属于是。妃子笑yyds<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li></ul><h3 id="23rd"><a href="#23rd" class="headerlink" title="23rd"></a>23rd</h3><ul><li>上午开了个会，改了一下互联网+那个比赛的前端代码，<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>点了七口辣的火锅杯，一会儿拿完外卖再买半个西瓜再回宿舍，刷几集神探狄仁杰（真的没啥好剧可以看了，还是看这种老剧有意思，拍的真好啊），打算三点多的时候再出门吧，去院办把bit的章盖了，然后把留在院办的东西拿回来。学习，晚上再学<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>晚上不想学呜呜，呜呜能不能直接躺平等预推免啊，夏0营太耗费精力了呜呜，学不动 烦死啦，回去继续刷神探狄仁杰！！！！！！！！！！！</li></ul><h3 id="24th"><a href="#24th" class="headerlink" title="24th"></a>24th</h3><ul><li>昨天晚上南京下暴雨，一早睡到十点半才醒，中午点了黄焖鸡米饭，点的这家的不好吃，不如一号门外面的那家黄焖鸡米饭，有空出去吃一吃那家的<span class="github-emoji"><span>😮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>下午把计网的第一章看完了，好多啊好多啊，将近200页ppt，真的会谢，突然想起去年这个时候大概也在复习计网，hhh去年七月初考的计网好像是。</li><li>晚上数字图像处理的成绩出了，大三最后一门。以后再也不用卷生卷死卷分数啦 ，从大一上最初的82点几的均分，到大三下92点几的均分，还真是个逐渐“卷”化的三年，呜呜，这三年怎么这么快，呜呜<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="25th"><a href="#25th" class="headerlink" title="25th"></a>25th</h3><ul><li>上午又是一觉睡到十点多，虽然每天都是七点左右自然醒，但是醒了又没完全醒，所以继续睡<span class="github-emoji"><span>😴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f634.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>下午都在写PPT，没时间复习呜呜呜。</li><li>晚上去一号路吃了那个麻辣牛肚卷，牛肚真好吃呀，明天如果没吃晚饭的话就再去吃一次嘿嘿:happy:看计网的应用层的PPT看到了80页<span class="github-emoji"><span>💁♀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f481-2640.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，嗯，明天干啥呢，赌一波明天能不能早起，如果早起的话争取上午把应用层这一章的ppt看完吧，下午复习一下数据结构的查找那一章；晚上再过一遍os的进程这一章以及上午（可能）没看完的计网ppt</li></ul><h3 id="26th"><a href="#26th" class="headerlink" title="26th"></a>26th</h3><ul><li>早起成功，不过已经是早上十点<span class="github-emoji"><span>🕙</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f559.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，上午看了40页PPT，呜呜华东师范寄了呜呜，真就夏0营呗，呜呜呜呜，川大要是再给我寄，真的会emo呜呜，川大，我的川大<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>虽然说智能的去年前几名也是夏0营，呜呜，我知道是神仙打架，但是能不能给我一个offer保底呐QWQ，心痛呜呜，下午决定把那几个不想去的学校也报一下呜呜，能不能让我有个夏令营体验感！！！！！</li><li>15:50的时候终于把应用层这章的PPT看完了<span class="github-emoji"><span>🤠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f920.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>下午跟cbj学长聊了会儿保研的事情，呜呜感觉自己又重新燃起了自己一定有书读的期望！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</li><li>18:57把数据结构的排序这章看了2/3，好饿QwQ，出去吃昨天吃的牛肚卷！<span class="github-emoji"><span>🤗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f917.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>吃饱回来再学</li><li>牛肚卷好好吃✌，吃完回来把排序这张看完了；昨天画的饼没有实现<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>（虽然是意料之中</li><li>如果明天能够早起的话，画的饼应该就是：上午把王道的排序这章节题做了，如果互联网+的ppt浪费的时间不多的话，复习一下os的存储管理这一章，然后倒着过一遍进程和死锁那一章；</li></ul><h3 id="27th-30th"><a href="#27th-30th" class="headerlink" title="27th-30th"></a>27th-30th</h3><ul><li>头痛摸鱼睡觉不愿打字</li></ul><h2 id="July"><a href="#July" class="headerlink" title="July"></a>July</h2><h3 id="1st"><a href="#1st" class="headerlink" title="1st"></a>1st</h3><ul><li>买的摄像头和支架到了，白天复习了操作系统的文件管理（一半），还剩最后的IO设备管理</li><li>今天晚上把比赛报告改完然后看一遍，再把ppt做了，还要川大的面试ppt</li><li>2、3、4、5、希望3号之前能把os过一遍，4、5号复习数据结构，自我介绍打个草稿QwQ</li><li>等南大的机试完了（寄了）然后开始跑步运动；上旬复习408，下旬复习数学！zyl可真会画大饼呐</li></ul><h3 id="2nd"><a href="#2nd" class="headerlink" title="2nd"></a>2nd</h3><ul><li><p>越是ddl就越是懒，在摆烂的边缘疯狂试探</p></li><li><p>下午把文件管理和设备管理走马观花看完了，晚上回寝室摸鱼嘿嘿嘿</p></li><li><p>夏天的天空真的好好看，不用p图的好看</p><p><img src="https://s2.loli.net/2022/07/03/Aje27ih1sdmZpEG.jpg" alt="SHWY_N_7P9@M87J3UOU_VXK.jpg" style="zoom: 50%;"></p></li><li><p>晚上嘴馋但是不饿，点了鸡丁炒饭，我觉得酸豇豆和酸萝卜真的好吃，感觉一般般，所以吃了一个多小时一半都没吃完</p><p><img src="https://s2.loli.net/2022/07/03/wEos5eXkpqvArFu.jpg" alt="5__WOM1`GU_05CH60Q9_K83.jpg" style="zoom:20%;"></p></li><li><p>听闻某同学 北大，复旦，人大，中山，上交都入营了之后的内心活动：<br>真厉害啊不愧是ta太牛啦<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>呜呜呜不愧是我太废物啦<span class="github-emoji"><span>😿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f63f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>呜呜真就2%的人拿98%的offer<span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>好累尼玛，等川大面试完就躺平准备预推免吧，夏令营不适合我这种垃圾<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>每个高校的夏令营就是硬气，只要985和211的rk1[自抱]希望你们预推免和九推的时候也敢这么硬气<span class="github-emoji"><span>😮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>希望大佬们夏令营赶紧拿完offer早点确定，预推免不要跟我这种垃圾争<span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li></ul><h3 id="3rd"><a href="#3rd" class="headerlink" title="3rd"></a>3rd</h3><ul><li>呜呜呜我以为 今天能够把os过一遍，结果晚上才开始过进程这一章呜呜，明天就开营了淦</li><li>买了一盒周黑鸭的鸭翅，好好吃<span class="github-emoji"><span>💃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f483.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>💃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f483.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>💃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f483.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="4th"><a href="#4th" class="headerlink" title="4th"></a>4th</h3><ul><li>排队等njucs的网络测试浪费我一个下午，哼哼</li></ul><h3 id="5th"><a href="#5th" class="headerlink" title="5th"></a>5th</h3><ul><li><p>吼吼，生活费到账了，点了绝味的鸭翅，真没有周黑鸭的鸭翅好吃，这波属实周黑鸭赢！</p></li><li><p>今天发现网易云的一个新功能，就是用歌房的耳返功能来背书，真不错！！！！！！！</p></li><li><p>早上起来发现寝室没电了，问了六个人校园卡里有没有钱，结果都没有hhhh</p><p><img src="https://s2.loli.net/2022/07/05/wW6aUFudTLZe2mD.png" alt="image.png" style="zoom: 33%;"></p></li><li><p>北航入营了，得知入营的瞬间是开心的，但又发现机试过不了的话不仅无法面试，还不能报之后的预推免，悲，真的是大喜大悲，无尽的悲。这种给你希望又让你意识到最后没有希望的感觉真是太上头迷死人啦<span class="github-emoji"><span>😡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f621.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，夏令营==体验营；明天川大cs我连数据结构都没复习完，项目也没复习呜呜呜。为什么过得会比期末都痛苦啊<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，期末复习好了期末就有希望，夏令营就算复习好了也没希望，并且根本不可能复习不好，一个寄字贯穿zyl的一生</p><p><img src="https://s2.loli.net/2022/07/05/lrbLWzi1T6UQNB7.png" alt="image.png" style="zoom:33%;"></p></li><li><p>原来在学校感受到的夏天的傍晚是，趴在阳台看晚霞，听楼下小树林的蝉鸣，还有足球场上少年们的欢呼</p><p><img src="https://s2.loli.net/2022/07/05/mExB3HPnWcdN5ST.jpg" alt="~BAFHI42FAD1J___2A_D7_Y.jpg" style="zoom: 25%;"></p></li><li><p>后悔，究极后悔，<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>!<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！</p></li><li>呜呜，明天面试我真的复习不完了呜呜哒咩<span class="github-emoji"><span>😖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f616.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，执行一个宵的通，面试完回来进行一个大觉的睡<span class="github-emoji"><span>😪</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="6th"><a href="#6th" class="headerlink" title="6th"></a>6th</h3><ul><li><p>中午scu面试，英语阅读和翻译磕磕绊绊，答题也答得磕磕绊绊，夏令营的第一个面试，算是攒了一丢丢经验，赢！hhh最后也不期待有没有优营了，随缘吧</p></li><li><p>面完试回去洗了个澡，下午去院办找同学盖章，快要下雨前的天气真的又闷又热，爬个坡又出汗了，澡白洗了属于是</p></li><li><p>晚上出去一号门吃了酸汤水饺，还有他们家的素菜拼盘，素菜拼盘好便宜，七块钱那么大一盘；然后去菜市场那边买了几颗水蜜桃，还有白糖罂，呜呜现在好像没看到有妃子笑卖了，在妃子笑面前，白糖罂永远是弟弟，妃子笑就是最好吃的品种！然后称了一点那个🍇，老板说那个品种叫郁金香，不得不说真的难吃啊，真不如夏黑或者巨峰；吃完饭出来突然发现晚霞很好看</p><p><img src="https://s2.loli.net/2022/07/07/QhVYP628ewDBtXn.jpg" alt="8X~HO6__03F0~F2B4JEW_VS.jpg" style="zoom:25%;"></p><p><img src="https://s2.loli.net/2022/07/07/JSEAljVx38WUDiO.jpg" alt="4CMH4PPX_DF_LZES@HO57_X.jpg" style="zoom:20%;"></p></li><li><p>回去的路上去取了个快递，买的可乐到了，然后回院办拿了遗忘在那里的三脚架</p></li><li><p>晚上收拾了一下宿舍，把好多好多不要的书都扔了，这些仿佛不是扔掉的书，而是之前一个个立下的但是从来没有完成过的flag，悲，大学三年立了这么多flag</p><p><img src="https://s2.loli.net/2022/07/07/4TfJ2vNw8YCBMgL.jpg" alt="G5SUA7QFD9__0__7__XKENM.jpg" style="zoom:33%;"></p></li><li><p>收拾东西的时候又把当年军训的那张大合照翻了出来，真的是，每一个人现在都不像从前了，毕竟那估计是大家最丑的时候hhhhh</p><p><img src="https://s2.loli.net/2022/07/07/BHETgdk2RMGm9aW.jpg" alt="_F14C`QC1WTM_CK6P2_AB_B.jpg" style="zoom: 25%;"></p></li></ul><h3 id="8th"><a href="#8th" class="headerlink" title="8th"></a>8th</h3><ul><li>buaa爆零，当初为什么不拿csp抵！！！！后悔，算了，看来<span class="github-emoji"><span>🐁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f401.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f401.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>我注定和buaa无缘，嘤嘤嘤这是命</li><li>下午睡一觉睡到了晚上，醒来好难过好难过好难过，我真的会有书读吗<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>我怎么这么垃圾这么废物呜呜</li><li>晚上好饿，点了炸串，最近真的吃好多</li><li>淦，吃撑了不舒服，呜呜更加难过了<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>scu专硕，虽然说不定最后能递补到学硕，但感觉又不想去了，四舍五入还是夏0营</li></ul><h3 id="9th"><a href="#9th" class="headerlink" title="9th"></a>9th</h3><ul><li>不知道自己干了啥</li></ul><h3 id="10th"><a href="#10th" class="headerlink" title="10th"></a>10th</h3><ul><li><p>上午家里人打电话说了一些蛮悲伤和一些挺无奈的事情，晚上知道了一些让自己破大防的事情，非常非常，心态非常崩的一天，真的好难过好难过，2022年最难过的一天，心态崩到十一点上床一直到一点半都没睡着，然后和好朋友聊天聊到三点多<span class="github-emoji"><span>😴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f634.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。直到11号早上起来写下这个记录还是很难过，呜呜呜呜我好废物啊</p><p><img src="https://s2.loli.net/2022/07/11/3dcVNGeya5Lbf1x.jpg" alt="TW_X_ZIXCY_S_R9_WS53@6O.jpg" style="zoom:25%;"></p><p><img src="https://s2.loli.net/2022/07/11/fl5dmFIxH379oE4.jpg" alt="QR5_`TGOUG0_@DZYW0_S_G7.jpg" style="zoom: 25%;"></p></li></ul><h3 id="11th"><a href="#11th" class="headerlink" title="11th"></a>11th</h3><ul><li>好了但没完全好呜呜</li></ul><h3 id="12th"><a href="#12th" class="headerlink" title="12th"></a>12th</h3><ul><li><p>好烦<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不想学</p><p><img src="https://s2.loli.net/2022/07/13/BegP3Lf1EN4hm5Z.jpg" alt="PL__@_98W8_0T37_7_FSR_X.jpg" style="zoom:33%;"></p></li></ul><h3 id="13th"><a href="#13th" class="headerlink" title="13th"></a>13th</h3><ul><li><p>好烦<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不想学；今天七点半就起床了，buaa软院机试，寄。</p></li><li><p>昨天换的微信犯贱专用新头像，乐；</p><p><img src="https://s2.loli.net/2022/07/13/zWqyZi1maLY3kGr.jpg" alt="O537D20K97~DQRED_PR__VP.jpg" style="zoom: 25%;"></p></li><li><p>我就喜欢这种又带有一点幽默同时又讲得条理清晰的博客</p><p><img src="https://s2.loli.net/2022/07/13/PsLIB9KO8Axtd1X.png" alt="image.png" style="zoom: 43%;"></p></li></ul><h3 id="14th-17th"><a href="#14th-17th" class="headerlink" title="14th-17th"></a>14th-17th</h3><p>难过到一定程度就不想说话</p><h3 id="18th-1"><a href="#18th-1" class="headerlink" title="18th"></a>18th</h3><ul><li><p>呜呜我昨天晚上做梦了，看到了好美好美的彩虹和晚霞，真的好美好美，无法形容的美，醒来还是觉得真tmd太美了</p></li><li><p>我真的觉得 我需要花一个暑假去治愈那致郁的20min，太痛苦了呜呜呜呜<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>每次回想都超级难过和心塞呜呜呜呜，这个暑假最让我难过的事情呜呜呜</p></li><li><p>下午太困了，睡醒起来就傍晚了，还是被热醒的，很可恶。出门的时候看到晚霞挺好看，但是没有昨天梦里见到的晚霞那么好看。还得是梦比较有意思。我每次脑袋放空然后突然想到那致郁的二十分钟，都真的好难过，上大学到现在还没有什么经历带给我的后劲这么大。</p><p><img src="https://s2.loli.net/2022/07/18/tEGrTc67CjB8JwL.jpg" alt="M`3SDQ7_PE2_JW9_A3U_I_O.jpg" style="zoom: 43%;"></p><p>​        前段时间堂哥打电话闲聊家常，他随口问了我一句读书压力大不，我没太在意，半开玩笑的语气说确实有点大。后来我妈突然给我发微信说不要给自己太大压力，可能就是新闻看多了就生怕我像电视新闻里的那样想不开。倒也没有。但我细想从小到大的压力几乎都是自己给的，似乎没有外在的谁给我带来什么压力。至少在读书方面，家里人从来没要求我说一定要上什么什么大学，一定要读到研究生还是读到博士，从来没给我带来任何压力。大概自驱力太强，也大概是觉得，什么都靠不住，除了自己。</p><p>​        记得在刚上大一的时候，一位朋友曾跟我聊过社会原子化的概念，当时只是觉得有意思。现在却越来越觉得很对。原子化的每个个体都是孤独的、埋头于物质享受的，这样的个体普遍存在，并且这些个体之间也没有强有力的联系。大概人的各种想法和见解确实会随经历和时间改变，说不定过几年回看此刻的想法会觉得荒诞和可笑，管它呢，那就过几年再说吧。好像人与人之间的联系根本就是这样，一点也不紧密，大家都是原子化孤立的个体，看似牢不可破的连接只是看似而已。啧，感觉自己好悲观，也不是悲观。</p><p>​        此刻耳机里刚好放到陈奕迅的《最佳损友》这首歌，“来日陌生的是昨日最亲的某某”。我真该以一种发展和质疑的眼光看待每一段人与人之间的关系。基于一种对任何人都不可信和不值得信的态度，甚至逐渐养成了回避型依恋人格。不过我很喜欢这种有效的自我保护机制，挺好的。所以，把任何人考虑进未来规划中都是很愚蠢的想法，对我来说。所以，狠狠地自我批判一下前一段时间愚蠢的自己。</p><p>​        某朋友之前说得不错，我有点不太能认清自己，以及太在意别人的看法。太对了，别人的看法其实跟自己半毛钱关系都没有，“别人的看法”在某种角度上来看，其实就是，自己给自己戴上的一副枷锁。我tmd做什么选择，过得好不好，跟别人的看法有半毛钱关系。或者说，我tmd连自己都过不好为什么还要在意别人怎么想。世界上所有事情概括起来无非是“关我p事”和“关你p事”这两件事了。emm，我最近一定是太难过了呜呜，才会七想八想想这么多，呜呜呜不愧是本废物。回来的路上看到那些夜跑的人，意识到自己好久没有运动了。</p></li><li><p>今天中午一个人在寝室吃了螺蛳粉，晚上出门吃了黄焖鸡米饭，都挺好吃的，但是胃口不大吃了不到一般都没吃完，属实有点浪费了。</p><p><img src="https://s2.loli.net/2022/07/18/YkcCLs8oTRJy3uP.jpg" alt="BE_P_S__EYU_2___06HU3_O.jpg" style="zoom: 33%;"></p></li></ul><p>  <img src="https://s2.loli.net/2022/07/18/TicYUdItLMJQSEb.jpg" alt="N9F4NX@_E_20SS`Q_@JIIV1.jpg" style="zoom: 33%;"></p><h3 id="19th-1"><a href="#19th-1" class="headerlink" title="19th"></a>19th</h3><ul><li><p>为什么夏天可以这么困啊，整个一天都属于很想睡觉的状态；早上根本起不来<span class="github-emoji"><span>❔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2754.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li><li><p>但是没有很摆烂，下午还是学了一丢丢；</p></li><li><p>晚上点了一家之前没有吃过的酸萝卜鱼，真的好好吃，关键是汤真的好好喝！</p><p><img src="https://s2.loli.net/2022/07/19/QmoYhXlSUGCWFps.jpg" alt="KQU2VNSJJV_UH_7NJX90RPG.jpg" style="zoom: 33%;"></p></li></ul><h3 id="20th-1"><a href="#20th-1" class="headerlink" title="20th"></a>20th</h3><ul><li>星汉灿烂真的好好看，吴磊好帅，赵露思好甜呜呜呜 </li><li>晚上去跑了三公里，好久没跑步了有点拉跨了，看来以后应该要抽空多锻炼锻炼捏OwO</li></ul><h3 id="21st-1"><a href="#21st-1" class="headerlink" title="21st"></a>21st</h3><ul><li><p>突然得到seu要联系导师才能入营，得知消息后花半个小时写完套磁信，联系了之前看上的那位导师，不到五分钟的样子导师就回复了我，然后过了一会儿就发腾讯会议号说过两个多小时就面试，真的好高效啊，我赶忙给自我介绍打草稿，然后面试面了整整半个小时，说实话，感觉每一场面试都能发现自己很多问题，一紧张就语速变快不会断句的臭毛病什么时候能该啊呜呜呜，然后最后可以推荐入营了呜呜呜开心。</p></li><li><p>之前本来想着但凡能拿到seu的专硕甚至候补保个底，现在 看这个导师的方向真的越看越喜欢，感觉真的好有意思！！！！！！！！！感觉课题组氛围好像也不错，呜呜呜，如果真的能拿到夏令营的offer，如果这位导师真的愿意收我我就直接有学上就躺平了hhh。然后在绿群遇到和我报同一个导师的hxd，看来大家的想法都是出奇的一致hhhh</p><p><img src="https://s2.loli.net/2022/07/22/RgXori7K4sYpSlu.png" alt="_HBP_Y__O2IRFT5JA61B@CS.png" style="zoom: 25%;"></p></li></ul><h3 id="22nd-1"><a href="#22nd-1" class="headerlink" title="22nd"></a>22nd</h3><ul><li>没啥事，开始复习计网啦！</li></ul><h3 id="23rd-1"><a href="#23rd-1" class="headerlink" title="23rd"></a>23rd</h3><ul><li>突然想到21号晚上那个面试好像有个问题我答错了我焯，师兄问的是最短路径的算法，我突然意识到我当时答成了最小生成树的算法我焯，啊啊啊啊啊啊啊！！！！！难怪当时师兄说话的时候停顿了一下，啊啊啊，师兄该不会觉得我是傻x啊啊啊，师兄一定会觉得我究竟是什么大笨比啊TAT，我焯，好丢脸，真的好丢脸，我替师兄感到尴尬替自己 感到丢脸，当时我居然没有意识到任何问题！！！！！！！！！！！！！！！！！！现在回想起来简直是，加倍的丢脸的感觉，超级加倍<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="24th-1"><a href="#24th-1" class="headerlink" title="24th"></a>24th</h3><ul><li>计网，怎么会，这么多啊</li><li>今天买了个特别可爱的库洛米和美乐蒂的气泡，太可爱了，在列表好友里挨个炫耀了一番，真的是很好看，还会冒星星和 蝴蝶结，太可爱啦！！！！！！！！！！！！！！！！！</li></ul><h3 id="25th-1"><a href="#25th-1" class="headerlink" title="25th"></a>25th</h3><ul><li>计网，好多好多，加油加油</li><li>天才基本法的芝士世界部分拍的好好看，好热血！</li><li>今天吃了两个榴莲千层，真好吃呜呜<span class="github-emoji"><span>🙋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>我好喜欢，晚上洗完头吹干头发然后睡觉，把头发散开铺在枕头上，稍微一侧过头就能闻到洗发水的香味，忍不住把脸埋进头发的，超级助眠<span class="github-emoji"><span>👊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="26th-1"><a href="#26th-1" class="headerlink" title="26th"></a>26th</h3><ul><li>对不起一觉睡到十一点呜呜，对不起我自己（<span class="github-emoji"><span>🐷</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f437.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>外面下雨了，坐在宿舍听着歌，好安心</li><li>下午没太阳了就去取了几个快递，新买的T恤到了，颜色真不错，但是真的显壮啊<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>今天买了四个水蜜桃，花了三十块钱，心疼，不过真的好吃，谁能拒绝水蜜桃呢，软桃yyds</li><li>晚上去二运跑步，跑了三公里，出了好多汗，然后回去洗了个澡，敷了个面膜，追了个剧，好舒服嘿嘿，但是张新成和张子枫在天才基本法里面演的毫无cp感，完全嗑不到，还不如芝士世界那部分的小演员们演得好，草莓世界的部分太垃圾了:happy:</li></ul><h3 id="27th"><a href="#27th" class="headerlink" title="27th"></a>27th</h3><ul><li><p>今天早起啦！七点半就起床啦，然后去吃了个早饭（暑假第一顿早饭<span class="github-emoji"><span>🌞</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f31e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>），然后去操场晒晒太阳，走了两圈，啊已经体会到退休后的幸福生活了<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><img src="https://s2.loli.net/2022/07/27/J45I1lhWubXdRvB.jpg" alt="_早饭.jpg" style="zoom: 33%;"></p></li><li><p>晚上去跑了三公里，好累好累好累，然后去一号门买了两颗水蜜桃<span class="github-emoji"><span>🍑</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f351.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li><li><p>今麦郎的板面真的好好吃，好香！！！！！跑完步回来没忍住又泡了一桶，真的香<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li></ul><h3 id="28th"><a href="#28th" class="headerlink" title="28th"></a>28th</h3><ul><li><p>做梦真的很神奇，梦里我的小学高中大学同学坐在一个教室里上课hhhhhhhhh</p></li><li><p>7cake的榴莲千层真的好好吃啊，吃了两个</p></li><li><p>今天晚上跑了5公里，有点进步</p><p><img src="https://s2.loli.net/2022/07/29/9tOEJbzsTjK8Fkr.jpg" alt="4CZHP2C_I0GH1_A_69TZ~I1.jpg"></p></li></ul><h3 id="29th"><a href="#29th" class="headerlink" title="29th"></a>29th</h3><ul><li><p>今天六点二十就醒了，还是自然醒，然后去操场跑了几圈，一个人承包操场的感觉好爽</p><p><img src="https://s2.loli.net/2022/07/29/Gf2jalHuksnhMdw.jpg" alt="LEQ_@I6WC945N8S0OC_MY4S.jpg" style="zoom: 25%;"></p></li><li><p>然后去明苑吃了个早餐，星苑的早餐种类太少了，还得是明苑才行，面比星苑的好吃，但食堂的面我从来都没有吃完过，对于一个从小到大都不怎么爱吃面条的人来说<span class="github-emoji"><span>✋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/270b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，然后回去看了会儿视频，不到十点钟就困得不行，早起还真毁一天，爬上床睡了个回笼觉，做了个好奇怪的梦，融合平行时空+玄幻+现实题材的梦，还梦到外婆了，她一定是想我了。然后醒来就十一点了，被蚊子咬醒的<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p><img src="https://s2.loli.net/2022/07/29/AaedUq7EwT2npBD.jpg" alt="U_C__5OC_Q4FD90~K9H30X4.jpg" style="zoom: 25%;"></p></li><li><p>今天看网上的面经，这位博主的心态属实 真的值得学习一波！🤣<strong>实在不行读本校</strong>🤣<strong>估计我也过不了</strong>🤣</p><p><img src="https://s2.loli.net/2022/07/29/5HKnRCcelMEDAoa.png" alt="image.png"></p></li></ul><h3 id="30th"><a href="#30th" class="headerlink" title="30th"></a>30th</h3><ul><li>下午练keep，晚上跑步，好累，不过很爽</li></ul><h3 id="31st"><a href="#31st" class="headerlink" title="31st"></a>31st</h3><ul><li><p>去b站搜一个知识点的讲解，感觉讲的不错，一看up主的信息，不得不感慨现在的年轻人真的好牛啊，真的好厉害</p><p><img src="https://s2.loli.net/2022/07/31/SC3WBrnpPMDNQvU.png" alt="image.png" style="zoom:43%;"></p></li><li><p>昨晚做了个梦，梦到我被人背着，长大以来好久都没被人背过呜呜，好喜欢这种感觉</p></li><li><p>下午刷了《快乐再出发》这部综艺，把最新更新的刷完了，真的太好看了！2022年度最好看综艺！不愧豆瓣评分9.5+</p></li></ul><hr><h2 id="August"><a href="#August" class="headerlink" title="August"></a>August</h2><h3 id="1st-1"><a href="#1st-1" class="headerlink" title="1st"></a>1st</h3><ul><li>8月第一天，很好，早起失败，我发现每天早上自然醒后继续睡，做的梦都好奇怪，我梦到我被一个女的跟踪，在下雨天里到处跑，然后搭摩托车，摩托车开进一片雾里，开出雾里之后就没有路了，是很高很高的悬崖，然后我就寄了QAQ</li><li>突然认为，我应该觉得，<strong>我现在有书读，有学上，暂时没有生存压力，是件很幸福的事情</strong>😶好好学习吧！</li><li>没忍住，晚上又点了烧烤，牛肉串和鸭肠好香，很好，看来前几天都白运动了，今天终于把图论这部分搞完了然后稍微背了下计网，希望明天能够早起洗个头，如果明天腿和胳膊不酸了的话晚上就去跑会步。</li><li>怎么说呢，今天还是稍微比较充实🤣，好好学习耶，良好开端！</li></ul><h3 id="2nd-1"><a href="#2nd-1" class="headerlink" title="2nd"></a>2nd</h3><ul><li>晚上去北区跑步，GPS信号好弱啊，而且下午刚下过雨，空气又潮又闷，跑着都感觉缺氧，跑了几圈就去一号门外面买水果了，巨峰葡萄真好吃，巨峰葡萄就是最有葡萄味的葡萄🤗</li></ul><h3 id="3rd-1"><a href="#3rd-1" class="headerlink" title="3rd"></a>3rd</h3><ul><li>嘶，忘了干啥了</li></ul><h3 id="4th-1"><a href="#4th-1" class="headerlink" title="4th"></a>4th</h3><ul><li>统一的茄皇牛肉面的番茄味真的好香，我把汤喝得还剩一点点然后扔垃圾桶里，现在我蹲在椅子上玩手机都能闻到旁边垃圾桶散发出的番茄香。还有今麦郎的板面也很好吃，前段时间一天狂炫两桶。然后又去教超屯了四桶回来。都怪我上个月有段时间天天吃kfc导致有点超预算了呜呜呜呜我是猪</li><li>最近天天点牛约堡的蛋堡那个套餐，附带一小瓶可乐，但我一般不喝就在搁那里屯着越屯越多，再也不打算买可乐了hh😮</li><li>战德臣教授讲的数据库真的讲得好好，b站上最棒的课程了我觉得，今天一天狂炫到了70p，笔记做了十几页;一共250p，还剩将近1/4，有点后悔一开始没拿个厚一点的笔记本啊，我好喜欢这种没有ddl逼我的学习，想学就学，爱咋学咋学🤤</li></ul><h3 id="5th-1"><a href="#5th-1" class="headerlink" title="5th"></a>5th</h3><ul><li>好好学习的一天嗷</li></ul><h3 id="6th-1"><a href="#6th-1" class="headerlink" title="6th"></a>6th</h3><ul><li><p>我靠，今天右脚不知道为什么突然好痛，还有点点肿，前脚掌走路一发力就痛到后来坐着不发力就痛，呜呜呜，痛死啦</p></li><li><p>报告，好看的晚霞！</p><p><img src="https://s2.loli.net/2022/08/13/A5YtR9ZWj7mvTno.jpg" alt="_ORYON1W3QW@A_KK3M7OCVW.jpg" style="zoom:20%;"></p></li></ul><h3 id="7th"><a href="#7th" class="headerlink" title="7th"></a>7th</h3><ul><li>呜呜脚还是好疼，等明天校医院开门呜呜</li></ul><h3 id="8th-1"><a href="#8th-1" class="headerlink" title="8th"></a>8th</h3><ul><li>早上起床忍着脚肿痛去取外卖，刚取回来又突然低血糖，缓了缓稍微好些了之后照镜子一看脸色苍白，甚至心想要是真能这么白就好了（啊我在想什么啊</li><li>每每突然无意间知道曾经的同学的现状都会觉得很惊讶，春节的时候无意间知道一个不太熟的高中同学结婚了，最近又知道人家前几个月娃都生了。前年，也差不多暑假这个时候，我同样得知另一个小学同学也生娃了。每次想到这种，差不多年纪的同龄人，过着很不同的日子就觉得，嗯，很神奇。大概是毕业后再也没见过 ，所以她们在我心中一直都是坐在教室里扎着马尾穿着校服的女同学这种印象。就，怎么说呢，虽然知道每个人的人生轨迹都不同，但，就是觉得很神奇 。我感觉我目前很难脱离学生的身份看自己，我一直都觉得我是个学生，其实本来也是，但是她感觉，就更像一个成年大人。好像同龄但又好像没有同龄人的感觉，但是这个世界本来就千姿百态嘛。嗯，有时候看到她们的人生，我就会想如果多少多少年后我也会不会该结婚生娃，但一想到这些事情我都觉得很奇怪，离我很遥远，二十多岁的人还依然觉得自己是个孩子 ，除了学生和子女这两个社会角色，其他的更有挑战性的角色我至少，现在来说，是我不敢想象的。淦，npy都没有想这么多虚头巴脑的干嘛啊咸吃萝卜淡操心</li></ul><h3 id="9th-1"><a href="#9th-1" class="headerlink" title="9th"></a>9th</h3><ul><li><p>外卖都吃腻了真的好想吃排骨炖藕，但是外卖没看到卖的，食堂也没有，我好想吃家里冬天拿高压锅炖的排骨炖藕，我能嗦好几碗。今年寒假回家第一件事就是让家里人给我做排骨炖藕南京的晚霞还是多好看的，今天去食堂看到领军训服的学弟们了，这么好的天气不军训简直是可惜了</p></li><li><p>我现在真的很怀疑校医院医生的水平，前脚掌突然就莫名其妙地又肿又痛了三天，走路一发力就痛，医生居然说是感染，明明没有外伤口没有破皮而是从骨头里面的疼，我还以为至少得给我先拍个片啊上个药啊啥的，结果医生说不用直接给我开了几瓶青霉素输液很不能理解 </p></li><li><p>会骑电瓶的人真好啊，可惜我连自行车都不敢骑</p></li><li><p>发现了，只要我闲下来就会开始焦虑。比如今天上午去输液，下午去输液，晚上躺着床上刷抖音，突然想到自己今天啥正事儿都没干，该背的没背该学的没学好焦虑啊，玩会儿手机先</p></li><li><p>好像是长这么大，记事以来第一次输液（应该），好奇妙的感觉</p><p><img src="https://s2.loli.net/2022/08/13/DMNlfCbGvU79HAR.jpg" alt="~_5XF_63_SE_~H23_@3_WFI.jpg" style="zoom:15%;"></p></li></ul><h3 id="10th-1"><a href="#10th-1" class="headerlink" title="10th"></a>10th</h3><ul><li><p>请给我快点好起来，天天输液我真的会破产，（这张拍的我看着自己都想摸自己的腿，（好变态😭</p><p><img src="https://s2.loli.net/2022/08/13/pXlmOMs48wWCRFK.jpg" alt="86BD_`_H~M2UZ4_K`6_YR@E.jpg" style="zoom: 15%;"></p></li><li><p>报告，好看的晚霞！</p><p><img src="https://s2.loli.net/2022/08/13/aB7cSY81FNnQqkz.jpg" alt="47@_VVFOP8Q_ZIPM_1TW__U.jpg" style="zoom:25%;"></p></li></ul><h3 id="11th-1"><a href="#11th-1" class="headerlink" title="11th"></a>11th</h3><ul><li><p>好像好了点</p></li><li><p>看啊，一个明明有很多事情可以做，但事情多到一件都不想做的摆烂人居然在叠星星</p><p><img src="https://s2.loli.net/2022/08/13/rnKaDyShFsbEXjO.jpg" alt="62M@E5DSXEL_QP19_@YA_`H.jpg" style="zoom:15%;"></p></li></ul><h3 id="12th-1"><a href="#12th-1" class="headerlink" title="12th"></a>12th</h3><ul><li><p>今天去教超买了两根香蕉，居然才1.9块，好久没买过这么便宜的水果了（虽然不算便宜，但看到付款1.9还是被小小地震惊了一下，这感觉就像在教超买了一半不怎么大的西瓜却花了我整整19块那种卧槽怎么这么贵的同样的震惊的感觉 </p></li><li><p>它真的，居然只给了我一根筷子。第一次吃糖芋苗感觉很一般，不会想点第二次的那种一般。这家的鸭血也不好吃，有股腥味没处理好。想念大一放国庆的时候去上海找虫眼在她学校附近吃的那家正宗成都麻辣鸭血旺，现在想起来还是觉得那是我吃过最好吃的鸭血。</p><p><img src="https://s2.loli.net/2022/08/13/AkjIGnucg57PXTa.jpg" alt="_Y_P0P9KZEO@@NOJVU3VY4K.jpg" style="zoom:15%;"></p></li></ul><h3 id="13th-1"><a href="#13th-1" class="headerlink" title="13th"></a>13th</h3><ul><li>今天突然特别想追以前看的一部剧，今天一整天把它刷完了，四十多集，虽然好狗血但还是好爱。呜呜，为什么不能活在偶像剧里啊，甜死我了</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些碎碎念记录&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://example.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="胡言乱语" scheme="http://example.com/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>【题解】模板题总结</title>
    <link href="http://example.com/2022/06/15/2022-06-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A8%A1%E6%9D%BF%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/06/15/2022-06-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A8%A1%E6%9D%BF%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-15T08:18:55.000Z</published>
    <updated>2022-06-15T07:51:57.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础算法&quot;&gt;&lt;a href=&quot;#基础算法&quot; class=&quot;headerlink&quot; title=&quot;基础算法&quot;&gt;&lt;/a&gt;基础算法&lt;/h1&gt;&lt;h2 id=&quot;快排&quot;&gt;&lt;a href=&quot;#快排&quot; class=&quot;headerlink&quot; title=&quot;快排&quot;&gt;&lt;/a&gt;快排&lt;/h</summary>
      
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【题解】每日一题</title>
    <link href="http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2022-05-19T03:08:20.000Z</published>
    <updated>2022-05-19T13:46:57.219Z</updated>
    
    <content type="html"><![CDATA[<ul><li>AcWing的每日一题（</li></ul><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;AcWing的每日一题（&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【题解】DFS</title>
    <link href="http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91DFS/"/>
    <id>http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91DFS/</id>
    <published>2022-05-19T01:55:34.000Z</published>
    <updated>2022-06-14T09:01:35.498Z</updated>
    
    <content type="html"><![CDATA[<ul><li>所有用到DFS的题，从简单到难</li><li>栈stack、O(h)、不具有最短性</li><li>回溯、剪枝er~</li></ul><span id="more"></span><h1 id="AcW-842-排列数字"><a href="#AcW-842-排列数字" class="headerlink" title="AcW-842. 排列数字 "></a><a href="https://www.acwing.com/problem/content/844/">AcW-842. 排列数字 </a></h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//dfs每一个位置 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(x&gt;n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!st[i]){</span><br><span class="line">st[i]=<span class="literal">true</span>;</span><br><span class="line">a[x]=i;</span><br><span class="line"><span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">st[i]=<span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="AcW-843-n-皇后问题"><a href="#AcW-843-n-皇后问题" class="headerlink" title="AcW-843. n-皇后问题"></a><a href="https://www.acwing.com/problem/content/845/">AcW-843. n-皇后问题</a></h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> row[N],col[N],rd[N],ld[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(x&gt;n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">cout&lt;&lt;g[i][j];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=n;y++){</span><br><span class="line"><span class="keyword">if</span>(!col[y]&amp;&amp;!rd[x+y<span class="number">-1</span>]&amp;&amp;!ld[n+x-y]){</span><br><span class="line">g[x][y]=<span class="string">'Q'</span>;</span><br><span class="line">col[y]=rd[x+y<span class="number">-1</span>]=ld[n+x-y]=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">col[y]=rd[x+y<span class="number">-1</span>]=ld[n+x-y]=<span class="literal">false</span>;</span><br><span class="line">g[x][y]=<span class="string">'.'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) g[i][j]=<span class="string">'.'</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;所有用到DFS的题，从简单到难&lt;/li&gt;
&lt;li&gt;栈stack、O(h)、不具有最短性&lt;/li&gt;
&lt;li&gt;回溯、剪枝er~&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>【SE】软件设计模式例题总结</title>
    <link href="http://example.com/2022/05/16/2022-05-16-%E3%80%90SE%E3%80%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BE%8B%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/05/16/2022-05-16-%E3%80%90SE%E3%80%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BE%8B%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-16T14:45:34.000Z</published>
    <updated>2022-05-17T14:37:58.204Z</updated>
    
    <content type="html"><![CDATA[<p>【考试向】13种设计模式的 PPT+网上+书上 的各种例题搜集汇总</p><span id="more"></span><h1 id="【行为型】策略模式"><a href="#【行为型】策略模式" class="headerlink" title="【行为型】策略模式"></a>【行为型】策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，让算法的变化独立于算法的客户。</p><h2 id="类图与使用场景"><a href="#类图与使用场景" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/LJux3dzrG4YUPWZ.png" alt="image.png"></p><ul><li>想使用对象中 <strong>各种不同的算法变体</strong>，并且希望能在<strong>运行时切换</strong>算法</li><li>有许多 <strong>仅在执行某些行为时略有不同的相似类</strong><ul><li>将不同行为抽取到一个独立类（Strategy）层次结构中，并将原始类组合成一个</li></ul></li><li>算法在Context中的逻辑不重要，可以用策略模式将类的<strong>业务逻辑与算法实现细节隔离</strong>开来</li><li>类中使用了复杂条件运算符<strong>（if-else）</strong>以在同一算法的不同变体中切换</li></ul><hr><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><p>通过某些行为来<strong>参数化</strong>对象：<u>命令模式、策略模式</u></p></li><li><p>装饰者模式更改对象的外表，策略模式更改其本质</p></li><li><p>模板方法 基于<strong>继承</strong>：允许通过扩展子类的部分内容改变部分算法；</p><ul><li><p>策略模式 基于<strong>组合</strong>：通过相应行为提供的<strong>不同策略</strong>来改变对象的行为；</p><ul><li><p>模板方法 在<strong>类</strong>层次上运作，<strong>静态</strong>。</p></li><li><p>策略模式在<strong>对象</strong>层次上运作，允许运行时动态切换</p></li></ul></li></ul></li><li><p><strong>状态模式</strong>可以视为策略模式的<strong>扩展</strong>，都基于<strong>组合</strong>；</p><ul><li><p>都通过将部分工作 <strong>委 托</strong> 给 对象 来改变在不同情景下的行为</p><ul><li><p>策略模式：这些对象（具体策略）之间完全相互独立，不知道其他对象存在;客户知道具体策略</p></li><li><p>状态模式：没有限制具体状态之间的依赖，运行自行改变在不同情景下的状态；客户不知道具体状态</p></li></ul></li></ul></li></ul><hr><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><blockquote><ul><li>找出修改频率较高的算法</li><li>声明该算法所有变体的通用策略接口<strong>Stategy</strong></li><li>将算法逐一抽取到各自的类中，都必须<strong>implements</strong>策略接口</li><li>Context类中<strong>添加一个成员变量保存Stategy的引用</strong>；提供setter方法便于修改它；</li></ul></blockquote><h3 id="例1：导游路线规划"><a href="#例1：导游路线规划" class="headerlink" title="例1：导游路线规划"></a>例1：导游路线规划</h3><p>一个导游程序，有<strong>多种</strong>规划路线的功能，包括规划公路路线、规划步行路线、规划公共交通路线，但是不久之后，可能要规划其他路线，比如骑行路线等等</p><p><img src="https://s2.loli.net/2022/05/16/1oJEcLMkDsneTXi.png" alt="image.png"></p><h3 id="例2：出行方式"><a href="#例2：出行方式" class="headerlink" title="例2：出行方式"></a>例2：出行方式</h3><p>人的出行方式<strong>多种</strong>。假如你需要前往机场。你可以选择乘坐公共汽车、预约出租车或骑自行车。这些就是你的出行策略。</p><p><img src="https://s2.loli.net/2022/05/16/dJzmc9qEQHtFelr.png" alt="image.png"></p><h3 id="例3：电影院售票"><a href="#例3：电影院售票" class="headerlink" title="例3：电影院售票"></a>例3：电影院售票</h3><p>某电影院售票系统为不同类型的用户提供<strong>不同</strong>打折方式（Discount），学生凭学生证享受8折优惠（StudentDiscount），儿童享受减免10元优惠（ChildrenDiscount），VIP用户除享受半价优惠还可积分（VIPDiscount）</p><p><img src="https://s2.loli.net/2022/05/16/iQgyCXP2o1fbDTk.png" alt="image.png"></p><h3 id="例4：税额计算"><a href="#例4：税额计算" class="headerlink" title="例4：税额计算"></a>例4：税额计算</h3><p>一个电子商务系统，其中有一个控制器对象（TaskController），用于处理销售请求，能够确认何时有人在请求销售订单，并将请求转给SalesOrder对象处理。SalesOrder对象的功能包括：允许客户通过GUI填写订单，处理税额的计算，处理订单和打印销售收据。新需求：要处理<strong>多种税额计算</strong>的方法，美国、加拿大、中国三个国家的税收方法</p><p><img src="https://s2.loli.net/2022/05/16/iQlFqTLtM1EJfBu.png" alt="image.png" style="zoom:67%;"></p><h3 id="例5：计算器"><a href="#例5：计算器" class="headerlink" title="例5：计算器"></a>例5：计算器</h3><p>设计一个简单计算器，能实现两个操作数的加减乘除四种运算</p><h3 id="例6：图书打折方式"><a href="#例6：图书打折方式" class="headerlink" title="例6：图书打折方式"></a>例6：图书打折方式</h3><p>一个贩卖各类书籍的电子商务网站的购物车（Shopping Cart）系统计算本次购物金额的方法有<strong>多种</strong>，比如：对所有的教材类图书实行每本1元的折扣；对连环画类图书提供每本7%的促销折扣；对非教材类的计算机图书有3%的折扣；对其余的图书没有折扣</p><hr><h3 id="例7：会员打折方式"><a href="#例7：会员打折方式" class="headerlink" title="例7：会员打折方式"></a>例7：会员打折方式</h3><p>现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。</p><p><img src="https://s2.loli.net/2022/05/16/z9YMfdCWLu1qPbt.png" alt="image.png"></p><h3 id="例8：各种飞机"><a href="#例8：各种飞机" class="headerlink" title="例8：各种飞机"></a>例8：各种飞机</h3><p>某软件公司现欲开发一款飞机模拟系统,该系统主要模拟<strong>不同种类</strong>飞机的飞行特征与起飞特征。还能<strong>支持模拟更多种类</strong>的飞机。</p><p><img src="https://s2.loli.net/2022/05/16/Xfmbu75wz34o2ih.png" alt="image.png" style="zoom:67%;"></p><p>对比书上的例子（照喵画虎）</p><p><img src="https://s2.loli.net/2022/05/16/316ragLTyltDMKz.png" alt="image.png" style="zoom:67%;"></p><h3 id="例9：图片滤镜"><a href="#例9：图片滤镜" class="headerlink" title="例9：图片滤镜"></a>例9：图片滤镜</h3><p>为了实现一些特殊的显示效果，某公司欲开发一款手机数码照片处理软件，在该软件中为照片(Photograph)提供了<strong>多种</strong>滤镜(Filter)效果，例如黑白滤镜(BlackWhiteFilter)、单色滤镜(MonochromaticFilter)、怀旧滤镜(NostalgicFilter)等，不同的滤镜通过不同的算法对照片进行美化，该软件可以<strong>灵活地增加一些新的</strong>滤镜效果。</p><h3 id="例10：加密"><a href="#例10：加密" class="headerlink" title="例10：加密"></a>例10：加密</h3><p>某系统需要对重要数据（如用户密码）进行加密，并提供了<strong>几种</strong>加密方案（如凯撒加密、DES加密等），对该加密模块进行设计，使得用户可以<strong>动态选择</strong>加密方式</p><hr><h3 id="例11：排序策略问题"><a href="#例11：排序策略问题" class="headerlink" title="例11：排序策略问题"></a>例11：排序策略问题</h3><p>某系统提供了一个用于对数组数据进行操作的类，该类封装了对数组的常见操作，如查找数组元素、对数组元素进行排序等。现以排序操作为例，使用策略模式设计该数组操作类，使得客户端可以动态地更换排序算法，可以根据需要选择冒泡排序或选择排序或插入排序，也能够灵活地增加新的排序算法。</p><h1 id="【行为型】观察者模式"><a href="#【行为型】观察者模式" class="headerlink" title="【行为型】观察者模式"></a>【行为型】观察者模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>定义了对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖者都会收到通知并且自动更新</p><h2 id="类图与使用场景-1"><a href="#类图与使用场景-1" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/YpCHBNUnFP7MOzc.png" alt="image.png" style="zoom:67%;"></p><ul><li>当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的</li><li>当应用中的一些对象必须观察其他对象时</li></ul><h2 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><p>关键词：<code>通知</code>, <code>出版&amp;订阅</code>，<code>一个对象变化，通知其他多个对象它变化了</code></p><blockquote><p>拥有一些值得关注的状态的对象通常被称为目标，由于它要<strong>将自身的状态改变通知给其他对象</strong>，我们也将其称为发布者（publisher，也即subject）。所有<strong>希望关注发布者状态变化</strong>的其他对象被称为订阅者（subscribers，也即observer）。为发布者类添加订阅机制，让每个对象都能订阅或取消订阅发布者事件流。该机制包括</p><p> 1）一个用于存储订阅者对象<strong>引用的列表成员变量</strong>；</p><p>2）几个用于<strong>添加或删除该列表中订阅者</strong>的公有方法。</p></blockquote><h3 id="例1：股票价格通知"><a href="#例1：股票价格通知" class="headerlink" title="例1：股票价格通知"></a>例1：股票价格通知</h3><p>当股票购买者所购买的<strong>某只股票</strong>价格变化幅度达到5%时，系统<strong>自动发送通知</strong>给购买该股票的股民</p><p><img src="https://s2.loli.net/2022/05/16/ZnXTjCpd1kWJeSx.png" alt="image.png"></p><h3 id="例2：地震监测报警"><a href="#例2：地震监测报警" class="headerlink" title="例2：地震监测报警"></a>例2：地震监测报警</h3><p>现需要开发一个地震监测报警系统，如果接收到相关<strong>监测机构</strong>发来的<strong>预警数据</strong>，系统将作出反应，将信号<strong>传递</strong>给响应设备，如广播自动播放报警信息、逃生指示灯亮起、安全门锁打开、电梯自动停用等，每一种响应设备的行为由专门的程序来控制。支持将来引入新类型的响应设备。</p><h3 id="例3：电子商务系统"><a href="#例3：电子商务系统" class="headerlink" title="例3：电子商务系统"></a>例3：电子商务系统</h3><p>一个电子商务系统，当一个新的消费用户加入系统，希望做以下两个操作：向消费者发送一封欢迎邮件；向邮局查证消费者地址</p><p><img src="https://s2.loli.net/2022/05/16/wTMrSJcxa5ZnsgC.png" alt="image.png" style="zoom:50%;"></p><h3 id="例4：机房监控系统"><a href="#例4：机房监控系统" class="headerlink" title="例4：机房监控系统"></a>例4：机房监控系统</h3><p>如果机房达到一定指定温度，<strong>传感器</strong>将作出反应，将<strong>信号传递</strong>给响应设备，如警示灯将闪烁，报警器将发出警报，安全逃生门将自动开启、隔热门将自动关闭，每一响应设备的行为由专门的程序来控制，支持将来引入新类型的响应设备。</p><p><img src="https://s2.loli.net/2022/05/16/XWw2xoZtavPzFK4.png" alt="image.png"></p><h3 id="例5：多人联机对战"><a href="#例5：多人联机对战" class="headerlink" title="例5：多人联机对战"></a>例5：多人联机对战</h3><p>某在线游戏支持多人联机对战，每个玩家都可以加入某一战队组成联盟，当战队中某一成员受到敌人攻击时将给所有盟友<strong>发送通知</strong>，盟友收到通知后将作出响应</p><p><img src="https://s2.loli.net/2022/05/16/Gb8BOLEWyvfXja6.png" alt="image.png" style="zoom: 50%;"></p><hr><h1 id="【行为型】状态模式"><a href="#【行为型】状态模式" class="headerlink" title="【行为型】状态模式"></a>【行为型】状态模式</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类</p><h2 id="类图与使用场景-2"><a href="#类图与使用场景-2" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/3174QBdu5TswFfe.png" alt="image.png" style="zoom:67%;"></p><ul><li>对象的行为依赖于它的状态（如某些属性值），<strong>状态的改变将导致行为的变化</strong></li><li>在代码中包含大量与<strong>对象状态有关的条件语句</strong>，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。</li></ul><h2 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><p>在状态模式中， 特定状态（可以）知道其他所有状态的存在，且能触发从一个状态到另一个状态的转换；<strong>行为对客户来说是透明的</strong>，客户不知道状态对象的存在</p><ul><li><p>策略则几乎完全不知道其他策略的存在。</p></li><li><p>状态可被视为策略的扩展。两者都基于组合机制：它们都通过将部分工作<strong>委派</strong>给“帮手”对象来改变其在不同情景下的行为。策略使得这些对象相互之间完全独立，它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖，且允许它们自行改变在不同情景下的状态。</p></li></ul></li></ul><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h2><p>关键词：<code>状态</code>，<code>动作使得状态转换</code></p><ul><li>为对象的<strong>每</strong>一个 <strong>所有可能状态</strong> 新建一个类(ConcreteState)，将所有该状态的对应行为抽取到这些类中</li><li>Context类持有State/ConcreteState成员变量</li></ul><h3 id="例1：信用卡账户"><a href="#例1：信用卡账户" class="headerlink" title="例1：信用卡账户"></a>例1：信用卡账户</h3><p> 信用卡业务系统，账户(Account)是核心类之一，<strong>账户</strong>存在三种状态，且在不同状态下账户存在不同的行为，具体说明如下：</p><ul><li><p>(1) 如果账户中余额大于等于0，则账户的状态为<strong>正常状态(</strong>Normal State)，此时用户既可以向该账户存款也可以从该账户取款；</p></li><li><p>(2) 如果账户中余额小于0，并且大于-2000，则账户的状态为<strong>透支状态</strong>(Overdraft State)，此时用户既可以向该账户存款也可以从该账户取款，但需要按天计算利息；</p></li><li><p>(3) 如果账户中余额等于-2000，那么账户的状态为<strong>受限状态</strong>(Restricted State)，此时用户只能向该账户存款，不能再从中取款，同时也将按天计算利息；       </p></li><li><p>(4) 根据余额的不同，以上三种状态<strong>可发生相互转换</strong>。</p><ul><li>分析：账户==Context，三种状态 == ConcreteState；封装进状态的动作：存款、取款、利息计算、根据余额进行状态转换</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/16/w1Pe5C3qoJpZGX6.png" alt="image.png"></p><h3 id="例2：开关"><a href="#例2：开关" class="headerlink" title="例2：开关"></a>例2：开关</h3><p>如果某系统要求两个开关对象（Context）要么都处于开的状态，要么都处于关的状态，在使用时它们的<strong>状态必须保持一致</strong>，开关可以由开转换到关，也可以由关转换到开</p><ul><li><p>分析：多个环境对象可能需要共享同一个状态，如果希望在系统中实现<strong>多个环境对象共享一个或多个状态对象</strong>，那么需要将这些<strong>状态对象</strong>定义为环境类的<strong>静态成员对象</strong>。</p></li><li><p>Switch里的三个state都是静态成员变量（所以应该还有下划线表示才对</p></li></ul><p><img src="https://s2.loli.net/2022/05/16/5qF7zvOZBQDwVGK.png" alt="image.png" style="zoom:80%;"></p><h3 id="例3：屏幕放大"><a href="#例3：屏幕放大" class="headerlink" title="例3：屏幕放大"></a>例3：屏幕放大</h3><p>一个屏幕放大镜工具： 用户单击“放大镜”按钮之后屏幕将放大一倍，再点击一次“放大镜”按钮屏幕再放大一倍，第三次点击该按钮后屏幕将还原到默认大小</p><ul><li>定义三个<strong>屏幕状态类</strong>NormalState、LargerState和LargestState来对应屏幕的三种状态，分别是正常状态、二倍放大状态和四倍放大状态，屏幕类Screen充当Context类</li></ul><p><img src="https://s2.loli.net/2022/05/16/xJjpWI32DAU8ZRb.png" alt="image.png"></p><h3 id="例4：纸牌游戏"><a href="#例4：纸牌游戏" class="headerlink" title="例4：纸牌游戏"></a>例4：纸牌游戏</h3><p>某纸牌游戏中，<strong>人物角色</strong>具有<strong>入门级</strong>（Primary），<strong>熟练级</strong>(Secondary)，<strong>高手级</strong>(Professional)和<strong>骨灰级</strong>(Final)四种等级，<strong>角色的等级与积分相对应</strong>，游戏胜利将增加积分，失败则扣除积分，入门级具有最基本的游戏功能play()，熟练级增加了游戏胜利积分加倍功能doubleScore（），高手级在熟练级基础上再增加换牌功能changeCards()，骨灰级在高手级基础上再增加偷看他人的牌的功能peekCards()</p><ul><li>第一眼儿看差点以为是策略模式；但是要注意“角色的等级与积分相对应”，说明等级会随着积分的改变而发生改变，游戏又对积分有各种操作；所以更应该是状态模式</li></ul><p><img src="https://s2.loli.net/2022/05/16/ICLzGuw6t8BZMKo.png" alt="image.png"></p><h3 id="例5：线程状态"><a href="#例5：线程状态" class="headerlink" title="例5：线程状态"></a>例5：线程状态</h3><p>多线程存在 5 种状态，分别为新建状态、就绪状态、运行状态、阻塞状态和死亡状态，各个状态当遇到相关方法调用或事件触发时会转换到其他状态</p><p><img src="https://s2.loli.net/2022/05/16/cKTs741XiDV5rnE.png" alt="image.png" style="zoom:67%;"></p><h3 id="例6：传输门"><a href="#例6：传输门" class="headerlink" title="例6：传输门"></a>例6：传输门</h3><p>传输门具有Open（打开）、Closed（关闭）、Opening（正在打开）、StayOpen（保持打开）、Closing（正在关闭）五种状态。触发状态的转换事件有click、complete和timeout三种。</p><hr><h3 id="例7：抽奖活动"><a href="#例7：抽奖活动" class="headerlink" title="例7：抽奖活动"></a>例7：抽奖活动</h3><p>编写程序完成APP抽奖活动，具体要求如下：</p><p>（1）加入每参加一次这个活动要扣除用户50积分，中奖概率是10%</p><p>（2）奖品数量固定，抽完就不能抽奖</p><p>（3）活动有4个状态：可以抽奖、不能抽奖、发放奖品和奖品领完</p><hr><h1 id="【行为型】模板方法模式"><a href="#【行为型】模板方法模式" class="headerlink" title="【行为型】模板方法模式"></a>【行为型】模板方法模式</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>在一个方法中定义了一个<strong>算法的骨架</strong>，将一些<strong>步骤延迟到子类</strong>中。这样子类在<strong>不改变算法结构</strong>的情况下，可以<strong>重新定义</strong>算法中的某些步骤</p><h2 id="类图与使用场景-3"><a href="#类图与使用场景-3" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/nKLYQsofcxud6NR.png" alt="image.png" style="zoom:50%;"></p><ul><li>只希望客户端扩展某个特定算法步骤，而不是整个算法或其结构时</li><li>当多个类的算法除一些细微不同之外几乎完全一样时</li></ul><blockquote><ul><li>将算法分解为一系列步骤</li><li>将这些步骤改写为方法<ul><li>步骤可以是 抽象 的，也可以有一些默认的实现。</li></ul></li><li>在“模板方法”中依次调用这些方法。</li><li>为了能够使用算法，客户端需要自行提供子类并实现所有的抽象步骤。如有必要还需重写一些步骤（但这一步中不包括模板方法自身）。</li></ul></blockquote><h2 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><p><u>工厂方法</u> 是 模板方法的一种<strong>特殊形式</strong>。工厂方法可以作为一个大型模板方法的一个步骤</p></li><li><p>模板方法基于<strong>继承</strong>机制：它允许你通过<strong>扩展子类中的部分内容</strong>来改变部分算法。</p><ul><li><p>策略基于<strong>组合</strong>机制：你可以通过对<strong>相应行为提供不同的策略</strong>来改变对象的部分行为。</p><ul><li><p>模板方法在类层次上运作，因此它是静态的。</p></li><li><p>策略在对象层次上运作，因此允许在运行时切换行为。</p></li></ul></li></ul></li></ul><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h2><p>关键词：<code>一系列步骤</code>，<code>流程</code>，<code>不同类只有某些步骤相似但不同</code></p><blockquote><ul><li>分析目标算法，确定能否将其<strong>分解为多个步骤</strong>。从所有子类的角度出发，考虑哪些步骤能够通用，哪些步骤各不相同</li><li>创建抽象基类并声明<strong>一个模板方法</strong>和代表算法步骤的<strong>一系列抽象方法</strong>。 在模板方法中根据算法结构依次调用相应步骤。可用 <code>final</code> 修饰模板方法以防止子类对其进行重写。</li><li>可考虑在算法的关键步骤之间添加钩子</li><li>为每个算法变体新建一个具体子类，它必须<strong>实现所有的抽象步骤</strong>，也可以重写部分可选步骤</li></ul></blockquote><h3 id="例1：数据库操作"><a href="#例1：数据库操作" class="headerlink" title="例1：数据库操作"></a>例1：数据库操作</h3><p>对数据库的操作一般包括连接、打开、使用、关闭等<strong>步骤</strong>，在数据库操作模板类中我们定义了connDB（）,openDB（）,useDB()，closeDB（）四个方法分别对应这四个步骤，对于<strong>不同类型</strong>的数据库（如SQLserver和Oracle），其余操作步骤都一致，<strong>只是</strong>连接数据库connDB（）方法<strong>有所区别</strong></p><ul><li>分析：将四个步骤按顺序封装到一个方法里，那个在不同类中 <strong>不同的步骤</strong> 在方法外<strong>声明为抽象方法</strong></li></ul><p><img src="https://s2.loli.net/2022/05/16/zOc76gdTuGSnmL8.png" alt="image.png" style="zoom: 50%;"></p><h3 id="例2：利息计算"><a href="#例2：利息计算" class="headerlink" title="例2：利息计算"></a>例2：利息计算</h3><p>给出一个利息计算流程，但流程中<strong>有个步骤</strong>  <strong>根据用户类型</strong> 不同计算利息的方式<strong>不同</strong></p><p><img src="https://s2.loli.net/2022/05/16/mXEFgj71iGTdkHl.png" alt="image.png" style="zoom:50%;"></p><h3 id="例3：数据图表"><a href="#例3：数据图表" class="headerlink" title="例3：数据图表"></a>例3：数据图表</h3><p>一个数据图表显示功能包括三个<strong>步骤</strong>，（从数据源获取数据，数据转换为XML，以某种图表方式显示XML格式数据）支持<strong>多种数据源和多种图表显示方式</strong>， <strong>如果</strong>已经是XML<strong>则</strong>无需进行数据转换（说明有个钩子方法）</p><ul><li>分析：钩子方法能够作为<strong>条件</strong> <strong>控制算法的流程</strong></li></ul><p><img src="https://s2.loli.net/2022/05/16/cDzb8Xf9PrRNMJn.png" alt="image.png" style="zoom:67%;"></p><h3 id="例4：豆浆制作"><a href="#例4：豆浆制作" class="headerlink" title="例4：豆浆制作"></a>例4：豆浆制作</h3><p>编写制作豆浆的程序，说明如下:</p><ul><li>制作豆浆的流程 选材—&gt;<strong>添加配料</strong>—&gt;浸泡—&gt;放到豆浆机打碎</li><li>通过<strong>添加不同的配料</strong>，可以制作出<strong>不同口味的豆浆</strong></li><li>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆<strong>都是一样</strong>的</li></ul><p><img src="https://s2.loli.net/2022/05/16/zdXoCHWbsAgv6a7.png" alt="image.png" style="zoom:50%;"></p><hr><h1 id="【行为型】命令模式"><a href="#【行为型】命令模式" class="headerlink" title="【行为型】命令模式"></a>【行为型】命令模式</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>将<strong>请求封装成对象</strong>，以便使用不同的请求、队列或日志来<strong>参数化其他对象</strong>。也支持<strong>可撤销</strong>的操作</p><h2 id="类图与使用场景-4"><a href="#类图与使用场景-4" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/gAPXm8ZUFoGqKzv.png" alt="image.png" style="zoom: 50%;"></p><ul><li>系统需要<strong>将请求调用者和请求接收者</strong>解耦，使得<strong>调用者和接收者不直接交互</strong>。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。</li><li>要支持命令的<strong>撤销(Undo)操作和恢复(Redo)操作</strong></li><li>系统需要将<strong>一组操作组合</strong>在一起形成宏命令。</li></ul><p><img src="https://s2.loli.net/2022/05/16/rBET5sk4ecMU2Rd.png" alt="image.png" style="zoom:50%;"></p><h2 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><h2 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：遥控器功能键"><a href="#例1：遥控器功能键" class="headerlink" title="例1：遥控器功能键"></a>例1：遥控器功能键</h3><p>某遥控器提供了一些按键，使用户可以自定义按键功能，如功能键FunctionButton可用于调出菜单（ShowMenu），也可用于打开帮助界面（DisplayHelp），也可用于打开机顶盒（OpenSTB）。用户可以通过修改配置文件来改变按键的用途，使<strong>按键类与功能类之间解耦</strong>，<strong>相同的按键可以对应不同的功能.</strong></p><p><img src="https://s2.loli.net/2022/05/16/7tbFPhZBWYqEozA.png" alt="image.png"></p><h3 id="例2：公告板"><a href="#例2：公告板" class="headerlink" title="例2：公告板"></a>例2：公告板</h3><p>一个基于windows平台的公告板系统，该系统提供一个主菜单（Menu），在主菜单中包含了一些菜单项(MenuItem)，可以通过Menu类的addMenuItem()方法添加菜单项，菜单项的主要方法是click()，每一个菜单项包含一个抽象命令类，具体命令类包含OpenCommand(打开命令）、CreateCommand(创建命令）和EditeCommand(编辑命令）等，命令类内置有一个excute()方法，用于调用公告板系统界面类(BoardScrean）的open（）、create()、edite（）等方法，要使<strong>MenuItem类与BoardScreen类的耦合度降低</strong></p><p><img src="https://s2.loli.net/2022/05/16/dU95ONAKxWSkCz8.png" alt="image.png"></p><h3 id="例3：餐馆点菜"><a href="#例3：餐馆点菜" class="headerlink" title="例3：餐馆点菜"></a>例3：餐馆点菜</h3><p>场景：餐馆点菜。角色：1.接收者：厨师，是命令的真正执行者。本例分为两种：做热菜的厨师和做凉菜的厨师 2.服务员：负责命令和接收者的组装，并持有命令对象（菜单），最后启动命令的也是服务员 3.命令对象：A、每一道菜是个命令对象；B、菜单（组合对象，由多道菜组成）</p><p><img src="https://s2.loli.net/2022/05/16/4NrnIeHvCx1gmPj.png" alt="image.png"></p><h3 id="例4：桌面版应用程序"><a href="#例4：桌面版应用程序" class="headerlink" title="例4：桌面版应用程序"></a>例4：桌面版应用程序</h3><p>一提供了一系列自定义功能键，用户可以通过这些功能键来实现一些快捷操作。发现不同的用户可能会有不同的使用习惯，例如有的人喜欢将第一个功能键设置为“打开帮助文档”，有的人则喜欢将该功能键设置为“最小化至托盘”，设计使用户能够<strong>灵活地进行功能键的设置</strong></p><p><img src="https://s2.loli.net/2022/05/16/XNI5ezT2obpnS4R.png" alt="image.png"></p><h3 id="例5：计算器-1"><a href="#例5：计算器-1" class="headerlink" title="例5：计算器"></a>例5：计算器</h3><p>简易计算器，可以实现简单的数学运算，还可以对运算<strong>实施撤销操作</strong></p><p><img src="https://s2.loli.net/2022/05/16/um2epAzPC6HlLNo.png" alt="image.png" style="zoom:67%;"></p><h3 id="例6：智能生活"><a href="#例6：智能生活" class="headerlink" title="例6：智能生活"></a>例6：智能生活</h3><p>（1）买一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装app就可以控制这些家电工作</p><p>（2）这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个app，分别控制，<strong>只希望有一个app就可以控制全部智能家电</strong>。</p><ul><li><p>要实现一个app控制所有智能家电的需求，则每个智能家电厂家都要提供一个<strong>统一的接口</strong>给app调用，这时 就可以考虑命令模式</p></li><li><p>命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来</p></li><li><p>动作的请求者是手机app，动作的执行者是每个厂商的一个家电产品</p></li></ul><hr><h1 id="【行为型】迭代器模式"><a href="#【行为型】迭代器模式" class="headerlink" title="【行为型】迭代器模式"></a>【行为型】迭代器模式</h1><h1 id="【创建型】工厂方法模式"><a href="#【创建型】工厂方法模式" class="headerlink" title="【创建型】工厂方法模式"></a>【创建型】工厂方法模式</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p>定义了一个<strong>创建对象的接口</strong>，但由<strong>子类决定要实例化的类</strong>是哪一个，让类把实例化<strong>推迟到子类</strong></p><h2 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：图片读取器"><a href="#例1：图片读取器" class="headerlink" title="例1：图片读取器"></a>例1：图片读取器</h3><p>现需要设计一个程序来读取多种不同类型的图片格式，针对每一种图片格式都设计一个图片读取器(ImageReader)，如GIF图片读取器(GifReader)用于读取GIF格式的图片、JPG图片读取器(JpgReader)用于读取JPG格式的图片。图片读取器对象通过图片读取器工厂ImageReaderFactory来创建，ImageReaderFactory是一个抽象类，用于定义创建图片读取器的工厂方法，其子类GifReaderFactory和JpgReaderFactory用于创建具体的图片读取器对象</p><p><img src="https://s2.loli.net/2022/05/17/6JDZLTqxybsGCzS.png" alt="image.png"></p><h3 id="例2：日志记录器"><a href="#例2：日志记录器" class="headerlink" title="例2：日志记录器"></a>例2：日志记录器</h3><p>某日志记录器 要求支持多种日志记录方式，如文件日志记录（FileLog）、数据库日志记录（DatabaseLog）等；用户可根据需要动态地选择日志记录方式 ( 我甚至觉得这个题用策略模式也不是不可以？)</p><p><img src="https://s2.loli.net/2022/05/17/rxynbwU84HaG9JQ.png" alt="image.png" style="zoom:67%;"></p><h3 id="例3：电视机工厂"><a href="#例3：电视机工厂" class="headerlink" title="例3：电视机工厂"></a>例3：电视机工厂</h3><p>有一电视机工厂，生产各种电视机。现要将原有的工厂进行分割，为每种品牌的电视机提供一个子工厂，海尔工厂专门负责生产海尔电视机，海信工厂专门负责生产海信电视机；如果需要生产其他某个品牌电视机，只需要对应增加一个新的该品牌电视机工厂即可，而原有的工厂无须做任何修改，使得整个系统具有更加的灵活性和可扩展性</p><h1 id="【创建型】抽象工厂模式"><a href="#【创建型】抽象工厂模式" class="headerlink" title="【创建型】抽象工厂模式"></a>【创建型】抽象工厂模式</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>提供一个接口，用来<strong>创建</strong> 相关或依赖对象的<strong>家族</strong>，而不需要明确指定具体类</p><h2 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：数据库"><a href="#例1：数据库" class="headerlink" title="例1：数据库"></a>例1：数据库</h3><p>某系统为了改进数据库操作的性能，自定义数据库连接对象Connection和语句对象Statement，可针对不同类型的数据库提供不同的连接对象和语句对象，如提供Oracle或MySQL专用<strong>连接类和语句类</strong>，而且用户可以通过配置文件等方式根据实际需要<strong>动态地选择</strong>系统数据库</p><p><img src="https://s2.loli.net/2022/05/17/XuAk4C2ZlOTUMGV.png" alt="image.png"></p><h3 id="例2：操作系统"><a href="#例2：操作系统" class="headerlink" title="例2：操作系统"></a>例2：操作系统</h3><p>创建在不同操作系统的视窗环境下都能够运行的系统两种操作系统：windows和unix</p><ul><li><p>windows操作系统下，使用具有windows风格的视窗构件（这里设为windowsButton对象和WindowsText对象）</p></li><li><p>Unix操作系统下，使用具有Unix风格的视窗构件UnixButton对象和UnixText对象</p></li><li><p>如何进行设计，使得 1，当需要<strong>增加对新操作系统的支持</strong>时（如系统还需要支持Solaris），现有代码不必修改（符合“开-闭原则”）    2，在系统的设计中约束用户使用的各种构件一定属于同一操作系统（不会出现将WindowsButton和UnixText一起使用这种情况）</p></li></ul><p><img src="https://s2.loli.net/2022/05/17/9ctW5GiOwuYAkIT.png" alt="image.png"></p><h3 id="例3：动物游戏"><a href="#例3：动物游戏" class="headerlink" title="例3：动物游戏"></a>例3：动物游戏</h3><p>在一个电脑游戏中，存在着美洲和非洲两块大陆。美洲大陆上有食肉动物(美洲虎)和食草动物(美洲羊) ;非洲大陆上有食肉动物(非洲虎)和食草动物(非洲羊)。电脑游戏的应用逻辑中需要实现这样的场景</p><ul><li>根据当前主人公角色所处大陆(美洲或非洲)来初始化当前游戏中的食肉动物和食肉动物</li><li>食肉动物开始追捕食草动物</li></ul><p><img src="https://s2.loli.net/2022/05/17/8CbVPz17KaAhOBk.png" alt="image.png" style="zoom:67%;"></p><h3 id="例4：驱动"><a href="#例4：驱动" class="headerlink" title="例4：驱动"></a>例4：驱动</h3><p>设计一个系统来显示和打印数据库中读出的图形，并满足：根据当前所使用硬件的配置来选择驱动——速度快的机器选择高分辨率的显示、打印驱动，速度慢的选择低分辨率的驱动：</p><p>驱动类型     在低配置硬件情况下    在高配置硬件情况下</p><p>显示驱动         LRDD                              HRDD</p><p>打印驱动         LPPD                               HPPD</p><p><img src="https://s2.loli.net/2022/05/17/vQslOhJATDp3ura.png" alt="image.png" style="zoom:67%;"></p><h1 id="【创建型】单件模式"><a href="#【创建型】单件模式" class="headerlink" title="【创建型】单件模式"></a>【创建型】单件模式</h1><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>确保类只有一个实例，并提供一个全局的访问点</p><h2 id="多线程处理"><a href="#多线程处理" class="headerlink" title="多线程处理"></a>多线程处理</h2><h3 id="双重检查加锁的理解"><a href="#双重检查加锁的理解" class="headerlink" title="双重检查加锁的理解"></a>双重检查加锁的理解</h3><p>假如在某一瞬间线程A和线程B都在调用<code>getInstance()</code>方法，此时instance对象为null值，均能通过<code>instance == null</code>的判断(<strong>第一重检查</strong>）。由于实现了<strong>synchronized加锁机制</strong>，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定代码。但当A执行完毕时，<strong>线程B并不知道实例已经创建</strong>，如果没有第二重检查的话，将继续创建新的实例，导致产生多个单例对象，违背单例模式的设计思想，因此需要进行进一步改进，在 synchronized中<strong>再进行一次(instance == null)判断</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span>{</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton instance = null;</span><br><span class="line">    <span class="comment">//被volatile修饰的成员变量可以确保多个线程都能够正确处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == null){<span class="comment">//第一重检查</span></span><br><span class="line">            <span class="built_in">synchronized</span>(LazySingleton.class){ <span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span>(instance == null){ <span class="comment">//第二重检查</span></span><br><span class="line">                     instance = <span class="keyword">new</span> <span class="built_in">LazySingleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><ul><li><p>急切实例化</p><p><img src="https://s2.loli.net/2022/05/17/iW3zKQELYD4paXj.png" alt="image.png" style="zoom: 50%;"></p></li><li><p>延迟实例化</p><p><img src="https://s2.loli.net/2022/05/17/klizjRVSZ2Jq3IN.png" alt="image.png" style="zoom:50%;"></p></li><li><p>急切实例化和延迟实例化的比较</p><ul><li><p>急切：在类被加载时就将自己实例化，它的优点在于<strong>无须考虑多线程访问问题，可以确保实例的唯一性</strong>；从<strong>调用速度和反应时间</strong>角度来讲，由于单例对象一开始就得以创建，因此要<strong>优于延迟</strong>。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该 对象就需要创建，因此从<strong>资源利用效率</strong>角度来讲，不及延迟，而且在系统加载时由于需要创建单例对象，<strong>加载时间可能会比较长</strong>。 </p></li><li><p>延迟：在第一次使用时创建，<strong>无须一直占用系统资源</strong>，实现了延迟加载，但是必须处 理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源 初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过<strong>双重检查锁定</strong>等机制进行控制，这将<strong>导致系统性能受到一定影响</strong>。 </p></li></ul></li></ul><h2 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：负载均衡器"><a href="#例1：负载均衡器" class="headerlink" title="例1：负载均衡器"></a>例1：负载均衡器</h3><p>Sunny软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台 负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责 服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何<strong>确保负载均衡器的唯一性</strong>是该软件成功的关键</p><p><img src="https://s2.loli.net/2022/05/17/2tcRkujKbyfEiZH.png" alt="image.png" style="zoom:50%;"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancer</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LoadBalancer instance;</span><br><span class="line">    <span class="keyword">private</span> List serverList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LoadBalancer</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoadBalancer <span class="title">getLoadBalancer</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line">             instance = <span class="keyword">new</span> LoadBalancer();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="例2：文档窗口"><a href="#例2：文档窗口" class="headerlink" title="例2：文档窗口"></a>例2：文档窗口</h3><p>设计一个多文档窗口（注：在Java AWT/Swing开发中可使用JDesktopPane和JInternalFrame来实现），要求在主窗体中某个<strong>内部子窗体只能实例化一</strong>次，即只能弹出一个相同的子窗体</p><ul><li>单件模式用在子窗体上</li></ul><p><img src="https://s2.loli.net/2022/05/17/xbWtmLo9VT3SvlY.png" alt="image.png" style="zoom:50%;"></p><h3 id="例3：回收站"><a href="#例3：回收站" class="headerlink" title="例3：回收站"></a>例3：回收站</h3><p>windows回收站的创建模拟  在整个视窗系统中，回收站只能有一个实例，整个系统都使用这个唯一的实例，不管如何双击“回收站”图标，打开的回收站窗口始终是唯一的一个</p><h3 id="例4：网络计数器"><a href="#例4：网络计数器" class="headerlink" title="例4：网络计数器"></a>例4：网络计数器</h3><p>网站计数器是WEB应用程序的一项基本功能，用于统计使用网站或者应用程序的人数，可反映出网站或者应用程序的受欢迎程序，对于电子商务网站可信度的研究有一定的参考价值</p><h1 id="【结构型】适配器模式"><a href="#【结构型】适配器模式" class="headerlink" title="【结构型】适配器模式"></a>【结构型】适配器模式</h1><h2 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：🐕"><a href="#例1：🐕" class="headerlink" title="例1：🐕"></a>例1：🐕</h3><p>现需要设计一个可以模拟各种动物行为的机器人，在机器人中定义了一系列方法，如机器人叫喊方法cry()、机器人移动方法move()等。如果希望在不修改已有代码的基础上使得机器人能够像狗一样叫，像狗一样跑</p><h1 id="【结构型】组合模式"><a href="#【结构型】组合模式" class="headerlink" title="【结构型】组合模式"></a>【结构型】组合模式</h1><h2 id="样例-9"><a href="#样例-9" class="headerlink" title="样例"></a>样例</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p>在水果盘(Plate)中有一些水果，如苹果(Apple)、香蕉(Banana)、梨子(Pear)，当然大水果盘中还可以有小水果盘，现需要对盘中的水果进行遍历（吃），当然如果对一个水果盘执行“吃”方法，实际上就是吃其中的水果</p><h1 id="【结构型】装饰者模式"><a href="#【结构型】装饰者模式" class="headerlink" title="【结构型】装饰者模式"></a>【结构型】装饰者模式</h1><h1 id="【结构型】外观模式"><a href="#【结构型】外观模式" class="headerlink" title="【结构型】外观模式"></a>【结构型】外观模式</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;【考试向】13种设计模式的 PPT+网上+书上 的各种例题搜集汇总&lt;/p&gt;</summary>
    
    
    
    <category term="软件工程" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="软件设计模式" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【动态规划】最长上升子序列模型</title>
    <link href="http://example.com/2022/04/30/2022-4-30-%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/04/30/2022-4-30-%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-04-30T03:17:01.000Z</published>
    <updated>2022-08-03T04:03:09.812Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>动态规划中最长上升子序列模型题目总结</li></ul></li></ul><span id="more"></span><h1 id="Easy-Part"><a href="#Easy-Part" class="headerlink" title="Easy Part"></a>Easy Part</h1><blockquote><p>都是些常见基本模板题</p></blockquote><h2 id="AcWing-895-最长上升子序列（序列最长1000）"><a href="#AcWing-895-最长上升子序列（序列最长1000）" class="headerlink" title="AcWing 895. 最长上升子序列（序列最长1000）"></a><a href="https://www.acwing.com/problem/content/897/">AcWing 895. 最长上升子序列</a>（序列最长1000）</h2><blockquote><p>数列长度1＜N＜1000，求给定序列的 数值严格递增的子序列长度；【模板题】</p></blockquote><h3 id="思路-【基于动态规划】"><a href="#思路-【基于动态规划】" class="headerlink" title="思路 【基于动态规划】"></a>思路 【基于动态规划】</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/a61f3906e9a02f30.png" style="zoom:45%;"></p><ul><li>状态表示：<code>dp[i]</code>：以 <code>a[i]</code><strong>结尾</strong>的最长上升子序列的长度</li><li>初始值：<code>dp[i]=1</code>,<code>i∈[0,n−1]</code> 表示<strong>最初</strong>一个数本身就是最长上升子序列，长度为 1</li><li>状态转移：把前<code>i−1</code>个数字中所有<strong>满足条件</strong><code>dp[j]&lt;dp[i]</code>（上升子序列） 的<code>j</code>找出来，那么<code>dp[i]</code>就可以试着更新为以 <strong>dp[j] 结尾的最长上升子序列的长度+自己的长度 1</strong>，但可能更新后的结果没之前的大，最后两者取max</li></ul><h3 id="代码-O-n-2"><a href="#代码-O-n-2" class="headerlink" title="代码 $O(n^2)$"></a>代码 $O(n^2)$</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++){</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;a[i]) </span><br><span class="line">dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">} </span><br><span class="line">ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">} </span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing896-最长上升子序列（序列最长100000）"><a href="#AcWing896-最长上升子序列（序列最长100000）" class="headerlink" title="AcWing896 最长上升子序列（序列最长100000）"></a>AcWing896 最长上升子序列（序列最长100000）</h2><blockquote><p>数列长度1＜N＜100 000  ，求数值严格递增的子序列长度</p></blockquote><h3 id="思路【基于二分】"><a href="#思路【基于二分】" class="headerlink" title="思路【基于二分】"></a>思路【基于二分】</h3><p>数据达到100000，考虑$nlogn$的算法</p><h3 id="代码-O-nlogn"><a href="#代码-O-nlogn" class="headerlink" title="代码$O(nlogn)$"></a>代码$O(nlogn)$</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],q[N];<span class="comment">//q[i]表示长度是i的上升子序列最后一个数的最小值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n,cnt=<span class="number">0</span>;<span class="comment">//cnt:前i个数中最大的最长上升子序列的值</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    q[<span class="number">0</span>]=INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=cnt;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r){</span><br><span class="line">            <span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid]&lt;a[i]) l=mid;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        cnt=<span class="built_in">max</span>(cnt,r+<span class="number">1</span>);</span><br><span class="line">        q[r+<span class="number">1</span>]=a[i];        </span><br><span class="line">    }</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>更好理解的一种</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;stk;</span><br><span class="line">stk.<span class="built_in">push_back</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;stk.<span class="built_in">back</span>()) stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line"><span class="keyword">else</span>{ <span class="comment">//替换掉第一个大于等于它的数</span></span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=stk.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r){</span><br><span class="line"><span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(stk[mid]&gt;=a[i]) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>; </span><br><span class="line">}  <span class="comment">// *lower_bound(stk.begin(), stk.end(), a[i]) = a[i];</span></span><br><span class="line">stk[l]=a[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;stk.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing897-最长公共子序列"><a href="#AcWing897-最长公共子序列" class="headerlink" title="AcWing897 最长公共子序列"></a>AcWing897 最长公共子序列</h2><blockquote><p>两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">状态表示（集合表示）：dp[i][j] 所有在A[<span class="number">1</span>…i]中出现过且在B[<span class="number">1</span>…j]中也出现过的子序列</span><br><span class="line">       <span class="comment">//以选到A[i]和B[j]结尾的满足条件子序列</span></span><br><span class="line">属性：   最大值</span><br><span class="line">状态计算（集合划分）：根据A[i]是否等于B[j]</span><br><span class="line">    <span class="number">1</span>) A[i] == B[j] dp[i][j] → dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="number">2</span>) A[i] != B[j] dp[i][j] → <span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])</span><br></pre></td></tr></tbody></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=y;i++) cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=y;j++){</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[x][y]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="P1439-最长公共子序列"><a href="#P1439-最长公共子序列" class="headerlink" title="P1439 最长公共子序列"></a><a href="https://www.luogu.com.cn/problem/P1439">P1439 最长公共子序列</a></h2><blockquote><p>给出 1,2,…n 的两个排列 P1 和 P2 ，求它们的最长公共子序列。n&lt;=100 000</p></blockquote><p>数据范围大，按上一题的思路明显不行，所以考虑：</p><p>因为是1到 n的排列，所以两个子序列的元素都相同，只是位置不同</p><p>比如</p><figure class="highlight apache"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">P1</span>: <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> 映射成→ a b c d e  那么</span><br><span class="line"><span class="attribute">P2</span>: <span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> 映射成→ e a b c d  所以转换成求单个序列的最长上升子序列问题（AcWing<span class="number">896</span>）</span><br></pre></td></tr></tbody></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line">a[x]=i;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line">b[i]=a[x];</span><br><span class="line">}</span><br><span class="line"><span class="comment">//求b[]的最长上升子序列</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;stk;</span><br><span class="line">stk.<span class="built_in">push_back</span>(b[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(stk.<span class="built_in">back</span>()&lt;b[i]) stk.<span class="built_in">push_back</span>(b[i]);</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">*<span class="built_in">lower_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),b[i])=b[i];</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">cout&lt;&lt;stk.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing-902-最短编辑距离"><a href="#AcWing-902-最短编辑距离" class="headerlink" title="AcWing 902. 最短编辑距离"></a><a href="https://www.acwing.com/activity/content/problem/content/1094/">AcWing 902. 最短编辑距离</a></h2><blockquote><p>给两字符串 A 和 B，将 A 经过若干操作变为 B，求出将 A 变为B 至少需要的操作次数。可进行操作有：</p><ol><li>删除–将字符串 A 中的某个字符删除。</li><li>插入–在字符串 A 的某个位置插入某个字符。</li><li>替换–将字符串 A 中的某个字符替换为另一个字符。</li></ol></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">状态表示：dp[i][j]: 将A的前i个字符变成B的前j个字符</span><br><span class="line">    属性：最小操作次数</span><br><span class="line">状态计算：</span><br><span class="line">    <span class="number">1</span>) a[i]==b[j]: → dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="number">2</span>) 删除：dp[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">   插入：dp[i][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">       替换: dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">           </span><br><span class="line">关于初始化：</span><br><span class="line"><span class="number">1.</span>在<span class="keyword">for</span>遍历的时候需要用到的但是事先没有的 就要预处理 → 往往就是<span class="number">0</span>、<span class="number">1</span>之类的 </span><br><span class="line"><span class="number">2.</span>如果要找min → INF; 要找有负数的max → -INF</span><br><span class="line">因此：</span><br><span class="line">  f[<span class="number">0</span>][i]：如果a初始长度是<span class="number">0</span>，只能用插入操作让a变成b</span><br><span class="line">  f[i][<span class="number">0</span>]：如果b初始长度是<span class="number">0</span>，只能用删除操作让a变成b</span><br></pre></td></tr></tbody></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];<span class="comment">//dp[i][j]将A的前i个字母变成B的前j个字母的操作次数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;a+<span class="number">1</span>;<span class="comment">//使得a从下标1开始存储 </span></span><br><span class="line">cin&gt;&gt;m&gt;&gt;b+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[<span class="number">0</span>][i]=i;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="comment">//删除or删除 </span></span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//or替换</span></span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>,dp[i][j]);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing-899-编辑距离"><a href="#AcWing-899-编辑距离" class="headerlink" title="AcWing 899. 编辑距离"></a><a href="https://www.acwing.com/activity/content/problem/content/1006/">AcWing 899. 编辑距离</a></h2><blockquote><p> n个长度不超过 10 的字符串以及m 次询问，每次询问给出一个字符串和一个操作次数上限。</p><p>对每次询问，求给定的 n 个串中有多少个串可以在上限操作次数内经过操作变成询问给出的字符串。</p></blockquote><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> s[N][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">char</span> a[],<span class="keyword">char</span> b[])</span></span>{</span><br><span class="line"><span class="keyword">int</span> lena=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> lenb=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lena;i++) dp[i][<span class="number">0</span>]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lenb;i++) dp[<span class="number">0</span>][i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lena;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenb;j++){</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dp[lena][lenb];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;(s[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">char</span> b[<span class="number">15</span>];cin&gt;&gt;(b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">0</span>; cin&gt;&gt;len;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp); <span class="comment">//注意点</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">dis</span>(s[i],b)&lt;=len) cnt++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Medium-Part"><a href="#Medium-Part" class="headerlink" title="Medium Part"></a>Medium Part</h1><blockquote><p>非模板题目，在基础模板上的一丢丢变化且不难的题</p></blockquote><h2 id="AcWing-1014-登山"><a href="#AcWing-1014-登山" class="headerlink" title="AcWing 1014. 登山"></a><a href="https://www.acwing.com/activity/content/problem/content/1260/">AcWing 1014. 登山</a></h2><blockquote><p>给定序列，求先单调上升再单调下降的最长子序列长度</p></blockquote><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>先分别按数组 顺序和逆序 求以<code>a[i]</code>结尾的最长上升子序列长度<code>f[i]</code></p><p>得到以<code>a[i]</code>结尾的先上升后下降的最长子序列长度即为<code>f[i]+g[i]-1</code></p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N],g[N],a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">f[i]=<span class="number">1</span>,g[i]=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++){</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;a[j]) f[i]=<span class="built_in">max</span>(f[i],f[j]+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;i;j--){</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;a[j]) g[i]=<span class="built_in">max</span>(g[i],g[j]+<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=<span class="built_in">max</span>(ans,f[i]+g[i]<span class="number">-1</span>);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;动态规划中最长上升子序列模型题目总结&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Kademlia基本原理</title>
    <link href="http://example.com/2022/04/19/2022-04-19-Kademlia%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2022/04/19/2022-04-19-Kademlia%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-18T16:22:17.000Z</published>
    <updated>2022-04-19T06:57:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>分布式路由算法Kademlia的原理理解</p><span id="more"></span><h1 id="Kademlia"><a href="#Kademlia" class="headerlink" title="Kademlia"></a>Kademlia</h1><p>来源：<a href="https://www.jianshu.com/p/f2c31e632f1d">易懂分布式 | Kademlia算法 - 简书 (jianshu.com)</a></p><blockquote><p>ps：这篇文章真的写得太棒啦！！！！！是我所看过讲Kademlia文章中逻辑最清晰表达最棒的一篇文章！</p></blockquote><h2 id="基本原理理解"><a href="#基本原理理解" class="headerlink" title="基本原理理解"></a>基本原理理解</h2><p><strong>Kad算法</strong> 是一种<strong>分布式存储</strong>及路由的算法，DHT (Distributed Hash Table) 的一种</p><p>Kad优点：</p><ul><li>对于任意一个有[ 2^(n−1) ,2^n)个节点的网络，<strong>最多只需要n步</strong>搜索即可找到目标节点；</li><li>K-bucket的更新机制一定程度上保持了网络的<strong>活性和安全性</strong></li></ul><blockquote><p>分布式存储：<strong>不设立中心化</strong>的服务器，所有（资源）文件<strong>分散存储</strong>在各个节点上</p></blockquote><p><strong>DHT</strong>：一种去中心化的分布式系统</p><ul><li>在这类系统中，每个node分别维护<strong>一部分的存储内容</strong>以及<strong>其他</strong>（部分）<strong>节点的路由/地址</strong><ul><li>使得网络中任何节点的进入和退出，对整个网络造成的影响最小。</li></ul></li></ul><hr><p><strong>考虑的问题</strong>：</p><ul><li>分配：如何进行资源分配，把分配的内容存储到各个节点上，新增或者删除内容如何处理</li><li>路由：如果某节点 想要<strong>获取</strong>某个特定的资源，<strong>如何找到</strong>存储资源的节点\地址\路径</li></ul><hr><p><strong>针对每个节点</strong>：</p><ul><li><p>被分配到的资源 以<key,value>的形式储存；</key,value></p><blockquote><p>通俗的理解：key-资源名（确切一点，是资源名的hash值），value-资源内容</p></blockquote></li><li><p>维护一张路由表；用来去找其他节点</p><ul><li>这张路由表，也称为“k-bucket”（k桶）</li><li>路由表<strong>按异或距离分层</strong><ul><li>本节点的nodeID 异或  目标节点的nodeID</li></ul></li><li>记录<strong>有限</strong>个数的<strong>其他节点的ID</strong> （nodeID）、IP地址和端口</li></ul></li></ul><hr><p><strong>为什么每个节点不能拥有其他所有的节点路由信息</strong>：</p><ul><li>分布式系统中，节点的进入退出十分频繁<ul><li>如果每次变动都全网广播，通讯量很大</li></ul></li><li>不安全：如果一个节点被攻破的话</li></ul><hr><p><strong>分布式存储后，资源如何存储和查找？</strong></p><p>例子：</p><blockquote><p>假设《分布式算法》这本书的书名的hash值是 <strong>00010000</strong>，那么这本书就会被要求存在学号为<strong>00010000</strong>的同学手上。（这要求hash算法的值域与node ID的值域一致。Kademlia的Node ID是160位2进制。这里的示例对Node ID进行了简略）<br> 但还得考虑到会有同学缺勤。万一<em>00010000</em>今天没来上学（节点<strong>没有上线或彻底退出</strong>网络），那《分布式算法》这本书岂不是谁都拿不到了？那算法要求这本书不能只存在一个同学手上，而是被要求<strong>同时存储在学号最接近00010000</strong>的<strong>k</strong>位同学手上，即<em>00010001</em>、<em>00010010</em>、<em>00010011</em>…等同学手上都会有这本书。</p><p>同样地，当你需要找《分布式算法》这本书时，将书名hash一下，得到 <em>00010000</em>，这个便是索书号，你就知道该找哪（几）位同学了。</p></blockquote><p>剩下的问题，就是找到这（几）位同学的手机号（路由）。</p><p>但是，你手中的通讯录里<strong>可能没他们的手机号</strong></p><p>即是：已知源节点<strong>持有的路由表</strong>，和 目的节点<strong>target</strong>的<strong>nodeID</strong>，如果找到目的节点的IP</p><blockquote><p>算法的核心思路：</p><p>当你知道<strong>目标同学Z</strong>与你之间的<strong>距离</strong>（这个距离通过你的nodeID和目标的nodeID异或得到）</p><p>你可以在你的通讯录（即：路由表）上先找到一个你认为与同学Z<strong>最相近的同学B</strong>，请同学B再进一步去<strong>查找同学Z</strong>的手机号。</p><p>每个同学只维护<strong>一部分</strong>的通讯录，这个通讯录按照距离分层（可以理解为按学号与自己的学号从第几位开始不同而分层），即k-bucket1, k-bucket 2, k-bucket 3…</p><p>虽然每个k-bucket中实际存在的同学人数逐渐增多，但每个同学在它自己的每个k-bucket中<strong>只记录k位同学</strong>的手机号</p></blockquote><p><strong>对应</strong>：每个k-bucket只存 k个节点的地址与端口，这里的k是一个<strong>可调节的常量参数</strong></p><blockquote><p>由于学号（节点的ID）有160位，所以每个同学的通讯录中共分160层（节点共有160个k-bucket）。整个网络最多可以容纳2^160个同学（节点），但是每个同学（节点）最多只维护<strong>160 * k</strong> 行通讯录（其他节点的地址与端口）</p></blockquote><hr><p><strong>节点的定位</strong>：</p><p>A同学（学号<em>00000110</em>）想找《分布式算法》，A首先需要<strong>计算</strong>书名的<strong>哈希值</strong>，hash(《分布式算法》) = <strong>00010000</strong>。那么A就知道ta需要找到<strong>00010000</strong>号同学（命名为Z同学）或学号与Z<strong>邻近的</strong>同学。<br> Z的学号<em>00010000</em>与自己的<strong>异或距离</strong>为 <em>00010110</em>，距离范围在[2^4, 2^5)，所以这个Z同学可能在k-bucket 5中（或者说，Z同学的学号与A同学的学号从第5位开始不同，所以Z同学可能在k-bucket 5中）。<br> 然后<strong>A同学看看自己的k-bucket 5</strong>有没有Z同学：</p><ul><li>如果有，那就直接联系Z同学要书；</li><li>如果没有，在k-bucket 5里<strong>随便找一个</strong>B同学（注意任意B同学，它的学号第5位肯定与Z相同，即它与Z同学的距离会小于24，相当于比Z、A之间的<strong>距离缩短了一半以上</strong>），请求B同学在它自己的通讯录里按同样的查找方式找一下Z同学：<ul><li>如果B知道Z同学，那就把Z同学的手机号（IP Address）告诉A；</li><li>如果B也不知道Z同学，那<strong>B按同样的搜索方法</strong>，可以在自己的通讯录里找到一个离Z更近的C同学（Z、C之间距离小于2^3），把C同学推荐给A；A同学请求C同学进行下一步查找。<strong>（递归）</strong></li></ul></li></ul><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h3><ul><li><strong>keyspace</strong><ul><li>nodeID有多少位</li><li>决定每个节点的路由表有几层</li></ul></li><li><p><strong>k</strong></p><ul><li>每一层k-bucket里<strong>装k个node信息</strong>：<nodeid, ip,="" address="" ,port=""></nodeid,></li><li>每次查找node，<strong>返回k个node信息</strong></li><li>对于某个特定的data，它的ID也就是所说的key，离其key<strong>最近的k个节点</strong>也要存储这个data</li></ul></li><li><p>α</p><ul><li>每次向其他node请求查找某个node时，会<strong>向α个node发送请求</strong></li></ul></li></ul><hr><h3 id="节点的指令"><a href="#节点的指令" class="headerlink" title="节点的指令"></a>节点的指令</h3><blockquote><p>每个节点只有4个指令</p></blockquote><ul><li>PING：测试一个节点是否在线</li><li>STORE：要求一个节点存储一份数据</li><li>FIND_NODE：根据nodeID查找一个node</li><li>FIND_VALUE：根据KEY查找一个data，跟FIND_NODE十分相似</li></ul><hr><h3 id="k-bucket的维护和更新机制"><a href="#k-bucket的维护和更新机制" class="headerlink" title="k-bucket的维护和更新机制"></a>k-bucket的维护和更新机制</h3><blockquote><p>保证任何节点的加入和离开都不影响整体网络</p></blockquote><ul><li>每个bucket里的节点都按最后一次接触的时间倒序排列<ul><li>也就是：最近接触的放在队尾</li></ul></li><li>每次执行四个指令中的任何一个，都会触发更新</li><li>当<font color="green">一个节点</font>和<strong>自己</strong>接触时，检查它是否在<strong>自己</strong>的k-bucket中<ul><li>在：把<font color="green">这个节点</font>挪到k-bucket列表的末尾</li><li>不在：PING一下列表最头部的<font color="orange">一个节点</font><ul><li>PING通：把<font color="orange">旧节点</font>挪到列表的末尾，丢弃<font color="green">新节点</font></li><li>PING不通：删除<font color="orange">旧节点</font>，并将<font color="green">新节点</font>加入列表</li></ul></li></ul></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;分布式路由算法Kademlia的原理理解&lt;/p&gt;</summary>
    
    
    
    <category term="信安赛" scheme="http://example.com/categories/%E4%BF%A1%E5%AE%89%E8%B5%9B/"/>
    
    
    <category term="以太坊" scheme="http://example.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>【SE】线性代数</title>
    <link href="http://example.com/2022/04/17/2022-04-17-%E3%80%90SE%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://example.com/2022/04/17/2022-04-17-%E3%80%90SE%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</id>
    <published>2022-04-17T14:45:34.000Z</published>
    <updated>2022-04-19T06:54:22.503Z</updated>
    
    <content type="html"><![CDATA[<p>线性代数基本概念复习总结</p><span id="more"></span><p>[先挖个坑….]</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;线性代数基本概念复习总结&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【SE】词法分析器和语法分析器的设计</title>
    <link href="http://example.com/2022/04/15/2022-04-15-%E3%80%90SE%E3%80%91%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/04/15/2022-04-15-%E3%80%90SE%E3%80%91%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-04-15T14:45:34.000Z</published>
    <updated>2022-05-04T10:37:18.434Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>实现词法分析器</li><li>实现语法分析器</li></ul></li></ul><span id="more"></span><h1 id="1-词法分析器"><a href="#1-词法分析器" class="headerlink" title="1. 词法分析器"></a>1. 词法分析器</h1><h2 id="1-1-基本原理"><a href="#1-1-基本原理" class="headerlink" title="1.1 基本原理"></a>1.1 基本原理</h2><ul><li><p><strong>正规文法</strong></p><ul><li>也称<strong>3型</strong>文法 G=(VN,VT,S,P)</li><li>其中P中的每一条规则都有下述形式：<code>A-&gt;aB或A-&gt;a</code>，其中A和B是非终结符，a是终结符的闭包</li></ul></li><li><p><strong>不确定的有穷自动机NFA</strong></p><blockquote><p>一个不确定的 有穷自动机M 是一个五元组：$M=（K,\sum,f,S,Z)$</p></blockquote><ul><li>K：有穷集，每个元素称为一个<strong>状态</strong></li><li><p>Σ：有穷字母表，每一个元素称为一个<strong>输入符号</strong></p></li><li><p>f：一个映射</p></li><li>S ⊆ K：非空初态集（对于<strong>DFA，初态唯一</strong>）</li><li>Z ⊆ K：终态集</li></ul></li><li><p><strong>字符串t能被DFA所接收</strong></p><ul><li>对于$\sum^{*}$中的任何符号串t，若存在一条从初态节点到某一终态节点的道路，且这条道路的所有弧的标记符连接成的符号等于t，则称t可被这个DFA所接收（识别），若DFA的初态节点同时又是终态节点，则空字($\epsilon$)可为DFA所接收</li></ul></li></ul><h2 id="1-2-设计思路"><a href="#1-2-设计思路" class="headerlink" title="1.2 设计思路"></a>1.2 设计思路</h2><p>​    最先开始先以课本上给出的简单构词规则进行编写代码，进行调试，然后逐步扩充和完善构词规则，进行编码和调试。严格按照词法分析流程，根据规定的正规文法，先<strong>构建NFA</strong>，再利用子集法<strong>确定为DFA</strong>，分模块逐步完成主要函数。最后再通过DFA，读入测试程序进行扫描进行词法分析，得到<strong>输出的token序列</strong>或者错误信息。生成 token 列表（三元组：所在行号，类别，token 内容）。由于算法所用数据结构和C++中许多已有数据结构概念相符，因此可考虑用C++代码编写，充分利用C++中的STL库，十分方便算法的实现。总体流程图如下：</p><p><img src="https://i.bmp.ovh/imgs/2022/05/03/b31be7f16a2e2127.png" style="zoom: 30%;"></p><h2 id="1-3-文件结构"><a href="#1-3-文件结构" class="headerlink" title="1.3 文件结构"></a>1.3 文件结构</h2><div class="table-container"><table><thead><tr><th>路径</th><th>文件说明</th></tr></thead><tbody><tr><td>Lexical\TXT\GRAMMAR.txt</td><td>存放构词规则（正规文法）</td></tr><tr><td>Lexical\TXT\INCHAR.txt</td><td>存放终结符</td></tr><tr><td>Lexical\TXT\KEYWORDS.txt</td><td>存放关键字</td></tr><tr><td>Lexical\TXT\LIMITER.txt</td><td>存放界符(限定符）</td></tr><tr><td>Lexical\TXT\OPERATOR.txt</td><td>存放操作符</td></tr><tr><td>Lexical\TXT\ROW.txt</td><td>存放源程序中每一行的token数，便于语法分析器的报错提示</td></tr><tr><td>Lexical\TXT\SOURCE.txt</td><td>存放源程序代码</td></tr><tr><td>Lexical\TXT\TOKEN_TRIAD.txt</td><td>存放输出的token序列（三元组）</td></tr><tr><td>Lexical\TXT\TOKEN.txt</td><td>存放输出的token序列（二元组）</td></tr><tr><td>Lexical\TXT\WRONG.txt</td><td>存放语法分析器的报错信息，同时便于语法分析器的分析判断</td></tr><tr><td>Lexical\lexical.cpp</td><td>函数实现</td></tr><tr><td>Lexical\path.h</td><td>文件路径定义的头文件</td></tr><tr><td>Lexical\lexical.h</td><td>函数和变量声明的头文件</td></tr><tr><td>Lexical\main.cpp</td><td>主函数</td></tr></tbody></table></div><h2 id="1-4-构词规则"><a href="#1-4-构词规则" class="headerlink" title="1.4 构词规则"></a>1.4 构词规则</h2><p>基于本课程考核要求的内容，确定词法分析的构词如下：</p><p><img src="https://i.bmp.ovh/imgs/2022/05/03/a19bf29f8f13c3e2.png" style="zoom:40%;"></p><p>因此，根据构词规则设置正规文法，文法中的各项产生式的作用和之间的<strong>逻辑关系和分类</strong>如下：</p><ol><li>界符(限定符)</li></ol><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095219277.png" alt="image-20220503095219277" style="zoom: 30%;"></p><ol><li><p>标识符</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095318581.png" alt="image-20220503095318581" style="zoom: 33%;"></p></li><li><p>运算符</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095435881.png" alt="image-20220503095435881" style="zoom: 33%;"></p></li><li><p>常量</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095607966.png" alt="image-20220503095607966" style="zoom:80%;"></p></li></ol><h2 id="1-5-具体实现"><a href="#1-5-具体实现" class="headerlink" title="1.5 具体实现"></a>1.5 具体实现</h2><h3 id="（1）初始化所有加载项：void-init"><a href="#（1）初始化所有加载项：void-init" class="headerlink" title="（1）初始化所有加载项：void init()"></a>（1）初始化所有加载项：void init()</h3><p>预处理，从各文本文件中加载终结符、关键字、操作符、界符到各自的数据结构中。</p><div class="table-container"><table><thead><tr><th>类型</th><th>数据结构</th><th>函数名</th></tr></thead><tbody><tr><td>终结符</td><td>vector<char>INCHAR</char></td><td>void load_inchar();</td></tr><tr><td>关键字</td><td>vector<string> KEYWORDS</string></td><td>void load_keywords();</td></tr><tr><td>操作符</td><td>vector<string> OPT</string></td><td>void load_opt();</td></tr><tr><td>界符</td><td>vector<string>LIMITER</string></td><td>void load_limiter();</td></tr></tbody></table></div><h3 id="（2）创建NFA：void-createNFA"><a href="#（2）创建NFA：void-createNFA" class="headerlink" title="（2）创建NFA：void createNFA()"></a>（2）创建NFA：void createNFA()</h3><ul><li><p><strong>数据结构定义</strong></p><ul><li><p>NFA中的一条边的数据结构，结构体存储三元组的形式：边的起点，边的输入（权重），边的终点</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503100210138.png" alt="image-20220503100210138" style="zoom: 50%;"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Triad</span> {</span></span><br><span class="line">&nbsp; <span class="keyword">char</span> startPoint, input, endPoint;</span><br><span class="line">} Triad;</span><br></pre></td></tr></tbody></table></figure></li><li><p>NFA的数据结构： 结构体保存<code>initialState</code>-初态，<code>finalState</code>-终态，<code>f</code>-NFA中所有边的集合</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NFA</span> {</span></span><br><span class="line">&nbsp; <span class="keyword">char</span> initialState;</span><br><span class="line">&nbsp; vector&lt;<span class="keyword">char</span>&gt; finalState;</span><br><span class="line">&nbsp; vector&lt;Triad&gt; f;</span><br><span class="line">} NFA;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>读入的正规文法创建NFA</strong></p><ul><li><p>根据<strong>右线性</strong>正规文法的转换规则（注：t 为 VT 或ε）：</p><pre><code>① 增加一个终态结点，开始符号对应的结点作为初态② 对形如 A→t 的规则，引一条从A到终态结点的弧，标记为t③ 对形如 A→tB 的规则，引一条从A到B的弧，标记为t</code></pre></li><li><p>算法具体流程图如下，由于NFA的终态集合采用的是vector，最后需要对vector的元素进行去重，但代码运行时即使不去重也没有影响。</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503100618138.png" alt="image-20220503100618138" style="zoom:50%;"></p></li></ul></li></ul><h3 id="（3）将NFA转换成DFA：void-NFA-TO-DFA"><a href="#（3）将NFA转换成DFA：void-NFA-TO-DFA" class="headerlink" title="（3）将NFA转换成DFA：void NFA_TO_DFA()"></a>（3）将NFA转换成DFA：void NFA_TO_DFA()</h3><p>​    首先，定义DFA的数据结构，利用结构体保存初态-initialState、终态集合-finalState、边的集合-f；在定义DFA的边的集合时，并没有采用像NFA一样的结构体来定义边，而是采用一个二维数组<code>f[MAX_NODES][MAX_NODES]</code>，比如<code>f[state][input]=nextState</code>就表示从当前状态<code>state</code>输入字符<code>input</code>后转移到下一个状态<code>nextState</code>，将char隐式地转换成int类型作为数组下标，在代码中利用change函数实现，比如初始状态表示字符<code>S</code>对应int中0，其余状态<code>A</code>对应int中的1，<code>B</code>对应int中的2……以此类推。的实现了O(1)查找，提高了算法的效率。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DFA</span> {</span></span><br><span class="line">&nbsp; <span class="keyword">char</span> initialState;</span><br><span class="line">&nbsp; vector&lt;<span class="keyword">char</span>&gt; finalState;</span><br><span class="line">&nbsp; <span class="keyword">int</span> f[MAX_NODES][MAX_NODES]; &nbsp;</span><br><span class="line">} DFA;</span><br></pre></td></tr></tbody></table></figure><p>算法的关键部分的伪代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开始e-<span class="built_in">closure</span>(K0)令C为中唯一成员，并且它是未被标记的。</span><br><span class="line"><span class="built_in">While</span> (C 中存在尚未标记的子集T) <span class="keyword">do</span></span><br><span class="line">{    标记T；</span><br><span class="line">     <span class="built_in">For</span>(每个输入字符a) <span class="keyword">do</span></span><br><span class="line">      {   U:=e-<span class="built_in">closure</span>(<span class="built_in">move</span>(T,a))</span><br><span class="line">          <span class="built_in">If</span> (U不在C中) then</span><br><span class="line">          { 将U作为未标记的子集加载C中；}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中，需要求闭包和move集：</p><ul><li><p><strong>求状态集T的闭包:</strong></p><ul><li><p>对应代码的函数名为<code>set&lt;char&gt; e_closure(set&lt;char&gt; T)</code>。</p></li><li><p>传入参数，类型为<code>set&lt;char&gt;</code>的状态集T，函数返回状态集T的一个闭包。</p></li><li>求T的闭包即是求状态集<strong>T中的任何状态</strong>，及<strong>经过任意条ε弧所能到达的状态</strong>的集合。</li><li>由于集合的概念和C++的STL中的set概念一致，所以采用的是set类型来保存所有满足要求的状态，这样就没有重复元素，不需要去重。</li></ul></li><li><p><strong>求集合I的move集：</strong></p><ul><li><p>对应代码的函数名为<code>set&lt;char&gt; move(set&lt;char&gt; I, char input)</code>。</p></li><li><p>传入参数，类型为<code>set&lt;char&gt;</code>  的集合I，和一个char类型的字符input，求它的move集，即是求所有可以从I中的某一状态经一条input弧所能到达的状态，返回满足要求的状态的集合。</p></li></ul></li></ul><p>定义完求闭包和求move集的函数后，编写NFA转换成DFA的算法。根据伪代码转换的具体算法流程图如下：</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503111033602.png" alt="image-20220503111033602" style="zoom:50%;"></p><h3 id="（4）读入源程序进行词法分析：void-scanSourceCode"><a href="#（4）读入源程序进行词法分析：void-scanSourceCode" class="headerlink" title="（4）读入源程序进行词法分析：void scanSourceCode()"></a>（4）读入源程序进行词法分析：void scanSourceCode()</h3><p>​    首先，在读入源程序之前，需要将源程序一些不必要的换行和tab符号过滤掉，然后存到数组中，然后对这些已经用空格分隔该来的预处理字符串序列进行处理，将一个个字符串分割成一个个单词，初始化对应的单词类型为空串，具体算法执行流程如下：</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503125941169.png" alt="image-20220503125941169" style="zoom:50%;"></p><p>​    然后单词分割完毕后，对每个单词进行类型判断，通过DFA的状态转移表f对字符串序列逐个处理，每处理一个更新当前状态，直至状态为-1即找不到下一个状态为止，判断当前是否是因为未知符号导致的中断，将已经识别的字符串作为一个token识别其属于关键字，操作符，界符，常数和标识符的哪一种。具体算法执行流程如下：</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503130118347.png" alt="image-20220503130118347" style="zoom:50%;"></p><h3 id="（5）其他非关键函数"><a href="#（5）其他非关键函数" class="headerlink" title="（5）其他非关键函数"></a>（5）其他非关键函数</h3><ul><li>包括：打印NFA、打印DFA、关键词、界符等的判断函数、状态重命名函数、过滤源程序函数等等。</li></ul><h2 id="1-6-实例分析"><a href="#1-6-实例分析" class="headerlink" title="1.6 实例分析"></a>1.6 实例分析</h2><ul><li><p>输入正确源程序，词法分析成功，无误。</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503220718340.png" alt="image-20220503220718340" style="zoom:30%;"></p></li><li><p>修改源程序，检查，能够报出错误信息，指明出错位置</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503221014826.png" alt="image-20220503221014826" style="zoom:30%;"></p></li></ul><h1 id="2-LR-1-语法分析器"><a href="#2-LR-1-语法分析器" class="headerlink" title="2. LR(1)语法分析器"></a>2. LR(1)语法分析器</h1><h2 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h2><ul><li><strong>LR分析法</strong><ul><li>根据<strong>状态栈</strong>，和<strong>向右顺序查看</strong>输入串的$k(k≥0)$ 个符号，就可以唯一地确定分析器的动作<strong>是移进还是归约</strong>和用哪个产生式归约，因而能就确定唯一的句柄。</li><li>LR分析法的归约过程是规范推导的逆过程，所以LR分析过程是一种规范归约的过程</li></ul></li><li><strong>LR分析器</strong><ul><li>总控程序</li><li>分析表：Action-Goto表</li><li>分析栈：状态栈、符号栈；<ul><li>分析器的动作由栈顶状态和当前输入符号来确定<ul><li>移进：当$S_{j}=GOTO[S_{i},a]$ 成立，将$S_{j}$ 移入到状态栈，将$a$ 移入符号栈</li><li>归约：当栈顶形成句柄$\beta$ ，用$\beta$ 归约为相应的非终结符</li><li>接受：归约到文法符号栈中只剩下开始符号S，并且输入符号串结束，分析成功</li><li>报错：当遇到状态栈顶为某一状态下出现不该遇到的文法符号时报错，无法接受该句子</li></ul></li></ul></li></ul></li><li><strong>几种LR分析法的区别</strong><ul><li><strong>LR(0)</strong><ul><li>分析过程不需要向右查看输入符号</li><li>不存在<strong>移进-归约</strong> 和 <strong>归约-归约</strong> 冲突，即 R(0)文法分析<strong>不能解决这两种冲突</strong>，所以适用范围最小</li></ul></li><li><strong>SLR(1)</strong><ul><li>简单的LR(1)，存在<strong>多余（无效）归约</strong>的情况</li><li>不存在归约-归约冲突，<strong>有可能存在移进-归约冲突</strong>，但是如果可以用 follow集解决则是 SLR文法。换句话说，SLR文法分析过程可以解决归约-归约冲突，但是<strong>不一定能解决移进-归约冲突</strong>。用 follow集来处理即出现移进-归约冲突的两条产生式，如果其 follow集相交为空则为 SLR文法，反之不是。</li></ul></li><li><strong>LR(1)</strong><ul><li>因为 LR(1)文法的范围比较大，所以文法几乎都是 LR(1)的</li></ul></li></ul></li><li><strong>项目集中的项目种类</strong><ul><li>移进项目、待约项目、归约项目、接受项</li></ul></li></ul><h2 id="2-2-设计思路"><a href="#2-2-设计思路" class="headerlink" title="2.2 设计思路"></a>2.2 设计思路</h2><ul><li>读入二型文法产生式文档，识别出所有终结符和非终结符，求相应的First集</li><li>构建初始项目集，对核其闭包，进行状态转移，得到项目集族，构建Action-Goto表</li><li>构造分析表。</li></ul><p>编码过程中，严格分模块进行，每完成一个模块就进行一个模块的测试和校正。大量使用STL极大的简便了繁琐的编码。</p><h2 id="2-3-文件结构"><a href="#2-3-文件结构" class="headerlink" title="2.3 文件结构"></a>2.3 文件结构</h2><div class="table-container"><table><thead><tr><th>路径</th><th>文件说明</th></tr></thead><tbody><tr><td>Parser\TXT\ACTION_GOTO.txt</td><td>存放产生的Action-Goto表</td></tr><tr><td>Parser\TXT\ANALYSIS.TXT</td><td>存放分析表</td></tr><tr><td>Parser\TXT\GRAMMAR.txt</td><td>存放文法表</td></tr><tr><td>Parser\TXT\ITEMSET.txt</td><td>存放产生的项目集</td></tr><tr><td>Parser\main.cpp</td><td>主函数</td></tr><tr><td>Parser\parser.cpp</td><td>函数实现</td></tr><tr><td>Parser\parser.h</td><td>函数和变量声明的头文件</td></tr><tr><td>Parser\path.h</td><td>文件路径定义的头文件</td></tr></tbody></table></div><h2 id="2-4-语法规则"><a href="#2-4-语法规则" class="headerlink" title="2.4 语法规则"></a>2.4 语法规则</h2><p>​    实现基本的运算，赋值，定义变量，if-else，while，do-while，for，switch-case分支语句的判别。抽象的文法映射成程序中的文法规则的逻辑分类如下：</p><ol><li><p>程序框架</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144649721.png" alt="image-20220503144649721" style="zoom: 50%;"></p></li><li><p>赋值语句</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144737724.png" alt="image-20220503144737724" style="zoom:45%;"></p></li><li><p>操作语句</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144812202.png" alt="image-20220503144812202" style="zoom: 45%;"></p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144847851.png" alt="image-20220503144847851" style="zoom:40%;"></p></li><li><p>分支语句</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144921107.png" alt="image-20220503144921107" style="zoom:60%;"></p></li><li><p>代码块</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144941722.png" alt="image-20220503144941722" style="zoom:50%;"></p></li></ol><h2 id="2-5-具体实现"><a href="#2-5-具体实现" class="headerlink" title="2.5 具体实现"></a>2.5 具体实现</h2><h3 id="（1）预处理阶段：读取给定的二型文法文件"><a href="#（1）预处理阶段：读取给定的二型文法文件" class="headerlink" title="（1）预处理阶段：读取给定的二型文法文件"></a>（1）预处理阶段：读取给定的二型文法文件</h3><ul><li><p>数据结构定义</p><ul><li><p>二型文法产生式的数据结构</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Grammar</span>{</span></span><br><span class="line">&nbsp; &nbsp; <span class="keyword">char</span> left;</span><br><span class="line">&nbsp; &nbsp; string right;</span><br><span class="line">}Grammar;</span><br></pre></td></tr></tbody></table></figure></li><li><p>存放所有产生式的数据结构</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Grammar&gt; grammar; </span><br></pre></td></tr></tbody></table></figure></li><li><p>定义存放token的数据结构，将词法分析器获取的token的<strong>单词映射成一个字符</strong>，存入token字符串中</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    &nbsp;string token;</span><br></pre></td></tr></tbody></table></figure></li><li><p>定义存放终结符和非终结符的数据结构，VT存放终结符，其中不包括epsilon，epsilon单独处理； VN存放非终结符。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">char</span>&gt; VT; &nbsp;</span><br><span class="line">set&lt;<span class="keyword">char</span>&gt; VN;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>算法具体流程如下：</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503145537941.png" alt="image-20220503145537941" style="zoom:60%;"></p></li></ul><h3 id="（2）创建项目集族和Action-Goto表：void-create-char-left-char-right"><a href="#（2）创建项目集族和Action-Goto表：void-create-char-left-char-right" class="headerlink" title="（2）创建项目集族和Action-Goto表：void create(char left,char right)"></a>（2）创建项目集族和Action-Goto表：void create(char left,char right)</h3><ul><li><p><strong>数据结构定义</strong></p><ul><li><p>LR(1)项目集中的一条项目</p><ul><li><p><code>left</code>项目的产生式左边，<code>right</code>产生式右边，<code>position</code>圆点的位置，规定在<code>right[position]</code>的左边，<code>index</code> 本项目产生式在文法中的位置索引，<code>forward</code>向前搜索符集；</p></li><li><p>另外重载 <code>＜</code> 和 <code>==</code>便于后续的一些比较</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Item</span>{</span></span><br><span class="line"><span class="keyword">char</span> left; </span><br><span class="line">string right;</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> index; </span><br><span class="line">set&lt;<span class="keyword">char</span>&gt; forward; </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> struct Item &amp; item) <span class="keyword">const</span>{...详细见代码...}</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> struct Item &amp; item) <span class="keyword">const</span>{...详细见代码...} </span><br><span class="line">}Item;</span><br></pre></td></tr></tbody></table></figure></li><li><p>LR(1)项目集族的数据结构</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;Item&gt; Itemset[<span class="number">1000</span>];  </span><br></pre></td></tr></tbody></table></figure></li><li><p>Action-Goto表的数据结构</p><p>​    因为Action和Goto表的<strong>移进项没有本质区别</strong>，只有Action中的移进和归约态有区别。因为终结符和非终结符本代码都只用了一个字符表示，所以采用了char到int的隐式转换作为二维数组的索引，实现了O(1)的查找。。再判断的时候也和256作比较再进行下一步的判断。例如<code>ActionGoto[state][input]</code>的值表示栈顶状态为<code>state</code>时，遇见字符<code>input</code>所要执行的动作。</p><p>​    <strong>对ActionGoto数组的值的规定</strong>：</p><ul><li>-1 标识接受动作；</li><li>-2 标识不存在这个状态转移，即出错动作；</li><li>其余：Action表中的移进和归约用是否加256区分：x标识移进动作，x+256表示规约动作</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ActionGoto[<span class="number">300</span>][<span class="number">300</span>]; </span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>算法具体流程</strong></p><p>​    left是增广文法的左部非终结符，right是原文法的起始非终结符，用于初始化初始项目集，然后创建所有项目集，得到最终的项目集族，采用的是宽搜的方式，遍历所有终结符和非终结符。</p><p>​    如果能进行状态转移，那么就核和闭包，扩充项目集。若与原项目集不同则加入到项目集族，增加一条状态转移；若相同则只增加一条状态转移（指向自己），同时填充ActionGoto数组。</p><p>​    直至项目集族中不再有新项目集出现为止。在建好项目集族后，再来遍历项目集族判断项目集中是否含有归约项，区分和填充ActionGoto数组中的归约项和接受项。</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503204749919.png" alt="image-20220503204749919" style="zoom:77%;"></p><p>在构造DFA项目集的过程中，还涉及到以下函数调用</p><p>| 函数作用         | 函数名                                            | 说明                                                         |<br>| :———————- | ————————————————————————- | —————————————————————————————— |<br>| 求核             | <code>set&lt;Item&gt; getKernel(char c, set&lt;Item&gt; itemSet)</code>  | 遍历项目集中的每个项目，与文法进行匹配即可                   |<br>| 求闭包           | <code>set&lt;Item&gt; getClosure(set&lt;Item&gt; itemSet)</code>         | 通过while循环，循环体内遍历项目集中的每一个项目，若还有能扩充项目则继续迭代，直至项目集中的每一个项目不再能进行扩充。 |<br>| 求向前搜索符号集 | <code>set&lt;char&gt; getForward(char c, set&lt;char&gt; forward)</code> | 关键在于需要进行c是否为epsilon以及c是否能推出空来判断相应的动作，得到向前搜素符。 |<br>| 求First集        | <code>void getFirstSet()</code>                              | 通过while循环，循环体内遍历每一个文法，直至每个非终结符的First集不再发生改变就停止迭代，若还有变化则继续迭代。 |</p></li></ul><h3 id="（3）扫描token序列进行语法分析：void-scanSourceToken-string-token-str"><a href="#（3）扫描token序列进行语法分析：void-scanSourceToken-string-token-str" class="headerlink" title="（3）扫描token序列进行语法分析：void scanSourceToken(string token_str)"></a>（3）扫描token序列进行语法分析：void scanSourceToken(string token_str)</h3><p>​    首先检查词法分析无误，然后再进行语法分析，依据Action-Goto表依次对输入的token进行分析，根据当前的项目集（即DFA状态）和当前的token找Action-Goto表中的对应项，根据表中对应的值，判断是移进还是归约还是acc还是报错。如果是移进则更新当前状态，同时将状态和token入栈；如果是归约，则符号栈和状态栈依据归约文法进行退栈和入栈，同时根据最新的状态和token进行移进。直至acc或者检测到语法出错，则迭代结束。具体流程图如下：</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503210635580.png" alt="image-20220503210635580" style="zoom:50%;"></p><h2 id="2-6-实例分析"><a href="#2-6-实例分析" class="headerlink" title="2.6 实例分析"></a>2.6 实例分析</h2><ul><li>输入正确源程序，语法分析成功，无误。</li></ul><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503221437398.png" alt="image-20220503221437398" style="zoom:33%;"></p><ul><li><p>修改源程序，检查，能够报出错误信息，指明出错位置</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503221705649.png" alt="image-20220503221705649" style="zoom:33%;"></p></li></ul><h1 id="3-运行环境说明"><a href="#3-运行环境说明" class="headerlink" title="3. 运行环境说明"></a>3. 运行环境说明</h1><ul><li><p>操作系统：Windows 10</p></li><li><p>运行环境：Visual Studio Code</p></li><li><p>说明：编译链接Lexical或者Parser中的各个.cpp文件，然后运行main.cpp即可，Visual Studio Code环境下推荐CodeRunner插件一键运行；若更改源程序进行语法分析器的测试，请先运行词法分析器得到相应的token，再进行语法分析</p></li></ul><h1 id="3-课设总结"><a href="#3-课设总结" class="headerlink" title="3. 课设总结"></a>3. 课设总结</h1><p>​    本次课设花了将近两周的时间，首先由于是上学期学的编译原理，时间一长难免有些遗忘，所以在写代码前提前粗略地复习了一下之前学过的知识。在写代码过程中的同时，将理论知识转换成实际代码，也加深了我对编译原理课程所学知识的理解，也对我的代码能力有一定的提高。在写代码的过程中，感受到了选择一项好的数据结构的重要性，尤其是对C++中STL的实际应用，各种各样的数据结构让我体会到了STL的简便性。</p><p>​    在本次课设中，也遇到了一些磕磕碰碰，比如在进行语法分析器的设计，因为之前用的是书上的例子，导致之前开的保存项目集族的全局变量并没有很大，结果在代入自己的文法时，异常中断，最后通过开一大数组解决问题。还比如，在进行set的遍历时，删除了容器的部分元素，导致当前迭代器失效，通过预先获取下一步的迭代器，再删除现有的迭代器解决问题。</p><p>​    但是通过此次课程设计，让我体会到代码的模块化能够大大地节省编码过程中的调试时间，使代码逻辑层次更加清晰的好处。在编码过程中，将各个算法所用到的函数一个个写好，分阶段测试函数，整合算法，边写边检查和调试，就能够保证最终整合代码运行时报错模块数量最少。上学期虽然编译原理学得不错，但是转换成具体可用的程序来说，仍是有点陌生，但通过手动实现词法分析器和语法分析器，让我加深了对编译原理的理解和运用，总体来说收获颇丰。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;实现词法分析器&lt;/li&gt;
&lt;li&gt;实现语法分析器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="编译原理" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>区块链的一些简单理解</title>
    <link href="http://example.com/2022/04/12/2022-04-12-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2022/04/12/2022-04-12-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</id>
    <published>2022-04-11T16:22:17.000Z</published>
    <updated>2022-04-13T04:21:34.836Z</updated>
    
    <content type="html"><![CDATA[<p>关于比特币、以太坊、区块链结构</p><span id="more"></span><h1 id="比特币-区块链1-0"><a href="#比特币-区块链1-0" class="headerlink" title="比特币-区块链1.0"></a>比特币-区块链1.0</h1><ul><li><p>高度自治，</p></li><li><p>无国界贸易：</p><p><img src="https://i.bmp.ovh/imgs/2022/04/12/638806197ed4b7c7.png" style="zoom: 50%;"></p></li><li><p>不可篡改：交易一旦完成，交易数据不可篡改</p></li><li>隐私安全：每个用户可以拥有一个或多个账户，且无需提供用户信息，只需要提供密钥即可</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/12/f7ca63ac0036f299.png" style="zoom:50%;"></p><h2 id="去中心化模型"><a href="#去中心化模型" class="headerlink" title="去中心化模型"></a>去中心化模型</h2><p>去中心化模型：点对点（P2P）通信</p><p>去中心化<strong>并不是没有中心，而是中心不断的变化</strong>，每一次的中心都是由节点竞争而来</p><h2 id="账本隐私和快速对账"><a href="#账本隐私和快速对账" class="headerlink" title="账本隐私和快速对账"></a>账本隐私和快速对账</h2><p>比特币如何保护账本隐私：</p><ul><li>比特币系统利用<strong>哈希</strong>算法对交易信息进行加密、保护隐私<ul><li>交易信息：账户、信息内容</li></ul></li><li>哈希算法<ul><li><strong>能够提取事物的特征</strong></li><li>通过哈希值是<strong>无法反推</strong>出原来的明文</li><li>哈希算法 可以保护隐私和<strong>对账</strong><ul><li>只要哈希值不一样，账本中的数据就存在差异</li></ul></li></ul></li></ul><h2 id="账本一致性"><a href="#账本一致性" class="headerlink" title="账本一致性"></a>账本一致性</h2><p>比特币系统规则：<strong>最长链</strong>为可信任的链条</p><p>比特币中的<strong>矿工</strong>：创造区块，使链增长</p><p><img src="https://i.bmp.ovh/imgs/2022/04/12/78b98e299aa26c30.png" alt=""></p><h3 id="争夺记账权的方式：工作量证明"><a href="#争夺记账权的方式：工作量证明" class="headerlink" title="争夺记账权的方式：工作量证明"></a><strong>争夺记账权的方式：工作量证明</strong></h3><ul><li><p>工作量证明（Proof of Work）简称<strong>POW</strong></p></li><li><p>节点通过竞争PoW求解来获取记账权</p><ul><li>包括区块挖掘在内的区块链活动都是具有<strong>强时效性</strong>的竞争活动，竞争过程中，拥有<strong>哈希和拓扑优势</strong>的节点将有更高的概率获胜</li></ul></li><li><p>通过重复计算Nonce直至哈希值小于目标哈希值的过程：挖矿；这一整套算法成为POW算法</p></li><li><p>算力的体现就是单位时间内Nounce尝试的次数</p><p><a href=""><img src="https://s1.ax1x.com/2022/04/12/LnFzMd.png" style="zoom: 67%;"></a></p></li><li><p>伪造账本想要成为朱利安，必须要和比特币系统其余的人比拼算力，只有长时间的保持算力优先，才有伪造账本的可能。但<strong>保持长时间的算力优先的难度巨大</strong>，有可能高于伪造账本的获利</p></li></ul><h2 id="比特币的分叉"><a href="#比特币的分叉" class="headerlink" title="比特币的分叉"></a>比特币的分叉</h2><ul><li>不同矿工，使用不同版本的比特币系统进行挖矿，导致链条分叉<ul><li>硬分叉：系统的更新导致出现分支，无法合并,比如区块的扩容、</li><li>软分叉：可以合并</li></ul></li><li>这是矿工再比特币系统 协议层面上产生了分歧</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>比特币不是一种货币，是一个分布式的账本系统</p></li><li><p>账本记录交易过程，由节点广播道网络，保持其余节点数据一致</p></li></ul><hr><h1 id="区块链技术的形成"><a href="#区块链技术的形成" class="headerlink" title="区块链技术的形成"></a>区块链技术的形成</h1><p>区块链技术</p><ul><li>分布式数据存储<ul><li>每个参与者电脑上备份</li><li>账本实时同步和对账–&gt;保证公开透明</li></ul></li><li>点对点传输</li><li>共识机制<ul><li>比特币系统的主链容易出现短暂的分叉，这个分叉最终是会合并到主链上去的</li><li>比特币系统采用pow算法保证了账本的一致性，也让比特币系统变得更加安全可靠</li></ul></li><li>加密算法</li></ul><h1 id="以太坊-区块链2-0"><a href="#以太坊-区块链2-0" class="headerlink" title="以太坊-区块链2.0"></a>以太坊-区块链2.0</h1><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><strong>比特币的不足</strong>：</p><ul><li>交易速度慢</li><li>POW算法、耗电</li><li>仅仅完成了货币的去中心化，而现实中货币的价值建立在国家的公信力的基础上。</li></ul><p><strong>以太坊的改进</strong>：</p><ul><li><p>交易速度加快</p></li><li><p>POW+POS算法，逐步向POS算法过度</p></li><li><p>引入<strong>智能合约</strong></p><ul><li><p>不受人为因素的影响，没有黑幕</p></li><li><p>违反规则，直接扣除保证金</p></li></ul></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>以太坊</strong>是运行在计算机网络中的<strong>软件</strong>，它确保<strong>数据</strong>以及<strong>智能合约的小程序</strong>可以在没有中心协调者的情况下，被所有网络中的 计算机复制和处理</p><p><strong>以太坊平台能够承载应用</strong></p><p>以太坊的愿景是创建一个<strong>无法停止</strong>，<strong>抗屏蔽</strong>（审查）和<strong>自我维持</strong>的<strong>去中心化</strong>世计算机</p><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>智能合约：跑在以太坊系统中的合同，其实质是<strong>一段代码</strong></p><ul><li>它们像公示出来的法律合同，违反它们的人将遭到处罚</li></ul><p><strong>智能合约</strong>能表达：<strong>规则明确，不受主观因素影响</strong>的业务、规则不轻易修改的业务</p><ul><li>如果业务规则经常变化，无法通过智能合约编写，因为智能合约小程序一旦写完，运行在以太坊，是无法通过软件升级去进行规则更新的</li></ul><h2 id="ghost协议"><a href="#ghost协议" class="headerlink" title="ghost协议"></a>ghost协议</h2><p>以太坊快速出块产生的问题：区块分叉</p><hr><h1 id="区块链结构"><a href="#区块链结构" class="headerlink" title="区块链结构"></a>区块链结构</h1><p><img src="https://i.bmp.ovh/imgs/2022/04/13/eb0ad5cd836bb5a6.png" style="zoom:50%;"></p><p>Merkle树，快速<strong>归纳和校验大</strong>规模数据完整性的数据结构</p><ul><li>最下面的<strong>叶子节点存储哈希值或数据</strong></li><li>每个中间节点是<strong>两个子结点的内容的哈希值</strong>，</li><li><p>根节点也是两个子结点内容的哈希值</p></li><li><p>只要存储数据的叶子节点由任何的变动，都会传递道相应的父节点，<strong>导致其Merkle树的根节点发生变化</strong></p></li></ul><h2 id="区块链的P2P网络"><a href="#区块链的P2P网络" class="headerlink" title="区块链的P2P网络"></a>区块链的P2P网络</h2><h3 id="混合式：集中式-分布式"><a href="#混合式：集中式-分布式" class="headerlink" title="混合式：集中式+分布式"></a>混合式：集中式+分布式</h3><ul><li><p>网络中存在多个<strong>超级节点</strong>组成的<strong>分布式</strong>网络</p></li><li><p>而每个超级节点由多个<strong>普通节点</strong>和它组成局部的<strong>集中式</strong>网络</p></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/340e3a8ce5c9f06e.png" style="zoom: 33%;"></p><ul><li>新节点的加入：<ul><li>先选择一个超级节点进行通信</li><li>该超级节点再推送给其他超级节点列表给新加入节点<ul><li><strong>洪泛广播只发生在超级节点</strong>之间，避免大规模洪泛</li></ul></li><li>加入节点根据列表中的超级节点状态选择一个具体的超级节点作为父节点</li></ul></li></ul><hr><h3 id="比特币网络：混合式"><a href="#比特币网络：混合式" class="headerlink" title="比特币网络：混合式"></a>比特币网络：混合式</h3><p><strong>所有节点</strong>都会 </p><ul><li>参与校验、广播交易和区块信息；</li><li>发现和维持与其他节点的连接</li></ul><p><strong>全节点Full Node</strong></p><ul><li><p>承担网络中<strong>交易和区块的验证</strong>工作</p></li><li><p>包含<strong>完整的区块链数据库</strong>，包括所有交易数据</p></li></ul><p><strong>轻节点（LightWeight Node）或SPV节点</strong></p><ul><li>只存储区块链数据库的<strong>一部分</strong><ul><li>一般<strong>只存储区块头</strong>而不存储交易数据，通过<strong>简化交易验证（SPV）</strong>完成交易检验</li><li>验证<strong>前置交易</strong>的有效性</li></ul></li></ul><hr><p>比特币网络中的节点四大功能（只有<strong>比特币核心节点</strong>才会包含所有四大功能）：</p><ul><li>钱包 <strong>W</strong>allet<ul><li>PC或手机客户端的功能，用户通过钱包查看自己的账户余额，管理钱包地址和密钥，发起交易等</li><li>除了<strong>比特币核心钱包是全节点</strong>，大部分钱包都是轻节点</li></ul></li><li>挖矿 <strong>M</strong>iner<ul><li>挖矿节点通过解决<strong>PoW算法</strong>问题，与其他挖矿节点相互<strong>竞争创建新区块</strong></li><li><strong>独立矿工</strong>：全节点，存储完整的区块链数据库</li><li><strong>矿池矿工</strong>：和<strong>其他节点一起</strong>连接到矿池，参与集体挖矿<ul><li>形成了一个<strong>集中式矿池网络</strong>，中心节点是一个矿池服务器，其他挖矿节点全部连接到矿池服务器</li></ul></li></ul></li><li>区块链数据库 Full <strong>B</strong>lockchain</li><li>网络路由 <strong>N</strong>etwork Routing Node</li></ul><hr><p>整个比特币网络：</p><ul><li><strong>主网络</strong>：不同节点间使用<strong>比特币协议作</strong>为通信协议的的网络</li><li><strong>矿池网络</strong>：扩展网络<ul><li>不同的矿池网络可能使用不同的矿池挖矿协议<ul><li>Stratum协议：支持挖矿节点，支持瘦客户钱包</li></ul></li></ul></li><li>矿池矿工和矿池服务器之间的通信协议：<strong>矿池挖矿协议</strong></li><li>矿池服务器作为全节点与其他比特币节点使用<strong>主网络的比特币协议</strong>通信</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/98092e4534e957d3.png" alt=""></p><p>比特币传播网络（比特币中继网络）：</p><p>一个专门的传播网络：<strong>加快新区块在矿工之间的同步传播</strong></p><p>矿工创建新区块后，需要<strong>广播给全网</strong>所有节点，当全网都接受了该区块，给矿工的挖矿奖励才有效，然后才好开始下一个区块Hash的计算；</p><ul><li>矿工必须最大限度缩短区块的广播和下一个区块计算之间的时间</li></ul><hr><h3 id="结构化P2P"><a href="#结构化P2P" class="headerlink" title="结构化P2P"></a><strong>结构化P2P</strong></h3><ul><li>分布式网络：<strong>结构化</strong>网络、所有节点<strong>按照某种结构有序</strong>组织<ul><li>对比分布式网络：随机网络</li></ul></li><li>结构化网络的实现，基于DHT算法<ul><li><strong>DHT</strong>（Distributed Hah Table，分<strong>布式哈希表</strong>） <ul><li>网络模型，不涉及具体实现</li><li>解决分布式环境下快速准确地路由、定位数据</li><li>具体的实现算法：Chord、CAN、Kademlia等等<ul><li>以太坊网络采用Kademlia</li></ul></li></ul></li></ul></li></ul><hr><h4 id="DHT"><a href="#DHT" class="headerlink" title="DHT"></a><strong>DHT</strong></h4><p>P2P的两种空间：</p><ul><li>资源空间：所有节点保存的<strong>资源集合</strong></li><li>节点空间：所有<strong>节点的集合</strong></li></ul><p>对所有资源和节点编号：对资源名称或内容用<strong>hash函数变成一个数值</strong></p><ul><li>一个资源一个ID、一个节点一个ID、资源ID和节点ID建立映射关系</li><li>将资源n的<strong>索引信息</strong>存到节点n上，要搜资源n，则找节点n<ul><li>能够避免洪泛广播</li><li>能够快速准确路由 和 定位数据</li></ul></li></ul><p>DHT算法在资源编号和节点编号上使用 <strong>分布式哈希表</strong>，使得资源空间和节点空间的编号具有唯一性、均匀分布式</p><hr><h3 id="以太坊网络：结构化P2P"><a href="#以太坊网络：结构化P2P" class="headerlink" title="以太坊网络：结构化P2P"></a>以太坊网络：结构化P2P</h3><ul><li>采用<strong>Kad</strong>emlia算法实现：分布式哈希技术</li></ul><p>Kad网络</p><ul><li>每个节点由一个唯一的节点ID</li><li>不同节点间的距离：逻辑距离，两个节点ID<strong>异或</strong>得到</li><li>给定一个节点a和距离L，<strong>有且仅有一个节点</strong>使得a^b=L</li><li>通过这种方式能有效度量Kad网络中不同节点间的逻辑距离</li></ul><hr><p>近期的区块链架构</p><p><img src="https://i.bmp.ovh/imgs/2022/04/13/bcd6f70393329c9e.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于比特币、以太坊、区块链结构&lt;/p&gt;</summary>
    
    
    
    <category term="信安赛" scheme="http://example.com/categories/%E4%BF%A1%E5%AE%89%E8%B5%9B/"/>
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>【总结】字符串处理总结</title>
    <link href="http://example.com/2022/04/08/2022-04-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2022/04/08/2022-04-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</id>
    <published>2022-04-08T02:35:34.000Z</published>
    <updated>2022-07-12T09:07:02.062Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容：<ul><li>总结各类模拟题型中的一些字符串处理</li></ul></li></ul><span id="more"></span><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><strong>C语言里压根就没有string这个类</strong>，所以字符串都是通过<strong>char数组</strong>来存储的，而<string.h>这个头文件里声明的函数原型也全是针对char数组的种种操作。<strong>直到C++中才出现了string这个类</strong>(注意是类，不是类型)</string.h></p><h1 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> 大写字母 = 小写字母-<span class="string">'a'</span>+<span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span> 大写字母 = <span class="built_in">toupper</span>(小写字母);</span><br><span class="line"><span class="comment">//cout&lt;&lt;(char)toupper(c[i])直接cout要类型转换，因为toupper返回的时int的ascii</span></span><br><span class="line"><span class="keyword">char</span> 小写字母 = <span class="built_in">tolower</span>(大写字母);</span><br></pre></td></tr></tbody></table></figure><h1 id="string-char-int-之间的相互转换"><a href="#string-char-int-之间的相互转换" class="headerlink" title="string char[] int 之间的相互转换"></a>string char[] int 之间的相互转换</h1><h2 id="string-转-char"><a href="#string-转-char" class="headerlink" title="string 转 char[]"></a>string 转 char[]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">a=s.<span class="built_in">c_str</span>(); <span class="comment">//string转char数组</span></span><br></pre></td></tr></tbody></table></figure><h2 id="string-转-int"><a href="#string-转-int" class="headerlink" title="string 转 int"></a>string 转 int</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s=<span class="string">"123"</span>;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">stoi</span>(s); <span class="comment">//output:123</span></span><br><span class="line"><span class="comment">//同理还有：</span></span><br><span class="line"><span class="comment">//stoll():转换成long long</span></span><br><span class="line"><span class="comment">//stod():转换成double；stof():转换成floay</span></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></tbody></table></figure><h2 id="char-转-string"><a href="#char-转-string" class="headerlink" title="char[] 转 string"></a>char[] 转 string</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[]=<span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line">string s=ch</span><br></pre></td></tr></tbody></table></figure><h2 id="char-转-int"><a href="#char-转-int" class="headerlink" title="char[] 转 int"></a>char[] 转 int</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[]=<span class="string">"124"</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">atoi</span>(ch);</span><br></pre></td></tr></tbody></table></figure><h2 id="int-转-string"><a href="#int-转-string" class="headerlink" title="int 转 string"></a>int 转 string</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">123</span>;</span><br><span class="line">string s=<span class="built_in">to_string</span>(a);</span><br></pre></td></tr></tbody></table></figure><h2 id="int-转-char"><a href="#int-转-char" class="headerlink" title="int 转 char[]"></a>int 转 char[]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number =<span class="number">123</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">itoa</span>(number, s, <span class="number">10</span>);<span class="comment">//将number转换成十进制存在s数组中</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number =<span class="number">123</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(s,<span class="string">"%d"</span>,number);<span class="comment">//将number转换成十进制存在s数组中</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></tbody></table></figure><h1 id="字符串读取"><a href="#字符串读取" class="headerlink" title="字符串读取"></a>字符串读取</h1><h2 id="getline-cin-string-namae-end-char-读取一行"><a href="#getline-cin-string-namae-end-char-读取一行" class="headerlink" title="getline(cin,string_namae,end_char)读取一行"></a>getline(cin,string_namae,end_char)读取一行</h2><p>接受一个字符串，可以接受空格并输出</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str; </span><br><span class="line"><span class="built_in">getline</span>(cin,str); <span class="comment">//输入：ss ss ss</span></span><br><span class="line">cout&lt;&lt;str&lt;&lt;endl;  <span class="comment">//输出：ss ss ss</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin,str,<span class="string">'a'</span>);<span class="comment">//一个直到‘a’结束，其中任何字符包括'\n'都能够读入</span></span><br></pre></td></tr></tbody></table></figure><p>当同时使用<code>cin&gt;&gt;</code>和<code>getline(cin,str)</code>的时候，在<code>cin&gt;&gt;</code>输入完成之后，<code>getline(cin,str)</code>(str是真正想要的串)之前，需要<strong>先</strong><code>getline(cin,str)</code>（这个str是一个打算用来存储换行符的串）；<font color="red">将换行从输入流缓存中清除</font></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">string line;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">getline</span>(cin,line); <span class="comment">//清除缓存的换行!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="built_in">getline</span>(cin,line);</span><br></pre></td></tr></tbody></table></figure><h2 id="gets-char-读取一行"><a href="#gets-char-读取一行" class="headerlink" title="gets(char*)读取一行"></a>gets(char*)读取一行</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> t[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">gets</span>(t);</span><br><span class="line"><span class="built_in">puts</span>(t);</span><br></pre></td></tr></tbody></table></figure><h1 id="STL-string常用方法"><a href="#STL-string常用方法" class="headerlink" title="STL string常用方法"></a>STL string常用方法</h1><h2 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string line=<span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">int</span> st=<span class="number">3</span>,len=<span class="number">2</span>;</span><br><span class="line">string s1=<span class="built_in">substr</span>(line,st,len);</span><br><span class="line"><span class="comment">//从line的st位置开始，截取len长度的字符串</span></span><br></pre></td></tr></tbody></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> idx= line.<span class="built_in">find</span>(<span class="string">"cde"</span>);<span class="comment">//查得到则返回第一个下标，</span></span><br><span class="line"><span class="comment">//找不到会返回一个诡异的数字（反正比字符串长）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx=line.<span class="built_in">find</span>(<span class="string">"cde"</span>,<span class="number">2</span>);<span class="comment">//从第index=2的位置往后找</span></span><br></pre></td></tr></tbody></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">"0123456"</span>;</span><br><span class="line">string s=<span class="string">"aa"</span>;</span><br><span class="line">str=s.<span class="built_in">insert</span>(<span class="number">4</span>,s);<span class="comment">//0123aa456</span></span><br><span class="line"><span class="comment">//在str[4]之前插入s</span></span><br></pre></td></tr></tbody></table></figure><h2 id="大小写转换-1"><a href="#大小写转换-1" class="headerlink" title="大小写转换"></a>大小写转换</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transform(处理对象容器起始地址，处理对象容器结束地址，存放结果的容器地址，处理操作（可自定义））</span></span><br><span class="line"><span class="built_in">transform</span>( str.<span class="built_in">begin</span>() , str.<span class="built_in">end</span>() , str.<span class="built_in">begin</span>() , ::tolower );<span class="comment">//化为小写</span></span><br><span class="line"><span class="built_in">transform</span>( str.<span class="built_in">begin</span>() , str.<span class="built_in">end</span>() , str.<span class="built_in">begin</span>() , ::toupper );<span class="comment">//化为大写</span></span><br></pre></td></tr></tbody></table></figure><h1 id="string-h头文件"><a href="#string-h头文件" class="headerlink" title="string.h头文件"></a>string.h头文件</h1><p><code>strlen(char*)</code></p><p><code>strcmp(char* a, char* b)</code>字典序比较</p><ul><li>a&lt;b;返回负整数</li><li>a==b;返回0</li><li>a&gt;b;返回正整数</li></ul><p><code>strcpy(char* a ,char* b)</code>把a复制给b</p><p><code>strcat(char* a ,char* b)</code>把b接到a后面</p><h1 id="sscanf和sprintf"><a href="#sscanf和sprintf" class="headerlink" title="sscanf和sprintf"></a>sscanf和sprintf</h1><p><code>scanf(char* , "" ,&amp;)</code></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> t[<span class="number">100</span>]; <span class="built_in">gets</span>(t);<span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">sscanf</span>(t,<span class="string">"%d"</span>,a);<span class="comment">//把t以整型格式输入到a中</span></span><br><span class="line"><span class="built_in">sscanf</span>(t,<span class="string">"%d:%lf,%s"</span>,&amp;n,&amp;db,str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(t,<span class="string">"%d"</span>,a);<span class="comment">//把整型的a输出到字符串t中</span></span><br></pre></td></tr></tbody></table></figure><h1 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"aaa"</span>,b[]=<span class="string">"aaa"</span>;  </span><br><span class="line">string A = <span class="string">"AAA"</span>, B = <span class="string">"AAA"</span>;  </span><br><span class="line">cout &lt;&lt;<span class="string">"*a和*b的值分别是："</span> &lt;&lt;*a &lt;&lt; <span class="string">"，"</span> &lt;&lt; *b &lt;&lt; endl;  </span><br><span class="line">cout &lt;&lt;<span class="string">"*“aaa”的值是："</span>&lt;&lt; *<span class="string">"aaa"</span> &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的比较方法：</span></span><br><span class="line">cout &lt;&lt;<span class="string">"利用 == 比较a,b两个字符串，结果是（相等为1，不等为0）："</span> &lt;&lt;(a==b) &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的比较方法:</span></span><br><span class="line">cout &lt;&lt; <span class="string">"利用strcmp()比较a，b两个字符串，结果是（相等为0，不等非0）："</span>&lt;&lt;<span class="built_in">strcmp</span>(a,b) &lt;&lt; endl;  </span><br><span class="line">cout &lt;&lt; <span class="string">"利用 == 比较A,B两个string，结果是（相等为1，不等为0）："</span>&lt;&lt;(A==B) &lt;&lt; endl;  </span><br><span class="line">cout &lt;&lt; <span class="string">"利用compare()比较A,B两个string，结果是（相等为0，不等非0）："</span> &lt;&lt; A.<span class="built_in">compare</span>(B) &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br></pre></td></tr></tbody></table></figure><h1 id="int-isdigit-char"><a href="#int-isdigit-char" class="headerlink" title="int isdigit(char)"></a>int isdigit(char)</h1><p><code>isdigit</code>是计算机C(C++)语言中的一个函数，主要用于检查其参数<strong>是否为十进制数字字符</strong>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span> <span class="comment">//C</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span>  <span class="comment">//C++</span></span></span><br><span class="line"><span class="comment">//检查参数 c 是否为阿拉伯数字0 到9。</span></span><br><span class="line"><span class="comment">//若参数c为阿拉伯数字0~9，则返回非0值，否则返回0。</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容：&lt;ul&gt;
&lt;li&gt;总结各类模拟题型中的一些字符串处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【题解】贪心</title>
    <link href="http://example.com/2022/03/28/2022-03-28-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E8%B4%AA%E5%BF%83/"/>
    <id>http://example.com/2022/03/28/2022-03-28-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E8%B4%AA%E5%BF%83/</id>
    <published>2022-03-28T03:17:01.000Z</published>
    <updated>2022-04-04T01:33:00.120Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>一些贪心的题：区间问题、Huffman树、排列不等式、其他类型</li></ul></li></ul><span id="more"></span><h1 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h1><font color="red">区间问题的贪心一般都是上来先按左端点or右端点排序</font><p>然后手动模拟一下贪心，找性质，多找几组样例试试</p><h2 id="AcWing905-区间选点"><a href="#AcWing905-区间选点" class="headerlink" title="AcWing905 区间选点"></a>AcWing905 区间选点</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定<strong>N个闭区间</strong>，在数轴上选择尽量少的点，使<strong>每个区间至少包含</strong>一个选出的点，求选择的点的<strong>最小数量</strong></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/d297674baef4ce99.png" alt=""></p><ul><li>将每个区间<strong>按右端点</strong>从小到大<font color="red">排序</font></li><li>按照这个顺序从小到大<strong>枚举每个区间</strong><ul><li>对于当前区间，比如首先选择区间①的右端点，区间②、③都<strong>包含</strong>该点，所以直接pass（不在②、③区间选择点），继续往后枚举</li><li>当枚举到区间④时，发现区间①的右端点<strong>不在</strong>区间④内，所以此时<strong>选择</strong>区间④的右端点</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>,INF=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>{</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="comment">//重载小于号，按r从小到大排序 </span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Range&amp;W)<span class="keyword">const</span>{</span><br><span class="line"><span class="keyword">return</span> r&lt;W.r;</span><br><span class="line">}</span><br><span class="line">}range[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;range[i].l&gt;&gt;range[i].r;</span><br><span class="line"><span class="built_in">sort</span>(range,range+n);</span><br><span class="line"><span class="keyword">int</span> ed=-INF;  <span class="comment">//ed：当前区间右端点，初始化为最小值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(ed&lt;range[i].l){ <span class="comment">//如果前一个区间的右端点＜当前区间的左端点 </span></span><br><span class="line">ans++;</span><br><span class="line">ed=range[i].r;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing908-最大不相交区间数量"><a href="#AcWing908-最大不相交区间数量" class="headerlink" title="AcWing908 最大不相交区间数量"></a>AcWing908 最大不相交区间数量</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定<strong>N个闭区间</strong>，在数轴上<strong>选择若干区间</strong>，之间<strong>互不相交</strong>，求可选区间的<strong>最大</strong>数量</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li><strong>实际上和上题一样</strong>，区间相交 == 这几个区间能被同一个点覆盖 == 就只能从这几个区间中选择一个区间</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><ul><li>和上题一模一样</li></ul><h2 id="AcWing906-区间分组"><a href="#AcWing906-区间分组" class="headerlink" title="AcWing906 区间分组"></a>AcWing906 区间分组</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><ul><li><p>简单的理解，就是一种可以<strong>自动排序</strong>的队列</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;结构名,vector&lt;结构名&gt;,greater/less&lt;结构名&gt;&gt; 队列名</span><br><span class="line"><span class="comment">// greater代表升序,从小到大; less代表降序,从大到小</span></span><br><span class="line"><span class="comment">//比如小根堆:</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt;heap;</span><br><span class="line">heap.<span class="built_in">size</span>();</span><br><span class="line">heap.<span class="built_in">empty</span>();<span class="comment">//heap为空则返回1</span></span><br><span class="line">heap.<span class="built_in">push</span>(k);<span class="comment">//在heap队列中插入k</span></span><br><span class="line">heap.<span class="built_in">pop</span>();<span class="comment">//删除heap队列中的第一个元素,小根堆的话,就是删除最小的那个</span></span><br><span class="line">heap.<span class="built_in">top</span>();<span class="comment">//返回heap队列中的第一个元素,并不删除</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定<strong>N个闭区间</strong>，将其分组，使得<strong>每组</strong>里面的各个区间<strong>没有交集</strong>，求<strong>最小</strong>分组数量</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li><p>将所有区间按照<strong>左端点</strong> 从小到大<font color="red">排序</font></p></li><li><p>从前往后处理每个区间</p><ul><li><strong>判断能否将其放到</strong>某个 现有 的组中<code>L[i]＞MAX_r</code>：<strong>==</strong> 判断每一组的<strong>右端点最右</strong>的区间是否跟它<strong>有交集</strong> <ul><li>如果和每一个组都有交集，则开一个新的组，把当前区间放进去</li><li>如果和某一个组无交集，将当前组的<code>MAX_r</code>放进去，并更新<code>MAX_r</code></li></ul></li></ul></li><li><p>理解：循环到该区间时，在此之前有很多组，每组里面有很多个不相交的区间，<strong>每个组</strong>里面都有<strong>一个</strong>MAX_r；</p><p><img src="https://s3.bmp.ovh/imgs/2022/03/effb589caed4b102.png" style="zoom: 40%;"></p><p><img src="https://i.bmp.ovh/imgs/2022/03/6821c2d7023fdd3a.png" style="zoom:40%;"></p><p><img src="https://s3.bmp.ovh/imgs/2022/03/7e41023452060a5b.png" style="zoom:40%;"></p></li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>{</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Range&amp;M)<span class="keyword">const</span>{</span><br><span class="line"><span class="keyword">return</span> l&lt;M.l;</span><br><span class="line">}</span><br><span class="line">}range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> l,r; </span><br><span class="line">cin&gt;&gt;range[i].l&gt;&gt;range[i].r;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">sort</span>(range,range+n);</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(heap.<span class="built_in">empty</span>()||heap.<span class="built_in">top</span>()&gt;=range[i].l){<span class="comment">//第一个区间or当前区间左端点小于最小Max_r</span></span><br><span class="line">heap.<span class="built_in">push</span>(range[i].r);  <span class="comment">//新增一个</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">heap.<span class="built_in">pop</span>();  <span class="comment">//大于最小Max_r，就把堆顶那个最小Max_r弹出，更新为当前区间的r</span></span><br><span class="line">heap.<span class="built_in">push</span>(range[i].r);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;heap.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing907-区间覆盖"><a href="#AcWing907-区间覆盖" class="headerlink" title="AcWing907 区间覆盖"></a>AcWing907 区间覆盖</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p><strong>N个闭区间</strong>，一个线段区间[s,t] ，选择尽量<strong>少</strong>的区间，将指定<strong>线段区间完全覆盖</strong></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>将所有区间按<strong>左端点从小到大</strong>排序</li><li>从前往后依次枚举每个区间，<ul><li>在所有<strong>能覆盖s</strong>(左端点≤s的情况下)的区间中，选择一个<strong>右端点最大</strong>的区间</li><li>然后，将<strong>s更新</strong>为右端点的最大值</li><li><strong>直到</strong>右端点<strong>大于t</strong></li></ul></li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h1><h2 id="AcWing148-合并果子"><a href="#AcWing148-合并果子" class="headerlink" title="AcWing148 合并果子"></a>AcWing148 合并果子</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>N堆果子，每次<strong>任意合并两堆</strong>，每次合并消耗的体积等于这两堆重量之和，求合并完消耗的<strong>最小体力</strong></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>经典huffman模型，每次合并重量最小的两堆</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="comment">//定义小根堆：优先队列，对push进去的元素，会从小到大自动排序 </span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;heap;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> a;cin&gt;&gt;a;</span><br><span class="line">heap.<span class="built_in">push</span>(a);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(heap.<span class="built_in">size</span>()&gt;<span class="number">1</span>){</span><br><span class="line"><span class="comment">//每次取最小的两个合并 </span></span><br><span class="line"><span class="keyword">int</span> a=heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> b=heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line">ans+=(a+b);</span><br><span class="line"><span class="comment">//合并后再push到小根堆中 </span></span><br><span class="line">heap.<span class="built_in">push</span>(a+b);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h1><h2 id="AcWing913-排队打水"><a href="#AcWing913-排队打水" class="headerlink" title="AcWing913 排队打水"></a>AcWing913 排队打水</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p><strong>n个</strong>人排队打水，第i个人装满水的时间是ti，问如何排队使得所有人<strong>等待时间之和最小</strong></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p><a href="https://imgtu.com/i/q6ydhj"><img src="https://s1.ax1x.com/2022/03/29/q6ydhj.png" alt="q6ydhj.png" style="zoom: 50%;"></a></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[N];</span><br><span class="line">ll n,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">ans+=a[i]*(n-i<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing104-货舱选址"><a href="#AcWing104-货舱选址" class="headerlink" title="AcWing104 货舱选址"></a>AcWing104 货舱选址</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p><a href="https://imgtu.com/i/q6hctK"><img src="https://s1.ax1x.com/2022/03/29/q6hctK.png" alt="q6hctK.png" style="zoom: 33%;"></a></p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h1><h2 id="AcWing104-货仓选址"><a href="#AcWing104-货仓选址" class="headerlink" title="AcWing104 货仓选址"></a>AcWing104 货仓选址</h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>数轴上N个坐标，求一个坐标到每个坐标的距离之和最小，求距离最小值</p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>这个点在中间</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll n,ans;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++){</span><br><span class="line">ans+=<span class="built_in">abs</span>(a[n<span class="number">-1</span>-i]-a[i]);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h1 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h1><h2 id="AcWing1055-股票购买"><a href="#AcWing1055-股票购买" class="headerlink" title="AcWing1055 股票购买"></a>AcWing1055 股票购买</h2><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><p>长度为 N数组，第 i个数字表示一个给定股票在第 i天的价格。</p><p>计算你所能获取的<strong>最大利润</strong>。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>低买高出就行</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;a[i+<span class="number">1</span>]){</span><br><span class="line">ans+=a[i+<span class="number">1</span>]-a[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;一些贪心的题：区间问题、Huffman树、排列不等式、其他类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>DIP-2-频率域滤波</title>
    <link href="http://example.com/2022/03/24/2022-03-06-DIP-2-%E5%82%85%E9%87%8C%E5%8F%B6/"/>
    <id>http://example.com/2022/03/24/2022-03-06-DIP-2-%E5%82%85%E9%87%8C%E5%8F%B6/</id>
    <published>2022-03-24T13:10:02.000Z</published>
    <updated>2022-03-25T08:29:20.564Z</updated>
    
    <content type="html"><![CDATA[<ul><li>关于一些 让我自己觉得<strong>我自己就是个智障</strong>QAQ的东西  瞎几把乱写的通俗理解</li></ul><span id="more"></span><ul><li>任何<strong>周期函数</strong>，都可以看作 不同振幅、不同相位<strong>正弦波的叠加</strong></li><li>滤波：从某条曲线中去除一些特定的频率成分</li><li><p>频率分量：不同频率的正弦波</p><ul><li>将角频率为ω0的正弦波cos（ω0）看作基础，那么频域的基本单元就是ω0</li></ul></li><li><p>cos(0t)也就是一条直线，可以理解成一个周期长的正弦波</p><ul><li>所以在频率域，0频率 称为 直流分量</li></ul></li><li>频域的基本单元也可以理解为<strong>一个始终在旋转的圆</strong></li><li>简单说就是如果从时间域分析信号时，时间是横坐标振幅是纵坐标。而在<strong>频率域</strong>分析的时候则是<strong>频率是横坐标</strong>，<strong>振幅是纵坐标</strong></li><li><p>频域图像，也就是俗称的<strong>频谱</strong></p></li><li><p>空间域就是你看到的一个个像素。频率域就是空间域经过傅立叶变换的信号</p></li><li>在 图像处理中，频域反应了图像在空域<strong>灰度变化剧烈程度</strong>，也就是图像<strong>灰度的变化速度</strong>，也就是图像的梯度大小。对图像而言，图像的边缘部分是突变部分，变化较 快，因此反应在频域上是高频分量；图像的噪声大部分情况下是高频部分；图像平缓变化部分则为低频分量。也就是说，傅立叶变换提供另外一个角度来观察图像， 可以将图像从灰度分布转化到频率分布上来观察图像的特征。书面一点说就是，傅里叶变换提供了一条从空域到频率自由转换的途径。</li></ul><hr><ul><li>二维傅里叶变换就是 <strong>将一个图像分解称若干个复平面波之和</strong></li></ul><p>二维连续傅里叶变换的公式：</p><script type="math/tex; mode=display">F（u,v)=\int_{-\infin}^{+\infin} \int_{-\infin}^{+\infin} f(x,y)e^{-j2\pi(ux+vy)}dxdy</script><p>将<strong>图像f</strong> 与<strong>每个不同频率的不同方向的复平面波</strong>做内积</p><p>给定一幅图像f, 能够算出<strong>每个平面波在图像中的成分是多少</strong></p><p>也就说，求这个图像 ，在<strong>基上的投影</strong></p><ul><li>傅里叶谱的<strong>每个位置存储的数</strong>代表了所在位置复平面波 在图像中的成分占多数，</li><li>每个位置存储的数* 该位置所代表的平面波求和得到原来的图像</li></ul><p>已知一幅图像f（x,y), 二维离散傅里叶变换公式，一对uv值对应了基底的一种形式，也就是对应了一个对应频率下的复平面波，那么F（u，v）的模就可以用来在这个频率下的复平面波对图像的影响，可以把它看作一个权重，表示该频率对图像的贡献程度，傅里叶谱</p><ul><li>傅里叶谱，中间部分代表低频，四周代表高频</li><li><p>不同的频率有不同的幅度，</p><ul><li>如果谱中 ，亮度越高 ，意味着频幅越大，亮度越按，意味着频幅越小</li><li>而这个频幅，又代表这对应的该频率对原图像的影响程度<ul><li>一幅图像分解成 若干个 不同频率的复平面波之和，这个之和 应该是带权相加，而那个频幅就相当于这个权</li></ul></li></ul></li><li><p>频谱图中的每一个点都与空域中的<strong>整幅图像相关</strong>，相当于每一个点都代表一个用于表示原图的波或者频率；这个点越亮，代表着用于表示原图的那个频率占比越重</p></li><li>频域是一个全局的概念。<strong>低频高频，都是对于整幅图片而言的</strong>。低频幅度大 是因为图片大部分区域都是缓慢变化的，而锐利的边缘则非常稀疏（即高频幅度小）</li><li>频谱上的点与空域上的点不是一一对应的。<strong>频谱上每一点都与空域所有点有关</strong>，反之，空域每一点都与频谱上所有点有关。这可以从傅里叶变换的公式直观看出来。</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;关于一些 让我自己觉得&lt;strong&gt;我自己就是个智障&lt;/strong&gt;QAQ的东西  瞎几把乱写的通俗理解&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="数字图像处理Digital Image Processing" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86Digital-Image-Processing/"/>
    
  </entry>
  
</feed>
