<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiaN</title>
  
  <subtitle>是一只废物捏</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-22T12:40:40.276Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>LiaN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件设计模式</title>
    <link href="http://example.com/2022/03/22/2022-03-22-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/22/2022-03-22-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-22T09:55:34.000Z</published>
    <updated>2022-03-22T12:40:40.276Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>装饰者模式、</li></ul></li><li>参考资料：《HeadFirst设计模式》</li></ul><span id="more"></span><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><ul><li>不用继承如何达到复用？<ul><li><strong>组合和委托</strong> 可以在运行时具有继承行为的结果</li><li>利用继承设计子类的行为，是在编译时静态决定的，而且所有子类都会继承到相同的行为。如果利用组合 扩展对象的行为，就可以在运行时动态扩展</li><li>通过<strong>动态地组合对象</strong>，可以写新的代码添加新功能 且 无需修改现有代码</li></ul></li></ul><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><ul><li>内容：<strong>类应该对扩展开放，对修改关闭</strong></li><li>允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为：<ul><li>这样设计具有弹性</li><li>可以应对改变</li><li>可以接受新的功能来应对改变的需求</li></ul></li></ul><h2 id="认识装饰者模式"><a href="#认识装饰者模式" class="headerlink" title="认识装饰者模式"></a>认识装饰者模式</h2><ul><li>例如：以“饮料”为<strong>主体</strong>，在运行时以调料来“<strong>装饰</strong>”饮料</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/a0d7fddf8d6a7266.png" style="zoom: 67%;" /><img src="https://i.bmp.ovh/imgs/2022/03/b5619a2a5ba71c61.png" alt=""></p><p><img src="https://i.bmp.ovh/imgs/2022/03/b5619a2a5ba71c61.png" style="zoom:69%;" /></p><h2 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h2><ul><li>装饰者和被装饰者：<strong>相同的超类型</strong><ul><li>在任何需要<strong>原始对象</strong>（被包装）的场合，都可以用<strong>装饰过的对象</strong>代替它</li></ul></li><li><strong>一个 or 多个</strong>装饰者 包装一个对象</li><li>对象可以在<strong>任何时候</strong>被装饰<ul><li>运行时 <strong>动态地、不限量</strong>地装饰</li></ul></li><li><font color="red">装饰者可以在<strong>所委托</strong>的被装饰者的<strong>行为</strong>之前 与/或 之后，加上自己的<strong>行为</strong>，以达到特定目的</font><ul><li>这里的行为，或者说是<strong>责任</strong>，实际上指的就是…可以实现的一些<strong>功能</strong></li></ul></li></ul><h2 id="定义装饰者模式"><a href="#定义装饰者模式" class="headerlink" title="定义装饰者模式"></a>定义装饰者模式</h2><ul><li>定义：<font color="red">动态地将<strong>责任</strong> 附加到对象上。若要扩展功能，装饰者提供了比继承更有<strong>弹性</strong>的替代方案</font></li></ul><h2 id="装饰者模式的类图"><a href="#装饰者模式的类图" class="headerlink" title="装饰者模式的类图"></a>装饰者模式的类图</h2><p><img src="https://i.bmp.ovh/imgs/2022/03/54ca5a8ca57c2592.png" alt=""></p><ul><li><p><strong>重点说明</strong></p><ul><li>看似Decorator扩展子Component类，但是，重点在于：<font color="green">装饰者和被装饰者 必须类型一致</font>，也就是<font color="green">有共同的超类</font><ul><li>换言之，就是利用继承达到“<strong>类型匹配</strong>”，而不是利用继承获得“行为”</li></ul></li><li>因为装饰者<strong>必须能取代</strong>被装饰者，所有它们必须有相同的“接口”</li><li>当装饰者与组件组合时，就是在加入新的行为，所得到的新的行为，<strong>并不继承子超类，而是由组合对象得来</strong><ul><li>行为如果不是来自超类，就是子类覆盖后的版本</li><li>可以在任何时候，实现新的装饰者增加新的行为</li></ul></li></ul></li></ul><h2 id="一个栗子实现"><a href="#一个栗子实现" class="headerlink" title="一个栗子实现"></a>一个栗子实现</h2><p><img src="https://i.bmp.ovh/imgs/2022/03/34829ab9f6f28015.png" style="zoom: 67%;" /></p><h3 id="首先实现最上面的抽象类Beverage"><a href="#首先实现最上面的抽象类Beverage" class="headerlink" title="首先实现最上面的抽象类Beverage"></a>首先实现最上面的抽象类Beverage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    String discription = <span class="string">&quot;Unknown Beverage&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDiscription</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> discription;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cost必须在子类中实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="然后实现下面的抽象类Condiment"><a href="#然后实现下面的抽象类Condiment" class="headerlink" title="然后实现下面的抽象类Condiment"></a>然后实现下面的抽象类Condiment</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩展自Beverage，这样就能取代Beverage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDiscription</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写饮料的代码（具体组件（被装饰对象））"><a href="#写饮料的代码（具体组件（被装饰对象））" class="headerlink" title="写饮料的代码（具体组件（被装饰对象））"></a>写饮料的代码（具体组件（被装饰对象））</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span></span>&#123;</span><br><span class="line">discription = <span class="string">&quot;Espresso&quot;</span>;</span><br><span class="line">    &#125;<span class="comment">//实例变量discription继承自Beverage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="写调料代码（具体装饰者）"><a href="#写调料代码（具体装饰者）" class="headerlink" title="写调料代码（具体装饰者）"></a>写调料代码（具体装饰者）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span></span>&#123;</span><br><span class="line">    <span class="comment">//要让Mocha引用一个Beverage</span></span><br><span class="line">    <span class="comment">//也就是之前所说的：每个装饰者都有一个组件（被装饰者），也就是说，装饰者有一个实例变量来保存某个Component的引用</span></span><br><span class="line">    Beverage beverage;</span><br><span class="line">    <span class="comment">//把饮料（被装饰者）当作构造器的参数，将其记录在实例变量中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.beverage = beverage;<span class="comment">//运行时才知道</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用“委托”，得到被装饰者的Discription，再附加自己的“，Mocha”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDiscription</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> beverage.getDiscription() + <span class="string">&quot;,Mocha&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用“委托”，得到被装饰者的cost，再加上自己的cost</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.20</span>+beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>装饰者模式优缺点</strong><ul><li>优：比静态继承有更多的灵活性；在高层类中防止过多特征</li><li>缺：太多小类（指的是 具体的装饰者类），导致复用变得复杂</li></ul></li><li><strong>装饰者模式使用时机</strong><ul><li>需要为一个对象动态的添加责任（功能），并且不影响其他对象</li><li>处理可撤销的责任（？啥意思）</li><li>当生成子类不可行的时候，比如需要大量子类来支持各种排列组合（类爆炸）</li></ul></li><li><strong>其他要点</strong><ul><li>继承是扩展的一种形式，但 并不是获得灵活性最好的方式</li><li>组合 和 委托 可以用在动态时添加新行为</li><li>装饰者类 反映了它们所装饰对象的类型</li><li>可以将一个组件用任意数量的装饰者包装</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;装饰者模式、&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;参考资料：《HeadFirst设计模式》&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="软件设计模式" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>搜索与图论</title>
    <link href="http://example.com/2022/03/22/2022-03-22-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    <id>http://example.com/2022/03/22/2022-03-22-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</id>
    <published>2022-03-22T01:55:34.000Z</published>
    <updated>2022-03-22T07:48:49.443Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li></li></ul></li></ul><span id="more"></span><h1 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h1><ul><li>栈stack、O(h)、不具有最短性</li><li>回溯、剪枝儿</li></ul><h2 id="AcWing842-排列数字"><a href="#AcWing842-排列数字" class="headerlink" title="AcWing842 排列数字"></a>AcWing842 排列数字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==n)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cout&lt;&lt;path[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">path[k]=i;</span><br><span class="line">st[i]=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(k+<span class="number">1</span>);</span><br><span class="line">path[k]=<span class="number">0</span>;</span><br><span class="line">st[i]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing843-n皇后问题"><a href="#AcWing843-n皇后问题" class="headerlink" title="AcWing843 n皇后问题"></a>AcWing843 n皇后问题</h2><h1 id="宽度优先搜索BFS"><a href="#宽度优先搜索BFS" class="headerlink" title="宽度优先搜索BFS"></a>宽度优先搜索BFS</h1><ul><li>队列queue、O(2^h)、最短路(只有所有边权都是1 的时候才可以用BFS做最短路问题)</li></ul><h2 id="AcWing844-走迷宫"><a href="#AcWing844-走迷宫" class="headerlink" title="AcWing844 走迷宫"></a>AcWing844 走迷宫</h2><h1 id="树与图的DFS"><a href="#树与图的DFS" class="headerlink" title="树与图的DFS"></a>树与图的DFS</h1><ul><li>有向图<ul><li>邻接矩阵（用的比较少，g[a] [b])，不能存储重边</li><li>邻接表：每个节点开了一个表，存着这个点可以走到哪个点</li></ul></li></ul><h1 id="树与图的BFS"><a href="#树与图的BFS" class="headerlink" title="树与图的BFS"></a>树与图的BFS</h1>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="图论" scheme="http://example.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="搜索" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://example.com/2022/03/22/2022-03-22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/03/22/2022-03-22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-22T01:55:34.000Z</published>
    <updated>2022-03-22T09:10:31.732Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>链表、栈和队列、kmp、</li></ul></li></ul><span id="more"></span><h1 id="链表与邻接表"><a href="#链表与邻接表" class="headerlink" title="链表与邻接表"></a>链表与邻接表</h1><h2 id="数组模拟单链表（邻接表）"><a href="#数组模拟单链表（邻接表）" class="headerlink" title="数组模拟单链表（邻接表）"></a>数组模拟单链表（邻接表）</h2><ul><li>邻接表：常用于存储图和树</li></ul><h3 id="AcWing826-单链表（模板题）"><a href="#AcWing826-单链表（模板题）" class="headerlink" title="AcWing826 单链表（模板题）"></a>AcWing826 单链表（模板题）</h3><ul><li>来说，如果想删除链表第一个节点，会说“删除头结点”，如果想删除整个链表，会直接说“删除整个链表”~ head是指向头结点的指针，它本身是不存节点的，只是<strong>指向了整个链表的第一个节点</strong>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="comment">//head=头结点下标</span></span><br><span class="line"><span class="comment">//e[i]:节点i的值</span></span><br><span class="line"><span class="comment">//ne[i]:节点i的下一个的坐标</span></span><br><span class="line"><span class="comment">//idx:当前用到了哪个点 </span></span><br><span class="line"><span class="keyword">int</span> head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">head=<span class="number">-1</span>;</span><br><span class="line">idx=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//将x插入到头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">e[idx]=x;</span><br><span class="line">ne[idx]=head;</span><br><span class="line">head=idx;</span><br><span class="line">idx++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//将x插到下标是k的点的后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">e[idx]=x;</span><br><span class="line">ne[idx]=ne[k];</span><br><span class="line">ne[k]=idx;</span><br><span class="line">idx++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">ne[k]=ne[ne[k]];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="comment">//别忘记初始化</span></span><br><span class="line"><span class="built_in">init</span>(); </span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> k,x;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line">cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">cin&gt;&gt;x;<span class="built_in">add_to_head</span>(x);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>) head=ne[head];</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">remove</span>(k<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line"><span class="built_in">add</span>(k<span class="number">-1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head;i!=<span class="number">-1</span>;i=ne[i]) cout&lt;&lt;e[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组模拟双链表"><a href="#数组模拟双链表" class="headerlink" title="数组模拟双链表"></a>数组模拟双链表</h2><ul><li>双链表：用来优化某些题</li></ul><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;链表、栈和队列、kmp、&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>关于刷题的其他零零碎碎</title>
    <link href="http://example.com/2022/03/18/2022-03-18-%E5%85%B3%E4%BA%8E%E5%88%B7%E9%A2%98%E7%9A%84%E5%85%B6%E4%BB%96%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/"/>
    <id>http://example.com/2022/03/18/2022-03-18-%E5%85%B3%E4%BA%8E%E5%88%B7%E9%A2%98%E7%9A%84%E5%85%B6%E4%BB%96%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/</id>
    <published>2022-03-18T11:08:20.000Z</published>
    <updated>2022-03-18T10:28:27.637Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>没有主要的，全是次要的</li></ul></li></ul><span id="more"></span><h1 id="cin读入加速"><a href="#cin读入加速" class="headerlink" title="cin读入加速"></a>cin读入加速</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;没有主要的，全是次要的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>数学知识</title>
    <link href="http://example.com/2022/03/18/2022-03-15-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/03/18/2022-03-15-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</id>
    <published>2022-03-18T03:08:20.000Z</published>
    <updated>2022-03-18T10:24:32.348Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>数论、组合计数、高斯消元、简单博弈论</li></ul></li></ul><span id="more"></span><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><ul><li>定义（素数/质数）：在<strong>大于1</strong> 的整数中，如果只包含1和本身这两个约数</li><li>质数判定：试除法 O(√n)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分解质因数：试除法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h1><script type="math/tex; mode=display">|S_{1}\cup S_{2}\cup S_{3}|=|S_{1}|+|S_{2}|+|S_{3}|-|S_{1}\cap S_{2}|-|S_{1}\cap S_{3}|-|S_{2}\cap S_{3}|+|S_{1}\cap S_{2}\cap S_{3}|</script><ul><li>依次类推</li><li></li></ul><h1 id="简单博弈论"><a href="#简单博弈论" class="headerlink" title="简单博弈论"></a>简单博弈论</h1>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;数论、组合计数、高斯消元、简单博弈论&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>模拟-枚举-排序</title>
    <link href="http://example.com/2022/03/15/2022-03-15-%E6%A8%A1%E6%8B%9F-%E6%9E%9A%E4%B8%BE-%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/03/15/2022-03-15-%E6%A8%A1%E6%8B%9F-%E6%9E%9A%E4%B8%BE-%E6%8E%92%E5%BA%8F/</id>
    <published>2022-03-15T08:18:55.000Z</published>
    <updated>2022-03-15T14:27:15.851Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>一些题…</li></ul></li></ul><span id="more"></span><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><h2 id="AcWing1210-连号区间数量"><a href="#AcWing1210-连号区间数量" class="headerlink" title="AcWing1210 连号区间数量"></a>AcWing1210 连号区间数量</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/1212/">1210. 连号区间数 - AcWing题库</a></p><p>概括：给定排列的数组 求连号区间的个数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>首先，有个概念：<strong>排列</strong>，一般地，从n个<strong>不同元素</strong>中取出m（m≤n）个元素，按照一定的顺序排成一列，叫做从n个元素中取出m个元素的一个排列。</li><li>既然从a[L]到a[R]数组内的元素如果排序后严格逐个递增，那么必有<strong>max-min=R-L</strong>；题目已经说了是排列，所以不可能有相同的多个元素</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> maxx=a[i],minn=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">maxx = <span class="built_in">max</span>(maxx,a[j]);</span><br><span class="line">minn = <span class="built_in">min</span>(minn,a[j]);</span><br><span class="line"><span class="keyword">if</span>(maxx-minn == j-i) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing1236-递增三元组"><a href="#AcWing1236-递增三元组" class="headerlink" title="AcWing1236 递增三元组"></a>AcWing1236 递增三元组</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/1238/">1236. 递增三元组 - AcWing题库</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>首先考虑暴力求解，但至少三重循环，不太行，考虑如何优化：</li><li>根据数据范围 1e5 反推，时间复杂度最多时nlogn的，并且至少会有一层遍历n，所有考虑logn的算法</li><li>所以 可以循环遍历Bi，然后在A中找小于Bi的，在C中找大于Bi的；考虑用 <strong>前缀和</strong> 或者 <strong>二分</strong>的方法<ul><li>要求的是满足条件的三元组个数，则只需要 找到A中小于Bi个数，C中大于Bi的个数，相乘即可</li></ul></li><li><strong>细节</strong>：<ul><li></li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],b[N],c[N],sa[N],sc[N],s[N],cnt[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),a[i]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]),b[i]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]),c[i]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[a[i]]++;  <span class="comment">//sa[i]: 数组a中值等于i的个数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++) s[i]=s[i<span class="number">-1</span>]+cnt[i];  <span class="comment">//s[i]:数组中的值 小于等于i 的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sa[i]=s[b[i]<span class="number">-1</span>] ;<span class="comment">//a[i]表示 小于b[i]的个数 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span> s);</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span> cnt);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[c[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++) s[i]=s[i<span class="number">-1</span>]+cnt[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sc[i]=s[N<span class="number">-1</span>]-s[b[i]];</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">ans=ans+(LL)sa[i]*sc[i];</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;一些题…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>树状数组和线段树</title>
    <link href="http://example.com/2022/03/15/2022-03-15-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://example.com/2022/03/15/2022-03-15-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2022-03-15T03:08:20.000Z</published>
    <updated>2022-03-18T01:46:33.187Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>树状数组、线段树</li></ul></li></ul><span id="more"></span><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><ul><li>可以<strong>动态地、快速 求前缀和</strong> ； logN<ul><li>给某个位置的数 <strong>加上</strong> 一个数<strong>（单点修改）</strong></li><li>求某一个前缀和 <strong>（区间查询）</strong></li></ul></li><li>它只能解上述单点修改和区间查询问题，其他问题要<strong>转换成</strong>这种类型的才可以解</li><li>数组下标<strong>从1开始</strong></li></ul><blockquote><p>下图来源：<a href="https://www.acwing.com/solution/content/7526/">AcWing 1264. 动态求连续区间和 - AcWing</a></p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/03/c0f519a47e871e3c.png" style="zoom:60%;" /></p><ul><li><code>lowbit(x) = x &amp; -x = 2^k</code>：其中k：x末尾0的个数</li><li>``</li></ul><h2 id="AcWing1264-动态求连续区间和（模板题）"><a href="#AcWing1264-动态求连续区间和（模板题）" class="headerlink" title="AcWing1264 动态求连续区间和（模板题）"></a>AcWing1264 动态求连续区间和（模板题）</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="comment">//a原数组，tr树状数组 </span></span><br><span class="line"><span class="keyword">int</span> a[N],tr[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值= 2^k，其中k等于x二级制末尾0的个数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第i个数上加上v ，对应的树状数组发生改变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第1个数到第x个数的前缀和 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i)) res+=tr[i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">add</span>(i,a[i]);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> k,x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;k,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(y)-<span class="built_in">query</span>(x<span class="number">-1</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">add</span>(x,y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-1265数星星"><a href="#AcWing-1265数星星" class="headerlink" title="AcWing 1265数星星"></a>AcWing 1265数星星</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/1267/">1265. 数星星 - AcWing题库</a></p><p>概括：给定 N 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>动态输入每个点的坐标的时候，对于当前刚输入的点的坐标，它的左下方的坐标刚好是 当前输入点x方向左方的所有坐标</li><li>因此，只需要求出当前x坐标左边的星星个数即可；即可转换成求前缀和；</li><li>由于每输入一个星星坐标，对于前缀和数组，该星星后面的前缀和数组的值都会+1，所以可以看成一个动态区间求前缀和的 问题，因此完全可以转换成树状数组来求解</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">15005</span>,M=<span class="number">32005</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans[M],tr[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=<span class="number">32001</span>;i+=<span class="built_in">lowbit</span>(i)) tr[i]+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i;i-=<span class="built_in">lowbit</span>(i)) res+=tr[i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">x++; <span class="comment">//树状数组的下标从1 开始</span></span><br><span class="line"><span class="built_in">add</span>(x,<span class="number">1</span>);</span><br><span class="line">ans[<span class="built_in">query</span>(x)]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><ul><li>线段树能处理的范围包含树状数组</li><li>代码短、常数小</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;树状数组、线段树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="线段树" scheme="http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    <category term="树状数组" scheme="http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://example.com/2022/03/12/2022-03-12-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://example.com/2022/03/12/2022-03-12-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-03-12T03:17:01.000Z</published>
    <updated>2022-03-22T01:01:54.010Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>背包问题、线性DP</li></ul></li></ul><span id="more"></span><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/ceb293ff41829c0a.png" style="zoom:50%;" /></p><ul><li><strong>动态规划</strong><ul><li><strong>状态表示</strong>：f（i，j）<ul><li>表示的集合是啥<ul><li>01背包里面表示的所有满足条件选法的集合</li><li>满足的条件<ul><li>只从前 i 个物品选</li><li>选出来的物品的总体积≤ j</li></ul></li></ul></li><li>表示的集合属性：<strong>最大值</strong>、最小值、数量<ul><li>01背包：f（i，j）的值是集合里面所有选法的总价值的最大值</li></ul></li></ul></li><li><strong>状态计算</strong>：集合的划分<ul><li>选法中不含第 i 个物品 f（ i - 1，j ）， 选法中含第 i 个物品（先把所有选法中 的第i个物品去掉，f（ i - 1，j - vi ）+ wi ，再加上；最终的f（i，j）== 二者中的最大者</li><li>原则：不重 （不一定非要满足） 不漏</li></ul></li></ul></li><li><strong>DP优化</strong><ul><li>一般都是对动态规划的代码（方程）做一个等价变形</li><li>所以先考虑基本的形式，再做优化</li></ul></li></ul><hr><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><ul><li>N个物品，容量是V的背包</li><li>每个物品：体积v，价值w； 每个物品<strong>最多只能用一次</strong></li><li>从这N个物品挑几个使得 ：总体积≤V 且价值max</li><li><a href="https://www.bilibili.com/video/BV1Cf4y1R7Zz?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click">参考视频：0/1背包问题-动态规划 bilibili</a></li></ul><hr><h3 id="AcWing2-01背包问题（模板题）"><a href="#AcWing2-01背包问题（模板题）" class="headerlink" title="AcWing2 01背包问题（模板题）"></a>AcWing2 01背包问题（模板题）</h3><p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题 - AcWing题库</a></p><h4 id="代码（二维）"><a href="#代码（二维）" class="headerlink" title="代码（二维）"></a>代码（二维）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,v[N],w[N],dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  <span class="comment">//放前i个物品 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;  <span class="comment">//体积不超过j </span></span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j]; <span class="comment">//如果当前物品容量大于j，不能放进去</span></span><br><span class="line"><span class="comment">//如果当前物品体积小于j，说明能够放进去</span></span><br><span class="line"><span class="comment">//所以选择 不放进该物品 和 放进该物品 中取较大者 </span></span><br><span class="line"><span class="keyword">if</span>(v[i]&lt;=j) dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果要知道哪几个背包放进去</strong>：</p><ul><li>用数组x[N]存是否放进去</li><li>参考视频：<a href="https://www.bilibili.com/video/BV1jT4y1o71J?spm_id_from=333.337.search-card.all.click">【动态规划秘籍】01背包、一维数组优化、完全背包bilibili</a><img src="https://i.bmp.ovh/imgs/2022/03/a2a62e99dbe531ac.png" style="zoom:40%;" /></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j=m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[i][j]&gt;dp[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">x[i]=<span class="number">1</span>;j=j-v[i];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">x[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">cout&lt;&lt;x[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="代码（优化成一维）"><a href="#代码（优化成一维）" class="headerlink" title="代码（优化成一维）"></a>代码（优化成一维）</h4><ul><li>如果是j的遍历是顺序的话，那么之后的某个值的更新就用到的是新的值，而不是之前的旧值；所以要逆序</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/cfb0e6853cd99acc.png" style="zoom:33%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  <span class="comment">//放前i个物品 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=v[i];j--)&#123; <span class="comment">//放前i个物品的容量=j ;倒序</span></span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">cout&lt;&lt;dp[m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><ul><li>每种物品有<strong>无限个</strong></li><li>一般思路：<a href="https://www.acwing.com/solution/content/5345/">图片来源</a><img src="https://i.bmp.ovh/imgs/2022/03/c6822f5a883c96fa.png" style="zoom:50%;" /></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k*v[i]&lt;=j;k++)</span><br><span class="line">     dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-k*v[i]]+k*w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><ul><li>优化一下：</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/cf17394aaa99fae9.png" style="zoom:50%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line"><span class="keyword">if</span>(v[i]&lt;=j)&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对比01背包和完全背包</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]]+w[i]);<span class="comment">//01背包</span></span><br><span class="line"></span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j],f[i][j-v[i]]+w[i]);<span class="comment">//完全背包问题</span></span><br></pre></td></tr></table></figure><ul><li>再优化成一维</li><li>理解对比和01背包的遍历顺序：<ul><li>01背包问题中，在j - v[i]体积的情况下，里面不能存在v[i]这个物品，也就是说在求状态dp[j]的时候，dp[j -v[i]]还不能被更新过（<strong>后面的计算要用到前面的变量，所以在更新后面的时候，前面的数据不能变，所以从后往前</strong>），所以dp[j -v[i]]要放在dp[j]后更新，用递减循环的方式实现这个功能。</li><li>若内层循环顺序进行的话，就代表了在j-v[i]体积的情况下，里面还存有v[i]这个物品，对于同一件物品，会计算多次，直到有其他物品加入满足最优解 大于一件被计算多次后的值为止。–&gt; 完全背包</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt;=n ;i++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j = v[i] ; j&lt;=m ;j++)<span class="comment">//注意了，这里的j是从小到大枚举，和01背包的唯一不一样</span></span><br><span class="line">   &#123;</span><br><span class="line">           f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><ul><li>每种物品有<strong>有限个</strong></li><li>dp[ i ] [ j ]: 选前i种物品且总体积为 j 的方案的集合；方案的数量</li><li>状态转移，第i种物品选0，1，2 . . . .s[i]个 </li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s[i]&amp;&amp;k*s[i]&lt;=j;k++)&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-v[i]*k]+w[i]*k);</span><br></pre></td></tr></table></figure><ul><li><p>二进制优化版</p><p>第  i  种物品有s个，就可以把<strong>这 s 个物品拆分成 logs 组物品</strong>，每组物品只能用一次；转换成<strong>01背包问题</strong>，<strong>注意状态数量的大小 N*logS</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">20000</span>;<span class="comment">//N*logS =1010*12</span></span><br><span class="line"><span class="keyword">int</span> v[N],w[N],s[N];</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,V;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//进行二进制分组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,s;cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;=s)&#123;</span><br><span class="line">cnt++;</span><br><span class="line">v[cnt]=a*k;</span><br><span class="line">w[cnt]=b*k;</span><br><span class="line">s-=k;</span><br><span class="line">k*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">cnt++;</span><br><span class="line">v[cnt]=a*s;</span><br><span class="line">w[cnt]=b*s;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//直接用01背包求解</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=v[i];j--)</span><br><span class="line">dp[j]=<span class="built_in">max</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[V]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><ul><li>物品N组，每组物品有<strong>若干个</strong>，每组里面<strong>最多选一个</strong></li><li>关于这几种背包，写<code>dp[i][j]=max(dp[i][j],dp[i-1][j-xx]+yy)</code>，如果括号里面后者当某个下标==0 能够包含不选第i种物品的情况，可以直接就这么写，如果不能包含，就要先加一句<code>dp[i][j]=dp[i-1][j]</code>然后再<code>if xxx</code>，<code>dp[i][j]=max(dp[i][j],dp[i-1][j-xx]+yy)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> v[N][N],w[N][N],dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,V;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;V;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">cin&gt;&gt;s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s[i];j++)&#123;</span><br><span class="line">cin&gt;&gt;v[i][j]&gt;&gt;w[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=V;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=s[i];k++)</span><br><span class="line">    <span class="keyword">if</span>(v[i][k]&lt;=j) <span class="comment">//if不能放在上面的for里面，不然会直接break掉，不会++ 遍历该组后面的物品，而该组后面的物品的体积可能小于等于j是能够满足条件的</span></span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[N][V]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing1015-摘花生"><a href="#AcWing1015-摘花生" class="headerlink" title="AcWing1015 摘花生"></a>AcWing1015 摘花生</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/0f3b1eda54789be3.png" style="zoom:30%;" /></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> t,R,C,dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">cin&gt;&gt;R&gt;&gt;C;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=R;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=C;j++)&#123;</span><br><span class="line">cin&gt;&gt; dp[i][j];</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[R][C]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h1><ul><li>DP的时间复杂度一般等于 <strong>状态数量 乘以 转移的计算量</strong></li><li><a href="https://www.acwing.com/solution/content/10499/">下图来源</a><img src="https://i.bmp.ovh/imgs/2022/03/042685e65e6af425.png" alt=""></li></ul><h2 id="AcWing898-数字三角形"><a href="#AcWing898-数字三角形" class="headerlink" title="AcWing898 数字三角形"></a>AcWing898 数字三角形</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/900/">898. 数字三角形 - AcWing题库</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>整个过程中在不断做决策，到达某一点时，它要么从左上方来到该点，要么从右上方来到该点；注意考虑边缘的情况，初始化dp数组为最小值；注意dp数组的含义，达到路径之和最大并不是一定会走到dp[ N ] [ M ]整个点，而是在最后一行中取最大值</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> a[N][N],dp[N][N];</span><br><span class="line"><span class="comment">//dp(i,j)：走到i，j的路径的集合；值为走到i,j的路径之和最大值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) cin&gt;&gt;a[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i+<span class="number">1</span>;j++)</span><br><span class="line">dp[i][j]=-INF;</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> res=-INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">res=<span class="built_in">max</span>(res,dp[n][j]);</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing895-最长上升子序列"><a href="#AcWing895-最长上升子序列" class="headerlink" title="AcWing895 最长上升子序列"></a>AcWing895 最长上升子序列</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/a61f3906e9a02f30.png" style="zoom:45%;" /></p><ul><li>dp[i]：以 a[i]结尾的最长上升子序列的长度</li><li>初始值 dp[i]=1,i∈[0,n−1] 表示自己就是最长上升子序列，长度为 1</li><li>接下来考虑状态转移，把前 i−1个数字中所有满足条件 dp[j]&lt;dp[i]（上升子序列） 的 j找出来，那么dp[i] 就可以试着更新为以 <strong>dp[j] 结尾的最长上升子序列的长度+自己的长度 1</strong>，但可能更新完的结果没有之前更新过的 dp[i] 大，最后两者取一个 max</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N],dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="comment">//dp[i]：表示最后一个数是a[i]的子序列的集合,值为max</span></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=<span class="number">1</span>;<span class="comment">//初值要为1 ,因为可能a[i]之前的值都比a[i]大,</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j]&lt;a[i]) </span><br><span class="line">dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">ans = <span class="built_in">max</span>(ans,dp[i]);<span class="comment">// 求得每个以a[i]结尾的最长上升子序列的长度后dp[i],求最大值 </span></span><br><span class="line">&#125; </span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing897-最长公共子序列"><a href="#AcWing897-最长公共子序列" class="headerlink" title="AcWing897 最长公共子序列"></a>AcWing897 最长公共子序列</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="comment">//dp[i][j]以选到a[i]和b[j]结尾的满足条件子序列长度 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=y;i++) cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=y;j++)&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j])</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[x][y]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing-902-最短编辑距离"><a href="#AcWing-902-最短编辑距离" class="headerlink" title="AcWing 902 最短编辑距离"></a>AcWing 902 最短编辑距离</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/904/">902. 最短编辑距离 - AcWing题库</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>将字符串A变成B有三种操作，每次都会选一种（决策），想知道不同决策的最优结果</li><li>dp[i] [j] 表示：将A的前i个字符变成B的前j个字符的操作集合；注意dp数组的初始化<ul><li>插入<code>dp[i][j-1]+1</code></li><li>删除<code>dp[i-1][j]+1</code></li><li>替换<code>dp[i-1][j-1]+1</code></li><li>如果<code>a[i]==b[j]</code>，啥也不干</li></ul></li></ul><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> a[N],b[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;a+<span class="number">1</span>;  <span class="comment">//使得 字符数组下标从1 开始</span></span><br><span class="line">cin&gt;&gt;m&gt;&gt;b+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) dp[i][<span class="number">0</span>] = i;  <span class="comment">//B数组为空，A全删除</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) dp[<span class="number">0</span>][i] = i;  <span class="comment">//A数组为空，A全插入</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j])+<span class="number">1</span>;</span><br><span class="line">dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(a[i]!=b[j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[n][m]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing1212-地宫寻宝"><a href="#AcWing1212-地宫寻宝" class="headerlink" title="AcWing1212 地宫寻宝"></a>AcWing1212 地宫寻宝</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/1214/">1212. 地宫取宝 - AcWing题库</a></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><blockquote><p>今天看到了橙子哥大佬的ppt上面的话，搬下来就是：</p><p> “    <strong>动态规划=分治+记录子问题答案</strong>以避免重复解决子问题带来的巨大开销。<br>      按照我的理解，对于<strong>一件要做 n 个决策</strong>的事情，我们想知道不同决策的最优结果（或不同决策的方案数）。如果枚举每个决策的不同选择，根据乘法原理，这样的方案数很大。而如果不同的决策能够到达的局面数较小，那么我们选择不去记录如何决策，而去<strong>记录到达某一个局面时的状态</strong>，以及思考当前这个局面，做了某个决策后<strong>会到达哪些局面</strong>。<br>     这样来看，动态规划并不是一种算法，而是一种能够解决一类问题的方法。   ”</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2022/03/8f0d3f67eec0b63f.png" style="zoom:35%;" /></p><ul><li>回归正题，在这个题的过程中，要不断<strong>做决策</strong>——》 往下走or往右走 ，选当前宝贝or不选 ， 可以往动态规划的方向上思考</li><li>题目最终要求的是走到(n,m)，且选了k件宝贝，并且最大价值为c的方案数；</li><li>或许可以根据题目最终要达到的目的 来设置状态数组<code>dp[i][j][u][v]</code>:当走到(i,j)时,已选了u件且当前最大价值时 v 的方案数量 </li><li><strong>细节：</strong>物品的<strong>价值可以是0</strong>，在初始化时，对于在(1,1)位置，为了用0描述不选第一件物品，可以对所有物品价值做+1处理；如果方案数大于MOD，多于3个MOD相加会爆int，所以每两个方案数相加的时候都要模上MOD</li><li>对于<code>dp[i][j][u][v]</code>的状态转移<ul><li>走到（i，j）时，并没有选当前位置上的物品：<ul><li>从上往下 走到（i，j）：<code>dp[i-1][j][u][v]</code></li><li>从左往右 走到（i，j）:<code>dp[i][j-1][u][v]</code></li></ul></li><li>走到（i，j）时，<strong>若能够选上</strong>当前位置上的物品。说明在到（i，j）之前的最大价值c‘ 必须＜v，同时该物品的价值<code>v == w[i][j]</code>：<ul><li>从上往下 走到（i，j）：<code>dp[i-1][j][u-1][c&#39;]</code></li><li>从左往右 走到（i，j）:<code>dp[i][j-1][u-1][c&#39;]</code></li></ul></li></ul></li><li>最后对所有走到(n,m)，且选了k件宝贝，并且最大价值为1到C+1的方案数求和</li></ul><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">55</span>,M=<span class="number">15</span>,MOD=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,dp[N][N][M][M],w[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">cin&gt;&gt;w[i][j]; w[i][j]++;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;  <span class="comment">//不选第一件</span></span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>][w[<span class="number">1</span>][<span class="number">1</span>]]=<span class="number">1</span>; <span class="comment">//选第一件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;=k;u++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;M;v++)&#123;</span><br><span class="line">dp[i][j][u][v]=(dp[i][j][u][v]+dp[i<span class="number">-1</span>][j][u][v])%MOD;</span><br><span class="line">dp[i][j][u][v]=(dp[i][j][u][v]+dp[i][j<span class="number">-1</span>][u][v])%MOD;</span><br><span class="line"><span class="keyword">if</span>(v==w[i][j]&amp;&amp;u&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;w[i][j];c++)&#123;</span><br><span class="line">dp[i][j][u][v]=(dp[i][j][u][v]+dp[i<span class="number">-1</span>][j][u<span class="number">-1</span>][c])%MOD;</span><br><span class="line">dp[i][j][u][v]=(dp[i][j][u][v]+dp[i][j<span class="number">-1</span>][u<span class="number">-1</span>][c])%MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;M;i++) ans=(ans+dp[n][m][k][i])%MOD;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing1214-波动数列"><a href="#AcWing1214-波动数列" class="headerlink" title="AcWing1214 波动数列"></a>AcWing1214 波动数列</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/1216/">1214. 波动数列 - AcWing题库</a></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ul><li><p><strong>首先知道一下同余式</strong>：</p><ul><li><p>设m是给定的一个正整数，a、b是整数：</p></li><li><p><strong>a和b被m除时有相同的余数</strong>：记为a≡b(mod m)，或记为a≡b(m)。这个式子称为模m的同余式</p></li><li><p>同余式一边的数可以移到另一边，只要改变符号就可以了。若</p><script type="math/tex; mode=display">a+b ≡ c (mod\quad m)</script><p> 则</p><script type="math/tex; mode=display">a≡c-b (mod\quad m)</script></li></ul></li><li><p>根据题意，假设数列第一个数是x，则依次有<code>x</code>，<code>x+d1</code>，<code>x+d1+d2</code>… … <code>x+d1+d2+...+d(n-1)</code> 之和 等于s，将其变换处理一下</p><script type="math/tex; mode=display">nx+(n-1)d_{1}+(n-2)d_{2}+(n-3)d_{3}+...+d_{n-1} = s</script><p>因为x可以是任意数，将其分离出来可得：</p><script type="math/tex; mode=display">x=\frac{s-((n-1)d_{1}+(n-2)d_{2}+(n-3)d_{3}+...+d_{n-1})}{n}</script><p>所以，只要<code>s%n</code> (已知)与<code>后面那坨%n</code> 同余即可</p><script type="math/tex; mode=display">s\%n == ((n-1)d_{1}+(n-2)d_{2}+(n-3)d_{3}+...+d_{n-1}) \%n</script></li><li><p>故就演变成了：给定n-1个<code>di</code>  ，取值只能是<code>+a</code> 或者<code>-b</code>，求如何选取这<code>n-1</code>个数 使得满足条件（就是一个组合问题，很像背包问题对叭对）</p></li><li><p>设 <code>dp[ i ][ j ]</code> 表示选了前i个数<code>di</code>（就是确定了对应每个位置是该+a还是-b），使得<code>i * di</code>之和 %n的余数等于 j  的方案数</p><blockquote><p>题目最终要求：选了n-1个di，使得<code>i * di</code> 之和%n的余数 等于s%n</p></blockquote></li><li><p>状态转移： <code>dp[ i ][ j ]</code> 已经选了  i - 1 个数，再选第 i 个数使得之和 %n的余数为 j 的：</p><ul><li>若确定当前要选的第i个数为 +a：<code>dp[i-1][?]</code></li><li>若确定当前要选的第i个数为 -b ：<code>dp[i-1][??]</code></li></ul></li><li><p>要确定？和？？，首先设选完前 i-1 个数 的和为 C，一共有n-1个数</p><ul><li>若第i个数为+a<ul><li><code>j ≡ C + (n-i)*a (mod n)</code> （同余式：左边和右边模上n有相同的余数</li><li>所以，<code>C ≡ j-(n-i)*a (mod n)</code> ; 同理可以分析-b的情况</li></ul></li></ul></li><li><p>总结<img src="https://i.bmp.ovh/imgs/2022/03/6f1cfb0567a79d94.png" style="zoom:25%;" /></p></li></ul><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">100000007</span>;</span><br><span class="line"><span class="keyword">int</span> n,s,a,b,dp[<span class="number">1005</span>][<span class="number">1005</span>]; </span><br><span class="line"><span class="comment">//x%y要取正的余数 因为j=[1,n-1] </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMod</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x%y+y)%y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="comment">//dp[i][j]：前i项之和模n的余数 等于j的方案 数量</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//什么都不选是一种方案 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;  <span class="comment">//注意边界，i有n-1个</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;  <span class="comment">//余数 0~n-1</span></span><br><span class="line">dp[i][j]=(dp[i<span class="number">-1</span>][<span class="built_in">getMod</span>(j-(n-i)*a,n)]+dp[i<span class="number">-1</span>][<span class="built_in">getMod</span>(j+(n-i)*b,n)])%MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[n<span class="number">-1</span>][<span class="built_in">getMod</span>(s,n)]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><ul><li>状态表示的是某一个区间</li></ul><h2 id="AcWing282-石子合并"><a href="#AcWing282-石子合并" class="headerlink" title="AcWing282 石子合并"></a>AcWing282 石子合并</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p><a href="https://www.acwing.com/problem/content/284/">282. 石子合并 - AcWing题库</a></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><ul><li>将第1到N堆石子合并再一起，最后一步一定是将两堆合并在一起<ul><li>设<strong>dp[i] [j]</strong>：把第i到j堆合并在一起，那么最后的步骤是将<strong>第i到k堆和第k+1到 j 堆</strong>合并在一起，然后加上合并这两堆的代价（用前缀和求出）。</li></ul></li><li>区间遍历通常是：<strong>遍历区间长度+左端点</strong></li><li>将数组赋值最大<code>memset(a,0x3f,sizeof a);</code></li></ul><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> INF=<span class="number">1e9</span>; </span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="comment">//dp[i][j]:将第i到j堆合并的方案集合 </span></span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;s[i];s[i]+=s[i<span class="number">-1</span>];</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//for(int i=0;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//for(int j=0;j&lt;=n;j++) dp[i][j]=INF;</span></span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][i]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//第一层遍历的是区间大小,“将一堆合并”并不需要代价 人家本来就是一堆 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+len<span class="number">-1</span>&lt;=n;l++)&#123;  <span class="comment">//第二层遍历左端点 </span></span><br><span class="line"><span class="keyword">int</span> r=l+len<span class="number">-1</span>;  <span class="comment">//根据区间大小得到右端点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=r<span class="number">-1</span>;k++)&#123;  <span class="comment">//区间内遍历  </span></span><br><span class="line">dp[l][r]=<span class="built_in">min</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]+s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计数类DP"><a href="#计数类DP" class="headerlink" title="计数类DP"></a>计数类DP</h1><h1 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h1><h1 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h1>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;背包问题、线性DP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>基础算法【合辑】</title>
    <link href="http://example.com/2022/03/10/2022-03-10-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%90%E5%90%88%E8%BE%91%E3%80%91/"/>
    <id>http://example.com/2022/03/10/2022-03-10-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%90%E5%90%88%E8%BE%91%E3%80%91/</id>
    <published>2022-03-10T10:53:25.000Z</published>
    <updated>2022-03-19T01:46:25.286Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>二分</li><li>前缀和</li><li>差分 </li><li>双指针</li></ul></li></ul><span id="more"></span><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><blockquote><p><em>22-03-10: 今天想起写个题,发现自己连二分都写得磕磕绊绊的,我焯,zyl大煞笔</em></p></blockquote><ul><li><p>确定一个区间，使得目标值在区间里面</p></li><li><p>找一个性质 ，满足两点</p><ul><li>性质 具有二段性（所有二分 都要成立<ul><li>前半段满足，后半段不满足，中间没有缺失的地方<img src="https://i.bmp.ovh/imgs/2022/03/20c5859b35eb05a8.png" style="zoom:50%;" /></li></ul></li><li>答案是二段性的分界点</li></ul></li><li><p><strong>整数二分</strong></p><ul><li><p>第一类：目标值是红色区间的右端点</p><blockquote><p>中点mid属于右半区间，则左半区间是[l, mid-1]，右半区间是[mid, r]，更新方式是r = mid - 1;或者 l = mid;</p></blockquote><ul><li>将[L,R] 分成 [L,M-1] ,[M,R]</li><li>if M是红色的, ans在[M,R]之间<ul><li>else ans 仍然在[L,M-1]</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">    M=(L+R+<span class="number">1</span>)/<span class="number">2</span>;   <span class="comment">//关键+1 ,上取整</span></span><br><span class="line">    <span class="keyword">if</span> M红 then L=M;  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span> R=M<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二类：目标值是绿色区间的左端点</p><blockquote><p>中点mid属于左半区间，则左半区间是[l, mid]，右半区间是[mid+1, r]，更新方式是r = mid;或者 l = mid + 1;</p></blockquote><ul><li>将[L,R]分成[L,M]和[M+1,R]</li></ul></li><li><p>if M绿色 ans在[L,M]之间</p><ul><li>else ans在[M+1,R]</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">M=(L+R)/<span class="number">2</span>;        <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> M绿 then R=M  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">else</span> L=M+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>整数二分的总结</strong></p><blockquote><p><em>y总说按这种写法可以完美避掉所有坑 //o//</em>:</p><p>首先通过题目背景和check(mid)函数的逻辑，判断答案落在左半区间还是右半区间。</p></blockquote><ul><li>找一个<strong>区间[L,R]</strong>使得答案一定在该区间中</li><li>找一个<strong>判断条件</strong>,使得该判断条件具有<strong>二段性</strong>,并且答案一定是该二段行的分界点</li><li>分析中点M在该判断条件下<strong>是否成立</strong>,如果成立or不成立,考虑答案在<strong>哪个区间</strong></li><li><font color="red">如果更新方式**R=Mid**,则**不用做任何处理**</font></li><li><font color="red">如果更新方式**L=Mid**,则需要在计算Mid时**先加上1**</font></li></ul></li><li><p>实数二分</p><ul><li>while（ R-L &gt;某个数） 1e-6 , 1e-8</li><li>if ans在[M,R] L=M</li><li>else ans在[L,M]  </li></ul></li></ul><h2 id="AcWing789-数的范围（模板题）"><a href="#AcWing789-数的范围（模板题）" class="headerlink" title="AcWing789 数的范围（模板题）"></a>AcWing789 数的范围（模板题）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="keyword">int</span> k;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>,R=n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line"><span class="comment">//从左到右找第一个≥k 的数 (符合性质的第一个点,第一个！！！！！左区间的右端点</span></span><br><span class="line"><span class="comment">//[L,Mid],[Mid+1,R] </span></span><br><span class="line"><span class="comment">// 1 2 2 3    3 4</span></span><br><span class="line"><span class="keyword">int</span> mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="comment">//如果a[mid]≥k，说明第一个≥k的数必然在此时的[L,Mid]之间 </span></span><br><span class="line"><span class="keyword">if</span>(a[mid]&gt;=k) R=mid;</span><br><span class="line"><span class="keyword">else</span> L=mid+<span class="number">1</span>;  <span class="comment">//L 往左挪,所以+ </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终L==R,判断条件这里写RL都行 </span></span><br><span class="line"><span class="keyword">if</span>(a[R]==k)&#123;</span><br><span class="line">cout&lt;&lt;R&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="comment">//第一个数确定后，第二个数在R到n-1之间;</span></span><br><span class="line">R=n<span class="number">-1</span>; </span><br><span class="line"><span class="comment">//从右往左找第一个≤k的数 （右区间的左端点</span></span><br><span class="line"><span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(L+R+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>; <span class="comment">// 因为先通过写L=Mid最后判断要+1 </span></span><br><span class="line"><span class="comment">//如果a[mid]≤k,说明 必然在[Mid,R]之间 </span></span><br><span class="line"><span class="keyword">if</span>(a[mid]&lt;=k) L=mid;</span><br><span class="line"><span class="keyword">else</span> R= mid<span class="number">-1</span>; <span class="comment">//R往右挪,所以- </span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;L&lt;&lt;endl;  </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//补充:莫名其妙被上面的部分小东西给绕着了，还是自己写比较能理解自己</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(L+R)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;k) L=mid+<span class="number">1</span>;   <span class="comment">//对于我这种笨比,觉得还是把上面这里调换一下顺序更好理解</span></span><br><span class="line">        <span class="keyword">else</span> R=mid;  <span class="comment">//＜k，说明在mid+1到R之间 L继续往后挪（L向 k靠近</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[R]==k)&#123;</span><br><span class="line">        cout&lt;&lt;R&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        R=n<span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(L+R+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid]&gt;k) R=mid<span class="number">-1</span>;   <span class="comment">//大于k，说明在L到mid-1之间，R继续往右挪（R向k靠近</span></span><br><span class="line">            <span class="keyword">else</span> L=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;L&lt;&lt;endl;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing1227-分巧克力"><a href="#AcWing1227-分巧克力" class="headerlink" title="AcWing1227 分巧克力"></a>AcWing1227 分巧克力</h2><ul><li><a href="https://www.acwing.com/problem/content/1229/">1227. 分巧克力 - AcWing题库</a></li></ul><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>N个Hi乘Wi的方格组成的长方形，划分出K个大小相同且最大的正方形</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>一个HxW的长方形，分割成边长为x的正方形的块数：</p><script type="math/tex; mode=display">\lfloor\frac{H}{x}\rfloor\times\lfloor\frac{W}{x}\rfloor</script></li><li><p>随着x的增大，分割出的块数 减小，故 一定存在当x增大到值时，分割出的块数==K； 故可以采用二分<img src="https://i.bmp.ovh/imgs/2022/03/88a1d02c8e12586f.png" style="zoom:33%;" /></p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,a[N][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// check=true是满足条件的，从0到x之间的部分，所以后面写的是l=mid</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span> <span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">sum+=(a[i][<span class="number">0</span>]/m)*(a[i][<span class="number">1</span>]/m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i][<span class="number">0</span>],&amp;a[i][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=N;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l==r) cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing730-机器人跳跃问题"><a href="#AcWing730-机器人跳跃问题" class="headerlink" title="AcWing730 机器人跳跃问题"></a>AcWing730 机器人跳跃问题</h2><p><a href="https://www.acwing.com/problem/content/732/">730. 机器人跳跃问题 - AcWing题库</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>N+1座建筑，第i座的高度H(i)，当在第k座时能量为E，跳到第k+1座后能量为E=2*E-H(k)；整个过程能力不能为负值，求最初能量最少是多少。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>对于某些题目提到求“最值”的问题，可以首先往二分的角度想一想=V=</li><li>设最初能量为e，随着e从小到大增加，一定能找到一个E，<ul><li>当初值＜E时，跳跃过程中存在能量值＜0 的情况；</li><li>当初值=E时，<strong>刚好 </strong>不存在能力值小于0的情况；</li><li>当初值＞E，同样也一定 不存在能力值＜0的情况，</li><li>当在中间的某一时刻能量值≥1e5的话后面必然不会存在＜0的情况，防止爆掉int，所以这里要判断一下</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//check==true：初始值为m 不会存在小于0的情况 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> e=m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">e=e*<span class="number">2</span>-a[i];</span><br><span class="line"><span class="keyword">if</span>(e&gt;N) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(e&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r=N;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//求满足条件的最小值 </span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AcWing1221-四平方和"><a href="#AcWing1221-四平方和" class="headerlink" title="AcWing1221 四平方和"></a>AcWing1221 四平方和</h2><p><a href="https://www.acwing.com/problem/content/1223/">1221. 四平方和 - AcWing题库</a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><blockquote><p>参考：<a href="https://www.acwing.com/solution/content/31631/">AcWing 1221. 四平方和 + 自定义排序（重载&lt;）+二分 - AcWing</a></p></blockquote><h4 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h4><ul><li><p>重载运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x：任意名字，node：结构体的名字</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;x) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">//排序规则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如下面结构体中的s,c,d</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Sum &amp;t) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s!=t.s) <span class="keyword">return</span> s&lt;t.s;</span><br><span class="line">    <span class="keyword">if</span>(c!=t.c) <span class="keyword">return</span> c&lt;t.c;</span><br><span class="line">    <span class="keyword">return</span> d&lt;t.d;</span><br><span class="line">&#125;<span class="comment">//先比较s，如果s不同，则s小的结构体小；如果s相同但c不同，则c较小的结构体小....</span></span><br></pre></td></tr></table></figure></li><li><p>sort自定义排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,c,d;</span><br><span class="line">&#125;sum[<span class="number">2500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Sum a,Sum b)</span></span>&#123;<span class="comment">//自定义函数排序,Sum是结构体名</span></span><br><span class="line">    <span class="keyword">if</span>(a.s==b.s) <span class="keyword">return</span> a.c&lt;b.c;</span><br><span class="line">    <span class="keyword">if</span>(a.c==b.c) <span class="keyword">return</span> a.d&lt;b.d;</span><br><span class="line">    <span class="keyword">return</span> a.s&lt;b.s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);<span class="comment">//默认下标0~n-1升序</span></span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);<span class="comment">//默认下标1~n升序</span></span><br><span class="line"><span class="built_in">sort</span>(a,a+n,greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//降序</span></span><br><span class="line"><span class="built_in">sort</span>(a,a+n,cmp);<span class="comment">//自定义函数排序,重写cmp</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>把正整数n写成a,b,c,d这4个数平方和的形式，输出字典序最小的abcd升序排列</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>如果暴力的话<ul><li>直接枚举abc（但会爆掉</li></ul></li><li>考虑空间换时间<ul><li>最先想的是先枚举ab保存下来再枚举cd，发现这样的话大小顺序有问题；</li><li>所以，先枚举cd，用结构体数组保存每一组s=c^2+d^2，c，d；升序排序</li><li>再枚举ab，a和b从小到大枚举，对于每一对ab，通过计算t = n-a <em> a-b </em> b，然后再通过<strong>二分</strong>从结构体数组中找第一个满足条件且cd最小的数</li></ul></li><li>说明<ul><li>首先枚举一定能保证a＜=b，c＜=d</li><li>是如何保证b＜=c的？<ul><li>假设存在答案a,b,c,d ，使得a＜b&gt;c＜d；那么一定有 a×a+b×b&gt;a×a+c×c，因此a,c应当比a,b先出现，枚举一定是先枚举出的ac而不是ab，与假设矛盾，故假设不成立（弄个例子画一下就理解了）</li></ul></li></ul></li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2500010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,t;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, c, d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Sum &amp;t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s != t.s) <span class="keyword">return</span> s &lt; t.s;</span><br><span class="line">        <span class="keyword">if</span> (c != t.c) <span class="keyword">return</span> c &lt; t.c;</span><br><span class="line">        <span class="keyword">return</span> d &lt; t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(c=<span class="number">0</span>;c*c&lt;=n;c++)&#123;</span><br><span class="line"><span class="keyword">for</span>(d=c;d*d+c*c&lt;=n;d++)&#123;</span><br><span class="line">sum[cnt++]=&#123;c*c+d*d,c,d&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(sum,sum+cnt);</span><br><span class="line"><span class="keyword">for</span>(a=<span class="number">0</span>;a*a&lt;=n;a++)&#123;</span><br><span class="line"><span class="keyword">for</span>(b=a;a*a+b*b&lt;=n;b++)&#123;</span><br><span class="line">t = n-a*a-b*b;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">0</span>,r = cnt<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>; <span class="comment">//找满足性质的最小值</span></span><br><span class="line"><span class="keyword">if</span>(sum[mid].s&gt;=t) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum[l].s==t)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>,a,b,sum[l].c,sum[l].d);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><ul><li>只能处理静态数组：只能查询不能修改</li><li>线状数组和树状数组可以修改</li></ul><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><h3 id="Acwing795-前缀和（模板题）"><a href="#Acwing795-前缀和（模板题）" class="headerlink" title="Acwing795 前缀和（模板题）"></a>Acwing795 前缀和（模板题）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//给一个整数序列，求第l到第r个数的和</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[N],s[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> l,r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="AcWing1230-K倍区间"><a href="#AcWing1230-K倍区间" class="headerlink" title="AcWing1230 K倍区间"></a>AcWing1230 K倍区间</h3><p><a href="https://www.acwing.com/problem/content/1232/">1230. K倍区间 - AcWing题库</a></p><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>给定一组数列，求有多少个子序列的和 是k的倍数</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ul><li>首先想到的是双重循环+前缀和，时间复杂度n²，但是10^10会爆</li><li>然后考虑如何优化：<ul><li>假设用<code>S[i]</code>来表示前缀和数组，易知<code>Ai到Aj</code>的和为<code>S[R]-S[L-1]</code>  (L-1&lt;=R)</li><li><strong>关键</strong>：<code>(S[R] - S[L-1])%k==0</code> 等价于<code>(S[R]%k == S[L-1]%k)</code></li><li>所以可以考虑：<ul><li>遍历，对于一个当前时刻固定的R，计算该S[R]%k的值，看在该R之前的前缀和 有谁%k的值（即余数）与之相等</li><li>若相等，答案个数+1；设cnt[i]表示余数为i的个数</li><li>但是，并不是所有子序列都需要两个前缀和来获得，对于<code>S[R]%k==0</code> 的情况，它本身也满足条件，也该加进答案里面，所以这里一定要将<strong>cnt[0] = 1</strong>;</li><li>数据范围大，求和可能会爆int，所以<strong>用long long</strong></li></ul></li></ul></li></ul><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">LL s[N],cnt[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1 2 3 4 5  原数字 </span></span><br><span class="line"><span class="comment">1 3 6 10 15  前缀和数组 </span></span><br><span class="line"><span class="comment">1 1 0 0  1   模k=2以后的余数数组  cnt[i]余数=i的个数 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[i]+=s[i<span class="number">-1</span>]; </span><br><span class="line"></span><br><span class="line">LL ans=<span class="number">0</span>; cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=cnt[s[i]%k] ; <span class="comment">//这里理解下：对于当前第i个前缀和，它的余数是t=s[i]%k,cnt[t]则表示，在第i个前缀和之前的 余数也==t的个数；最初i=1，对于余数＞0的cnt[i]个数为0，随着循环更新增加 </span></span><br><span class="line">cnt[s[i]%k]++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><ul><li><p>前缀和矩阵的计算：</p><script type="math/tex; mode=display">S_{xy}=S_{x-1,y}+S_{x,y-1}-S_{x-1,y-1}+a_{x,y}</script></li><li><p>利用前缀和矩阵计算某个子矩阵（左上角(x1,y1) 到右下角(x2,y2)的和：</p><script type="math/tex; mode=display">S_{x_{2},y_{2}}-S_{x_{2},y_{1}-1}-S_{x_{1}-1,y_{2}}+S_{x_{1}-1,y_{1}-1}</script></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/858f026d6e85a7e3.png" style="zoom:50%;" /></p><h3 id="AcWing796-子矩阵的和（模板题）"><a href="#AcWing796-子矩阵的和（模板题）" class="headerlink" title="AcWing796 子矩阵的和（模板题）"></a>AcWing796 子矩阵的和（模板题）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//给定矩阵，求(x1,y1)到(x2,y2)的子矩阵的和</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q,a[N][N],s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);  <span class="comment">//前缀和矩阵</span></span><br><span class="line">s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x1<span class="number">-1</span>][y2]-s[x2][y1<span class="number">-1</span>]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AcWing99-激光炸弹"><a href="#AcWing99-激光炸弹" class="headerlink" title="AcWing99 激光炸弹"></a>AcWing99 激光炸弹</h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p><a href="https://www.acwing.com/problem/content/101/">99. 激光炸弹 - AcWing题库</a></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>很明显是个二维前缀和的问题</li><li>一些注意点（内存限制所以这道题看起来简单<strong>但是细节好多aaaa</strong>（预判一波或许隔段时间再做也会做错QAQ）<ul><li>R的取值范围＞N的取值范围，当R超过N的取值范围，就相当于直接求矩阵的和</li><li>因为题目取值范围从0开始，为了方便，让坐标都+1，避免考虑边界问题</li><li>……..</li></ul></li></ul><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5005</span>; </span><br><span class="line"><span class="keyword">int</span> n,r,s[N][N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;r);</span><br><span class="line">r=<span class="built_in">min</span>(<span class="number">5001</span>,r); <span class="comment">//这里只能是5001，因为正方形边长最大是5000，</span></span><br><span class="line"><span class="keyword">int</span> row=r,col=r; <span class="comment">//这里初始化为正方形的边长，就能考虑到r*r会比整个矩形大</span></span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="keyword">int</span> x,y,w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;w);</span><br><span class="line">x++,y++;  <span class="comment">//使所有坐标从1开始，避免考虑边界问题 </span></span><br><span class="line">s[x][y]+=w;  <span class="comment">//不同目标可以在同一个位置</span></span><br><span class="line">row=<span class="built_in">max</span>(row,x);</span><br><span class="line">col=<span class="built_in">max</span>(col,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=row;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=col;j++)&#123;</span><br><span class="line">s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+s[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&lt;=row;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=r;j&lt;=col;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> t=s[i][j]-s[i-r][j]-s[i][j-r]+s[i-r][j-r];</span><br><span class="line">ans=<span class="built_in">max</span>(ans,t);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>一般使用场景</p><p><strong>给出 n 个数，再给出 m 个询问，每个询问给出 l，r，x，要求你在 l 到 r 上每一个值都加上 x，而只给你 O(n) 的时间范围</strong></p><h2 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h2><h3 id="AcWing797-差分（模板题）"><a href="#AcWing797-差分（模板题）" class="headerlink" title="AcWing797 差分（模板题）"></a>AcWing797 差分（模板题）</h3><ul><li>关于差分数组b的构造（代码18行），也可以写成<code>insert(i,i,a[i])</code>：可以把初始原数组a看成全0，那么差分数组b也是全0，给数组赋初值等效于n次插入操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[N],b[N];</span><br><span class="line"><span class="comment">//关键方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">b[l]+=c;</span><br><span class="line">b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">b[i]=a[i]-a[i<span class="number">-1</span>];   <span class="comment">//构造差分数组</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="keyword">int</span> l,r,c;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line"><span class="built_in">insert</span>(l,r,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i]=a[i<span class="number">-1</span>]+b[i];</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h2><h3 id="AcWing798-差分矩阵（模板题）"><a href="#AcWing798-差分矩阵（模板题）" class="headerlink" title="AcWing798 差分矩阵（模板题）"></a>AcWing798 差分矩阵（模板题）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q;</span><br><span class="line"><span class="keyword">int</span> a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">b[x1][y1]+=c;</span><br><span class="line">b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line"><span class="comment">//b[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]; </span></span><br><span class="line"><span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2,c;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;</span><br><span class="line"><span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">a[i][j]=a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[i][j];</span><br><span class="line">cout&lt;&lt;a[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;二分&lt;/li&gt;
&lt;li&gt;前缀和&lt;/li&gt;
&lt;li&gt;差分 &lt;/li&gt;
&lt;li&gt;双指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="二分" scheme="http://example.com/tags/%E4%BA%8C%E5%88%86/"/>
    
    <category term="前缀和" scheme="http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="差分" scheme="http://example.com/tags/%E5%B7%AE%E5%88%86/"/>
    
    <category term="双指针" scheme="http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>递推（几道翻转类题目）</title>
    <link href="http://example.com/2022/03/09/2022-02-15-%E9%80%92%E6%8E%A8%EF%BC%88%E5%87%A0%E9%81%93%E7%BF%BB%E8%BD%AC%E7%B1%BB%E9%A2%98%E7%9B%AE%EF%BC%89/"/>
    <id>http://example.com/2022/03/09/2022-02-15-%E9%80%92%E6%8E%A8%EF%BC%88%E5%87%A0%E9%81%93%E7%BF%BB%E8%BD%AC%E7%B1%BB%E9%A2%98%E7%9B%AE%EF%BC%89/</id>
    <published>2022-03-09T13:31:55.000Z</published>
    <updated>2022-03-10T11:30:14.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-116-飞行员兄弟"><a href="#AcWing-116-飞行员兄弟" class="headerlink" title="AcWing 116 飞行员兄弟"></a>AcWing 116 飞行员兄弟</h1><p><a href="https://www.acwing.com/problem/content/description/118/">题目链接</a></p><h2 id="大意"><a href="#大意" class="headerlink" title="大意:"></a>大意:</h2><ul><li>4 x 4 翻转一个元素的话，顺带着所在行和列全跟着翻转；求全部翻转过来的步数和步骤</li></ul><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>如果枚举的话，2&lt;&lt;16次，复杂度还能够接受，可以枚举</li><li>枚举每个操作opt，每个操作opt的值转换成16位二进制，<ul><li>对于每个opt，要移位16次，每次右移取最低位 ,当==1表示翻转</li><li>注意翻转i行j列的时候，(i,j)被翻转了两次，记得恢复</li><li>储存符合条件的操作的位置，用vector存</li></ul></li></ul><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><ul><li><p>vector</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义： vector&lt;元素类型&gt; 名称；例如： vector&lt;PII&gt; vec;</span><br><span class="line">翻转： <span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">大小： vec.<span class="built_in">size</span>();</span><br><span class="line">清空： vec.<span class="built_in">clear</span>();</span><br><span class="line">插入： vec.<span class="built_in">push_back</span>(pi);</span><br></pre></td></tr></table></figure></li><li><p>for区间遍历 (C++11)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:vec)&#123;</span><br><span class="line">    cout&lt;&lt;i.x&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;i.y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pair</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second 方便</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line">PII pi; pi.first, pi.second</span><br></pre></td></tr></table></figure></li><li><p>memcpy</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *str1, <span class="keyword">const</span> <span class="keyword">void</span> *str2, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">str1：目的 str2：源 n：字节数</span></span><br></pre></td></tr></table></figure></li><li><p>二进制数i的第k位是否==1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i&gt;&gt;k&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="简洁版代码"><a href="#简洁版代码" class="headerlink" title="简洁版代码"></a>简洁版代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> ch[N][N],backup[N][N]; </span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; vec; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(backup[i][k]==<span class="string">&#x27;+&#x27;</span>) backup[i][k]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][k]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(backup[k][j]==<span class="string">&#x27;+&#x27;</span>) backup[k][j]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[k][j]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">&#x27;+&#x27;</span>) backup[i][j]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][j]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</span><br><span class="line">cin&gt;&gt;ch[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> opt=<span class="number">0</span>;opt&lt;(<span class="number">2</span>&lt;&lt;<span class="number">16</span>);opt++)&#123;</span><br><span class="line"><span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memcpy</span>(backup,ch,<span class="keyword">sizeof</span> ch);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(opt&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> row=(<span class="number">16</span>-i<span class="number">-1</span>)/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> col= <span class="number">4</span>-i%<span class="number">4</span>;</span><br><span class="line"><span class="built_in">turn</span>(row,col);</span><br><span class="line"> step++;</span><br><span class="line"> PII pi; pi.first=row;pi.second=col;</span><br><span class="line"> vec.<span class="built_in">push_back</span>(pi);</span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">flag=<span class="literal">false</span>; vec.<span class="built_in">clear</span>();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">cout&lt;&lt;step&lt;&lt;endl;</span><br><span class="line"><span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>()); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">cout&lt;&lt;vec[i].first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;vec[i].second&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="废话版代码"><a href="#废话版代码" class="headerlink" title="废话版代码"></a>废话版代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">最初想到的思路，参照“费解的开关”这道题</span></span><br><span class="line"><span class="comment">枚举，16个位置 有2^16种情况</span></span><br><span class="line"><span class="comment">枚举二进制 0到2^16-1</span></span><br><span class="line"><span class="comment">对于每种情况，对原状态数组进行操作 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> ch[N][N],backup[N][N]; </span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII; <span class="comment">//pair的用法；又是一个被我遗忘的东西，笑嘻</span></span><br><span class="line">vector&lt;PII&gt; vec; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">4</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(backup[i][k]==<span class="string">&#x27;+&#x27;</span>) backup[i][k]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][k]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(backup[k][j]==<span class="string">&#x27;+&#x27;</span>) backup[k][j]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[k][j]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;   <span class="comment">//当时写的时候，就差点忘记(i,j)的位置翻转了两次，所以下面要再翻回去</span></span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">&#x27;+&#x27;</span>) backup[i][j]=<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> backup[i][j]=<span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)</span><br><span class="line">cin&gt;&gt;ch[i][j];</span><br><span class="line"></span><br><span class="line"><span class="comment">//一共有2&lt;&lt;16次操作，枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> opt=<span class="number">0</span>;opt&lt;(<span class="number">2</span>&lt;&lt;<span class="number">16</span>);opt++)&#123;</span><br><span class="line"><span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//memcpy复制数组，不用写双重循环 </span></span><br><span class="line"><span class="built_in">memcpy</span>(backup,ch,<span class="keyword">sizeof</span> ch);</span><br><span class="line"><span class="comment">//for(int kk=1;kk&lt;=4;kk++)</span></span><br><span class="line"><span class="comment">//for(int jj=1;jj&lt;=4;jj++)</span></span><br><span class="line"><span class="comment">//backup[kk][jj]=ch[kk][jj];</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"> <span class="comment">//对于每个opt，移位16位 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">16</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(opt&gt;&gt;i&amp;<span class="number">1</span>)&#123; <span class="comment">//取最低位 ,如果==1的话就翻转；</span></span><br><span class="line"> <span class="comment">//例如：0000 0000 0000 0001；最先是1，</span></span><br><span class="line"> <span class="comment">//第0个对应(4,4) 第1个对应(4,3)</span></span><br><span class="line"><span class="keyword">int</span> row=(<span class="number">16</span>-i<span class="number">-1</span>)/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> col= <span class="number">4</span>-i%<span class="number">4</span>;</span><br><span class="line"><span class="built_in">turn</span>(row,col);</span><br><span class="line"> step++;</span><br><span class="line"> PII pi; pi.first=row;pi.second=col;</span><br><span class="line"> vec.<span class="built_in">push_back</span>(pi);</span><br><span class="line">                <span class="comment">//试了一下样例</span></span><br><span class="line"><span class="comment">// if(opt==45067)&#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;&quot;step== &quot;&lt;&lt;step&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// for(int i=1;i&lt;=4;i++)&#123;</span></span><br><span class="line"><span class="comment">//for(int j=1;j&lt;=4;j++)</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;backup[i][j];</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;endl; </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"> &#125; </span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(backup[i][j]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">flag=<span class="literal">false</span>; vec.<span class="built_in">clear</span>(); <span class="comment">//清空vector;</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">cout&lt;&lt;step&lt;&lt;endl;</span><br><span class="line"><span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());   <span class="comment">//vector的用法忘了，用重新复习下下</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>();i++)</span><br><span class="line">cout&lt;&lt;vec[i].first&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;vec[i].second&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;AcWing-116-飞行员兄弟&quot;&gt;&lt;a href=&quot;#AcWing-116-飞行员兄弟&quot; class=&quot;headerlink&quot; title=&quot;AcWing 116 飞行员兄弟&quot;&gt;&lt;/a&gt;AcWing 116 飞行员兄弟&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/description/118/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;大意&quot;&gt;&lt;a href=&quot;#大意&quot; class=&quot;headerlink&quot; title=&quot;大意:&quot;&gt;&lt;/a&gt;大意:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;4 x 4 翻转一个元素的话，顺带着所在行和列全跟着翻转；求全部翻转过来的步数和步骤&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="递推" scheme="http://example.com/tags/%E9%80%92%E6%8E%A8/"/>
    
  </entry>
  
  <entry>
    <title>英语老师Lee的每日听力练习笔记</title>
    <link href="http://example.com/2022/03/09/2022-03-09-%E8%8B%B1%E8%AF%AD%E8%80%81%E5%B8%88Lee%E7%9A%84%E5%90%AC%E5%8A%9B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/03/09/2022-03-09-%E8%8B%B1%E8%AF%AD%E8%80%81%E5%B8%88Lee%E7%9A%84%E5%90%AC%E5%8A%9B%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-09T12:01:13.000Z</published>
    <updated>2022-03-13T13:34:39.671Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>主要内容</strong><ul><li>每天十分钟的听力练习笔记</li><li>只是<strong>谨防自己三分钟热度</strong>所以敦促自己每天听的手段QAQ，随便记记而已</li></ul></li></ul><span id="more"></span><h1 id="22-03-09"><a href="#22-03-09" class="headerlink" title="22-03-09"></a>22-03-09</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/a29c5982022c9b64.png" style="zoom: 50%;" /></p><ul><li>单词<ul><li>scooter ：小摩托车</li><li>eyepatch：眼罩</li><li>pink eye：红眼，急性结膜炎</li><li><strong>greasy </strong>  <ul><li>含义：沾油脂的，油污的；含脂肪的，<strong>油腻的</strong>；油性的；滑的；<strong>圆滑的，虚情假意的</strong></li><li>可以用来形容食物 、头发</li></ul></li></ul></li><li>发音<ul><li>your –》 yer</li><li>lot of –》 lotta</li></ul></li></ul><h1 id="22-03-10"><a href="#22-03-10" class="headerlink" title="22-03-10"></a>22-03-10</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/388e55c499064533.png" style="zoom:40%;" /></p><ul><li>单词<ul><li>drug trial 药物实验</li><li>guinea pig<ul><li>豚鼠</li><li>a person used in medical or other experiments <strong>实验对象</strong></li></ul></li><li><strong>roll the side effects dice :冒着副作用的风险</strong><ul><li><strong>roll the dice</strong>：掷骰子， 可以引申为孤注一掷</li></ul></li><li><strong>hallucination</strong>：幻觉<ul><li>[həˌluːsɪˈneɪʃn]</li><li>A hallucination is a fact, not an error; what is erroneous is a judgment based upon it.</li></ul></li></ul></li></ul><h1 id="22-03-11"><a href="#22-03-11" class="headerlink" title="22-03-11"></a>22-03-11</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/6a1c902edfa52be8.png" style="zoom:50%;" /></p><ul><li>单词<ul><li>take advantage of<ul><li>之前经常 +sth 当作“充分利用”的正面词汇，类似还有比如take advantage of sb：占某人便宜</li></ul></li></ul></li></ul><h1 id="22-03-12"><a href="#22-03-12" class="headerlink" title="22-03-12"></a>22-03-12</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/668ebb46963226bf.png" style="zoom:45%;" /></p><ul><li>单词<ul><li>benefit<ul><li><strong>慈善晚会</strong></li><li>benefit concert 慈善音乐会</li></ul></li><li>up for：愿意参与某活动<ul><li>It`s exciting because it is very much <strong>up for grabs</strong><ul><li>工作、奖金、机会等 等待你去<strong>争取，赢取</strong></li></ul></li></ul></li><li>reprise：重复、重演、重奏、<strong>重现</strong><ul><li>A study which I now reprise for you now from a 2001 article</li></ul></li></ul></li></ul><h1 id="22-03-13"><a href="#22-03-13" class="headerlink" title="22-03-13"></a>22-03-13</h1><p><img src="https://i.bmp.ovh/imgs/2022/03/8579559b6e1fed1b.png" style="zoom:50%;" /></p><ul><li><strong>unwind</strong><ul><li>== relax</li></ul></li><li>a full day off：一整个休息日<ul><li>take a day off</li></ul></li><li><strong>of late:</strong> 最近，近来<ul><li>Religious oppression is another big issue that we`ve seen <strong>of late</strong></li><li>你最近都在忙什么：what`s been taken up your day as of late</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主要内容&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;每天十分钟的听力练习笔记&lt;/li&gt;
&lt;li&gt;只是&lt;strong&gt;谨防自己三分钟热度&lt;/strong&gt;所以敦促自己每天听的手段QAQ，随便记记而已&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="英语" scheme="http://example.com/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语听力" scheme="http://example.com/tags/%E8%8B%B1%E8%AF%AD%E5%90%AC%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>DIP-1-数字图像基础</title>
    <link href="http://example.com/2022/03/06/2022-03-06-DIP-1-%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/03/06/2022-03-06-DIP-1-%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-06T13:10:02.000Z</published>
    <updated>2022-03-12T03:20:59.140Z</updated>
    
    <content type="html"><![CDATA[<p>【主要内容】</p><ul><li>数字图像的概念及表示</li><li>图像获取</li><li>图像数字化(Digitization)</li><li>不同类型的数字图像</li><li>图像基本性质<ul><li>图像平均值Image Mean .</li><li>图像对比度Image Contrast</li><li>图像直方图Image Histogram</li><li>图像的熵Image Entropy</li><li>自适应直方图Adaptive Histogram</li></ul></li><li>直方图的应用</li></ul><span id="more"></span><h1 id="数字图像的概念及表示"><a href="#数字图像的概念及表示" class="headerlink" title="数字图像的概念及表示"></a>数字图像的概念及表示</h1><ul><li><strong>图像</strong>：三维场景 到 二维平面的一个投影<ul><li>表示一幅图像：二维函数f（x,y)<ul><li>任意一对空间坐标（<strong>x，y</strong>）处的<strong>幅值  f</strong> ：图像在该点的 强度或灰度</li></ul></li></ul></li><li><strong>数字图像</strong>：x 和 y 和 f 都是 <strong>有限的离散量</strong><ul><li>由有限数量的像素组成  —–》每个像素对应 一个（x，y）和一个f</li></ul></li><li><strong>数字图像的表示</strong>：二维矩阵  <img src="https://i.bmp.ovh/imgs/2022/03/91bd075dd44a0604.png" style="zoom: 33%;" /></li></ul><h1 id="图像获取"><a href="#图像获取" class="headerlink" title="图像获取"></a>图像获取</h1><h1 id="图像数字化（Digitization）"><a href="#图像数字化（Digitization）" class="headerlink" title="图像数字化（Digitization）"></a>图像数字化（Digitization）</h1><ul><li><p>数字化的两个过程<strong>：取样 + 量化</strong></p></li><li><p><strong>取样</strong></p><ul><li><p>即：对空间坐标<strong>x 和 y</strong>进行数字化</p></li><li><p>取样间隔必须满足 <strong>Nyquist条件</strong>：x和y方向的<font color="green">取样频率</font>必须 <strong>大于</strong>图像在 x 和 y 方向 <font color="green">最高频率</font>的两倍</p><ul><li><p>为什么要满足：确保取样以后的信号能<font color="orange">完全恢复</font>出原来的连续信号</p></li><li><p>低于这个条件，会产生<strong>混叠</strong>（Aliasing）</p><blockquote><p>什么是混叠？</p></blockquote></li></ul></li></ul></li><li><p><strong>量化</strong></p><ul><li>对<strong>灰度值 f</strong> 进行数字化</li></ul></li></ul><h1 id="不同类型的数字图像"><a href="#不同类型的数字图像" class="headerlink" title="不同类型的数字图像"></a>不同类型的数字图像</h1><p>暂略…</p><h1 id="图像基本性质"><a href="#图像基本性质" class="headerlink" title="图像基本性质"></a>图像基本性质</h1><h2 id="图像平均值-Image-Mean"><a href="#图像平均值-Image-Mean" class="headerlink" title="图像平均值 Image Mean"></a>图像平均值 Image Mean</h2><ul><li>图像平均值 = 像素之和 / 像素总个数 ，图像平均值 ↑ 👉图像亮度 ↑</li><li>公式如下：</li></ul><script type="math/tex; mode=display">I_{av} = \frac{\sum_{i} \sum_{j}I(i,j)}{\sum_i\sum_j1}</script><h2 id="图像对比度-Image-Contrast"><a href="#图像对比度-Image-Contrast" class="headerlink" title="图像对比度 Image Contrast"></a>图像对比度 Image Contrast</h2><ul><li><p>对比度是 图像复杂度的一种体现</p></li><li><p>首先，引入对比度的<strong>度量方式</strong>：</p><ul><li><p><strong>全局定义方式</strong>（统计学角度）：</p><p>（灰度）最大偏差</p><script type="math/tex; mode=display">max \left\{I(x,y) \right\} - min\left\{I(x,y)\right\}</script><p>（灰度）方差：</p><script type="math/tex; mode=display">var\left\{I(x,y)\right\}=mean\left\{(I(x,y)-I_{av})_{}^{2}\right\}</script><p>（灰度）标准差</p><script type="math/tex; mode=display">std\left\{I(x,y)\right\}=\sqrt{var\left\{I(x,y)\right\}}</script><p>   全局定义方式的<strong>缺点</strong>：不能感知局部结构，没有体现人类的视觉敏感性</p></li><li><p>（韦伯）<strong>局部对比度</strong></p><ul><li>．图像点的局部对比度表示<strong>该图像点(point)的 强度</strong> 与其 <strong>邻域(neihborhood) 强度</strong>之间的(相对)差:<script type="math/tex; mode=display">C=|\frac{I_{p}-I_{n}}{I_{n}}|</script></li></ul></li></ul></li></ul><h2 id="图像直方图-Image-Histogram"><a href="#图像直方图-Image-Histogram" class="headerlink" title="图像直方图 Image Histogram"></a>图像直方图 Image Histogram</h2><ul><li>直方图：用来表达一幅图像灰度级分布情况的统计表</li><li>横坐标→ 灰度级r； 纵坐标 ↑ 灰度值为r的像素个数n或者出现的概率p（r）</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/3829be80550cf6d6.png" style="zoom:50%;" /></p><ul><li><p>直方图<strong>不是一对一</strong>的映射关系  —&gt; 图像的直方图不能完全代表图像</p><ul><li>因此：直方图只能体现数据的统计特性，没有结构特点。</li><li>比如：将一张图的像素随机扰乱，直方图仍然是不变的<img src="https://i.bmp.ovh/imgs/2022/03/aa18aac1c82e01a2.png" style="zoom:50%;" /></li></ul></li><li><p>直方图的<strong>用处</strong>：分析图像对比度的好坏</p><ul><li><strong>给定图像，算出图像平均值和标准差</strong><img src="https://i.bmp.ovh/imgs/2022/03/05bad86faafba1d7.png" style="zoom:65%;" /></li></ul></li></ul><h2 id="图像的-熵-Image-Entropy"><a href="#图像的-熵-Image-Entropy" class="headerlink" title="图像的 熵 Image Entropy"></a>图像的 熵 Image Entropy</h2><ul><li><p>图像的熵的公式 (它是大于0的):</p><script type="math/tex; mode=display">Entropy(I) = -\sum_{k}P(k)logP(k)</script><ul><li>图像的熵表示图像值 的<strong>不确定性</strong></li><li>均匀分布：<strong>熵max</strong>；集中分布在某一处：<strong>熵min</strong></li><li>不频繁的事件比频繁的事件提供更多的信息</li><li>熵 是 直方图 <strong>离散度 </strong>的度量</li></ul></li></ul><h2 id="自适应直方图-Adaptive-Histogram"><a href="#自适应直方图-Adaptive-Histogram" class="headerlink" title="自适应直方图 Adaptive Histogram"></a>自适应直方图 Adaptive Histogram</h2><ul><li>在许多情况下，图像中的<strong>局部</strong>区域需要直方图<ul><li>比如:：模式检测、自适应增强、自适应阈值</li></ul></li><li>图像模糊<strong>不改变图像平均值</strong><ul><li>而是会<strong>减小方差、减小熵</strong></li></ul></li></ul><h1 id="直方图的应用"><a href="#直方图的应用" class="headerlink" title="直方图的应用"></a>直方图的应用</h1><ul><li><p>应用</p><ul><li>测量图像特性:平均值、方差、熵、对比度、区域(对于给定的灰度范围)</li><li><strong>阈值选择</strong> <strong>Threshold selection</strong></li><li>图像的距离</li><li>图像增强<ul><li><strong>直方图均衡化</strong></li><li><strong>直方图拉伸</strong></li><li><strong>直方图匹配</strong></li></ul></li></ul></li><li><p>阈值<strong>分割</strong>：</p><ul><li><p>阈值选取的基本规律：两个峰之间的谷底</p><p><img src="https://i.bmp.ovh/imgs/2022/03/7575a89fe2de9213.png" style="zoom:50%;" /></p></li></ul></li><li><p>图像的<strong>距离</strong></p><ul><li><p>问题:给定两幅图像A和B，其(归一化)直方图为Pa和Pb，定义图像之间的距离D(A,B)。</p><ul><li><strong>Minkowski距离</strong>： 存在的问题：距离可能 <strong>不能反映感知到的差异</strong></li></ul><script type="math/tex; mode=display">D_{p}(A,B)=[\sum_{k}|P_{A}(k)-P_{B}(k)|]^{1/p}</script><ul><li><strong>KL距离（散度）</strong>：非对称，同样面临Minkowski距离的缺点</li></ul><script type="math/tex; mode=display">D_{KL}(A||B)=\sum_{k}P_{A}(k)log\frac{P_{A}(k)}{P_{B}(k)}</script></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;【主要内容】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字图像的概念及表示&lt;/li&gt;
&lt;li&gt;图像获取&lt;/li&gt;
&lt;li&gt;图像数字化(Digitization)&lt;/li&gt;
&lt;li&gt;不同类型的数字图像&lt;/li&gt;
&lt;li&gt;图像基本性质&lt;ul&gt;
&lt;li&gt;图像平均值Image Mean .&lt;/li&gt;
&lt;li&gt;图像对比度Image Contrast&lt;/li&gt;
&lt;li&gt;图像直方图Image Histogram&lt;/li&gt;
&lt;li&gt;图像的熵Image Entropy&lt;/li&gt;
&lt;li&gt;自适应直方图Adaptive Histogram&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;直方图的应用&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数字图像处理Digital Image Processing" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86Digital-Image-Processing/"/>
    
  </entry>
  
  <entry>
    <title>DIP-2-基本运算</title>
    <link href="http://example.com/2022/03/06/2022-03-06-DIP-2-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2022/03/06/2022-03-06-DIP-2-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</id>
    <published>2022-03-06T13:10:02.000Z</published>
    <updated>2022-03-08T07:47:53.482Z</updated>
    
    <content type="html"><![CDATA[<p>暂无</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;暂无&lt;/p&gt;
</summary>
      
    
    
    
    <category term="课程笔记" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数字图像处理Digital Image Processing" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86Digital-Image-Processing/"/>
    
  </entry>
  
  <entry>
    <title>小世界网络</title>
    <link href="http://example.com/2022/02/26/2022-02-26-%E5%B0%8F%E4%B8%96%E7%95%8C%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2022/02/26/2022-02-26-%E5%B0%8F%E4%B8%96%E7%95%8C%E7%BD%91%E7%BB%9C/</id>
    <published>2022-02-26T07:45:01.000Z</published>
    <updated>2022-03-06T07:03:48.896Z</updated>
    
    <content type="html"><![CDATA[<ul><li>关于小世界网络—— 一种特殊的<strong>复杂网络</strong></li><li>随机性<strong>介于</strong> 随机网络和规则耦合网络<strong>之间</strong></li><li>适合模拟<strong>真实</strong>网络系统</li><li>其概念, 简单说是描述这样的一个事实:<ul><li>尽管一些网络系统有<strong>很大</strong>的尺寸, 但其中<strong>任意两个节点</strong>之间却有一个<strong>相对小</strong>的距离。</li></ul></li><li>小世界特征：比较<strong>短</strong>的<strong>平均距离</strong> + 相对较<strong>大</strong>的<strong>集聚系数</strong></li></ul><span id="more"></span><h1 id="两种常见的小世界网络"><a href="#两种常见的小世界网络" class="headerlink" title="两种常见的小世界网络"></a>两种常见的小世界网络</h1><h2 id="NW小世界网络"><a href="#NW小世界网络" class="headerlink" title="NW小世界网络"></a>NW小世界网络</h2><ul><li><strong>实现方式</strong>：<strong>规则耦合网络 </strong>上进行 <strong>随机加边</strong></li></ul><h2 id="WS小世界网络"><a href="#WS小世界网络" class="headerlink" title="WS小世界网络"></a>WS小世界网络</h2><ul><li><strong>实现方式</strong>：<strong>规则耦合网络</strong>上进行<strong>随机重连</strong></li></ul><blockquote><p>参考文献：</p><p><a href="">[1]赵小林,徐浩,薛静峰,宋天凌,胡晶晶,闫怀志.基于复杂网络的网络系统脆弱点发现方法研究[J].信息安全学报,2019,4(01):39-52.DOI:10.19363/J.cnki.cn10-1380/tn.2019.01.04.</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;关于小世界网络—— 一种特殊的&lt;strong&gt;复杂网络&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;随机性&lt;strong&gt;介于&lt;/strong&gt; 随机网络和规则耦合网络&lt;strong&gt;之间&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;适合模拟&lt;strong&gt;真实&lt;/strong&gt;网络系统&lt;/li&gt;
&lt;li&gt;其概念, 简单说是描述这样的一个事实:&lt;ul&gt;
&lt;li&gt;尽管一些网络系统有&lt;strong&gt;很大&lt;/strong&gt;的尺寸, 但其中&lt;strong&gt;任意两个节点&lt;/strong&gt;之间却有一个&lt;strong&gt;相对小&lt;/strong&gt;的距离。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;小世界特征：比较&lt;strong&gt;短&lt;/strong&gt;的&lt;strong&gt;平均距离&lt;/strong&gt; + 相对较&lt;strong&gt;大&lt;/strong&gt;的&lt;strong&gt;集聚系数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="信安赛" scheme="http://example.com/categories/%E4%BF%A1%E5%AE%89%E8%B5%9B/"/>
    
    
    <category term="复杂网络" scheme="http://example.com/tags/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/"/>
    
    <category term="文献笔记" scheme="http://example.com/tags/%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>复杂网络中重要节点、脆弱节点的检查、挖掘方法</title>
    <link href="http://example.com/2022/02/25/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E3%80%81%E8%84%86%E5%BC%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%A3%80%E6%9F%A5%E3%80%81%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/02/25/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%87%8D%E8%A6%81%E8%8A%82%E7%82%B9%E3%80%81%E8%84%86%E5%BC%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%A3%80%E6%9F%A5%E3%80%81%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/</id>
    <published>2022-02-25T00:29:40.000Z</published>
    <updated>2022-03-13T14:16:37.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>针对区块链网络和分布式系统的，网络脆弱节点的挖掘检测：</p><p>​    给定一个<strong>区块链网络</strong>，里边有很多节点，不同的<strong>配置、位置、算力</strong>，如何找到哪个节点是<strong>更重要</strong>、<strong>更脆弱</strong>。</p></blockquote><ul><li><p>从<strong>攻</strong>的角度，那就可以作为<strong>攻击目标</strong>。</p><blockquote><p>对节点的攻击：1. 随机攻击 2.蓄意攻击</p><p>随机攻击–&gt;即使很多节点失效崩溃，但整个网络仍可保持连通</p><p>蓄意攻击–&gt;针对度很大的节点，网络就变得脆弱，可能崩溃</p></blockquote></li><li><p>从<strong>防</strong>的角度，就是需要加强<strong>保护和完善</strong>的脆弱点</p></li></ul><span id="more"></span><h1 id="复杂网络中重要性节点发掘综述"><a href="#复杂网络中重要性节点发掘综述" class="headerlink" title="复杂网络中重要性节点发掘综述"></a>复杂网络中重要性节点发掘综述</h1><blockquote><p>阅读文献来源：</p><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2007&amp;filename=JSJA200712003&amp;uniplatform=NZKPT&amp;v=4M8fbSr9Jag8kRTp3gVwrqO7hkHjgcLxJ-HaeSp7dV_5lHNIpjut1rRC0PRykSht">复杂网络中重要性节点发掘综述 - 中国知网 (cnki.net)</a></p></blockquote><ul><li><p>该篇论文解决的问题：</p><p>复杂网络环境下几个领域中发掘重要性节点的方法</p></li></ul><h2 id="发掘复杂网络重要节点的三种方法"><a href="#发掘复杂网络重要节点的三种方法" class="headerlink" title="发掘复杂网络重要节点的三种方法"></a>发掘复杂网络重要节点的三种方法</h2><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><hr><h1 id="基于复杂网络的网络系统脆弱点发现研究方法"><a href="#基于复杂网络的网络系统脆弱点发现研究方法" class="headerlink" title="基于复杂网络的网络系统脆弱点发现研究方法"></a>基于复杂网络的网络系统脆弱点发现研究方法</h1><blockquote><p>阅读文献来源：</p><p><a href="">[1]赵小林,徐浩,薛静峰,宋天凌,胡晶晶,闫怀志.基于复杂网络的网络系统脆弱点发现方法研究[J].信息安全学报,2019,4(01):39-52.DOI:10.19363/J.cnki.cn10-1380/tn.2019.01.04.</a></p></blockquote><ul><li><p>该篇论文解决的问题：</p><ul><li>大量节点 加大了攻击图 的计算量 ，产生<strong>状态爆炸</strong>问题，限制了攻击图技术现实应用</li><li>因此，兼顾准确性&amp;&amp;<strong>减少计算量</strong>&amp;&amp;利用复杂网络的拓扑统计性质  <ul><li>寻找 脆弱点—&gt;达到目的：寻找<strong>更大规模</strong>（1000/10000以上）网络的脆弱点 </li></ul></li><li>提出了  对节点删除法的<strong>改进</strong></li></ul><hr></li></ul><ul><li><p>复杂网络 —&gt; 节点的集合 —&gt; 拥有自己的<strong>独立特征</strong>&amp;&amp;与其他个体有<strong>相互连接</strong>关系的节点</p></li><li><p>什么是脆弱节点?</p><ul><li><p><strong>受攻击</strong>后能引起网络性能<strong>大幅度下降</strong>的节点</p><ul><li><p>什么是网络性能?</p><ul><li>网络的<strong>连通性</strong>（网络能否正常工作）、平均最短路径（网络执行效率）等</li></ul></li></ul></li></ul></li></ul><h2 id="寻找脆弱节点的两种思路"><a href="#寻找脆弱节点的两种思路" class="headerlink" title="寻找脆弱节点的两种思路"></a>寻找脆弱节点的两种思路</h2><h3 id="思路一：网络中心性反映脆弱性"><a href="#思路一：网络中心性反映脆弱性" class="headerlink" title="思路一：网络中心性反映脆弱性"></a>思路一：网络中心性反映脆弱性</h3><ul><li><p><strong>中心性指标</strong></p><ul><li><p><strong>度中心性</strong></p><ul><li><p>归一化度值 <strong>越大，节点越重要</strong></p></li><li><script type="math/tex; mode=display">归一化度值=\frac{节点的度(与节点相连的其他节点个数)}{最大可能的度(N-1)}</script></li></ul></li></ul></li></ul><ul><li><p><strong>介数中心性</strong></p><ul><li><p>介数中心性 反映–&gt;节点在网络中的<strong>枢纽</strong>地位；通过该节点最短路径<strong>越多，节点越重要</strong></p><script type="math/tex; mode=display">介数=\frac{经过该节点的最短路径 条数}{所有最短路径 条数}</script></li><li><script type="math/tex; mode=display">介数中心性=\frac{某节点介数}{介数最大值}</script></li></ul></li></ul><ul><li><p><strong>接近度中心性</strong></p><ul><li>接近度：节点到其他节点 最短路径之和的倒数；<strong>越小越重要</strong></li><li>接近度中心性 = 某节点接近度  * （N-1）<ul><li>反映–&gt;节点通过网络到其他节点的<strong>影响能力</strong></li></ul></li></ul></li><li><p><strong>特征向量中心性</strong></p><ul><li>反映了节点间的<strong>相互影响</strong></li><li>反映了重要性和 <strong>连接的边数目</strong>有关、和<strong>连接的节点的重要性</strong>有关、连接重要的节点可<strong>提升</strong>自身节点的重要性</li></ul></li></ul><hr><h3 id="思路二：节点脆弱性-删除节点后对网络系统的破坏性"><a href="#思路二：节点脆弱性-删除节点后对网络系统的破坏性" class="headerlink" title="思路二：节点脆弱性 == 删除节点后对网络系统的破坏性"></a>思路二：节点脆弱性 == 删除节点后对网络系统的破坏性</h3><p> “核与核度”理论：</p><ul><li><p><strong>系统的“核”</strong>：</p><ul><li>给定的系统，若<strong>去掉or破坏</strong>其中若干个主要素，对系统<strong>破坏性最大</strong>的 这若干个主要素</li><li>—&gt; 可以：研究<strong>删除节点</strong>后对网络的<strong>破坏性</strong>来确定—&gt; 脆弱节点</li></ul></li><li><p><strong>如何“删除节点”？</strong></p><ul><li><p><strong>方法一</strong>：将节点对之间<strong>距离的倒数</strong>作为权数，对所有<strong>产生的</strong>不连通节点加权求和  以此度量破坏程度</p><blockquote><ul><li><p>参考文献：</p><p><a href="">[1]李鹏翔,任玉晴,席酉民.网络节点(集)重要性的一种度量指标[J].系统工程,2004(04):13-20.</a></p></li></ul></blockquote></li><li><p><strong>方法二：</strong></p><blockquote><ul><li><p>参考文献：</p><p><a href="">[1]刘浪,邓伟,采峰,陈玲. 节点重要度计算的新方法——优先等级法[C]//第九届中国管理科学学术年会论文集.[出版者不详],2007:168-171.</a></p></li></ul></blockquote></li></ul></li></ul><h3 id="该文献的思路"><a href="#该文献的思路" class="headerlink" title="该文献的思路"></a>该文献的思路</h3><ul><li>本文对<strong>节点删除法的改进 </strong>：针对网络攻防中 <strong>网络拓扑</strong>可能因为脆弱点 受到攻击而<strong>变化</strong>，寻找<strong>更符合网络实际情况</strong>的脆弱点<ul><li>通过计算 删除节点后对网络<strong>平均最短路径</strong>的影响 来 模拟当网络中节点 <strong>受到攻击 导致节点不可用</strong>时 对网络整体性质的影响</li></ul></li></ul><h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><ul><li><p>本文认为：主要影响的网络性质：<strong>平均最短路径</strong> &amp; <strong>连通节点对</strong>的变化</p><blockquote><p>删除节点后，可能<strong>产生</strong>一个or多个连通分支 ，可能<strong>改变</strong>某些节点对的最短路径</p></blockquote></li></ul><ol><li><p>首先考虑对平均最短路径的影响</p><ul><li><p>将<strong>不连通的节点对</strong> 间的距离设为 <strong>图的直径大小</strong></p><p><img src="https://i.bmp.ovh/imgs/2022/03/0662fb6717a810d5.png" style="zoom:50%;" /></p></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;针对区块链网络和分布式系统的，网络脆弱节点的挖掘检测：&lt;/p&gt;
&lt;p&gt;​    给定一个&lt;strong&gt;区块链网络&lt;/strong&gt;，里边有很多节点，不同的&lt;strong&gt;配置、位置、算力&lt;/strong&gt;，如何找到哪个节点是&lt;strong&gt;更重要&lt;/strong&gt;、&lt;strong&gt;更脆弱&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从&lt;strong&gt;攻&lt;/strong&gt;的角度，那就可以作为&lt;strong&gt;攻击目标&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对节点的攻击：1. 随机攻击 2.蓄意攻击&lt;/p&gt;
&lt;p&gt;随机攻击–&amp;gt;即使很多节点失效崩溃，但整个网络仍可保持连通&lt;/p&gt;
&lt;p&gt;蓄意攻击–&amp;gt;针对度很大的节点，网络就变得脆弱，可能崩溃&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从&lt;strong&gt;防&lt;/strong&gt;的角度，就是需要加强&lt;strong&gt;保护和完善&lt;/strong&gt;的脆弱点&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="信安赛" scheme="http://example.com/categories/%E4%BF%A1%E5%AE%89%E8%B5%9B/"/>
    
    
    <category term="复杂网络" scheme="http://example.com/tags/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/"/>
    
    <category term="文献笔记" scheme="http://example.com/tags/%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>区块链和复杂网络（基础知识）</title>
    <link href="http://example.com/2022/02/15/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/"/>
    <id>http://example.com/2022/02/15/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89/</id>
    <published>2022-02-14T16:22:17.000Z</published>
    <updated>2022-03-14T02:24:35.030Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>区块链，什么是，有什么技术架构、特点、应用场景、优缺点</li><li>复杂网络（complex network），弄明白什么是复杂网络（区块链网络就是一个例子）</li></ul></li></ul><span id="more"></span><h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><ul><li><p>​    一种在<strong>对等网络环境</strong>下，通过透明和可信<strong>规则</strong>，构建不可伪造、不可篡改、可追溯的<strong>块链式数据结构</strong>，实现和<strong>管理事务处理</strong>的模式。</p></li><li><p>​    区块链本质上是一个去中心化的分布式账本数据库（在与比特币相关的区块链应用中可使用这一术语，但区块链技术可能并不包含“账本”, 其本身是一串使用<strong>密码学相关联所产生的数据块</strong>，每一个数据块中包含了多次比特币网络交易有效确认的信息。)</p></li><li>每个区块按照 <strong>时间</strong> 线性顺序推进 </li></ul><blockquote><p>？对等网络环境：</p><ul><li><p>Peer-to-peer network （P2P）</p></li><li><p>彼此连接的多台计算机之间都处于对等的地位 有相同的功能，无主从之分，一台计算机既可作为服务器，设定共享资源供网络中其他计算机所使用，又可以作为工作站，整个网络一般来说不依赖专用的集中服务器，也没有专用的工作站</p></li><li>P2P一个重要特点是改变互联网现在的以太网站为中心的状态、重返“非中心化”，并把权力交还给用户</li></ul><p>？理解：特殊的分布式数据库→ </p><p>​                每个网络上的节点共享数据，通过共识算法，保证整个区块链网络的一致性和安全性</p></blockquote><h2 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h2><h3 id="密码学技术"><a href="#密码学技术" class="headerlink" title="密码学技术"></a>密码学技术</h3><ul><li>哈希算法</li><li>非对称加密技术</li><li>数字签名</li></ul><h3 id="区块结构-链式结构"><a href="#区块结构-链式结构" class="headerlink" title="区块结构+链式结构"></a>区块结构+链式结构</h3><h3 id="Merkle树"><a href="#Merkle树" class="headerlink" title="Merkle树"></a>Merkle树</h3><h3 id="P2P网络"><a href="#P2P网络" class="headerlink" title="P2P网络"></a>P2P网络</h3><h3 id="挖矿与共识"><a href="#挖矿与共识" class="headerlink" title="挖矿与共识"></a>挖矿与共识</h3><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>略</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>略</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>分布式的去中心化</strong><ul><li>去中心化：每个节点对等，基于<strong>P2P</strong></li></ul></li><li><strong>无须信任系统</strong><ul><li><strong>密码学+共识算法</strong> –&gt; 信任从第三方机构转移到区块链网络</li></ul></li><li><strong>不可篡改</strong><ul><li>每个区块的产生所需付出的<strong>算力成本高</strong></li></ul></li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p><strong>交易账本必须公开</strong></p></li><li><p><strong>延迟性</strong></p><ul><li>每隔<strong>一定时间</strong>将自上一个区块以后的交易<strong>打包生成新</strong>的区块</li></ul></li><li><p><strong>浪费能源</strong></p></li><li><p><strong>占用空间</strong></p><ul><li>每个节点可存储共享一份<strong>全网的账本数据</strong></li></ul></li><li><p><strong>修复时间长</strong></p><ul><li><p>出现代码漏洞需修复时，<strong>每个节点</strong>都采取措施更新才能最终完成漏洞修复。</p></li><li><p>从发布漏洞补丁到每个节点都完成修复耗时长，且不保证每个节点都被及时修复。</p><blockquote><ul><li>中心化的网络则可以通过同步下发给所有子节点进行快速修复。</li></ul></blockquote></li></ul></li></ul><h1 id="复杂网络"><a href="#复杂网络" class="headerlink" title="复杂网络"></a>复杂网络</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>典型的网络：节点+连接节点的边<ul><li>节点：代表真实系统中不同的<strong>个体</strong></li><li>边：代表个体之间的<strong>关系</strong></li><li>eg：神经网络、计算机网络、电力网络、社会关系网络</li></ul></li><li>网络的拓扑性质<ul><li>网络<strong>不依赖</strong>于节点的 <em>具体位置</em> 和 边的 <em>具体形态</em> 就能表现出来的性质</li><li>性质相应的结构：网络的拓扑结构</li></ul></li></ul><h3 id="复杂网络-1"><a href="#复杂网络-1" class="headerlink" title="复杂网络"></a>复杂网络</h3><ul><li><p>钱学森给出的严的定义：具有<strong>自组织、自相似、吸引子、小世界、无标度</strong>中 <strong>部分或全部</strong>性质 的网络</p></li><li><p>言外之意，复杂网络就是指一种呈现<strong>高度复杂性</strong>的网络</p></li><li><blockquote><blockquote><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2007&amp;filename=JSJA200712003&amp;uniplatform=NZKPT&amp;v=4M8fbSr9Jag8kRTp3gVwrqO7hkHjgcLxJ-HaeSp7dV8RwFv4B21WmBjH1CFMYSVH">[1]赫南,李德毅,淦文燕,朱熙.复杂网络中重要性节点发掘综述[J].计算机科学,2007(12):1-5+17.</a></p></blockquote></blockquote></li><li><p>上文献中认为：复杂网络没有精确严格的定义</p><ul><li><p>可以<strong>看作大量真实复杂系统的拓扑抽象</strong>。</p><blockquote><p>既不是规则网络，也不是随机网络</p><p>现实世界中的复杂网络比如：社会关系网络、论文引用网络、软件类网络…</p></blockquote></li></ul></li></ul><h4 id="特性1：小世界"><a href="#特性1：小世界" class="headerlink" title="特性1：小世界"></a><strong>特性1：小世界</strong></h4><ul><li><p>社交网络中的任何一个成员和任何一个陌生人之间所间隔的人<strong><font color="green">不会超过六个</font></strong> (六度空间理论）</p></li><li><p>小世界网络有 规则网络类似的<font color = "green">聚集性 </font>+ 随机网络类似的较小的<font color="green">平均路径长度</font></p></li><li><p><strong>衡量网络的两个特征</strong></p><ul><li><p><code>特征路径长度（characteristic path length）</code>：在网络中，任选两个节点，<strong>连通</strong>这两节点的<strong>最少</strong>边数，定义为这两个节点的路径长度，网络中<strong>所有节点对的路径长度的平均值</strong>，定义为网络的特征路径长度。</p><ul><li>网络的全局特征。</li></ul></li><li><p><code>聚合系数(clustering coefficient)</code>：假设某节点有k条边，则这k条边连接的节点（k个）之间最多可能存在的边的条数为k(k−1)/2</p><ul><li><p>节点的聚合系数：用<strong>实际存在的边数</strong>除以<strong>最多可能存在的边数</strong>得到的分数值</p></li><li><p><strong>所有节点的聚合系数的均值</strong>定义为网络的聚合系数。</p></li><li><p>聚合系数是网络的局部特征，反映了相邻两个人之间朋友圈子的<strong>重合度</strong>，即该节点的朋友之间也是朋友的程度。</p></li><li><p>对于规则网络，任意两个点（个体）之间的特征路径长度长（通过多少个体联系在一起），但聚合系数高（你是朋友的朋友的朋友的几率高）。</p><blockquote><p>规则网络：用一种固定的规则的结构表示：如二维平面上的欧几里得网格</p></blockquote></li><li><p>对于随机网络，任意两个点之间的特征路径长度短，但聚合系数低。而小世界网络，点之间特征路径长度小，接近随机网络，而聚合系数依旧相当高，接近规则网络。</p><blockquote><p>随机网络：节点之间的边不再是确定的，而是用一个概率决定</p></blockquote></li></ul></li></ul></li><li><p>实际的社会、生态、等网络都是小世界网络：</p><ul><li>信息传递速度快，并且少量改变几个连接，就可以剧烈地改变网络的性能，<ul><li>如对已存在的网络进行调整，如蜂窝电话网，改动很少几条线路，就可以显著提高性能。</li></ul></li></ul></li></ul><h4 id="特性2：无标度（Scale-free）"><a href="#特性2：无标度（Scale-free）" class="headerlink" title="特性2：无标度（Scale-free）"></a>特性2：无标度（Scale-free）</h4><ul><li><p>现实世界的网络大部分都不是随机网络，<strong>少数的节点往往拥有大量的连接，而大部分节点却很少</strong>，节点度数分布符合<strong>幂律分布</strong>—&gt;网络的无标度特性。度分布符合<strong>幂律分布</strong>的复杂网络—&gt;无标度网络。</p><blockquote><p>幂律分布：指某个具有分布性质的变量，且其分布密度函数是幂函数（由于分布密度函数必然满足“归一律”，所以这里的幂函数，一般规定小于负1）的分布</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2022/03/81fea0f2e904600c.png" style="zoom:33%;" /></p></li><li><p>无标度特性反映：复杂网络具有严重的<strong>异质性</strong>，其各节点之间的连接状况<strong>（度数）具有严重的不均匀分布性</strong></p><ul><li>网络中<strong>少数</strong>称之为<strong>Hub点</strong>的节点拥有<strong>极其多</strong>的连接，</li><li>而<strong>大多数</strong>节点只有很<strong>少量</strong>的连接。</li><li>少数Hub点对无标度网络的运行起着<strong>主导</strong>的作用。</li><li>从广义上说，无标度网络的无标度性是描述大量复杂系统<strong>整体上严重不均匀分布</strong>的一种内在性质。</li></ul></li><li><p>其实复杂网络的无标度特性与<strong>网络的鲁棒性分析</strong>具有密切的关系。</p><ul><li><p>无标度网络中<strong>幂律分布特性</strong>的存在极大地提高了<strong>高度数节点存在</strong>的可能性，因此，无标度网络同时显现出<strong>针对随机故障的鲁棒性和针对蓄意攻击的脆弱性</strong>。这种鲁棒且脆弱性对网络容错和抗攻击能力有很大影响。</p><blockquote><p>鲁棒性：在异常和危险情况下系统生存的能力</p></blockquote></li><li><p>无标度网络具有很强的容错性，但是对基于节点度值的选择性攻击而言，其<strong>抗攻击能力相当差</strong>，高度数节点的存在极大地削弱了网络的鲁棒性，一个恶意攻击者只需选择攻击网络很少的一部分高度数节点，就能使网络迅速瘫痪</p></li></ul></li></ul><h1 id="参考文献-博客出处"><a href="#参考文献-博客出处" class="headerlink" title="参考文献/博客出处"></a>参考文献/博客出处</h1><blockquote><p><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&amp;dbname=CJFD2007&amp;filename=JSJA200712003&amp;uniplatform=NZKPT&amp;v=4M8fbSr9Jag8kRTp3gVwrqO7hkHjgcLxJ-HaeSp7dV8RwFv4B21WmBjH1CFMYSVH">[1]赫南,李德毅,淦文燕,朱熙.复杂网络中重要性节点发掘综述[J].计算机科学,2007(12):1-5+17.</a></p><p><a href="https://www.cnblogs.com/maybe2030/p/4665847.html#_labelTop">[Network Analysis] 复杂网络分析总结 - Poll的笔记 - 博客园 (cnblogs.com)</a></p><p><a href="https://shuwoom.com/?p=403">区块链快速入门 - shuwoom的博客</a></p><p>[1]周涛,柏文洁,汪秉宏,刘之景,严钢.复杂网络研究概述[J].物理,2005(01):31-36.</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;区块链，什么是，有什么技术架构、特点、应用场景、优缺点&lt;/li&gt;
&lt;li&gt;复杂网络（complex network），弄明白什么是复杂网络（区块链网络就是一个例子）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="信安赛" scheme="http://example.com/categories/%E4%BF%A1%E5%AE%89%E8%B5%9B/"/>
    
    
    <category term="复杂网络" scheme="http://example.com/tags/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/"/>
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>test1</title>
    <link href="http://example.com/2022/01/21/test1/"/>
    <id>http://example.com/2022/01/21/test1/</id>
    <published>2022-01-20T16:50:26.000Z</published>
    <updated>2022-03-22T02:09:15.885Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个拿来测试的捏<br><span id="more"></span><br><div class="note info">            <p>现在该说点什么呢</p>          </div></p><p>其中，note 后面的class_name 可以是以下列表中的一个值：</p><ul><li>default</li><li>primary</li><li>success</li><li>info</li><li>warning</li><li>danger</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一个拿来测试的捏&lt;br&gt;</summary>
    
    
    
    <category term="部署测试" scheme="http://example.com/categories/%E9%83%A8%E7%BD%B2%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="测试" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
    <category term="部署" scheme="http://example.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/01/20/hello-world/"/>
    <id>http://example.com/2022/01/20/hello-world/</id>
    <published>2022-01-20T12:17:59.609Z</published>
    <updated>2022-01-20T17:04:21.159Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
