<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiaN</title>
  
  <subtitle>是一只废物捏</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-19T14:50:19.063Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>LiaN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【SE】数据库</title>
    <link href="http://example.com/2022/07/22/2022-07-22-%E3%80%90SE%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2022/07/22/2022-07-22-%E3%80%90SE%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-07-22T01:55:34.000Z</published>
    <updated>2022-07-19T14:50:19.063Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><strong>关系型数据库</strong>（RDBMS）：建立在关系模型基础上，由多张互相连接的<strong>二维表</strong>组成的数据库</p><ul><li>特点：使用表存储：格式统一；使用SQL语言操作：标准统一</li></ul><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>DDL：数据<strong>定义</strong>（define）语言；定义数据库对象（数据库、表、字段）</li><li>DML：数据<strong>操作</strong>（manipulation）语言；对数据库表的<strong>数据进行增删改</strong></li><li>DQL：数据<strong>查询</strong>（query）语言；查询数据库表的<strong>记录</strong></li><li>DCL： 数据<strong>控制</strong>（control）语言；创建数据库用户、控制数据库访问权限</li></ul><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><p>(中括号代表可选)</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES; </span><br><span class="line"># 查询当前所处的数据库</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE(); </span><br><span class="line"># 创建,字符集建议用utf8mb4不用utf8</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名[<span class="keyword">DEFAULT</span> CHARSET 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br><span class="line"># 删除</span><br><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] 数据库名;</span><br><span class="line"># 使用；</span><br><span class="line">USE 数据库名;</span><br></pre></td></tr></tbody></table></figure><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 查询当前数据库的 所有表</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"># 查询表结构</span><br><span class="line"><span class="keyword">DESC</span> 表名;</span><br><span class="line"># 查询指定表的建表语句</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"></span><br><span class="line"># 创建表，最后一个字段没有逗号</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型[COMMENT 字段<span class="number">1</span>注释],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型[COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br><span class="line"></span><br><span class="line"># 修改表</span><br><span class="line"># 添加字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度) [COMMENT 注释][约束];</span><br><span class="line"></span><br><span class="line"># 修改字段</span><br><span class="line"># 修改：字段类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型(长度);</span><br><span class="line"># 修改：字段名 和 字段类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束];</span><br><span class="line"></span><br><span class="line"># 删除字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名;</span><br><span class="line"></span><br><span class="line"># 删除表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>[IF <span class="keyword">EXISTS</span>]表名;</span><br><span class="line"># 删除指定表，并重新创建该表：清除了数据，只剩下表jie</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></tbody></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>char 和 varchar</strong>：</p><ul><li>char性能比varchar好</li><li>char定长，varchar变长</li></ul><p><strong>日期类型</strong>：</p><ul><li>DATE、TIME、YEAR、DATETIME、TIMESTAMP</li></ul><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;&lt;strong&gt;关系型数据库&lt;/strong&gt;（RDBMS）：建立在关系模型基础上，由多张互相连接的&lt;strong&gt;二维表&lt;/strong&gt;组成的数据库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;特点：使用表存储：格式统一；使用SQL语言操作</summary>
      
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【总结】数据结构（总结自《算法笔记》）</title>
    <link href="http://example.com/2022/07/08/2022-07-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%80%BB%E7%BB%93%E8%87%AA%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%EF%BC%89/"/>
    <id>http://example.com/2022/07/08/2022-07-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%80%BB%E7%BB%93%E8%87%AA%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%EF%BC%89/</id>
    <published>2022-07-08T11:08:20.000Z</published>
    <updated>2022-07-11T03:45:35.647Z</updated>
    
    <content type="html"><![CDATA[<ul><li>随便记记</li></ul><span id="more"></span><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line">st.<span class="built_in">push</span>(i);<span class="comment">//O(1)</span></span><br><span class="line">st.<span class="built_in">top</span>();<span class="comment">//O(1) 取得栈顶元素</span></span><br><span class="line">st.<span class="built_in">pop</span>();<span class="comment">//O(1) 弹出栈顶元素</span></span><br></pre></td></tr></tbody></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;<span class="comment">//以下时间复杂度都是O(1)</span></span><br><span class="line">q.<span class="built_in">front</span>(); q.<span class="built_in">back</span>();</span><br><span class="line">q.<span class="built_in">push</span>();  q.<span class="built_in">pop</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="中缀转后缀-求后缀表达式"><a href="#中缀转后缀-求后缀表达式" class="headerlink" title="中缀转后缀,求后缀表达式"></a>中缀转后缀,求后缀表达式</h2><p><a href="http://codeup.hustoj.com/problem.php?cid=100000602&amp;pid=0">题目链接</a></p><p>《算法笔记》P249</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line"><span class="keyword">double</span> num;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">};</span><br><span class="line">string str;</span><br><span class="line">queue&lt;node&gt;q;<span class="comment">//后缀表达式 </span></span><br><span class="line">stack&lt;node&gt;s;<span class="comment">//符号栈 </span></span><br><span class="line">map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;op;</span><br><span class="line"><span class="comment">//中缀转后缀 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">double</span> num;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();){</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>){</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp.num=str[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span>(i&lt;str.<span class="built_in">length</span>()&amp;&amp;str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>){</span><br><span class="line">temp.num = temp.num*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">q.<span class="built_in">push</span>(temp); <span class="comment">//数字存入后缀表达式队列中</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">temp.flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;op[str[i]]&lt;=op[s.<span class="built_in">top</span>().op]){</span><br><span class="line">q.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">}<span class="comment">//如果优先级不大于栈顶符号,把栈顶符号弹出,压入到后缀表达式中</span></span><br><span class="line">temp.op=str[i];<span class="comment">//直到优先级大于栈顶符号时,压入符号栈中</span></span><br><span class="line">s.<span class="built_in">push</span>(temp);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()){<span class="comment">//符号栈剩余符号压入后缀表达式中</span></span><br><span class="line">q.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//计算后缀表达式 </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cal</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">double</span> temp1,temp2;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t.flag) s.<span class="built_in">push</span>(t);</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp2=s.<span class="built_in">top</span>().num; s.<span class="built_in">pop</span>();</span><br><span class="line">temp1=s.<span class="built_in">top</span>().num; s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t.op==<span class="string">'+'</span>) temp.num =temp1+temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t.op==<span class="string">'-'</span>) temp.num=temp1-temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t.op==<span class="string">'*'</span>) temp.num=temp1*temp2;</span><br><span class="line"><span class="keyword">else</span> temp.num=temp1/temp2;</span><br><span class="line">s.<span class="built_in">push</span>(temp);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">top</span>().num;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">op[<span class="string">'+'</span>]=op[<span class="string">'-'</span>]=<span class="number">1</span>;</span><br><span class="line">op[<span class="string">'/'</span>]=op[<span class="string">'*'</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin,str),str!=<span class="string">"0"</span>){</span><br><span class="line"><span class="keyword">for</span>(string::iterator it=str.<span class="built_in">end</span>();it!=str.<span class="built_in">begin</span>();it--){</span><br><span class="line"><span class="keyword">if</span>(*it==<span class="string">' '</span>) str.<span class="built_in">erase</span>(it);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">Change</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,<span class="built_in">Cal</span>());</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h2><p><a href="http://codeup.hustoj.com/problem.php?cid=100000605&amp;pid=1">题目链接</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">stack&lt;<span class="keyword">char</span>&gt;s;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++){</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'['</span>||str[i]==<span class="string">'('</span>||str[i]==<span class="string">'{'</span>) s.<span class="built_in">push</span>(str[i]);</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">']'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'['</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">')'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'('</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'}'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'{'</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(!flag||!s.<span class="built_in">empty</span>()) cout&lt;&lt;<span class="string">"no"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"yes"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;随便记记&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【题解】BFS</title>
    <link href="http://example.com/2022/06/19/2022-06-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91BFS/"/>
    <id>http://example.com/2022/06/19/2022-06-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91BFS/</id>
    <published>2022-06-19T01:55:34.000Z</published>
    <updated>2022-07-11T03:51:40.576Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一些BFS</li></ul><span id="more"></span><h1 id="Easy-Part"><a href="#Easy-Part" class="headerlink" title="Easy Part"></a>Easy Part</h1><h2 id="AcW-844-走迷宫"><a href="#AcW-844-走迷宫" class="headerlink" title="AcW-844. 走迷宫 "></a><a href="https://www.acwing.com/problem/content/846/">AcW-844. 走迷宫 </a></h2><p>给定地图，求左上走到右下的步数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>({<span class="number">1</span>,<span class="number">1</span>});</span><br><span class="line">d[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> temp=q.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">int</span> x=temp.first,y=temp.second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=m&amp;&amp;d[xx][yy]==<span class="number">-1</span>&amp;&amp;g[x][y]==<span class="number">0</span>){</span><br><span class="line">d[xx][yy]=d[x][y]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({xx,yy});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;d[n][m]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Medium-Part"><a href="#Medium-Part" class="headerlink" title="Medium Part"></a>Medium Part</h1><h2 id="最小步数模型：状态的转变"><a href="#最小步数模型：状态的转变" class="headerlink" title="最小步数模型：状态的转变"></a>最小步数模型：状态的转变</h2><p>区分最短路模型：从一个点到另一个点的最短距离（比如AcW-844走迷宫）</p><p>关键：</p><ol><li>状态的存储：<ul><li><code>queue&lt;状态&gt;</code></li><li><code>unordered_map&lt;状态，步数&gt;dist</code>：记录到达状态的距离</li><li><code>unordered_map&lt;状态，&lt;前一个状态,转移操作&gt;</code>：记录前驱，用于路径输出</li></ul></li><li>状态的切换<ul><li>根据题意;</li><li>（下标从0开始）二维到一维：<code>int x = index / row_length, y = index % col_length</code></li></ul></li><li>思路：<ul><li>将初始状态加入到队列，然后BFS扩展，直到找到目标状态为止</li></ul></li></ol><h2 id="AcW-845-八数码"><a href="#AcW-845-八数码" class="headerlink" title="AcW-845. 八数码"></a><a href="https://www.acwing.com/problem/content/description/847/">AcW-845. 八数码</a></h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1、将每个3x3 理解成一个状态</span></span><br><span class="line"><span class="comment">2、从初始3x3到12345678x最小步数 -&gt; 从初始状态到目标状态 最短路</span></span><br><span class="line"><span class="comment">类比走迷宫那道题：从左上到右下的最小步数 </span></span><br><span class="line"><span class="comment">3、到达每个状态的对应一个步数：unordered_map&lt;string,int&gt;</span></span><br><span class="line"><span class="comment">4、unordered_map的count()用以统计key在unordered_map中出现的次数。</span></span><br><span class="line"><span class="comment">实际上，unordered_map不允许有重复的key。</span></span><br><span class="line"><span class="comment">因此，如果key存在，则count返回1，如果不存在，则count返回0. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(string start)</span></span>{</span><br><span class="line">queue&lt;string&gt;q;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt;d;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line">d[start]=<span class="number">0</span>;<span class="comment">//unordered_map[key]=value;</span></span><br><span class="line">string end=<span class="string">"12345678x"</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t==end) <span class="keyword">return</span> d[t];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx=t.<span class="built_in">find</span>(<span class="string">'x'</span>);</span><br><span class="line"><span class="keyword">int</span> x=idx/<span class="number">3</span>,y=idx%<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> dist=d[t];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;<span class="number">3</span>&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;<span class="number">3</span>){</span><br><span class="line"><span class="built_in">swap</span>(t[idx],t[xx*<span class="number">3</span>+yy]);</span><br><span class="line"><span class="keyword">if</span>(!d.<span class="built_in">count</span>(t)){</span><br><span class="line">d[t]=dist+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">swap</span>(t[idx],t[xx*<span class="number">3</span>+yy]);</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>];</span><br><span class="line">string start=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++){</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">start+=s[<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"><span class="comment">//cout&lt;&lt;start&lt;&lt;endl;</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">bfs</span>(start)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 2  3  4  1  5  x  7  6  8 </span></span><br></pre></td></tr></tbody></table></figure><h2 id="AcW-1107-魔板"><a href="#AcW-1107-魔板" class="headerlink" title="AcW-1107. 魔板 "></a><a href="https://www.acwing.com/problem/content/1109/">AcW-1107. 魔板 </a></h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> temp[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//每个状态string，存储上一个状态string </span></span><br><span class="line"><span class="comment">//经过操作char到达 </span></span><br><span class="line">unordered_map&lt;string,pair&lt;string,<span class="keyword">char</span>&gt;&gt;pre;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt;d;<span class="comment">//存储步数 </span></span><br><span class="line"><span class="keyword">void</span> _set(string s){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) temp[<span class="number">0</span>][i]=s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">7</span>;i&lt;<span class="number">4</span>,j&gt;<span class="number">3</span>;i++,j--) temp[<span class="number">1</span>][i]=s[j];</span><br><span class="line">}</span><br><span class="line"><span class="function">string <span class="title">get</span><span class="params">()</span></span>{</span><br><span class="line">string res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) res+=temp[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--) res+=temp[<span class="number">1</span>][i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//A:交换上下 </span></span><br><span class="line"><span class="function">string <span class="title">move0</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"> <span class="built_in">swap</span>(temp[<span class="number">0</span>],temp[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//B: </span></span><br><span class="line"><span class="function">string <span class="title">move1</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"><span class="keyword">char</span> a=temp[<span class="number">0</span>][<span class="number">3</span>],b=temp[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">temp[<span class="number">0</span>][i]=temp[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">temp[<span class="number">1</span>][i]=temp[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">} </span><br><span class="line">temp[<span class="number">0</span>][<span class="number">0</span>]=a;</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">0</span>]=b;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//C: </span></span><br><span class="line"><span class="function">string <span class="title">move2</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"><span class="keyword">char</span> t=temp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">temp[<span class="number">0</span>][<span class="number">2</span>]=temp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">temp[<span class="number">0</span>][<span class="number">1</span>]=temp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">1</span>]=temp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">2</span>]=t;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(string start,string end)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(start==end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">queue&lt;string&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line">d[start]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">string state[<span class="number">3</span>];</span><br><span class="line">state[<span class="number">0</span>]=<span class="built_in">move0</span>(t);</span><br><span class="line">state[<span class="number">1</span>]=<span class="built_in">move1</span>(t);</span><br><span class="line">state[<span class="number">2</span>]=<span class="built_in">move2</span>(t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++){</span><br><span class="line"><span class="keyword">if</span>(!d.<span class="built_in">count</span>(state[i])){</span><br><span class="line">d[state[i]]=d[t]+<span class="number">1</span>;</span><br><span class="line">pre[state[i]]={t,<span class="string">'A'</span>+i};</span><br><span class="line">q.<span class="built_in">push</span>(state[i]); </span><br><span class="line"><span class="keyword">if</span>(state[i]==end){</span><br><span class="line"><span class="keyword">return</span> d[state[i]];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">string start=<span class="string">"12345678"</span>;</span><br><span class="line">string end=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">end+=<span class="built_in"><span class="keyword">char</span></span>(c+<span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="built_in">bfs</span>(start,end);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">string res;<span class="comment">//从end往前找前驱 </span></span><br><span class="line"><span class="keyword">while</span>(end!=start){</span><br><span class="line">res+=pre[end].second;</span><br><span class="line">end=pre[end].first;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(ans&gt;<span class="number">0</span>) cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;一些BFS&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="BFS" scheme="http://example.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>【生活】Days Counter</title>
    <link href="http://example.com/2022/06/17/DaysCounter/"/>
    <id>http://example.com/2022/06/17/DaysCounter/</id>
    <published>2022-06-17T01:55:34.000Z</published>
    <updated>2022-07-22T12:43:19.797Z</updated>
    
    <content type="html"><![CDATA[<p>一些碎碎念记录</p><span id="more"></span><h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><h2 id="June"><a href="#June" class="headerlink" title="June"></a>June</h2><h3 id="17th"><a href="#17th" class="headerlink" title="17th"></a>17th</h3><ul><li>上午去把川大夏令营的章盖了，然后划水一上午</li><li>下午把网页代码写了一点，然后划水一下午</li><li>水群的时候看到fdu的夏令营开奖了，计科两位大佬入营了，太牛了，还好我没报，不然就要收到人生第一封夏令营拒信了OvO</li><li>小脑斧点赞我朋友圈了呜呜，泪目</li></ul><h3 id="18th"><a href="#18th" class="headerlink" title="18th"></a>18th</h3><ul><li>写了半天的前端</li><li>剩下半天划水</li><li>在b站刷到了以前的一部剧，《爱情宝典》，看了两集，果然还是那个年代的人做电视剧细心啊，服化道和人物形象和语言都让人觉得舒服，剧情节奏紧凑。</li></ul><h3 id="19th"><a href="#19th" class="headerlink" title="19th"></a>19th</h3><ul><li>上午把buaa的材料交了</li><li>下午睡了半个下午，写了半个下午的文档</li><li>呜呜感觉自己效率真的好低 ，一天下来好像什么也没干，等把信安赛初赛作品交了我要全身心投入复习！！！不能再像最近几天这么摸鱼了，感觉自己有好多东西要看，数据结构没复习完，计网还没开始背，操作系统也没有看，但操作系统应该很快就能看完吧。acwing的基础课还没有刷完，之前卖的linux基础课也没看，项目还没有好好整理复习。救命，怎么会有这么多事情要做，感觉自己一样都没开始做好QAQ。</li></ul><h3 id="20th"><a href="#20th" class="headerlink" title="20th"></a>20th</h3><ul><li>嗯，有点烦躁的一天。嗯，怎么说呢，学好语文真的是太重要太重要了，尤其是对于理工科。</li><li>熬一熬，再熬一熬就可以全身心地开始复习专业课了啾咪啾咪</li><li>晚上把文档搞完了，九点多就回去躺着啦嘿嘿</li></ul><h3 id="21st"><a href="#21st" class="headerlink" title="21st"></a>21st</h3><ul><li>早上自然醒太早了，把闹钟关了睡了个回笼觉结果睡过头了，上午就看了一点点点二叉树</li><li>中午回去吃完饭睡个午觉一觉睡到了三点多，开空调也能被热醒QAQ，傍晚洗完头洗完澡舒服多了，晚上等温度降下来了然后出门转一转</li><li>等晚上回来再好好学习（希望如此，但是现在就是一个毫无动力的状态，没有ddl来push我学习效率真的是太低惹。</li><li>晚上并没有好好学习，不过解决了一件麻烦事，舒服了<span class="github-emoji"><span>💮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4ae.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>先给明天画个饼🤗：早起（8点之前？），看完计网第一章，复习os第二章，刷几道基础课的题<span class="github-emoji"><span>🔨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f528.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="22nd"><a href="#22nd" class="headerlink" title="22nd"></a>22nd</h3><ul><li><p>确实早起成功了，六点半自然醒，意识醒了但是眼睛 睁不开<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，勉强睡到七点半才下床</p></li><li><p>给未来几天画个大饼</p></li><li><p>晚上摸鱼去啦，去一号门外面买了点荔枝和山竹，荔枝还是得吃妃子笑，白糖荔真的垃圾，水分和甜度都比不上妃子笑，虽然看起来大个儿又好看，但是核太大了，一颗白糖荔半颗核属于是。妃子笑yyds<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li></ul><h3 id="23rd"><a href="#23rd" class="headerlink" title="23rd"></a>23rd</h3><ul><li>上午开了个会，改了一下互联网+那个比赛的前端代码，<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>点了七口辣的火锅杯，一会儿拿完外卖再买半个西瓜再回宿舍，刷几集神探狄仁杰（真的没啥好剧可以看了，还是看这种老剧有意思，拍的真好啊），打算三点多的时候再出门吧，去院办把bit的章盖了，然后把留在院办的东西拿回来。学习，晚上再学<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>晚上不想学呜呜，呜呜能不能直接躺平等预推免啊，夏0营太耗费精力了呜呜，学不动 烦死啦，回去继续刷神探狄仁杰！！！！！！！！！！！</li></ul><h3 id="24th"><a href="#24th" class="headerlink" title="24th"></a>24th</h3><ul><li>昨天晚上南京下暴雨，一早睡到十点半才醒，中午点了黄焖鸡米饭，点的这家的不好吃，不如一号门外面的那家黄焖鸡米饭，有空出去吃一吃那家的<span class="github-emoji"><span>😮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>下午把计网的第一章看完了，好多啊好多啊，将近200页ppt，真的会谢，突然想起去年这个时候大概也在复习计网，hhh去年七月初考的计网好像是。</li><li>晚上数字图像处理的成绩出了，大三最后一门。以后再也不用卷生卷死卷分数啦 ，从大一上最初的82点几的均分，到大三下92点几的均分，还真是个逐渐“卷”化的三年，呜呜，这三年怎么这么快，呜呜<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="25th"><a href="#25th" class="headerlink" title="25th"></a>25th</h3><ul><li>上午又是一觉睡到十点多，虽然每天都是七点左右自然醒，但是醒了又没完全醒，所以继续睡<span class="github-emoji"><span>😴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f634.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>下午都在写PPT，没时间复习呜呜呜。</li><li>晚上去一号路吃了那个麻辣牛肚卷，牛肚真好吃呀，明天如果没吃晚饭的话就再去吃一次嘿嘿:happy:看计网的应用层的PPT看到了80页<span class="github-emoji"><span>💁♀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f481-2640.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，嗯，明天干啥呢，赌一波明天能不能早起，如果早起的话争取上午把应用层这一章的ppt看完吧，下午复习一下数据结构的查找那一章；晚上再过一遍os的进程这一章以及上午（可能）没看完的计网ppt</li></ul><h3 id="26th"><a href="#26th" class="headerlink" title="26th"></a>26th</h3><ul><li>早起成功，不过已经是早上十点<span class="github-emoji"><span>🕙</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f559.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，上午看了40页PPT，呜呜华东师范寄了呜呜，真就夏0营呗，呜呜呜呜，川大要是再给我寄，真的会emo呜呜，川大，我的川大<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>虽然说智能的去年前几名也是夏0营，呜呜，我知道是神仙打架，但是能不能给我一个offer保底呐QWQ，心痛呜呜，下午决定把那几个不想去的学校也报一下呜呜，能不能让我有个夏令营体验感！！！！！</li><li>15:50的时候终于把应用层这章的PPT看完了<span class="github-emoji"><span>🤠</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f920.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>下午跟cbj学长聊了会儿保研的事情，呜呜感觉自己又重新燃起了自己一定有书读的期望！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</li><li>18:57把数据结构的排序这章看了2/3，好饿QwQ，出去吃昨天吃的牛肚卷！<span class="github-emoji"><span>🤗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f917.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>吃饱回来再学</li><li>牛肚卷好好吃✌，吃完回来把排序这张看完了；昨天画的饼没有实现<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>（虽然是意料之中</li><li>如果明天能够早起的话，画的饼应该就是：上午把王道的排序这章节题做了，如果互联网+的ppt浪费的时间不多的话，复习一下os的存储管理这一章，然后倒着过一遍进程和死锁那一章；</li></ul><h3 id="27th-30th"><a href="#27th-30th" class="headerlink" title="27th-30th"></a>27th-30th</h3><ul><li>头痛摸鱼睡觉不愿打字</li></ul><h2 id="July"><a href="#July" class="headerlink" title="July"></a>July</h2><h3 id="1st"><a href="#1st" class="headerlink" title="1st"></a>1st</h3><ul><li>买的摄像头和支架到了，白天复习了操作系统的文件管理（一半），还剩最后的IO设备管理</li><li>今天晚上把比赛报告改完然后看一遍，再把ppt做了，还要川大的面试ppt</li><li>2、3、4、5、希望3号之前能把os过一遍，4、5号复习数据结构，自我介绍打个草稿QwQ</li><li>等南大的机试完了（寄了）然后开始跑步运动；上旬复习408，下旬复习数学！zyl可真会画大饼呐</li></ul><h3 id="2nd"><a href="#2nd" class="headerlink" title="2nd"></a>2nd</h3><ul><li><p>越是ddl就越是懒，在摆烂的边缘疯狂试探</p></li><li><p>下午把文件管理和设备管理走马观花看完了，晚上回寝室摸鱼嘿嘿嘿</p></li><li><p>夏天的天空真的好好看，不用p图的好看</p><p><img src="https://s2.loli.net/2022/07/03/Aje27ih1sdmZpEG.jpg" alt="SHWY_N_7P9@M87J3UOU_VXK.jpg" style="zoom: 50%;"></p></li><li><p>晚上嘴馋但是不饿，点了鸡丁炒饭，我觉得酸豇豆和酸萝卜真的好吃，感觉一般般，所以吃了一个多小时一半都没吃完</p><p><img src="https://s2.loli.net/2022/07/03/wEos5eXkpqvArFu.jpg" alt="5__WOM1`GU_05CH60Q9_K83.jpg" style="zoom:20%;"></p></li><li><p>听闻某同学 北大，复旦，人大，中山，上交都入营了之后的内心活动：<br>真厉害啊不愧是ta太牛啦<span class="github-emoji"><span>😍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>呜呜呜不愧是我太废物啦<span class="github-emoji"><span>😿</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f63f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>呜呜真就2%的人拿98%的offer<span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>好累尼玛，等川大面试完就躺平准备预推免吧，夏令营不适合我这种垃圾<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>每个高校的夏令营就是硬气，只要985和211的rk1[自抱]希望你们预推免和九推的时候也敢这么硬气<span class="github-emoji"><span>😮</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>希望大佬们夏令营赶紧拿完offer早点确定，预推免不要跟我这种垃圾争<span class="github-emoji"><span>😩</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f629.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li></ul><h3 id="3rd"><a href="#3rd" class="headerlink" title="3rd"></a>3rd</h3><ul><li>呜呜呜我以为 今天能够把os过一遍，结果晚上才开始过进程这一章呜呜，明天就开营了淦</li><li>买了一盒周黑鸭的鸭翅，好好吃<span class="github-emoji"><span>💃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f483.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>💃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f483.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>💃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f483.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="4th"><a href="#4th" class="headerlink" title="4th"></a>4th</h3><ul><li>排队等njucs的网络测试浪费我一个下午，哼哼</li></ul><h3 id="5th"><a href="#5th" class="headerlink" title="5th"></a>5th</h3><ul><li><p>吼吼，生活费到账了，点了绝味的鸭翅，真没有周黑鸭的鸭翅好吃，这波属实周黑鸭赢！</p></li><li><p>今天发现网易云的一个新功能，就是用歌房的耳返功能来背书，真不错！！！！！！！</p></li><li><p>早上起来发现寝室没电了，问了六个人校园卡里有没有钱，结果都没有hhhh</p><p><img src="https://s2.loli.net/2022/07/05/wW6aUFudTLZe2mD.png" alt="image.png" style="zoom: 33%;"></p></li><li><p>北航入营了，得知入营的瞬间是开心的，但又发现机试过不了的话不仅无法面试，还不能报之后的预推免，悲，真的是大喜大悲，无尽的悲。这种给你希望又让你意识到最后没有希望的感觉真是太上头迷死人啦<span class="github-emoji"><span>😡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f621.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，夏令营==体验营；明天川大cs我连数据结构都没复习完，项目也没复习呜呜呜。为什么过得会比期末都痛苦啊<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，期末复习好了期末就有希望，夏令营就算复习好了也没希望，并且根本不可能复习不好，一个寄字贯穿zyl的一生</p><p><img src="https://s2.loli.net/2022/07/05/lrbLWzi1T6UQNB7.png" alt="image.png" style="zoom:33%;"></p></li><li><p>原来在学校感受到的夏天的傍晚是，趴在阳台看晚霞，听楼下小树林的蝉鸣，还有足球场上少年们的欢呼</p><p><img src="https://s2.loli.net/2022/07/05/mExB3HPnWcdN5ST.jpg" alt="~BAFHI42FAD1J___2A_D7_Y.jpg" style="zoom: 25%;"></p></li><li><p>后悔，究极后悔，<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>!<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！<strong>放下助人情结，尊重他人命运</strong>！</p></li><li>呜呜，明天面试我真的复习不完了呜呜哒咩<span class="github-emoji"><span>😖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f616.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>，执行一个宵的通，面试完回来进行一个大觉的睡<span class="github-emoji"><span>😪</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li></ul><h3 id="6th"><a href="#6th" class="headerlink" title="6th"></a>6th</h3><ul><li><p>中午scu面试，英语阅读和翻译磕磕绊绊，答题也答得磕磕绊绊，夏令营的第一个面试，算是攒了一丢丢经验，赢！hhh最后也不期待有没有优营了，随缘吧</p></li><li><p>面完试回去洗了个澡，下午去院办找同学盖章，快要下雨前的天气真的又闷又热，爬个坡又出汗了，澡白洗了属于是</p></li><li><p>晚上出去一号门吃了酸汤水饺，还有他们家的素菜拼盘，素菜拼盘好便宜，七块钱那么大一盘；然后去菜市场那边买了几颗水蜜桃，还有白糖罂，呜呜现在好像没看到有妃子笑卖了，在妃子笑面前，白糖罂永远是弟弟，妃子笑就是最好吃的品种！然后称了一点那个🍇，老板说那个品种叫郁金香，不得不说真的难吃啊，真不如夏黑或者巨峰；吃完饭出来突然发现晚霞很好看</p><p><img src="https://s2.loli.net/2022/07/07/QhVYP628ewDBtXn.jpg" alt="8X~HO6__03F0~F2B4JEW_VS.jpg" style="zoom:25%;"></p><p><img src="https://s2.loli.net/2022/07/07/JSEAljVx38WUDiO.jpg" alt="4CMH4PPX_DF_LZES@HO57_X.jpg" style="zoom:20%;"></p></li><li><p>回去的路上去取了个快递，买的可乐到了，然后回院办拿了遗忘在那里的三脚架</p></li><li><p>晚上收拾了一下宿舍，把好多好多不要的书都扔了，这些仿佛不是扔掉的书，而是之前一个个立下的但是从来没有完成过的flag，悲，大学三年立了这么多flag</p><p><img src="https://s2.loli.net/2022/07/07/4TfJ2vNw8YCBMgL.jpg" alt="G5SUA7QFD9__0__7__XKENM.jpg" style="zoom:33%;"></p></li><li><p>收拾东西的时候又把当年军训的那张大合照翻了出来，真的是，每一个人现在都不像从前了，毕竟那估计是大家最丑的时候hhhhh</p><p><img src="https://s2.loli.net/2022/07/07/BHETgdk2RMGm9aW.jpg" alt="_F14C`QC1WTM_CK6P2_AB_B.jpg" style="zoom: 25%;"></p></li></ul><h3 id="8th"><a href="#8th" class="headerlink" title="8th"></a>8th</h3><ul><li>buaa爆零，当初为什么不拿csp抵！！！！后悔，算了，看来<span class="github-emoji"><span>🐁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f401.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f401.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>我注定和buaa无缘，嘤嘤嘤这是命</li><li>下午睡一觉睡到了晚上，醒来好难过好难过好难过，我真的会有书读吗<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>我怎么这么垃圾这么废物呜呜</li><li>晚上好饿，点了炸串，最近真的吃好多</li><li>淦，吃撑了不舒服，呜呜更加难过了<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></li><li>scu专硕，虽然说不定最后能递补到学硕，但感觉又不想去了，四舍五入还是夏0营</li></ul><h3 id="9th"><a href="#9th" class="headerlink" title="9th"></a>9th</h3><ul><li>不知道自己干了啥</li></ul><h3 id="10th"><a href="#10th" class="headerlink" title="10th"></a>10th</h3><ul><li><p>上午家里人打电话说了一些蛮悲伤和一些挺无奈的事情，晚上知道了一些让自己破大防的事情，非常非常，心态非常崩的一天，真的好难过好难过，2022年最难过的一天，心态崩到十一点上床一直到一点半都没睡着，然后和好朋友聊天聊到三点多<span class="github-emoji"><span>😴</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f634.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。直到11号早上起来写下这个记录还是很难过，呜呜呜呜我好废物啊</p><p><img src="https://s2.loli.net/2022/07/11/3dcVNGeya5Lbf1x.jpg" alt="TW_X_ZIXCY_S_R9_WS53@6O.jpg" style="zoom:25%;"></p><p><img src="https://s2.loli.net/2022/07/11/fl5dmFIxH379oE4.jpg" alt="QR5_`TGOUG0_@DZYW0_S_G7.jpg" style="zoom: 25%;"></p></li></ul><h3 id="11th"><a href="#11th" class="headerlink" title="11th"></a>11th</h3><ul><li>好了但没完全好呜呜</li></ul><h3 id="12th"><a href="#12th" class="headerlink" title="12th"></a>12th</h3><ul><li><p>好烦<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不想学</p><p><img src="https://s2.loli.net/2022/07/13/BegP3Lf1EN4hm5Z.jpg" alt="PL__@_98W8_0T37_7_FSR_X.jpg" style="zoom:33%;"></p></li></ul><h3 id="13th"><a href="#13th" class="headerlink" title="13th"></a>13th</h3><ul><li><p>好烦<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>不想学；今天七点半就起床了，buaa软院机试，寄。</p></li><li><p>昨天换的微信犯贱专用新头像，乐；</p><p><img src="https://s2.loli.net/2022/07/13/zWqyZi1maLY3kGr.jpg" alt="O537D20K97~DQRED_PR__VP.jpg" style="zoom: 25%;"></p></li><li><p>我就喜欢这种又带有一点幽默同时又讲得条理清晰的博客</p><p><img src="https://s2.loli.net/2022/07/13/PsLIB9KO8Axtd1X.png" alt="image.png" style="zoom: 43%;"></p></li></ul><h3 id="14th-17th"><a href="#14th-17th" class="headerlink" title="14th-17th"></a>14th-17th</h3><p>难过到一定程度就不想说话</p><h3 id="18th-1"><a href="#18th-1" class="headerlink" title="18th"></a>18th</h3><ul><li><p>呜呜我昨天晚上做梦了，看到了好美好美的彩虹和晚霞，真的好美好美，无法形容的美，醒来还是觉得真tmd太美了</p></li><li><p>我真的觉得 我需要花一个暑假去治愈那致郁的20min，太痛苦了呜呜呜呜<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>每次回想都超级难过和心塞呜呜呜呜，这个暑假最让我难过的事情呜呜呜</p></li><li><p>下午太困了，睡醒起来就傍晚了，还是被热醒的，很可恶。出门的时候看到晚霞挺好看，但是没有昨天梦里见到的晚霞那么好看。还得是梦比较有意思。我每次脑袋放空然后突然想到那致郁的二十分钟，都真的好难过，上大学到现在还没有什么经历带给我的后劲这么大。</p><p><img src="https://s2.loli.net/2022/07/18/tEGrTc67CjB8JwL.jpg" alt="M`3SDQ7_PE2_JW9_A3U_I_O.jpg" style="zoom: 43%;"></p><p>​        前段时间堂哥打电话闲聊家常，他随口问了我一句读书压力大不，我没太在意，半开玩笑的语气说确实有点大。后来我妈突然给我发微信说不要给自己太大压力，可能就是新闻看多了就生怕我像电视新闻里的那样想不开。倒也没有。但我细想从小到大的压力几乎都是自己给的，似乎没有外在的谁给我带来什么压力。至少在读书方面，家里人从来没要求我说一定要上什么什么大学，一定要读到研究生还是读到博士，从来没给我带来任何压力。大概自驱力太强，也大概是觉得，什么都靠不住，除了自己。</p><p>​        记得在刚上大一的时候，一位朋友曾跟我聊过社会原子化的概念，当时只是觉得有意思。现在却越来越觉得很对。原子化的每个个体都是孤独的、埋头于物质享受的，这样的个体普遍存在，并且这些个体之间也没有强有力的联系。大概人的各种想法和见解确实会随经历和时间改变，说不定过几年回看此刻的想法会觉得荒诞和可笑，管它呢，那就过几年再说吧。好像人与人之间的联系根本就是这样，一点也不紧密，大家都是原子化孤立的个体，看似牢不可破的连接只是看似而已。啧，感觉自己好悲观，也不是悲观。</p><p>​        此刻耳机里刚好放到陈奕迅的《最佳损友》这首歌，“来日陌生的是昨日最亲的某某”。我真该以一种发展和质疑的眼光看待每一段人与人之间的关系。基于一种对任何人都不可信和不值得信的态度，甚至逐渐养成了回避型依恋人格。不过我很喜欢这种有效的自我保护机制，挺好的。所以，把任何人考虑进未来规划中都是很愚蠢的想法，对我来说。所以，狠狠地自我批判一下前一段时间愚蠢的自己。</p><p>​        某朋友之前说得不错，我有点不太能认清自己，以及太在意别人的看法。太对了，别人的看法其实跟自己半毛钱关系都没有，“别人的看法”在某种角度上来看，其实就是，自己给自己戴上的一副枷锁。我tmd做什么选择，过得好不好，跟别人的看法有半毛钱关系。或者说，我tmd连自己都过不好为什么还要在意别人怎么想。世界上所有事情概括起来无非是“关我p事”和“关你p事”这两件事了。emm，我最近一定是太难过了呜呜，才会七想八想想这么多，呜呜呜不愧是本废物。回来的路上看到那些夜跑的人，意识到自己好久没有运动了。</p></li><li><p>今天中午一个人在寝室吃了螺蛳粉，晚上出门吃了黄焖鸡米饭，都挺好吃的，但是胃口不大吃了不到一般都没吃完，属实有点浪费了。</p><p><img src="https://s2.loli.net/2022/07/18/YkcCLs8oTRJy3uP.jpg" alt="BE_P_S__EYU_2___06HU3_O.jpg" style="zoom: 33%;"></p></li></ul><p>  <img src="https://s2.loli.net/2022/07/18/TicYUdItLMJQSEb.jpg" alt="N9F4NX@_E_20SS`Q_@JIIV1.jpg" style="zoom: 33%;"></p><h3 id="19th-1"><a href="#19th-1" class="headerlink" title="19th"></a>19th</h3><ul><li><p>为什么夏天可以这么困啊，整个一天都属于很想睡觉的状态；早上根本起不来<span class="github-emoji"><span>❔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2754.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li><li><p>但是没有很摆烂，下午还是学了一丢丢；</p></li><li><p>晚上点了一家之前没有吃过的酸萝卜鱼，真的好好吃，关键是汤真的好好喝！</p><p><img src="https://s2.loli.net/2022/07/19/QmoYhXlSUGCWFps.jpg" alt="KQU2VNSJJV_UH_7NJX90RPG.jpg" style="zoom: 33%;"></p></li></ul><h3 id="20th-1"><a href="#20th-1" class="headerlink" title="20th"></a>20th</h3><ul><li>星汉灿烂真的好好看，吴磊好帅，赵露思好甜呜呜呜 </li><li>晚上去跑了三公里，好久没跑步了有点拉跨了，看来以后应该要抽空多锻炼锻炼捏OwO</li></ul><h3 id="21st-1"><a href="#21st-1" class="headerlink" title="21st"></a>21st</h3><ul><li><p>突然得到seu要联系导师才能入营，得知消息后花半个小时写完套磁信，联系了之前看上的那位导师，不到五分钟的样子导师就回复了我，然后过了一会儿就发腾讯会议号说过两个多小时就面试，真的好高效啊，我赶忙给自我介绍打草稿，然后面试面了整整半个小时，说实话，感觉每一场面试都能发现自己很多问题，一紧张就语速变快不会断句的臭毛病什么时候能该啊呜呜呜，然后最后可以推荐入营了呜呜呜开心。</p></li><li><p>之前本来想着但凡能拿到seu的专硕甚至候补保个底，现在 看这个导师的方向真的越看越喜欢，感觉真的好有意思！！！！！！！！！感觉课题组氛围好像也不错，呜呜呜，如果真的能拿到夏令营的offer，如果这位导师真的愿意收我我就直接有学上就躺平了hhh。然后在绿群遇到和我报同一个导师的hxd，看来大家的想法都是出奇的一致hhhh</p><p><img src="https://s2.loli.net/2022/07/22/RgXori7K4sYpSlu.png" alt="_HBP_Y__O2IRFT5JA61B@CS.png" style="zoom: 25%;"></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些碎碎念记录&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://example.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="胡言乱语" scheme="http://example.com/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>【题解】模板题总结</title>
    <link href="http://example.com/2022/06/15/2022-06-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A8%A1%E6%9D%BF%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/06/15/2022-06-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A8%A1%E6%9D%BF%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-15T08:18:55.000Z</published>
    <updated>2022-06-15T07:51:57.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础算法&quot;&gt;&lt;a href=&quot;#基础算法&quot; class=&quot;headerlink&quot; title=&quot;基础算法&quot;&gt;&lt;/a&gt;基础算法&lt;/h1&gt;&lt;h2 id=&quot;快排&quot;&gt;&lt;a href=&quot;#快排&quot; class=&quot;headerlink&quot; title=&quot;快排&quot;&gt;&lt;/a&gt;快排&lt;/h</summary>
      
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【题解】每日一题</title>
    <link href="http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2022-05-19T03:08:20.000Z</published>
    <updated>2022-05-19T13:46:57.219Z</updated>
    
    <content type="html"><![CDATA[<ul><li>AcWing的每日一题（</li></ul><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;AcWing的每日一题（&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【题解】DFS</title>
    <link href="http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91DFS/"/>
    <id>http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91DFS/</id>
    <published>2022-05-19T01:55:34.000Z</published>
    <updated>2022-06-14T09:01:35.498Z</updated>
    
    <content type="html"><![CDATA[<ul><li>所有用到DFS的题，从简单到难</li><li>栈stack、O(h)、不具有最短性</li><li>回溯、剪枝er~</li></ul><span id="more"></span><h1 id="AcW-842-排列数字"><a href="#AcW-842-排列数字" class="headerlink" title="AcW-842. 排列数字 "></a><a href="https://www.acwing.com/problem/content/844/">AcW-842. 排列数字 </a></h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//dfs每一个位置 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(x&gt;n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!st[i]){</span><br><span class="line">st[i]=<span class="literal">true</span>;</span><br><span class="line">a[x]=i;</span><br><span class="line"><span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">st[i]=<span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="AcW-843-n-皇后问题"><a href="#AcW-843-n-皇后问题" class="headerlink" title="AcW-843. n-皇后问题"></a><a href="https://www.acwing.com/problem/content/845/">AcW-843. n-皇后问题</a></h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> row[N],col[N],rd[N],ld[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(x&gt;n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">cout&lt;&lt;g[i][j];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=n;y++){</span><br><span class="line"><span class="keyword">if</span>(!col[y]&amp;&amp;!rd[x+y<span class="number">-1</span>]&amp;&amp;!ld[n+x-y]){</span><br><span class="line">g[x][y]=<span class="string">'Q'</span>;</span><br><span class="line">col[y]=rd[x+y<span class="number">-1</span>]=ld[n+x-y]=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">col[y]=rd[x+y<span class="number">-1</span>]=ld[n+x-y]=<span class="literal">false</span>;</span><br><span class="line">g[x][y]=<span class="string">'.'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) g[i][j]=<span class="string">'.'</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;所有用到DFS的题，从简单到难&lt;/li&gt;
&lt;li&gt;栈stack、O(h)、不具有最短性&lt;/li&gt;
&lt;li&gt;回溯、剪枝er~&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>【SE】软件设计模式例题总结</title>
    <link href="http://example.com/2022/05/16/2022-05-16-%E3%80%90SE%E3%80%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BE%8B%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/05/16/2022-05-16-%E3%80%90SE%E3%80%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BE%8B%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-16T14:45:34.000Z</published>
    <updated>2022-05-17T14:37:58.204Z</updated>
    
    <content type="html"><![CDATA[<p>【考试向】13种设计模式的 PPT+网上+书上 的各种例题搜集汇总</p><span id="more"></span><h1 id="【行为型】策略模式"><a href="#【行为型】策略模式" class="headerlink" title="【行为型】策略模式"></a>【行为型】策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，让算法的变化独立于算法的客户。</p><h2 id="类图与使用场景"><a href="#类图与使用场景" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/LJux3dzrG4YUPWZ.png" alt="image.png"></p><ul><li>想使用对象中 <strong>各种不同的算法变体</strong>，并且希望能在<strong>运行时切换</strong>算法</li><li>有许多 <strong>仅在执行某些行为时略有不同的相似类</strong><ul><li>将不同行为抽取到一个独立类（Strategy）层次结构中，并将原始类组合成一个</li></ul></li><li>算法在Context中的逻辑不重要，可以用策略模式将类的<strong>业务逻辑与算法实现细节隔离</strong>开来</li><li>类中使用了复杂条件运算符<strong>（if-else）</strong>以在同一算法的不同变体中切换</li></ul><hr><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><p>通过某些行为来<strong>参数化</strong>对象：<u>命令模式、策略模式</u></p></li><li><p>装饰者模式更改对象的外表，策略模式更改其本质</p></li><li><p>模板方法 基于<strong>继承</strong>：允许通过扩展子类的部分内容改变部分算法；</p><ul><li><p>策略模式 基于<strong>组合</strong>：通过相应行为提供的<strong>不同策略</strong>来改变对象的行为；</p><ul><li><p>模板方法 在<strong>类</strong>层次上运作，<strong>静态</strong>。</p></li><li><p>策略模式在<strong>对象</strong>层次上运作，允许运行时动态切换</p></li></ul></li></ul></li><li><p><strong>状态模式</strong>可以视为策略模式的<strong>扩展</strong>，都基于<strong>组合</strong>；</p><ul><li><p>都通过将部分工作 <strong>委 托</strong> 给 对象 来改变在不同情景下的行为</p><ul><li><p>策略模式：这些对象（具体策略）之间完全相互独立，不知道其他对象存在;客户知道具体策略</p></li><li><p>状态模式：没有限制具体状态之间的依赖，运行自行改变在不同情景下的状态；客户不知道具体状态</p></li></ul></li></ul></li></ul><hr><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><blockquote><ul><li>找出修改频率较高的算法</li><li>声明该算法所有变体的通用策略接口<strong>Stategy</strong></li><li>将算法逐一抽取到各自的类中，都必须<strong>implements</strong>策略接口</li><li>Context类中<strong>添加一个成员变量保存Stategy的引用</strong>；提供setter方法便于修改它；</li></ul></blockquote><h3 id="例1：导游路线规划"><a href="#例1：导游路线规划" class="headerlink" title="例1：导游路线规划"></a>例1：导游路线规划</h3><p>一个导游程序，有<strong>多种</strong>规划路线的功能，包括规划公路路线、规划步行路线、规划公共交通路线，但是不久之后，可能要规划其他路线，比如骑行路线等等</p><p><img src="https://s2.loli.net/2022/05/16/1oJEcLMkDsneTXi.png" alt="image.png"></p><h3 id="例2：出行方式"><a href="#例2：出行方式" class="headerlink" title="例2：出行方式"></a>例2：出行方式</h3><p>人的出行方式<strong>多种</strong>。假如你需要前往机场。你可以选择乘坐公共汽车、预约出租车或骑自行车。这些就是你的出行策略。</p><p><img src="https://s2.loli.net/2022/05/16/dJzmc9qEQHtFelr.png" alt="image.png"></p><h3 id="例3：电影院售票"><a href="#例3：电影院售票" class="headerlink" title="例3：电影院售票"></a>例3：电影院售票</h3><p>某电影院售票系统为不同类型的用户提供<strong>不同</strong>打折方式（Discount），学生凭学生证享受8折优惠（StudentDiscount），儿童享受减免10元优惠（ChildrenDiscount），VIP用户除享受半价优惠还可积分（VIPDiscount）</p><p><img src="https://s2.loli.net/2022/05/16/iQgyCXP2o1fbDTk.png" alt="image.png"></p><h3 id="例4：税额计算"><a href="#例4：税额计算" class="headerlink" title="例4：税额计算"></a>例4：税额计算</h3><p>一个电子商务系统，其中有一个控制器对象（TaskController），用于处理销售请求，能够确认何时有人在请求销售订单，并将请求转给SalesOrder对象处理。SalesOrder对象的功能包括：允许客户通过GUI填写订单，处理税额的计算，处理订单和打印销售收据。新需求：要处理<strong>多种税额计算</strong>的方法，美国、加拿大、中国三个国家的税收方法</p><p><img src="https://s2.loli.net/2022/05/16/iQlFqTLtM1EJfBu.png" alt="image.png" style="zoom:67%;"></p><h3 id="例5：计算器"><a href="#例5：计算器" class="headerlink" title="例5：计算器"></a>例5：计算器</h3><p>设计一个简单计算器，能实现两个操作数的加减乘除四种运算</p><h3 id="例6：图书打折方式"><a href="#例6：图书打折方式" class="headerlink" title="例6：图书打折方式"></a>例6：图书打折方式</h3><p>一个贩卖各类书籍的电子商务网站的购物车（Shopping Cart）系统计算本次购物金额的方法有<strong>多种</strong>，比如：对所有的教材类图书实行每本1元的折扣；对连环画类图书提供每本7%的促销折扣；对非教材类的计算机图书有3%的折扣；对其余的图书没有折扣</p><hr><h3 id="例7：会员打折方式"><a href="#例7：会员打折方式" class="headerlink" title="例7：会员打折方式"></a>例7：会员打折方式</h3><p>现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。</p><p><img src="https://s2.loli.net/2022/05/16/z9YMfdCWLu1qPbt.png" alt="image.png"></p><h3 id="例8：各种飞机"><a href="#例8：各种飞机" class="headerlink" title="例8：各种飞机"></a>例8：各种飞机</h3><p>某软件公司现欲开发一款飞机模拟系统,该系统主要模拟<strong>不同种类</strong>飞机的飞行特征与起飞特征。还能<strong>支持模拟更多种类</strong>的飞机。</p><p><img src="https://s2.loli.net/2022/05/16/Xfmbu75wz34o2ih.png" alt="image.png" style="zoom:67%;"></p><p>对比书上的例子（照喵画虎）</p><p><img src="https://s2.loli.net/2022/05/16/316ragLTyltDMKz.png" alt="image.png" style="zoom:67%;"></p><h3 id="例9：图片滤镜"><a href="#例9：图片滤镜" class="headerlink" title="例9：图片滤镜"></a>例9：图片滤镜</h3><p>为了实现一些特殊的显示效果，某公司欲开发一款手机数码照片处理软件，在该软件中为照片(Photograph)提供了<strong>多种</strong>滤镜(Filter)效果，例如黑白滤镜(BlackWhiteFilter)、单色滤镜(MonochromaticFilter)、怀旧滤镜(NostalgicFilter)等，不同的滤镜通过不同的算法对照片进行美化，该软件可以<strong>灵活地增加一些新的</strong>滤镜效果。</p><h3 id="例10：加密"><a href="#例10：加密" class="headerlink" title="例10：加密"></a>例10：加密</h3><p>某系统需要对重要数据（如用户密码）进行加密，并提供了<strong>几种</strong>加密方案（如凯撒加密、DES加密等），对该加密模块进行设计，使得用户可以<strong>动态选择</strong>加密方式</p><hr><h3 id="例11：排序策略问题"><a href="#例11：排序策略问题" class="headerlink" title="例11：排序策略问题"></a>例11：排序策略问题</h3><p>某系统提供了一个用于对数组数据进行操作的类，该类封装了对数组的常见操作，如查找数组元素、对数组元素进行排序等。现以排序操作为例，使用策略模式设计该数组操作类，使得客户端可以动态地更换排序算法，可以根据需要选择冒泡排序或选择排序或插入排序，也能够灵活地增加新的排序算法。</p><h1 id="【行为型】观察者模式"><a href="#【行为型】观察者模式" class="headerlink" title="【行为型】观察者模式"></a>【行为型】观察者模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>定义了对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖者都会收到通知并且自动更新</p><h2 id="类图与使用场景-1"><a href="#类图与使用场景-1" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/YpCHBNUnFP7MOzc.png" alt="image.png" style="zoom:67%;"></p><ul><li>当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的</li><li>当应用中的一些对象必须观察其他对象时</li></ul><h2 id="与其他模式的关系-1"><a href="#与其他模式的关系-1" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h2><p>关键词：<code>通知</code>, <code>出版&amp;订阅</code>，<code>一个对象变化，通知其他多个对象它变化了</code></p><blockquote><p>拥有一些值得关注的状态的对象通常被称为目标，由于它要<strong>将自身的状态改变通知给其他对象</strong>，我们也将其称为发布者（publisher，也即subject）。所有<strong>希望关注发布者状态变化</strong>的其他对象被称为订阅者（subscribers，也即observer）。为发布者类添加订阅机制，让每个对象都能订阅或取消订阅发布者事件流。该机制包括</p><p> 1）一个用于存储订阅者对象<strong>引用的列表成员变量</strong>；</p><p>2）几个用于<strong>添加或删除该列表中订阅者</strong>的公有方法。</p></blockquote><h3 id="例1：股票价格通知"><a href="#例1：股票价格通知" class="headerlink" title="例1：股票价格通知"></a>例1：股票价格通知</h3><p>当股票购买者所购买的<strong>某只股票</strong>价格变化幅度达到5%时，系统<strong>自动发送通知</strong>给购买该股票的股民</p><p><img src="https://s2.loli.net/2022/05/16/ZnXTjCpd1kWJeSx.png" alt="image.png"></p><h3 id="例2：地震监测报警"><a href="#例2：地震监测报警" class="headerlink" title="例2：地震监测报警"></a>例2：地震监测报警</h3><p>现需要开发一个地震监测报警系统，如果接收到相关<strong>监测机构</strong>发来的<strong>预警数据</strong>，系统将作出反应，将信号<strong>传递</strong>给响应设备，如广播自动播放报警信息、逃生指示灯亮起、安全门锁打开、电梯自动停用等，每一种响应设备的行为由专门的程序来控制。支持将来引入新类型的响应设备。</p><h3 id="例3：电子商务系统"><a href="#例3：电子商务系统" class="headerlink" title="例3：电子商务系统"></a>例3：电子商务系统</h3><p>一个电子商务系统，当一个新的消费用户加入系统，希望做以下两个操作：向消费者发送一封欢迎邮件；向邮局查证消费者地址</p><p><img src="https://s2.loli.net/2022/05/16/wTMrSJcxa5ZnsgC.png" alt="image.png" style="zoom:50%;"></p><h3 id="例4：机房监控系统"><a href="#例4：机房监控系统" class="headerlink" title="例4：机房监控系统"></a>例4：机房监控系统</h3><p>如果机房达到一定指定温度，<strong>传感器</strong>将作出反应，将<strong>信号传递</strong>给响应设备，如警示灯将闪烁，报警器将发出警报，安全逃生门将自动开启、隔热门将自动关闭，每一响应设备的行为由专门的程序来控制，支持将来引入新类型的响应设备。</p><p><img src="https://s2.loli.net/2022/05/16/XWw2xoZtavPzFK4.png" alt="image.png"></p><h3 id="例5：多人联机对战"><a href="#例5：多人联机对战" class="headerlink" title="例5：多人联机对战"></a>例5：多人联机对战</h3><p>某在线游戏支持多人联机对战，每个玩家都可以加入某一战队组成联盟，当战队中某一成员受到敌人攻击时将给所有盟友<strong>发送通知</strong>，盟友收到通知后将作出响应</p><p><img src="https://s2.loli.net/2022/05/16/Gb8BOLEWyvfXja6.png" alt="image.png" style="zoom: 50%;"></p><hr><h1 id="【行为型】状态模式"><a href="#【行为型】状态模式" class="headerlink" title="【行为型】状态模式"></a>【行为型】状态模式</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类</p><h2 id="类图与使用场景-2"><a href="#类图与使用场景-2" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/3174QBdu5TswFfe.png" alt="image.png" style="zoom:67%;"></p><ul><li>对象的行为依赖于它的状态（如某些属性值），<strong>状态的改变将导致行为的变化</strong></li><li>在代码中包含大量与<strong>对象状态有关的条件语句</strong>，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。</li></ul><h2 id="与其他模式的关系-2"><a href="#与其他模式的关系-2" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><p>在状态模式中， 特定状态（可以）知道其他所有状态的存在，且能触发从一个状态到另一个状态的转换；<strong>行为对客户来说是透明的</strong>，客户不知道状态对象的存在</p><ul><li><p>策略则几乎完全不知道其他策略的存在。</p></li><li><p>状态可被视为策略的扩展。两者都基于组合机制：它们都通过将部分工作<strong>委派</strong>给“帮手”对象来改变其在不同情景下的行为。策略使得这些对象相互之间完全独立，它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖，且允许它们自行改变在不同情景下的状态。</p></li></ul></li></ul><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h2><p>关键词：<code>状态</code>，<code>动作使得状态转换</code></p><ul><li>为对象的<strong>每</strong>一个 <strong>所有可能状态</strong> 新建一个类(ConcreteState)，将所有该状态的对应行为抽取到这些类中</li><li>Context类持有State/ConcreteState成员变量</li></ul><h3 id="例1：信用卡账户"><a href="#例1：信用卡账户" class="headerlink" title="例1：信用卡账户"></a>例1：信用卡账户</h3><p> 信用卡业务系统，账户(Account)是核心类之一，<strong>账户</strong>存在三种状态，且在不同状态下账户存在不同的行为，具体说明如下：</p><ul><li><p>(1) 如果账户中余额大于等于0，则账户的状态为<strong>正常状态(</strong>Normal State)，此时用户既可以向该账户存款也可以从该账户取款；</p></li><li><p>(2) 如果账户中余额小于0，并且大于-2000，则账户的状态为<strong>透支状态</strong>(Overdraft State)，此时用户既可以向该账户存款也可以从该账户取款，但需要按天计算利息；</p></li><li><p>(3) 如果账户中余额等于-2000，那么账户的状态为<strong>受限状态</strong>(Restricted State)，此时用户只能向该账户存款，不能再从中取款，同时也将按天计算利息；       </p></li><li><p>(4) 根据余额的不同，以上三种状态<strong>可发生相互转换</strong>。</p><ul><li>分析：账户==Context，三种状态 == ConcreteState；封装进状态的动作：存款、取款、利息计算、根据余额进行状态转换</li></ul></li></ul><p><img src="https://s2.loli.net/2022/05/16/w1Pe5C3qoJpZGX6.png" alt="image.png"></p><h3 id="例2：开关"><a href="#例2：开关" class="headerlink" title="例2：开关"></a>例2：开关</h3><p>如果某系统要求两个开关对象（Context）要么都处于开的状态，要么都处于关的状态，在使用时它们的<strong>状态必须保持一致</strong>，开关可以由开转换到关，也可以由关转换到开</p><ul><li><p>分析：多个环境对象可能需要共享同一个状态，如果希望在系统中实现<strong>多个环境对象共享一个或多个状态对象</strong>，那么需要将这些<strong>状态对象</strong>定义为环境类的<strong>静态成员对象</strong>。</p></li><li><p>Switch里的三个state都是静态成员变量（所以应该还有下划线表示才对</p></li></ul><p><img src="https://s2.loli.net/2022/05/16/5qF7zvOZBQDwVGK.png" alt="image.png" style="zoom:80%;"></p><h3 id="例3：屏幕放大"><a href="#例3：屏幕放大" class="headerlink" title="例3：屏幕放大"></a>例3：屏幕放大</h3><p>一个屏幕放大镜工具： 用户单击“放大镜”按钮之后屏幕将放大一倍，再点击一次“放大镜”按钮屏幕再放大一倍，第三次点击该按钮后屏幕将还原到默认大小</p><ul><li>定义三个<strong>屏幕状态类</strong>NormalState、LargerState和LargestState来对应屏幕的三种状态，分别是正常状态、二倍放大状态和四倍放大状态，屏幕类Screen充当Context类</li></ul><p><img src="https://s2.loli.net/2022/05/16/xJjpWI32DAU8ZRb.png" alt="image.png"></p><h3 id="例4：纸牌游戏"><a href="#例4：纸牌游戏" class="headerlink" title="例4：纸牌游戏"></a>例4：纸牌游戏</h3><p>某纸牌游戏中，<strong>人物角色</strong>具有<strong>入门级</strong>（Primary），<strong>熟练级</strong>(Secondary)，<strong>高手级</strong>(Professional)和<strong>骨灰级</strong>(Final)四种等级，<strong>角色的等级与积分相对应</strong>，游戏胜利将增加积分，失败则扣除积分，入门级具有最基本的游戏功能play()，熟练级增加了游戏胜利积分加倍功能doubleScore（），高手级在熟练级基础上再增加换牌功能changeCards()，骨灰级在高手级基础上再增加偷看他人的牌的功能peekCards()</p><ul><li>第一眼儿看差点以为是策略模式；但是要注意“角色的等级与积分相对应”，说明等级会随着积分的改变而发生改变，游戏又对积分有各种操作；所以更应该是状态模式</li></ul><p><img src="https://s2.loli.net/2022/05/16/ICLzGuw6t8BZMKo.png" alt="image.png"></p><h3 id="例5：线程状态"><a href="#例5：线程状态" class="headerlink" title="例5：线程状态"></a>例5：线程状态</h3><p>多线程存在 5 种状态，分别为新建状态、就绪状态、运行状态、阻塞状态和死亡状态，各个状态当遇到相关方法调用或事件触发时会转换到其他状态</p><p><img src="https://s2.loli.net/2022/05/16/cKTs741XiDV5rnE.png" alt="image.png" style="zoom:67%;"></p><h3 id="例6：传输门"><a href="#例6：传输门" class="headerlink" title="例6：传输门"></a>例6：传输门</h3><p>传输门具有Open（打开）、Closed（关闭）、Opening（正在打开）、StayOpen（保持打开）、Closing（正在关闭）五种状态。触发状态的转换事件有click、complete和timeout三种。</p><hr><h3 id="例7：抽奖活动"><a href="#例7：抽奖活动" class="headerlink" title="例7：抽奖活动"></a>例7：抽奖活动</h3><p>编写程序完成APP抽奖活动，具体要求如下：</p><p>（1）加入每参加一次这个活动要扣除用户50积分，中奖概率是10%</p><p>（2）奖品数量固定，抽完就不能抽奖</p><p>（3）活动有4个状态：可以抽奖、不能抽奖、发放奖品和奖品领完</p><hr><h1 id="【行为型】模板方法模式"><a href="#【行为型】模板方法模式" class="headerlink" title="【行为型】模板方法模式"></a>【行为型】模板方法模式</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>在一个方法中定义了一个<strong>算法的骨架</strong>，将一些<strong>步骤延迟到子类</strong>中。这样子类在<strong>不改变算法结构</strong>的情况下，可以<strong>重新定义</strong>算法中的某些步骤</p><h2 id="类图与使用场景-3"><a href="#类图与使用场景-3" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/nKLYQsofcxud6NR.png" alt="image.png" style="zoom:50%;"></p><ul><li>只希望客户端扩展某个特定算法步骤，而不是整个算法或其结构时</li><li>当多个类的算法除一些细微不同之外几乎完全一样时</li></ul><blockquote><ul><li>将算法分解为一系列步骤</li><li>将这些步骤改写为方法<ul><li>步骤可以是 抽象 的，也可以有一些默认的实现。</li></ul></li><li>在“模板方法”中依次调用这些方法。</li><li>为了能够使用算法，客户端需要自行提供子类并实现所有的抽象步骤。如有必要还需重写一些步骤（但这一步中不包括模板方法自身）。</li></ul></blockquote><h2 id="与其他模式的关系-3"><a href="#与其他模式的关系-3" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><p><u>工厂方法</u> 是 模板方法的一种<strong>特殊形式</strong>。工厂方法可以作为一个大型模板方法的一个步骤</p></li><li><p>模板方法基于<strong>继承</strong>机制：它允许你通过<strong>扩展子类中的部分内容</strong>来改变部分算法。</p><ul><li><p>策略基于<strong>组合</strong>机制：你可以通过对<strong>相应行为提供不同的策略</strong>来改变对象的部分行为。</p><ul><li><p>模板方法在类层次上运作，因此它是静态的。</p></li><li><p>策略在对象层次上运作，因此允许在运行时切换行为。</p></li></ul></li></ul></li></ul><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h2><p>关键词：<code>一系列步骤</code>，<code>流程</code>，<code>不同类只有某些步骤相似但不同</code></p><blockquote><ul><li>分析目标算法，确定能否将其<strong>分解为多个步骤</strong>。从所有子类的角度出发，考虑哪些步骤能够通用，哪些步骤各不相同</li><li>创建抽象基类并声明<strong>一个模板方法</strong>和代表算法步骤的<strong>一系列抽象方法</strong>。 在模板方法中根据算法结构依次调用相应步骤。可用 <code>final</code> 修饰模板方法以防止子类对其进行重写。</li><li>可考虑在算法的关键步骤之间添加钩子</li><li>为每个算法变体新建一个具体子类，它必须<strong>实现所有的抽象步骤</strong>，也可以重写部分可选步骤</li></ul></blockquote><h3 id="例1：数据库操作"><a href="#例1：数据库操作" class="headerlink" title="例1：数据库操作"></a>例1：数据库操作</h3><p>对数据库的操作一般包括连接、打开、使用、关闭等<strong>步骤</strong>，在数据库操作模板类中我们定义了connDB（）,openDB（）,useDB()，closeDB（）四个方法分别对应这四个步骤，对于<strong>不同类型</strong>的数据库（如SQLserver和Oracle），其余操作步骤都一致，<strong>只是</strong>连接数据库connDB（）方法<strong>有所区别</strong></p><ul><li>分析：将四个步骤按顺序封装到一个方法里，那个在不同类中 <strong>不同的步骤</strong> 在方法外<strong>声明为抽象方法</strong></li></ul><p><img src="https://s2.loli.net/2022/05/16/zOc76gdTuGSnmL8.png" alt="image.png" style="zoom: 50%;"></p><h3 id="例2：利息计算"><a href="#例2：利息计算" class="headerlink" title="例2：利息计算"></a>例2：利息计算</h3><p>给出一个利息计算流程，但流程中<strong>有个步骤</strong>  <strong>根据用户类型</strong> 不同计算利息的方式<strong>不同</strong></p><p><img src="https://s2.loli.net/2022/05/16/mXEFgj71iGTdkHl.png" alt="image.png" style="zoom:50%;"></p><h3 id="例3：数据图表"><a href="#例3：数据图表" class="headerlink" title="例3：数据图表"></a>例3：数据图表</h3><p>一个数据图表显示功能包括三个<strong>步骤</strong>，（从数据源获取数据，数据转换为XML，以某种图表方式显示XML格式数据）支持<strong>多种数据源和多种图表显示方式</strong>， <strong>如果</strong>已经是XML<strong>则</strong>无需进行数据转换（说明有个钩子方法）</p><ul><li>分析：钩子方法能够作为<strong>条件</strong> <strong>控制算法的流程</strong></li></ul><p><img src="https://s2.loli.net/2022/05/16/cDzb8Xf9PrRNMJn.png" alt="image.png" style="zoom:67%;"></p><h3 id="例4：豆浆制作"><a href="#例4：豆浆制作" class="headerlink" title="例4：豆浆制作"></a>例4：豆浆制作</h3><p>编写制作豆浆的程序，说明如下:</p><ul><li>制作豆浆的流程 选材—&gt;<strong>添加配料</strong>—&gt;浸泡—&gt;放到豆浆机打碎</li><li>通过<strong>添加不同的配料</strong>，可以制作出<strong>不同口味的豆浆</strong></li><li>选材、浸泡和放到豆浆机打碎这几个步骤对于制作每种口味的豆浆<strong>都是一样</strong>的</li></ul><p><img src="https://s2.loli.net/2022/05/16/zdXoCHWbsAgv6a7.png" alt="image.png" style="zoom:50%;"></p><hr><h1 id="【行为型】命令模式"><a href="#【行为型】命令模式" class="headerlink" title="【行为型】命令模式"></a>【行为型】命令模式</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>将<strong>请求封装成对象</strong>，以便使用不同的请求、队列或日志来<strong>参数化其他对象</strong>。也支持<strong>可撤销</strong>的操作</p><h2 id="类图与使用场景-4"><a href="#类图与使用场景-4" class="headerlink" title="类图与使用场景"></a>类图与使用场景</h2><p><img src="https://s2.loli.net/2022/05/16/gAPXm8ZUFoGqKzv.png" alt="image.png" style="zoom: 50%;"></p><ul><li>系统需要<strong>将请求调用者和请求接收者</strong>解耦，使得<strong>调用者和接收者不直接交互</strong>。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。</li><li>要支持命令的<strong>撤销(Undo)操作和恢复(Redo)操作</strong></li><li>系统需要将<strong>一组操作组合</strong>在一起形成宏命令。</li></ul><p><img src="https://s2.loli.net/2022/05/16/rBET5sk4ecMU2Rd.png" alt="image.png" style="zoom:50%;"></p><h2 id="与其他模式的关系-4"><a href="#与其他模式的关系-4" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><h2 id="样例-4"><a href="#样例-4" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：遥控器功能键"><a href="#例1：遥控器功能键" class="headerlink" title="例1：遥控器功能键"></a>例1：遥控器功能键</h3><p>某遥控器提供了一些按键，使用户可以自定义按键功能，如功能键FunctionButton可用于调出菜单（ShowMenu），也可用于打开帮助界面（DisplayHelp），也可用于打开机顶盒（OpenSTB）。用户可以通过修改配置文件来改变按键的用途，使<strong>按键类与功能类之间解耦</strong>，<strong>相同的按键可以对应不同的功能.</strong></p><p><img src="https://s2.loli.net/2022/05/16/7tbFPhZBWYqEozA.png" alt="image.png"></p><h3 id="例2：公告板"><a href="#例2：公告板" class="headerlink" title="例2：公告板"></a>例2：公告板</h3><p>一个基于windows平台的公告板系统，该系统提供一个主菜单（Menu），在主菜单中包含了一些菜单项(MenuItem)，可以通过Menu类的addMenuItem()方法添加菜单项，菜单项的主要方法是click()，每一个菜单项包含一个抽象命令类，具体命令类包含OpenCommand(打开命令）、CreateCommand(创建命令）和EditeCommand(编辑命令）等，命令类内置有一个excute()方法，用于调用公告板系统界面类(BoardScrean）的open（）、create()、edite（）等方法，要使<strong>MenuItem类与BoardScreen类的耦合度降低</strong></p><p><img src="https://s2.loli.net/2022/05/16/dU95ONAKxWSkCz8.png" alt="image.png"></p><h3 id="例3：餐馆点菜"><a href="#例3：餐馆点菜" class="headerlink" title="例3：餐馆点菜"></a>例3：餐馆点菜</h3><p>场景：餐馆点菜。角色：1.接收者：厨师，是命令的真正执行者。本例分为两种：做热菜的厨师和做凉菜的厨师 2.服务员：负责命令和接收者的组装，并持有命令对象（菜单），最后启动命令的也是服务员 3.命令对象：A、每一道菜是个命令对象；B、菜单（组合对象，由多道菜组成）</p><p><img src="https://s2.loli.net/2022/05/16/4NrnIeHvCx1gmPj.png" alt="image.png"></p><h3 id="例4：桌面版应用程序"><a href="#例4：桌面版应用程序" class="headerlink" title="例4：桌面版应用程序"></a>例4：桌面版应用程序</h3><p>一提供了一系列自定义功能键，用户可以通过这些功能键来实现一些快捷操作。发现不同的用户可能会有不同的使用习惯，例如有的人喜欢将第一个功能键设置为“打开帮助文档”，有的人则喜欢将该功能键设置为“最小化至托盘”，设计使用户能够<strong>灵活地进行功能键的设置</strong></p><p><img src="https://s2.loli.net/2022/05/16/XNI5ezT2obpnS4R.png" alt="image.png"></p><h3 id="例5：计算器-1"><a href="#例5：计算器-1" class="headerlink" title="例5：计算器"></a>例5：计算器</h3><p>简易计算器，可以实现简单的数学运算，还可以对运算<strong>实施撤销操作</strong></p><p><img src="https://s2.loli.net/2022/05/16/um2epAzPC6HlLNo.png" alt="image.png" style="zoom:67%;"></p><h3 id="例6：智能生活"><a href="#例6：智能生活" class="headerlink" title="例6：智能生活"></a>例6：智能生活</h3><p>（1）买一套智能家电，有照明灯、风扇、冰箱、洗衣机，我们只要在手机上安装app就可以控制这些家电工作</p><p>（2）这些智能家电来自不同的厂家，我们不想针对每一种家电都安装一个app，分别控制，<strong>只希望有一个app就可以控制全部智能家电</strong>。</p><ul><li><p>要实现一个app控制所有智能家电的需求，则每个智能家电厂家都要提供一个<strong>统一的接口</strong>给app调用，这时 就可以考虑命令模式</p></li><li><p>命令模式可将“动作的请求者”从“动作的执行者”对象中解耦出来</p></li><li><p>动作的请求者是手机app，动作的执行者是每个厂商的一个家电产品</p></li></ul><hr><h1 id="【行为型】迭代器模式"><a href="#【行为型】迭代器模式" class="headerlink" title="【行为型】迭代器模式"></a>【行为型】迭代器模式</h1><h1 id="【创建型】工厂方法模式"><a href="#【创建型】工厂方法模式" class="headerlink" title="【创建型】工厂方法模式"></a>【创建型】工厂方法模式</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p>定义了一个<strong>创建对象的接口</strong>，但由<strong>子类决定要实例化的类</strong>是哪一个，让类把实例化<strong>推迟到子类</strong></p><h2 id="样例-5"><a href="#样例-5" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：图片读取器"><a href="#例1：图片读取器" class="headerlink" title="例1：图片读取器"></a>例1：图片读取器</h3><p>现需要设计一个程序来读取多种不同类型的图片格式，针对每一种图片格式都设计一个图片读取器(ImageReader)，如GIF图片读取器(GifReader)用于读取GIF格式的图片、JPG图片读取器(JpgReader)用于读取JPG格式的图片。图片读取器对象通过图片读取器工厂ImageReaderFactory来创建，ImageReaderFactory是一个抽象类，用于定义创建图片读取器的工厂方法，其子类GifReaderFactory和JpgReaderFactory用于创建具体的图片读取器对象</p><p><img src="https://s2.loli.net/2022/05/17/6JDZLTqxybsGCzS.png" alt="image.png"></p><h3 id="例2：日志记录器"><a href="#例2：日志记录器" class="headerlink" title="例2：日志记录器"></a>例2：日志记录器</h3><p>某日志记录器 要求支持多种日志记录方式，如文件日志记录（FileLog）、数据库日志记录（DatabaseLog）等；用户可根据需要动态地选择日志记录方式 ( 我甚至觉得这个题用策略模式也不是不可以？)</p><p><img src="https://s2.loli.net/2022/05/17/rxynbwU84HaG9JQ.png" alt="image.png" style="zoom:67%;"></p><h3 id="例3：电视机工厂"><a href="#例3：电视机工厂" class="headerlink" title="例3：电视机工厂"></a>例3：电视机工厂</h3><p>有一电视机工厂，生产各种电视机。现要将原有的工厂进行分割，为每种品牌的电视机提供一个子工厂，海尔工厂专门负责生产海尔电视机，海信工厂专门负责生产海信电视机；如果需要生产其他某个品牌电视机，只需要对应增加一个新的该品牌电视机工厂即可，而原有的工厂无须做任何修改，使得整个系统具有更加的灵活性和可扩展性</p><h1 id="【创建型】抽象工厂模式"><a href="#【创建型】抽象工厂模式" class="headerlink" title="【创建型】抽象工厂模式"></a>【创建型】抽象工厂模式</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>提供一个接口，用来<strong>创建</strong> 相关或依赖对象的<strong>家族</strong>，而不需要明确指定具体类</p><h2 id="样例-6"><a href="#样例-6" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：数据库"><a href="#例1：数据库" class="headerlink" title="例1：数据库"></a>例1：数据库</h3><p>某系统为了改进数据库操作的性能，自定义数据库连接对象Connection和语句对象Statement，可针对不同类型的数据库提供不同的连接对象和语句对象，如提供Oracle或MySQL专用<strong>连接类和语句类</strong>，而且用户可以通过配置文件等方式根据实际需要<strong>动态地选择</strong>系统数据库</p><p><img src="https://s2.loli.net/2022/05/17/XuAk4C2ZlOTUMGV.png" alt="image.png"></p><h3 id="例2：操作系统"><a href="#例2：操作系统" class="headerlink" title="例2：操作系统"></a>例2：操作系统</h3><p>创建在不同操作系统的视窗环境下都能够运行的系统两种操作系统：windows和unix</p><ul><li><p>windows操作系统下，使用具有windows风格的视窗构件（这里设为windowsButton对象和WindowsText对象）</p></li><li><p>Unix操作系统下，使用具有Unix风格的视窗构件UnixButton对象和UnixText对象</p></li><li><p>如何进行设计，使得 1，当需要<strong>增加对新操作系统的支持</strong>时（如系统还需要支持Solaris），现有代码不必修改（符合“开-闭原则”）    2，在系统的设计中约束用户使用的各种构件一定属于同一操作系统（不会出现将WindowsButton和UnixText一起使用这种情况）</p></li></ul><p><img src="https://s2.loli.net/2022/05/17/9ctW5GiOwuYAkIT.png" alt="image.png"></p><h3 id="例3：动物游戏"><a href="#例3：动物游戏" class="headerlink" title="例3：动物游戏"></a>例3：动物游戏</h3><p>在一个电脑游戏中，存在着美洲和非洲两块大陆。美洲大陆上有食肉动物(美洲虎)和食草动物(美洲羊) ;非洲大陆上有食肉动物(非洲虎)和食草动物(非洲羊)。电脑游戏的应用逻辑中需要实现这样的场景</p><ul><li>根据当前主人公角色所处大陆(美洲或非洲)来初始化当前游戏中的食肉动物和食肉动物</li><li>食肉动物开始追捕食草动物</li></ul><p><img src="https://s2.loli.net/2022/05/17/8CbVPz17KaAhOBk.png" alt="image.png" style="zoom:67%;"></p><h3 id="例4：驱动"><a href="#例4：驱动" class="headerlink" title="例4：驱动"></a>例4：驱动</h3><p>设计一个系统来显示和打印数据库中读出的图形，并满足：根据当前所使用硬件的配置来选择驱动——速度快的机器选择高分辨率的显示、打印驱动，速度慢的选择低分辨率的驱动：</p><p>驱动类型     在低配置硬件情况下    在高配置硬件情况下</p><p>显示驱动         LRDD                              HRDD</p><p>打印驱动         LPPD                               HPPD</p><p><img src="https://s2.loli.net/2022/05/17/vQslOhJATDp3ura.png" alt="image.png" style="zoom:67%;"></p><h1 id="【创建型】单件模式"><a href="#【创建型】单件模式" class="headerlink" title="【创建型】单件模式"></a>【创建型】单件模式</h1><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>确保类只有一个实例，并提供一个全局的访问点</p><h2 id="多线程处理"><a href="#多线程处理" class="headerlink" title="多线程处理"></a>多线程处理</h2><h3 id="双重检查加锁的理解"><a href="#双重检查加锁的理解" class="headerlink" title="双重检查加锁的理解"></a>双重检查加锁的理解</h3><p>假如在某一瞬间线程A和线程B都在调用<code>getInstance()</code>方法，此时instance对象为null值，均能通过<code>instance == null</code>的判断(<strong>第一重检查</strong>）。由于实现了<strong>synchronized加锁机制</strong>，线程A进入synchronized锁定的代码中执行实例创建代码，线程B处于排队等待状态，必须等待线程A执行完毕后才可以进入synchronized锁定代码。但当A执行完毕时，<strong>线程B并不知道实例已经创建</strong>，如果没有第二重检查的话，将继续创建新的实例，导致产生多个单例对象，违背单例模式的设计思想，因此需要进行进一步改进，在 synchronized中<strong>再进行一次(instance == null)判断</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span>{</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazySingleton instance = null;</span><br><span class="line">    <span class="comment">//被volatile修饰的成员变量可以确保多个线程都能够正确处理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == null){<span class="comment">//第一重检查</span></span><br><span class="line">            <span class="built_in">synchronized</span>(LazySingleton.class){ <span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span>(instance == null){ <span class="comment">//第二重检查</span></span><br><span class="line">                     instance = <span class="keyword">new</span> <span class="built_in">LazySingleton</span>();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><ul><li><p>急切实例化</p><p><img src="https://s2.loli.net/2022/05/17/iW3zKQELYD4paXj.png" alt="image.png" style="zoom: 50%;"></p></li><li><p>延迟实例化</p><p><img src="https://s2.loli.net/2022/05/17/klizjRVSZ2Jq3IN.png" alt="image.png" style="zoom:50%;"></p></li><li><p>急切实例化和延迟实例化的比较</p><ul><li><p>急切：在类被加载时就将自己实例化，它的优点在于<strong>无须考虑多线程访问问题，可以确保实例的唯一性</strong>；从<strong>调用速度和反应时间</strong>角度来讲，由于单例对象一开始就得以创建，因此要<strong>优于延迟</strong>。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该 对象就需要创建，因此从<strong>资源利用效率</strong>角度来讲，不及延迟，而且在系统加载时由于需要创建单例对象，<strong>加载时间可能会比较长</strong>。 </p></li><li><p>延迟：在第一次使用时创建，<strong>无须一直占用系统资源</strong>，实现了延迟加载，但是必须处 理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源 初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过<strong>双重检查锁定</strong>等机制进行控制，这将<strong>导致系统性能受到一定影响</strong>。 </p></li></ul></li></ul><h2 id="样例-7"><a href="#样例-7" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：负载均衡器"><a href="#例1：负载均衡器" class="headerlink" title="例1：负载均衡器"></a>例1：负载均衡器</h3><p>Sunny软件公司承接了一个服务器负载均衡(Load Balance)软件的开发工作，该软件运行在一台 负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高系统的整体处理能力，缩短响应时间。由于集群中的服务器需要动态删减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责 服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何<strong>确保负载均衡器的唯一性</strong>是该软件成功的关键</p><p><img src="https://s2.loli.net/2022/05/17/2tcRkujKbyfEiZH.png" alt="image.png" style="zoom:50%;"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancer</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LoadBalancer instance;</span><br><span class="line">    <span class="keyword">private</span> List serverList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LoadBalancer</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LoadBalancer <span class="title">getLoadBalancer</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line">             instance = <span class="keyword">new</span> LoadBalancer();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="例2：文档窗口"><a href="#例2：文档窗口" class="headerlink" title="例2：文档窗口"></a>例2：文档窗口</h3><p>设计一个多文档窗口（注：在Java AWT/Swing开发中可使用JDesktopPane和JInternalFrame来实现），要求在主窗体中某个<strong>内部子窗体只能实例化一</strong>次，即只能弹出一个相同的子窗体</p><ul><li>单件模式用在子窗体上</li></ul><p><img src="https://s2.loli.net/2022/05/17/xbWtmLo9VT3SvlY.png" alt="image.png" style="zoom:50%;"></p><h3 id="例3：回收站"><a href="#例3：回收站" class="headerlink" title="例3：回收站"></a>例3：回收站</h3><p>windows回收站的创建模拟  在整个视窗系统中，回收站只能有一个实例，整个系统都使用这个唯一的实例，不管如何双击“回收站”图标，打开的回收站窗口始终是唯一的一个</p><h3 id="例4：网络计数器"><a href="#例4：网络计数器" class="headerlink" title="例4：网络计数器"></a>例4：网络计数器</h3><p>网站计数器是WEB应用程序的一项基本功能，用于统计使用网站或者应用程序的人数，可反映出网站或者应用程序的受欢迎程序，对于电子商务网站可信度的研究有一定的参考价值</p><h1 id="【结构型】适配器模式"><a href="#【结构型】适配器模式" class="headerlink" title="【结构型】适配器模式"></a>【结构型】适配器模式</h1><h2 id="样例-8"><a href="#样例-8" class="headerlink" title="样例"></a>样例</h2><h3 id="例1：🐕"><a href="#例1：🐕" class="headerlink" title="例1：🐕"></a>例1：🐕</h3><p>现需要设计一个可以模拟各种动物行为的机器人，在机器人中定义了一系列方法，如机器人叫喊方法cry()、机器人移动方法move()等。如果希望在不修改已有代码的基础上使得机器人能够像狗一样叫，像狗一样跑</p><h1 id="【结构型】组合模式"><a href="#【结构型】组合模式" class="headerlink" title="【结构型】组合模式"></a>【结构型】组合模式</h1><h2 id="样例-9"><a href="#样例-9" class="headerlink" title="样例"></a>样例</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p>在水果盘(Plate)中有一些水果，如苹果(Apple)、香蕉(Banana)、梨子(Pear)，当然大水果盘中还可以有小水果盘，现需要对盘中的水果进行遍历（吃），当然如果对一个水果盘执行“吃”方法，实际上就是吃其中的水果</p><h1 id="【结构型】装饰者模式"><a href="#【结构型】装饰者模式" class="headerlink" title="【结构型】装饰者模式"></a>【结构型】装饰者模式</h1><h1 id="【结构型】外观模式"><a href="#【结构型】外观模式" class="headerlink" title="【结构型】外观模式"></a>【结构型】外观模式</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;【考试向】13种设计模式的 PPT+网上+书上 的各种例题搜集汇总&lt;/p&gt;</summary>
    
    
    
    <category term="软件工程" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="软件设计模式" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【DP】最长上升子序列模型</title>
    <link href="http://example.com/2022/04/30/2022-4-30-%E3%80%90DP%E3%80%91%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/04/30/2022-4-30-%E3%80%90DP%E3%80%91%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-04-30T03:17:01.000Z</published>
    <updated>2022-05-03T15:01:22.556Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>动态规划中最长上升子序列模型题目总结</li></ul></li></ul><span id="more"></span><h1 id="895-最长上升子序列"><a href="#895-最长上升子序列" class="headerlink" title="895. 最长上升子序列"></a><a href="https://www.acwing.com/problem/content/897/">895. 最长上升子序列</a></h1><blockquote><p>数列长度1＜N＜1000，求数值严格递增的子序列长度</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">状态表示：dp[i]-以原数组a[i]结尾的上升子序列</span><br><span class="line">状态计算：dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>)  ※a[j]＜a[i]</span><br><span class="line">注：序列形如...a[j],a[i]</span><br></pre></td></tr></tbody></table></figure><h1 id="896-最长上升子序列-II"><a href="#896-最长上升子序列-II" class="headerlink" title="896. 最长上升子序列 II "></a><a href="https://www.acwing.com/problem/content/898/">896. 最长上升子序列 II </a></h1><blockquote><p>数列长度1＜N＜100 000  ，求数值严格递增的子序列长度</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">贪心+二分</span><br><span class="line">q[i]：所有长度为i的序列中结尾最小的值</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;动态规划中最长上升子序列模型题目总结&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="DP" scheme="http://example.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Kademlia基本原理</title>
    <link href="http://example.com/2022/04/19/2022-04-19-Kademlia%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2022/04/19/2022-04-19-Kademlia%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</id>
    <published>2022-04-18T16:22:17.000Z</published>
    <updated>2022-04-19T06:57:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>分布式路由算法Kademlia的原理理解</p><span id="more"></span><h1 id="Kademlia"><a href="#Kademlia" class="headerlink" title="Kademlia"></a>Kademlia</h1><p>来源：<a href="https://www.jianshu.com/p/f2c31e632f1d">易懂分布式 | Kademlia算法 - 简书 (jianshu.com)</a></p><blockquote><p>ps：这篇文章真的写得太棒啦！！！！！是我所看过讲Kademlia文章中逻辑最清晰表达最棒的一篇文章！</p></blockquote><h2 id="基本原理理解"><a href="#基本原理理解" class="headerlink" title="基本原理理解"></a>基本原理理解</h2><p><strong>Kad算法</strong> 是一种<strong>分布式存储</strong>及路由的算法，DHT (Distributed Hash Table) 的一种</p><p>Kad优点：</p><ul><li>对于任意一个有[ 2^(n−1) ,2^n)个节点的网络，<strong>最多只需要n步</strong>搜索即可找到目标节点；</li><li>K-bucket的更新机制一定程度上保持了网络的<strong>活性和安全性</strong></li></ul><blockquote><p>分布式存储：<strong>不设立中心化</strong>的服务器，所有（资源）文件<strong>分散存储</strong>在各个节点上</p></blockquote><p><strong>DHT</strong>：一种去中心化的分布式系统</p><ul><li>在这类系统中，每个node分别维护<strong>一部分的存储内容</strong>以及<strong>其他</strong>（部分）<strong>节点的路由/地址</strong><ul><li>使得网络中任何节点的进入和退出，对整个网络造成的影响最小。</li></ul></li></ul><hr><p><strong>考虑的问题</strong>：</p><ul><li>分配：如何进行资源分配，把分配的内容存储到各个节点上，新增或者删除内容如何处理</li><li>路由：如果某节点 想要<strong>获取</strong>某个特定的资源，<strong>如何找到</strong>存储资源的节点\地址\路径</li></ul><hr><p><strong>针对每个节点</strong>：</p><ul><li><p>被分配到的资源 以<key,value>的形式储存；</key,value></p><blockquote><p>通俗的理解：key-资源名（确切一点，是资源名的hash值），value-资源内容</p></blockquote></li><li><p>维护一张路由表；用来去找其他节点</p><ul><li>这张路由表，也称为“k-bucket”（k桶）</li><li>路由表<strong>按异或距离分层</strong><ul><li>本节点的nodeID 异或  目标节点的nodeID</li></ul></li><li>记录<strong>有限</strong>个数的<strong>其他节点的ID</strong> （nodeID）、IP地址和端口</li></ul></li></ul><hr><p><strong>为什么每个节点不能拥有其他所有的节点路由信息</strong>：</p><ul><li>分布式系统中，节点的进入退出十分频繁<ul><li>如果每次变动都全网广播，通讯量很大</li></ul></li><li>不安全：如果一个节点被攻破的话</li></ul><hr><p><strong>分布式存储后，资源如何存储和查找？</strong></p><p>例子：</p><blockquote><p>假设《分布式算法》这本书的书名的hash值是 <strong>00010000</strong>，那么这本书就会被要求存在学号为<strong>00010000</strong>的同学手上。（这要求hash算法的值域与node ID的值域一致。Kademlia的Node ID是160位2进制。这里的示例对Node ID进行了简略）<br> 但还得考虑到会有同学缺勤。万一<em>00010000</em>今天没来上学（节点<strong>没有上线或彻底退出</strong>网络），那《分布式算法》这本书岂不是谁都拿不到了？那算法要求这本书不能只存在一个同学手上，而是被要求<strong>同时存储在学号最接近00010000</strong>的<strong>k</strong>位同学手上，即<em>00010001</em>、<em>00010010</em>、<em>00010011</em>…等同学手上都会有这本书。</p><p>同样地，当你需要找《分布式算法》这本书时，将书名hash一下，得到 <em>00010000</em>，这个便是索书号，你就知道该找哪（几）位同学了。</p></blockquote><p>剩下的问题，就是找到这（几）位同学的手机号（路由）。</p><p>但是，你手中的通讯录里<strong>可能没他们的手机号</strong></p><p>即是：已知源节点<strong>持有的路由表</strong>，和 目的节点<strong>target</strong>的<strong>nodeID</strong>，如果找到目的节点的IP</p><blockquote><p>算法的核心思路：</p><p>当你知道<strong>目标同学Z</strong>与你之间的<strong>距离</strong>（这个距离通过你的nodeID和目标的nodeID异或得到）</p><p>你可以在你的通讯录（即：路由表）上先找到一个你认为与同学Z<strong>最相近的同学B</strong>，请同学B再进一步去<strong>查找同学Z</strong>的手机号。</p><p>每个同学只维护<strong>一部分</strong>的通讯录，这个通讯录按照距离分层（可以理解为按学号与自己的学号从第几位开始不同而分层），即k-bucket1, k-bucket 2, k-bucket 3…</p><p>虽然每个k-bucket中实际存在的同学人数逐渐增多，但每个同学在它自己的每个k-bucket中<strong>只记录k位同学</strong>的手机号</p></blockquote><p><strong>对应</strong>：每个k-bucket只存 k个节点的地址与端口，这里的k是一个<strong>可调节的常量参数</strong></p><blockquote><p>由于学号（节点的ID）有160位，所以每个同学的通讯录中共分160层（节点共有160个k-bucket）。整个网络最多可以容纳2^160个同学（节点），但是每个同学（节点）最多只维护<strong>160 * k</strong> 行通讯录（其他节点的地址与端口）</p></blockquote><hr><p><strong>节点的定位</strong>：</p><p>A同学（学号<em>00000110</em>）想找《分布式算法》，A首先需要<strong>计算</strong>书名的<strong>哈希值</strong>，hash(《分布式算法》) = <strong>00010000</strong>。那么A就知道ta需要找到<strong>00010000</strong>号同学（命名为Z同学）或学号与Z<strong>邻近的</strong>同学。<br> Z的学号<em>00010000</em>与自己的<strong>异或距离</strong>为 <em>00010110</em>，距离范围在[2^4, 2^5)，所以这个Z同学可能在k-bucket 5中（或者说，Z同学的学号与A同学的学号从第5位开始不同，所以Z同学可能在k-bucket 5中）。<br> 然后<strong>A同学看看自己的k-bucket 5</strong>有没有Z同学：</p><ul><li>如果有，那就直接联系Z同学要书；</li><li>如果没有，在k-bucket 5里<strong>随便找一个</strong>B同学（注意任意B同学，它的学号第5位肯定与Z相同，即它与Z同学的距离会小于24，相当于比Z、A之间的<strong>距离缩短了一半以上</strong>），请求B同学在它自己的通讯录里按同样的查找方式找一下Z同学：<ul><li>如果B知道Z同学，那就把Z同学的手机号（IP Address）告诉A；</li><li>如果B也不知道Z同学，那<strong>B按同样的搜索方法</strong>，可以在自己的通讯录里找到一个离Z更近的C同学（Z、C之间距离小于2^3），把C同学推荐给A；A同学请求C同学进行下一步查找。<strong>（递归）</strong></li></ul></li></ul><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h3><ul><li><strong>keyspace</strong><ul><li>nodeID有多少位</li><li>决定每个节点的路由表有几层</li></ul></li><li><p><strong>k</strong></p><ul><li>每一层k-bucket里<strong>装k个node信息</strong>：<nodeid, ip,="" address="" ,port=""></nodeid,></li><li>每次查找node，<strong>返回k个node信息</strong></li><li>对于某个特定的data，它的ID也就是所说的key，离其key<strong>最近的k个节点</strong>也要存储这个data</li></ul></li><li><p>α</p><ul><li>每次向其他node请求查找某个node时，会<strong>向α个node发送请求</strong></li></ul></li></ul><hr><h3 id="节点的指令"><a href="#节点的指令" class="headerlink" title="节点的指令"></a>节点的指令</h3><blockquote><p>每个节点只有4个指令</p></blockquote><ul><li>PING：测试一个节点是否在线</li><li>STORE：要求一个节点存储一份数据</li><li>FIND_NODE：根据nodeID查找一个node</li><li>FIND_VALUE：根据KEY查找一个data，跟FIND_NODE十分相似</li></ul><hr><h3 id="k-bucket的维护和更新机制"><a href="#k-bucket的维护和更新机制" class="headerlink" title="k-bucket的维护和更新机制"></a>k-bucket的维护和更新机制</h3><blockquote><p>保证任何节点的加入和离开都不影响整体网络</p></blockquote><ul><li>每个bucket里的节点都按最后一次接触的时间倒序排列<ul><li>也就是：最近接触的放在队尾</li></ul></li><li>每次执行四个指令中的任何一个，都会触发更新</li><li>当<font color="green">一个节点</font>和<strong>自己</strong>接触时，检查它是否在<strong>自己</strong>的k-bucket中<ul><li>在：把<font color="green">这个节点</font>挪到k-bucket列表的末尾</li><li>不在：PING一下列表最头部的<font color="orange">一个节点</font><ul><li>PING通：把<font color="orange">旧节点</font>挪到列表的末尾，丢弃<font color="green">新节点</font></li><li>PING不通：删除<font color="orange">旧节点</font>，并将<font color="green">新节点</font>加入列表</li></ul></li></ul></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;分布式路由算法Kademlia的原理理解&lt;/p&gt;</summary>
    
    
    
    <category term="信安赛" scheme="http://example.com/categories/%E4%BF%A1%E5%AE%89%E8%B5%9B/"/>
    
    
    <category term="以太坊" scheme="http://example.com/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
  </entry>
  
  <entry>
    <title>【SE】线性代数</title>
    <link href="http://example.com/2022/04/17/2022-04-17-%E3%80%90SE%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <id>http://example.com/2022/04/17/2022-04-17-%E3%80%90SE%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</id>
    <published>2022-04-17T14:45:34.000Z</published>
    <updated>2022-04-19T06:54:22.503Z</updated>
    
    <content type="html"><![CDATA[<p>线性代数基本概念复习总结</p><span id="more"></span><p>[先挖个坑….]</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;线性代数基本概念复习总结&lt;/p&gt;</summary>
    
    
    
    <category term="数学" scheme="http://example.com/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="线性代数" scheme="http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【SE】词法分析器和语法分析器的设计</title>
    <link href="http://example.com/2022/04/15/2022-04-15-%E3%80%90SE%E3%80%91%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2022/04/15/2022-04-15-%E3%80%90SE%E3%80%91%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-04-15T14:45:34.000Z</published>
    <updated>2022-05-04T10:37:18.434Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>实现词法分析器</li><li>实现语法分析器</li></ul></li></ul><span id="more"></span><h1 id="1-词法分析器"><a href="#1-词法分析器" class="headerlink" title="1. 词法分析器"></a>1. 词法分析器</h1><h2 id="1-1-基本原理"><a href="#1-1-基本原理" class="headerlink" title="1.1 基本原理"></a>1.1 基本原理</h2><ul><li><p><strong>正规文法</strong></p><ul><li>也称<strong>3型</strong>文法 G=(VN,VT,S,P)</li><li>其中P中的每一条规则都有下述形式：<code>A-&gt;aB或A-&gt;a</code>，其中A和B是非终结符，a是终结符的闭包</li></ul></li><li><p><strong>不确定的有穷自动机NFA</strong></p><blockquote><p>一个不确定的 有穷自动机M 是一个五元组：$M=（K,\sum,f,S,Z)$</p></blockquote><ul><li>K：有穷集，每个元素称为一个<strong>状态</strong></li><li><p>Σ：有穷字母表，每一个元素称为一个<strong>输入符号</strong></p></li><li><p>f：一个映射</p></li><li>S ⊆ K：非空初态集（对于<strong>DFA，初态唯一</strong>）</li><li>Z ⊆ K：终态集</li></ul></li><li><p><strong>字符串t能被DFA所接收</strong></p><ul><li>对于$\sum^{*}$中的任何符号串t，若存在一条从初态节点到某一终态节点的道路，且这条道路的所有弧的标记符连接成的符号等于t，则称t可被这个DFA所接收（识别），若DFA的初态节点同时又是终态节点，则空字($\epsilon$)可为DFA所接收</li></ul></li></ul><h2 id="1-2-设计思路"><a href="#1-2-设计思路" class="headerlink" title="1.2 设计思路"></a>1.2 设计思路</h2><p>​    最先开始先以课本上给出的简单构词规则进行编写代码，进行调试，然后逐步扩充和完善构词规则，进行编码和调试。严格按照词法分析流程，根据规定的正规文法，先<strong>构建NFA</strong>，再利用子集法<strong>确定为DFA</strong>，分模块逐步完成主要函数。最后再通过DFA，读入测试程序进行扫描进行词法分析，得到<strong>输出的token序列</strong>或者错误信息。生成 token 列表（三元组：所在行号，类别，token 内容）。由于算法所用数据结构和C++中许多已有数据结构概念相符，因此可考虑用C++代码编写，充分利用C++中的STL库，十分方便算法的实现。总体流程图如下：</p><p><img src="https://i.bmp.ovh/imgs/2022/05/03/b31be7f16a2e2127.png" style="zoom: 30%;"></p><h2 id="1-3-文件结构"><a href="#1-3-文件结构" class="headerlink" title="1.3 文件结构"></a>1.3 文件结构</h2><div class="table-container"><table><thead><tr><th>路径</th><th>文件说明</th></tr></thead><tbody><tr><td>Lexical\TXT\GRAMMAR.txt</td><td>存放构词规则（正规文法）</td></tr><tr><td>Lexical\TXT\INCHAR.txt</td><td>存放终结符</td></tr><tr><td>Lexical\TXT\KEYWORDS.txt</td><td>存放关键字</td></tr><tr><td>Lexical\TXT\LIMITER.txt</td><td>存放界符(限定符）</td></tr><tr><td>Lexical\TXT\OPERATOR.txt</td><td>存放操作符</td></tr><tr><td>Lexical\TXT\ROW.txt</td><td>存放源程序中每一行的token数，便于语法分析器的报错提示</td></tr><tr><td>Lexical\TXT\SOURCE.txt</td><td>存放源程序代码</td></tr><tr><td>Lexical\TXT\TOKEN_TRIAD.txt</td><td>存放输出的token序列（三元组）</td></tr><tr><td>Lexical\TXT\TOKEN.txt</td><td>存放输出的token序列（二元组）</td></tr><tr><td>Lexical\TXT\WRONG.txt</td><td>存放语法分析器的报错信息，同时便于语法分析器的分析判断</td></tr><tr><td>Lexical\lexical.cpp</td><td>函数实现</td></tr><tr><td>Lexical\path.h</td><td>文件路径定义的头文件</td></tr><tr><td>Lexical\lexical.h</td><td>函数和变量声明的头文件</td></tr><tr><td>Lexical\main.cpp</td><td>主函数</td></tr></tbody></table></div><h2 id="1-4-构词规则"><a href="#1-4-构词规则" class="headerlink" title="1.4 构词规则"></a>1.4 构词规则</h2><p>基于本课程考核要求的内容，确定词法分析的构词如下：</p><p><img src="https://i.bmp.ovh/imgs/2022/05/03/a19bf29f8f13c3e2.png" style="zoom:40%;"></p><p>因此，根据构词规则设置正规文法，文法中的各项产生式的作用和之间的<strong>逻辑关系和分类</strong>如下：</p><ol><li>界符(限定符)</li></ol><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095219277.png" alt="image-20220503095219277" style="zoom: 30%;"></p><ol><li><p>标识符</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095318581.png" alt="image-20220503095318581" style="zoom: 33%;"></p></li><li><p>运算符</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095435881.png" alt="image-20220503095435881" style="zoom: 33%;"></p></li><li><p>常量</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503095607966.png" alt="image-20220503095607966" style="zoom:80%;"></p></li></ol><h2 id="1-5-具体实现"><a href="#1-5-具体实现" class="headerlink" title="1.5 具体实现"></a>1.5 具体实现</h2><h3 id="（1）初始化所有加载项：void-init"><a href="#（1）初始化所有加载项：void-init" class="headerlink" title="（1）初始化所有加载项：void init()"></a>（1）初始化所有加载项：void init()</h3><p>预处理，从各文本文件中加载终结符、关键字、操作符、界符到各自的数据结构中。</p><div class="table-container"><table><thead><tr><th>类型</th><th>数据结构</th><th>函数名</th></tr></thead><tbody><tr><td>终结符</td><td>vector<char>INCHAR</char></td><td>void load_inchar();</td></tr><tr><td>关键字</td><td>vector<string> KEYWORDS</string></td><td>void load_keywords();</td></tr><tr><td>操作符</td><td>vector<string> OPT</string></td><td>void load_opt();</td></tr><tr><td>界符</td><td>vector<string>LIMITER</string></td><td>void load_limiter();</td></tr></tbody></table></div><h3 id="（2）创建NFA：void-createNFA"><a href="#（2）创建NFA：void-createNFA" class="headerlink" title="（2）创建NFA：void createNFA()"></a>（2）创建NFA：void createNFA()</h3><ul><li><p><strong>数据结构定义</strong></p><ul><li><p>NFA中的一条边的数据结构，结构体存储三元组的形式：边的起点，边的输入（权重），边的终点</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503100210138.png" alt="image-20220503100210138" style="zoom: 50%;"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Triad</span> {</span></span><br><span class="line">&nbsp; <span class="keyword">char</span> startPoint, input, endPoint;</span><br><span class="line">} Triad;</span><br></pre></td></tr></tbody></table></figure></li><li><p>NFA的数据结构： 结构体保存<code>initialState</code>-初态，<code>finalState</code>-终态，<code>f</code>-NFA中所有边的集合</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NFA</span> {</span></span><br><span class="line">&nbsp; <span class="keyword">char</span> initialState;</span><br><span class="line">&nbsp; vector&lt;<span class="keyword">char</span>&gt; finalState;</span><br><span class="line">&nbsp; vector&lt;Triad&gt; f;</span><br><span class="line">} NFA;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>读入的正规文法创建NFA</strong></p><ul><li><p>根据<strong>右线性</strong>正规文法的转换规则（注：t 为 VT 或ε）：</p><pre><code>① 增加一个终态结点，开始符号对应的结点作为初态② 对形如 A→t 的规则，引一条从A到终态结点的弧，标记为t③ 对形如 A→tB 的规则，引一条从A到B的弧，标记为t</code></pre></li><li><p>算法具体流程图如下，由于NFA的终态集合采用的是vector，最后需要对vector的元素进行去重，但代码运行时即使不去重也没有影响。</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503100618138.png" alt="image-20220503100618138" style="zoom:50%;"></p></li></ul></li></ul><h3 id="（3）将NFA转换成DFA：void-NFA-TO-DFA"><a href="#（3）将NFA转换成DFA：void-NFA-TO-DFA" class="headerlink" title="（3）将NFA转换成DFA：void NFA_TO_DFA()"></a>（3）将NFA转换成DFA：void NFA_TO_DFA()</h3><p>​    首先，定义DFA的数据结构，利用结构体保存初态-initialState、终态集合-finalState、边的集合-f；在定义DFA的边的集合时，并没有采用像NFA一样的结构体来定义边，而是采用一个二维数组<code>f[MAX_NODES][MAX_NODES]</code>，比如<code>f[state][input]=nextState</code>就表示从当前状态<code>state</code>输入字符<code>input</code>后转移到下一个状态<code>nextState</code>，将char隐式地转换成int类型作为数组下标，在代码中利用change函数实现，比如初始状态表示字符<code>S</code>对应int中0，其余状态<code>A</code>对应int中的1，<code>B</code>对应int中的2……以此类推。的实现了O(1)查找，提高了算法的效率。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DFA</span> {</span></span><br><span class="line">&nbsp; <span class="keyword">char</span> initialState;</span><br><span class="line">&nbsp; vector&lt;<span class="keyword">char</span>&gt; finalState;</span><br><span class="line">&nbsp; <span class="keyword">int</span> f[MAX_NODES][MAX_NODES]; &nbsp;</span><br><span class="line">} DFA;</span><br></pre></td></tr></tbody></table></figure><p>算法的关键部分的伪代码如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开始e-<span class="built_in">closure</span>(K0)令C为中唯一成员，并且它是未被标记的。</span><br><span class="line"><span class="built_in">While</span> (C 中存在尚未标记的子集T) <span class="keyword">do</span></span><br><span class="line">{    标记T；</span><br><span class="line">     <span class="built_in">For</span>(每个输入字符a) <span class="keyword">do</span></span><br><span class="line">      {   U:=e-<span class="built_in">closure</span>(<span class="built_in">move</span>(T,a))</span><br><span class="line">          <span class="built_in">If</span> (U不在C中) then</span><br><span class="line">          { 将U作为未标记的子集加载C中；}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中，需要求闭包和move集：</p><ul><li><p><strong>求状态集T的闭包:</strong></p><ul><li><p>对应代码的函数名为<code>set&lt;char&gt; e_closure(set&lt;char&gt; T)</code>。</p></li><li><p>传入参数，类型为<code>set&lt;char&gt;</code>的状态集T，函数返回状态集T的一个闭包。</p></li><li>求T的闭包即是求状态集<strong>T中的任何状态</strong>，及<strong>经过任意条ε弧所能到达的状态</strong>的集合。</li><li>由于集合的概念和C++的STL中的set概念一致，所以采用的是set类型来保存所有满足要求的状态，这样就没有重复元素，不需要去重。</li></ul></li><li><p><strong>求集合I的move集：</strong></p><ul><li><p>对应代码的函数名为<code>set&lt;char&gt; move(set&lt;char&gt; I, char input)</code>。</p></li><li><p>传入参数，类型为<code>set&lt;char&gt;</code>  的集合I，和一个char类型的字符input，求它的move集，即是求所有可以从I中的某一状态经一条input弧所能到达的状态，返回满足要求的状态的集合。</p></li></ul></li></ul><p>定义完求闭包和求move集的函数后，编写NFA转换成DFA的算法。根据伪代码转换的具体算法流程图如下：</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503111033602.png" alt="image-20220503111033602" style="zoom:50%;"></p><h3 id="（4）读入源程序进行词法分析：void-scanSourceCode"><a href="#（4）读入源程序进行词法分析：void-scanSourceCode" class="headerlink" title="（4）读入源程序进行词法分析：void scanSourceCode()"></a>（4）读入源程序进行词法分析：void scanSourceCode()</h3><p>​    首先，在读入源程序之前，需要将源程序一些不必要的换行和tab符号过滤掉，然后存到数组中，然后对这些已经用空格分隔该来的预处理字符串序列进行处理，将一个个字符串分割成一个个单词，初始化对应的单词类型为空串，具体算法执行流程如下：</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503125941169.png" alt="image-20220503125941169" style="zoom:50%;"></p><p>​    然后单词分割完毕后，对每个单词进行类型判断，通过DFA的状态转移表f对字符串序列逐个处理，每处理一个更新当前状态，直至状态为-1即找不到下一个状态为止，判断当前是否是因为未知符号导致的中断，将已经识别的字符串作为一个token识别其属于关键字，操作符，界符，常数和标识符的哪一种。具体算法执行流程如下：</p><p><img src="..\blogImages\2022-04-15-【SE】词法分析器和语法分析器的设计\image-20220503130118347.png" alt="image-20220503130118347" style="zoom:50%;"></p><h3 id="（5）其他非关键函数"><a href="#（5）其他非关键函数" class="headerlink" title="（5）其他非关键函数"></a>（5）其他非关键函数</h3><ul><li>包括：打印NFA、打印DFA、关键词、界符等的判断函数、状态重命名函数、过滤源程序函数等等。</li></ul><h2 id="1-6-实例分析"><a href="#1-6-实例分析" class="headerlink" title="1.6 实例分析"></a>1.6 实例分析</h2><ul><li><p>输入正确源程序，词法分析成功，无误。</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503220718340.png" alt="image-20220503220718340" style="zoom:30%;"></p></li><li><p>修改源程序，检查，能够报出错误信息，指明出错位置</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503221014826.png" alt="image-20220503221014826" style="zoom:30%;"></p></li></ul><h1 id="2-LR-1-语法分析器"><a href="#2-LR-1-语法分析器" class="headerlink" title="2. LR(1)语法分析器"></a>2. LR(1)语法分析器</h1><h2 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h2><ul><li><strong>LR分析法</strong><ul><li>根据<strong>状态栈</strong>，和<strong>向右顺序查看</strong>输入串的$k(k≥0)$ 个符号，就可以唯一地确定分析器的动作<strong>是移进还是归约</strong>和用哪个产生式归约，因而能就确定唯一的句柄。</li><li>LR分析法的归约过程是规范推导的逆过程，所以LR分析过程是一种规范归约的过程</li></ul></li><li><strong>LR分析器</strong><ul><li>总控程序</li><li>分析表：Action-Goto表</li><li>分析栈：状态栈、符号栈；<ul><li>分析器的动作由栈顶状态和当前输入符号来确定<ul><li>移进：当$S_{j}=GOTO[S_{i},a]$ 成立，将$S_{j}$ 移入到状态栈，将$a$ 移入符号栈</li><li>归约：当栈顶形成句柄$\beta$ ，用$\beta$ 归约为相应的非终结符</li><li>接受：归约到文法符号栈中只剩下开始符号S，并且输入符号串结束，分析成功</li><li>报错：当遇到状态栈顶为某一状态下出现不该遇到的文法符号时报错，无法接受该句子</li></ul></li></ul></li></ul></li><li><strong>几种LR分析法的区别</strong><ul><li><strong>LR(0)</strong><ul><li>分析过程不需要向右查看输入符号</li><li>不存在<strong>移进-归约</strong> 和 <strong>归约-归约</strong> 冲突，即 R(0)文法分析<strong>不能解决这两种冲突</strong>，所以适用范围最小</li></ul></li><li><strong>SLR(1)</strong><ul><li>简单的LR(1)，存在<strong>多余（无效）归约</strong>的情况</li><li>不存在归约-归约冲突，<strong>有可能存在移进-归约冲突</strong>，但是如果可以用 follow集解决则是 SLR文法。换句话说，SLR文法分析过程可以解决归约-归约冲突，但是<strong>不一定能解决移进-归约冲突</strong>。用 follow集来处理即出现移进-归约冲突的两条产生式，如果其 follow集相交为空则为 SLR文法，反之不是。</li></ul></li><li><strong>LR(1)</strong><ul><li>因为 LR(1)文法的范围比较大，所以文法几乎都是 LR(1)的</li></ul></li></ul></li><li><strong>项目集中的项目种类</strong><ul><li>移进项目、待约项目、归约项目、接受项</li></ul></li></ul><h2 id="2-2-设计思路"><a href="#2-2-设计思路" class="headerlink" title="2.2 设计思路"></a>2.2 设计思路</h2><ul><li>读入二型文法产生式文档，识别出所有终结符和非终结符，求相应的First集</li><li>构建初始项目集，对核其闭包，进行状态转移，得到项目集族，构建Action-Goto表</li><li>构造分析表。</li></ul><p>编码过程中，严格分模块进行，每完成一个模块就进行一个模块的测试和校正。大量使用STL极大的简便了繁琐的编码。</p><h2 id="2-3-文件结构"><a href="#2-3-文件结构" class="headerlink" title="2.3 文件结构"></a>2.3 文件结构</h2><div class="table-container"><table><thead><tr><th>路径</th><th>文件说明</th></tr></thead><tbody><tr><td>Parser\TXT\ACTION_GOTO.txt</td><td>存放产生的Action-Goto表</td></tr><tr><td>Parser\TXT\ANALYSIS.TXT</td><td>存放分析表</td></tr><tr><td>Parser\TXT\GRAMMAR.txt</td><td>存放文法表</td></tr><tr><td>Parser\TXT\ITEMSET.txt</td><td>存放产生的项目集</td></tr><tr><td>Parser\main.cpp</td><td>主函数</td></tr><tr><td>Parser\parser.cpp</td><td>函数实现</td></tr><tr><td>Parser\parser.h</td><td>函数和变量声明的头文件</td></tr><tr><td>Parser\path.h</td><td>文件路径定义的头文件</td></tr></tbody></table></div><h2 id="2-4-语法规则"><a href="#2-4-语法规则" class="headerlink" title="2.4 语法规则"></a>2.4 语法规则</h2><p>​    实现基本的运算，赋值，定义变量，if-else，while，do-while，for，switch-case分支语句的判别。抽象的文法映射成程序中的文法规则的逻辑分类如下：</p><ol><li><p>程序框架</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144649721.png" alt="image-20220503144649721" style="zoom: 50%;"></p></li><li><p>赋值语句</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144737724.png" alt="image-20220503144737724" style="zoom:45%;"></p></li><li><p>操作语句</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144812202.png" alt="image-20220503144812202" style="zoom: 45%;"></p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144847851.png" alt="image-20220503144847851" style="zoom:40%;"></p></li><li><p>分支语句</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144921107.png" alt="image-20220503144921107" style="zoom:60%;"></p></li><li><p>代码块</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503144941722.png" alt="image-20220503144941722" style="zoom:50%;"></p></li></ol><h2 id="2-5-具体实现"><a href="#2-5-具体实现" class="headerlink" title="2.5 具体实现"></a>2.5 具体实现</h2><h3 id="（1）预处理阶段：读取给定的二型文法文件"><a href="#（1）预处理阶段：读取给定的二型文法文件" class="headerlink" title="（1）预处理阶段：读取给定的二型文法文件"></a>（1）预处理阶段：读取给定的二型文法文件</h3><ul><li><p>数据结构定义</p><ul><li><p>二型文法产生式的数据结构</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Grammar</span>{</span></span><br><span class="line">&nbsp; &nbsp; <span class="keyword">char</span> left;</span><br><span class="line">&nbsp; &nbsp; string right;</span><br><span class="line">}Grammar;</span><br></pre></td></tr></tbody></table></figure></li><li><p>存放所有产生式的数据结构</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Grammar&gt; grammar; </span><br></pre></td></tr></tbody></table></figure></li><li><p>定义存放token的数据结构，将词法分析器获取的token的<strong>单词映射成一个字符</strong>，存入token字符串中</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    &nbsp;string token;</span><br></pre></td></tr></tbody></table></figure></li><li><p>定义存放终结符和非终结符的数据结构，VT存放终结符，其中不包括epsilon，epsilon单独处理； VN存放非终结符。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="keyword">char</span>&gt; VT; &nbsp;</span><br><span class="line">set&lt;<span class="keyword">char</span>&gt; VN;</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>算法具体流程如下：</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503145537941.png" alt="image-20220503145537941" style="zoom:60%;"></p></li></ul><h3 id="（2）创建项目集族和Action-Goto表：void-create-char-left-char-right"><a href="#（2）创建项目集族和Action-Goto表：void-create-char-left-char-right" class="headerlink" title="（2）创建项目集族和Action-Goto表：void create(char left,char right)"></a>（2）创建项目集族和Action-Goto表：void create(char left,char right)</h3><ul><li><p><strong>数据结构定义</strong></p><ul><li><p>LR(1)项目集中的一条项目</p><ul><li><p><code>left</code>项目的产生式左边，<code>right</code>产生式右边，<code>position</code>圆点的位置，规定在<code>right[position]</code>的左边，<code>index</code> 本项目产生式在文法中的位置索引，<code>forward</code>向前搜索符集；</p></li><li><p>另外重载 <code>＜</code> 和 <code>==</code>便于后续的一些比较</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Item</span>{</span></span><br><span class="line"><span class="keyword">char</span> left; </span><br><span class="line">string right;</span><br><span class="line"><span class="keyword">int</span> position = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> index; </span><br><span class="line">set&lt;<span class="keyword">char</span>&gt; forward; </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> struct Item &amp; item) <span class="keyword">const</span>{...详细见代码...}</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> struct Item &amp; item) <span class="keyword">const</span>{...详细见代码...} </span><br><span class="line">}Item;</span><br></pre></td></tr></tbody></table></figure></li><li><p>LR(1)项目集族的数据结构</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;Item&gt; Itemset[<span class="number">1000</span>];  </span><br></pre></td></tr></tbody></table></figure></li><li><p>Action-Goto表的数据结构</p><p>​    因为Action和Goto表的<strong>移进项没有本质区别</strong>，只有Action中的移进和归约态有区别。因为终结符和非终结符本代码都只用了一个字符表示，所以采用了char到int的隐式转换作为二维数组的索引，实现了O(1)的查找。。再判断的时候也和256作比较再进行下一步的判断。例如<code>ActionGoto[state][input]</code>的值表示栈顶状态为<code>state</code>时，遇见字符<code>input</code>所要执行的动作。</p><p>​    <strong>对ActionGoto数组的值的规定</strong>：</p><ul><li>-1 标识接受动作；</li><li>-2 标识不存在这个状态转移，即出错动作；</li><li>其余：Action表中的移进和归约用是否加256区分：x标识移进动作，x+256表示规约动作</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ActionGoto[<span class="number">300</span>][<span class="number">300</span>]; </span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>算法具体流程</strong></p><p>​    left是增广文法的左部非终结符，right是原文法的起始非终结符，用于初始化初始项目集，然后创建所有项目集，得到最终的项目集族，采用的是宽搜的方式，遍历所有终结符和非终结符。</p><p>​    如果能进行状态转移，那么就核和闭包，扩充项目集。若与原项目集不同则加入到项目集族，增加一条状态转移；若相同则只增加一条状态转移（指向自己），同时填充ActionGoto数组。</p><p>​    直至项目集族中不再有新项目集出现为止。在建好项目集族后，再来遍历项目集族判断项目集中是否含有归约项，区分和填充ActionGoto数组中的归约项和接受项。</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503204749919.png" alt="image-20220503204749919" style="zoom:77%;"></p><p>在构造DFA项目集的过程中，还涉及到以下函数调用</p><p>| 函数作用         | 函数名                                            | 说明                                                         |<br>| :———————- | ————————————————————————- | —————————————————————————————— |<br>| 求核             | <code>set&lt;Item&gt; getKernel(char c, set&lt;Item&gt; itemSet)</code>  | 遍历项目集中的每个项目，与文法进行匹配即可                   |<br>| 求闭包           | <code>set&lt;Item&gt; getClosure(set&lt;Item&gt; itemSet)</code>         | 通过while循环，循环体内遍历项目集中的每一个项目，若还有能扩充项目则继续迭代，直至项目集中的每一个项目不再能进行扩充。 |<br>| 求向前搜索符号集 | <code>set&lt;char&gt; getForward(char c, set&lt;char&gt; forward)</code> | 关键在于需要进行c是否为epsilon以及c是否能推出空来判断相应的动作，得到向前搜素符。 |<br>| 求First集        | <code>void getFirstSet()</code>                              | 通过while循环，循环体内遍历每一个文法，直至每个非终结符的First集不再发生改变就停止迭代，若还有变化则继续迭代。 |</p></li></ul><h3 id="（3）扫描token序列进行语法分析：void-scanSourceToken-string-token-str"><a href="#（3）扫描token序列进行语法分析：void-scanSourceToken-string-token-str" class="headerlink" title="（3）扫描token序列进行语法分析：void scanSourceToken(string token_str)"></a>（3）扫描token序列进行语法分析：void scanSourceToken(string token_str)</h3><p>​    首先检查词法分析无误，然后再进行语法分析，依据Action-Goto表依次对输入的token进行分析，根据当前的项目集（即DFA状态）和当前的token找Action-Goto表中的对应项，根据表中对应的值，判断是移进还是归约还是acc还是报错。如果是移进则更新当前状态，同时将状态和token入栈；如果是归约，则符号栈和状态栈依据归约文法进行退栈和入栈，同时根据最新的状态和token进行移进。直至acc或者检测到语法出错，则迭代结束。具体流程图如下：</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503210635580.png" alt="image-20220503210635580" style="zoom:50%;"></p><h2 id="2-6-实例分析"><a href="#2-6-实例分析" class="headerlink" title="2.6 实例分析"></a>2.6 实例分析</h2><ul><li>输入正确源程序，语法分析成功，无误。</li></ul><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503221437398.png" alt="image-20220503221437398" style="zoom:33%;"></p><ul><li><p>修改源程序，检查，能够报出错误信息，指明出错位置</p><p><img src="../blogImages/2022-04-15-【SE】词法分析器和语法分析器的设计/image-20220503221705649.png" alt="image-20220503221705649" style="zoom:33%;"></p></li></ul><h1 id="3-运行环境说明"><a href="#3-运行环境说明" class="headerlink" title="3. 运行环境说明"></a>3. 运行环境说明</h1><ul><li><p>操作系统：Windows 10</p></li><li><p>运行环境：Visual Studio Code</p></li><li><p>说明：编译链接Lexical或者Parser中的各个.cpp文件，然后运行main.cpp即可，Visual Studio Code环境下推荐CodeRunner插件一键运行；若更改源程序进行语法分析器的测试，请先运行词法分析器得到相应的token，再进行语法分析</p></li></ul><h1 id="3-课设总结"><a href="#3-课设总结" class="headerlink" title="3. 课设总结"></a>3. 课设总结</h1><p>​    本次课设花了将近两周的时间，首先由于是上学期学的编译原理，时间一长难免有些遗忘，所以在写代码前提前粗略地复习了一下之前学过的知识。在写代码过程中的同时，将理论知识转换成实际代码，也加深了我对编译原理课程所学知识的理解，也对我的代码能力有一定的提高。在写代码的过程中，感受到了选择一项好的数据结构的重要性，尤其是对C++中STL的实际应用，各种各样的数据结构让我体会到了STL的简便性。</p><p>​    在本次课设中，也遇到了一些磕磕碰碰，比如在进行语法分析器的设计，因为之前用的是书上的例子，导致之前开的保存项目集族的全局变量并没有很大，结果在代入自己的文法时，异常中断，最后通过开一大数组解决问题。还比如，在进行set的遍历时，删除了容器的部分元素，导致当前迭代器失效，通过预先获取下一步的迭代器，再删除现有的迭代器解决问题。</p><p>​    但是通过此次课程设计，让我体会到代码的模块化能够大大地节省编码过程中的调试时间，使代码逻辑层次更加清晰的好处。在编码过程中，将各个算法所用到的函数一个个写好，分阶段测试函数，整合算法，边写边检查和调试，就能够保证最终整合代码运行时报错模块数量最少。上学期虽然编译原理学得不错，但是转换成具体可用的程序来说，仍是有点陌生，但通过手动实现词法分析器和语法分析器，让我加深了对编译原理的理解和运用，总体来说收获颇丰。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;实现词法分析器&lt;/li&gt;
&lt;li&gt;实现语法分析器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="编译原理" scheme="http://example.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>区块链的一些简单理解</title>
    <link href="http://example.com/2022/04/12/2022-04-12-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2022/04/12/2022-04-12-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</id>
    <published>2022-04-11T16:22:17.000Z</published>
    <updated>2022-04-13T04:21:34.836Z</updated>
    
    <content type="html"><![CDATA[<p>关于比特币、以太坊、区块链结构</p><span id="more"></span><h1 id="比特币-区块链1-0"><a href="#比特币-区块链1-0" class="headerlink" title="比特币-区块链1.0"></a>比特币-区块链1.0</h1><ul><li><p>高度自治，</p></li><li><p>无国界贸易：</p><p><img src="https://i.bmp.ovh/imgs/2022/04/12/638806197ed4b7c7.png" style="zoom: 50%;"></p></li><li><p>不可篡改：交易一旦完成，交易数据不可篡改</p></li><li>隐私安全：每个用户可以拥有一个或多个账户，且无需提供用户信息，只需要提供密钥即可</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/12/f7ca63ac0036f299.png" style="zoom:50%;"></p><h2 id="去中心化模型"><a href="#去中心化模型" class="headerlink" title="去中心化模型"></a>去中心化模型</h2><p>去中心化模型：点对点（P2P）通信</p><p>去中心化<strong>并不是没有中心，而是中心不断的变化</strong>，每一次的中心都是由节点竞争而来</p><h2 id="账本隐私和快速对账"><a href="#账本隐私和快速对账" class="headerlink" title="账本隐私和快速对账"></a>账本隐私和快速对账</h2><p>比特币如何保护账本隐私：</p><ul><li>比特币系统利用<strong>哈希</strong>算法对交易信息进行加密、保护隐私<ul><li>交易信息：账户、信息内容</li></ul></li><li>哈希算法<ul><li><strong>能够提取事物的特征</strong></li><li>通过哈希值是<strong>无法反推</strong>出原来的明文</li><li>哈希算法 可以保护隐私和<strong>对账</strong><ul><li>只要哈希值不一样，账本中的数据就存在差异</li></ul></li></ul></li></ul><h2 id="账本一致性"><a href="#账本一致性" class="headerlink" title="账本一致性"></a>账本一致性</h2><p>比特币系统规则：<strong>最长链</strong>为可信任的链条</p><p>比特币中的<strong>矿工</strong>：创造区块，使链增长</p><p><img src="https://i.bmp.ovh/imgs/2022/04/12/78b98e299aa26c30.png" alt=""></p><h3 id="争夺记账权的方式：工作量证明"><a href="#争夺记账权的方式：工作量证明" class="headerlink" title="争夺记账权的方式：工作量证明"></a><strong>争夺记账权的方式：工作量证明</strong></h3><ul><li><p>工作量证明（Proof of Work）简称<strong>POW</strong></p></li><li><p>节点通过竞争PoW求解来获取记账权</p><ul><li>包括区块挖掘在内的区块链活动都是具有<strong>强时效性</strong>的竞争活动，竞争过程中，拥有<strong>哈希和拓扑优势</strong>的节点将有更高的概率获胜</li></ul></li><li><p>通过重复计算Nonce直至哈希值小于目标哈希值的过程：挖矿；这一整套算法成为POW算法</p></li><li><p>算力的体现就是单位时间内Nounce尝试的次数</p><p><a href=""><img src="https://s1.ax1x.com/2022/04/12/LnFzMd.png" style="zoom: 67%;"></a></p></li><li><p>伪造账本想要成为朱利安，必须要和比特币系统其余的人比拼算力，只有长时间的保持算力优先，才有伪造账本的可能。但<strong>保持长时间的算力优先的难度巨大</strong>，有可能高于伪造账本的获利</p></li></ul><h2 id="比特币的分叉"><a href="#比特币的分叉" class="headerlink" title="比特币的分叉"></a>比特币的分叉</h2><ul><li>不同矿工，使用不同版本的比特币系统进行挖矿，导致链条分叉<ul><li>硬分叉：系统的更新导致出现分支，无法合并,比如区块的扩容、</li><li>软分叉：可以合并</li></ul></li><li>这是矿工再比特币系统 协议层面上产生了分歧</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>比特币不是一种货币，是一个分布式的账本系统</p></li><li><p>账本记录交易过程，由节点广播道网络，保持其余节点数据一致</p></li></ul><hr><h1 id="区块链技术的形成"><a href="#区块链技术的形成" class="headerlink" title="区块链技术的形成"></a>区块链技术的形成</h1><p>区块链技术</p><ul><li>分布式数据存储<ul><li>每个参与者电脑上备份</li><li>账本实时同步和对账–&gt;保证公开透明</li></ul></li><li>点对点传输</li><li>共识机制<ul><li>比特币系统的主链容易出现短暂的分叉，这个分叉最终是会合并到主链上去的</li><li>比特币系统采用pow算法保证了账本的一致性，也让比特币系统变得更加安全可靠</li></ul></li><li>加密算法</li></ul><h1 id="以太坊-区块链2-0"><a href="#以太坊-区块链2-0" class="headerlink" title="以太坊-区块链2.0"></a>以太坊-区块链2.0</h1><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><strong>比特币的不足</strong>：</p><ul><li>交易速度慢</li><li>POW算法、耗电</li><li>仅仅完成了货币的去中心化，而现实中货币的价值建立在国家的公信力的基础上。</li></ul><p><strong>以太坊的改进</strong>：</p><ul><li><p>交易速度加快</p></li><li><p>POW+POS算法，逐步向POS算法过度</p></li><li><p>引入<strong>智能合约</strong></p><ul><li><p>不受人为因素的影响，没有黑幕</p></li><li><p>违反规则，直接扣除保证金</p></li></ul></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>以太坊</strong>是运行在计算机网络中的<strong>软件</strong>，它确保<strong>数据</strong>以及<strong>智能合约的小程序</strong>可以在没有中心协调者的情况下，被所有网络中的 计算机复制和处理</p><p><strong>以太坊平台能够承载应用</strong></p><p>以太坊的愿景是创建一个<strong>无法停止</strong>，<strong>抗屏蔽</strong>（审查）和<strong>自我维持</strong>的<strong>去中心化</strong>世计算机</p><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>智能合约：跑在以太坊系统中的合同，其实质是<strong>一段代码</strong></p><ul><li>它们像公示出来的法律合同，违反它们的人将遭到处罚</li></ul><p><strong>智能合约</strong>能表达：<strong>规则明确，不受主观因素影响</strong>的业务、规则不轻易修改的业务</p><ul><li>如果业务规则经常变化，无法通过智能合约编写，因为智能合约小程序一旦写完，运行在以太坊，是无法通过软件升级去进行规则更新的</li></ul><h2 id="ghost协议"><a href="#ghost协议" class="headerlink" title="ghost协议"></a>ghost协议</h2><p>以太坊快速出块产生的问题：区块分叉</p><hr><h1 id="区块链结构"><a href="#区块链结构" class="headerlink" title="区块链结构"></a>区块链结构</h1><p><img src="https://i.bmp.ovh/imgs/2022/04/13/eb0ad5cd836bb5a6.png" style="zoom:50%;"></p><p>Merkle树，快速<strong>归纳和校验大</strong>规模数据完整性的数据结构</p><ul><li>最下面的<strong>叶子节点存储哈希值或数据</strong></li><li>每个中间节点是<strong>两个子结点的内容的哈希值</strong>，</li><li><p>根节点也是两个子结点内容的哈希值</p></li><li><p>只要存储数据的叶子节点由任何的变动，都会传递道相应的父节点，<strong>导致其Merkle树的根节点发生变化</strong></p></li></ul><h2 id="区块链的P2P网络"><a href="#区块链的P2P网络" class="headerlink" title="区块链的P2P网络"></a>区块链的P2P网络</h2><h3 id="混合式：集中式-分布式"><a href="#混合式：集中式-分布式" class="headerlink" title="混合式：集中式+分布式"></a>混合式：集中式+分布式</h3><ul><li><p>网络中存在多个<strong>超级节点</strong>组成的<strong>分布式</strong>网络</p></li><li><p>而每个超级节点由多个<strong>普通节点</strong>和它组成局部的<strong>集中式</strong>网络</p></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/340e3a8ce5c9f06e.png" style="zoom: 33%;"></p><ul><li>新节点的加入：<ul><li>先选择一个超级节点进行通信</li><li>该超级节点再推送给其他超级节点列表给新加入节点<ul><li><strong>洪泛广播只发生在超级节点</strong>之间，避免大规模洪泛</li></ul></li><li>加入节点根据列表中的超级节点状态选择一个具体的超级节点作为父节点</li></ul></li></ul><hr><h3 id="比特币网络：混合式"><a href="#比特币网络：混合式" class="headerlink" title="比特币网络：混合式"></a>比特币网络：混合式</h3><p><strong>所有节点</strong>都会 </p><ul><li>参与校验、广播交易和区块信息；</li><li>发现和维持与其他节点的连接</li></ul><p><strong>全节点Full Node</strong></p><ul><li><p>承担网络中<strong>交易和区块的验证</strong>工作</p></li><li><p>包含<strong>完整的区块链数据库</strong>，包括所有交易数据</p></li></ul><p><strong>轻节点（LightWeight Node）或SPV节点</strong></p><ul><li>只存储区块链数据库的<strong>一部分</strong><ul><li>一般<strong>只存储区块头</strong>而不存储交易数据，通过<strong>简化交易验证（SPV）</strong>完成交易检验</li><li>验证<strong>前置交易</strong>的有效性</li></ul></li></ul><hr><p>比特币网络中的节点四大功能（只有<strong>比特币核心节点</strong>才会包含所有四大功能）：</p><ul><li>钱包 <strong>W</strong>allet<ul><li>PC或手机客户端的功能，用户通过钱包查看自己的账户余额，管理钱包地址和密钥，发起交易等</li><li>除了<strong>比特币核心钱包是全节点</strong>，大部分钱包都是轻节点</li></ul></li><li>挖矿 <strong>M</strong>iner<ul><li>挖矿节点通过解决<strong>PoW算法</strong>问题，与其他挖矿节点相互<strong>竞争创建新区块</strong></li><li><strong>独立矿工</strong>：全节点，存储完整的区块链数据库</li><li><strong>矿池矿工</strong>：和<strong>其他节点一起</strong>连接到矿池，参与集体挖矿<ul><li>形成了一个<strong>集中式矿池网络</strong>，中心节点是一个矿池服务器，其他挖矿节点全部连接到矿池服务器</li></ul></li></ul></li><li>区块链数据库 Full <strong>B</strong>lockchain</li><li>网络路由 <strong>N</strong>etwork Routing Node</li></ul><hr><p>整个比特币网络：</p><ul><li><strong>主网络</strong>：不同节点间使用<strong>比特币协议作</strong>为通信协议的的网络</li><li><strong>矿池网络</strong>：扩展网络<ul><li>不同的矿池网络可能使用不同的矿池挖矿协议<ul><li>Stratum协议：支持挖矿节点，支持瘦客户钱包</li></ul></li></ul></li><li>矿池矿工和矿池服务器之间的通信协议：<strong>矿池挖矿协议</strong></li><li>矿池服务器作为全节点与其他比特币节点使用<strong>主网络的比特币协议</strong>通信</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/98092e4534e957d3.png" alt=""></p><p>比特币传播网络（比特币中继网络）：</p><p>一个专门的传播网络：<strong>加快新区块在矿工之间的同步传播</strong></p><p>矿工创建新区块后，需要<strong>广播给全网</strong>所有节点，当全网都接受了该区块，给矿工的挖矿奖励才有效，然后才好开始下一个区块Hash的计算；</p><ul><li>矿工必须最大限度缩短区块的广播和下一个区块计算之间的时间</li></ul><hr><h3 id="结构化P2P"><a href="#结构化P2P" class="headerlink" title="结构化P2P"></a><strong>结构化P2P</strong></h3><ul><li>分布式网络：<strong>结构化</strong>网络、所有节点<strong>按照某种结构有序</strong>组织<ul><li>对比分布式网络：随机网络</li></ul></li><li>结构化网络的实现，基于DHT算法<ul><li><strong>DHT</strong>（Distributed Hah Table，分<strong>布式哈希表</strong>） <ul><li>网络模型，不涉及具体实现</li><li>解决分布式环境下快速准确地路由、定位数据</li><li>具体的实现算法：Chord、CAN、Kademlia等等<ul><li>以太坊网络采用Kademlia</li></ul></li></ul></li></ul></li></ul><hr><h4 id="DHT"><a href="#DHT" class="headerlink" title="DHT"></a><strong>DHT</strong></h4><p>P2P的两种空间：</p><ul><li>资源空间：所有节点保存的<strong>资源集合</strong></li><li>节点空间：所有<strong>节点的集合</strong></li></ul><p>对所有资源和节点编号：对资源名称或内容用<strong>hash函数变成一个数值</strong></p><ul><li>一个资源一个ID、一个节点一个ID、资源ID和节点ID建立映射关系</li><li>将资源n的<strong>索引信息</strong>存到节点n上，要搜资源n，则找节点n<ul><li>能够避免洪泛广播</li><li>能够快速准确路由 和 定位数据</li></ul></li></ul><p>DHT算法在资源编号和节点编号上使用 <strong>分布式哈希表</strong>，使得资源空间和节点空间的编号具有唯一性、均匀分布式</p><hr><h3 id="以太坊网络：结构化P2P"><a href="#以太坊网络：结构化P2P" class="headerlink" title="以太坊网络：结构化P2P"></a>以太坊网络：结构化P2P</h3><ul><li>采用<strong>Kad</strong>emlia算法实现：分布式哈希技术</li></ul><p>Kad网络</p><ul><li>每个节点由一个唯一的节点ID</li><li>不同节点间的距离：逻辑距离，两个节点ID<strong>异或</strong>得到</li><li>给定一个节点a和距离L，<strong>有且仅有一个节点</strong>使得a^b=L</li><li>通过这种方式能有效度量Kad网络中不同节点间的逻辑距离</li></ul><hr><p>近期的区块链架构</p><p><img src="https://i.bmp.ovh/imgs/2022/04/13/bcd6f70393329c9e.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于比特币、以太坊、区块链结构&lt;/p&gt;</summary>
    
    
    
    <category term="信安赛" scheme="http://example.com/categories/%E4%BF%A1%E5%AE%89%E8%B5%9B/"/>
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>【总结】字符串处理总结</title>
    <link href="http://example.com/2022/04/08/2022-04-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2022/04/08/2022-04-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</id>
    <published>2022-04-08T02:35:34.000Z</published>
    <updated>2022-07-12T09:07:02.062Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容：<ul><li>总结各类模拟题型中的一些字符串处理</li></ul></li></ul><span id="more"></span><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p><strong>C语言里压根就没有string这个类</strong>，所以字符串都是通过<strong>char数组</strong>来存储的，而<string.h>这个头文件里声明的函数原型也全是针对char数组的种种操作。<strong>直到C++中才出现了string这个类</strong>(注意是类，不是类型)</string.h></p><h1 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> 大写字母 = 小写字母-<span class="string">'a'</span>+<span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">char</span> 大写字母 = <span class="built_in">toupper</span>(小写字母);</span><br><span class="line"><span class="comment">//cout&lt;&lt;(char)toupper(c[i])直接cout要类型转换，因为toupper返回的时int的ascii</span></span><br><span class="line"><span class="keyword">char</span> 小写字母 = <span class="built_in">tolower</span>(大写字母);</span><br></pre></td></tr></tbody></table></figure><h1 id="string-char-int-之间的相互转换"><a href="#string-char-int-之间的相互转换" class="headerlink" title="string char[] int 之间的相互转换"></a>string char[] int 之间的相互转换</h1><h2 id="string-转-char"><a href="#string-转-char" class="headerlink" title="string 转 char[]"></a>string 转 char[]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">a=s.<span class="built_in">c_str</span>(); <span class="comment">//string转char数组</span></span><br></pre></td></tr></tbody></table></figure><h2 id="string-转-int"><a href="#string-转-int" class="headerlink" title="string 转 int"></a>string 转 int</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s=<span class="string">"123"</span>;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">stoi</span>(s); <span class="comment">//output:123</span></span><br><span class="line"><span class="comment">//同理还有：</span></span><br><span class="line"><span class="comment">//stoll():转换成long long</span></span><br><span class="line"><span class="comment">//stod():转换成double；stof():转换成floay</span></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">atoi</span>(s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></tbody></table></figure><h2 id="char-转-string"><a href="#char-转-string" class="headerlink" title="char[] 转 string"></a>char[] 转 string</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[]=<span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">//方式一</span></span><br><span class="line">string s=ch</span><br></pre></td></tr></tbody></table></figure><h2 id="char-转-int"><a href="#char-转-int" class="headerlink" title="char[] 转 int"></a>char[] 转 int</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[]=<span class="string">"124"</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">atoi</span>(ch);</span><br></pre></td></tr></tbody></table></figure><h2 id="int-转-string"><a href="#int-转-string" class="headerlink" title="int 转 string"></a>int 转 string</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">123</span>;</span><br><span class="line">string s=<span class="built_in">to_string</span>(a);</span><br></pre></td></tr></tbody></table></figure><h2 id="int-转-char"><a href="#int-转-char" class="headerlink" title="int 转 char[]"></a>int 转 char[]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number =<span class="number">123</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">itoa</span>(number, s, <span class="number">10</span>);<span class="comment">//将number转换成十进制存在s数组中</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number =<span class="number">123</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(s,<span class="string">"%d"</span>,number);<span class="comment">//将number转换成十进制存在s数组中</span></span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br></pre></td></tr></tbody></table></figure><h1 id="字符串读取"><a href="#字符串读取" class="headerlink" title="字符串读取"></a>字符串读取</h1><h2 id="getline-cin-string-namae-end-char-读取一行"><a href="#getline-cin-string-namae-end-char-读取一行" class="headerlink" title="getline(cin,string_namae,end_char)读取一行"></a>getline(cin,string_namae,end_char)读取一行</h2><p>接受一个字符串，可以接受空格并输出</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str; </span><br><span class="line"><span class="built_in">getline</span>(cin,str); <span class="comment">//输入：ss ss ss</span></span><br><span class="line">cout&lt;&lt;str&lt;&lt;endl;  <span class="comment">//输出：ss ss ss</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin,str,<span class="string">'a'</span>);<span class="comment">//一个直到‘a’结束，其中任何字符包括'\n'都能够读入</span></span><br></pre></td></tr></tbody></table></figure><p>当同时使用<code>cin&gt;&gt;</code>和<code>getline(cin,str)</code>的时候，在<code>cin&gt;&gt;</code>输入完成之后，<code>getline(cin,str)</code>(str是真正想要的串)之前，需要<strong>先</strong><code>getline(cin,str)</code>（这个str是一个打算用来存储换行符的串）；<font color="red">将换行从输入流缓存中清除</font></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">string line;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">getline</span>(cin,line); <span class="comment">//清除缓存的换行!!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="built_in">getline</span>(cin,line);</span><br></pre></td></tr></tbody></table></figure><h2 id="gets-char-读取一行"><a href="#gets-char-读取一行" class="headerlink" title="gets(char*)读取一行"></a>gets(char*)读取一行</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> t[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">gets</span>(t);</span><br><span class="line"><span class="built_in">puts</span>(t);</span><br></pre></td></tr></tbody></table></figure><h1 id="STL-string常用方法"><a href="#STL-string常用方法" class="headerlink" title="STL string常用方法"></a>STL string常用方法</h1><h2 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string line=<span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="keyword">int</span> st=<span class="number">3</span>,len=<span class="number">2</span>;</span><br><span class="line">string s1=<span class="built_in">substr</span>(line,st,len);</span><br><span class="line"><span class="comment">//从line的st位置开始，截取len长度的字符串</span></span><br></pre></td></tr></tbody></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> idx= line.<span class="built_in">find</span>(<span class="string">"cde"</span>);<span class="comment">//查得到则返回第一个下标，</span></span><br><span class="line"><span class="comment">//找不到会返回一个诡异的数字（反正比字符串长）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx=line.<span class="built_in">find</span>(<span class="string">"cde"</span>,<span class="number">2</span>);<span class="comment">//从第index=2的位置往后找</span></span><br></pre></td></tr></tbody></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">"0123456"</span>;</span><br><span class="line">string s=<span class="string">"aa"</span>;</span><br><span class="line">str=s.<span class="built_in">insert</span>(<span class="number">4</span>,s);<span class="comment">//0123aa456</span></span><br><span class="line"><span class="comment">//在str[4]之前插入s</span></span><br></pre></td></tr></tbody></table></figure><h2 id="大小写转换-1"><a href="#大小写转换-1" class="headerlink" title="大小写转换"></a>大小写转换</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//transform(处理对象容器起始地址，处理对象容器结束地址，存放结果的容器地址，处理操作（可自定义））</span></span><br><span class="line"><span class="built_in">transform</span>( str.<span class="built_in">begin</span>() , str.<span class="built_in">end</span>() , str.<span class="built_in">begin</span>() , ::tolower );<span class="comment">//化为小写</span></span><br><span class="line"><span class="built_in">transform</span>( str.<span class="built_in">begin</span>() , str.<span class="built_in">end</span>() , str.<span class="built_in">begin</span>() , ::toupper );<span class="comment">//化为大写</span></span><br></pre></td></tr></tbody></table></figure><h1 id="string-h头文件"><a href="#string-h头文件" class="headerlink" title="string.h头文件"></a>string.h头文件</h1><p><code>strlen(char*)</code></p><p><code>strcmp(char* a, char* b)</code>字典序比较</p><ul><li>a&lt;b;返回负整数</li><li>a==b;返回0</li><li>a&gt;b;返回正整数</li></ul><p><code>strcpy(char* a ,char* b)</code>把a复制给b</p><p><code>strcat(char* a ,char* b)</code>把b接到a后面</p><h1 id="sscanf和sprintf"><a href="#sscanf和sprintf" class="headerlink" title="sscanf和sprintf"></a>sscanf和sprintf</h1><p><code>scanf(char* , "" ,&amp;)</code></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> t[<span class="number">100</span>]; <span class="built_in">gets</span>(t);<span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">sscanf</span>(t,<span class="string">"%d"</span>,a);<span class="comment">//把t以整型格式输入到a中</span></span><br><span class="line"><span class="built_in">sscanf</span>(t,<span class="string">"%d:%lf,%s"</span>,&amp;n,&amp;db,str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>(t,<span class="string">"%d"</span>,a);<span class="comment">//把整型的a输出到字符串t中</span></span><br></pre></td></tr></tbody></table></figure><h1 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"aaa"</span>,b[]=<span class="string">"aaa"</span>;  </span><br><span class="line">string A = <span class="string">"AAA"</span>, B = <span class="string">"AAA"</span>;  </span><br><span class="line">cout &lt;&lt;<span class="string">"*a和*b的值分别是："</span> &lt;&lt;*a &lt;&lt; <span class="string">"，"</span> &lt;&lt; *b &lt;&lt; endl;  </span><br><span class="line">cout &lt;&lt;<span class="string">"*“aaa”的值是："</span>&lt;&lt; *<span class="string">"aaa"</span> &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的比较方法：</span></span><br><span class="line">cout &lt;&lt;<span class="string">"利用 == 比较a,b两个字符串，结果是（相等为1，不等为0）："</span> &lt;&lt;(a==b) &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的比较方法:</span></span><br><span class="line">cout &lt;&lt; <span class="string">"利用strcmp()比较a，b两个字符串，结果是（相等为0，不等非0）："</span>&lt;&lt;<span class="built_in">strcmp</span>(a,b) &lt;&lt; endl;  </span><br><span class="line">cout &lt;&lt; <span class="string">"利用 == 比较A,B两个string，结果是（相等为1，不等为0）："</span>&lt;&lt;(A==B) &lt;&lt; endl;  </span><br><span class="line">cout &lt;&lt; <span class="string">"利用compare()比较A,B两个string，结果是（相等为0，不等非0）："</span> &lt;&lt; A.<span class="built_in">compare</span>(B) &lt;&lt; endl;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br></pre></td></tr></tbody></table></figure><h1 id="int-isdigit-char"><a href="#int-isdigit-char" class="headerlink" title="int isdigit(char)"></a>int isdigit(char)</h1><p><code>isdigit</code>是计算机C(C++)语言中的一个函数，主要用于检查其参数<strong>是否为十进制数字字符</strong>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span> <span class="comment">//C</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span>  <span class="comment">//C++</span></span></span><br><span class="line"><span class="comment">//检查参数 c 是否为阿拉伯数字0 到9。</span></span><br><span class="line"><span class="comment">//若参数c为阿拉伯数字0~9，则返回非0值，否则返回0。</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容：&lt;ul&gt;
&lt;li&gt;总结各类模拟题型中的一些字符串处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【题解】贪心</title>
    <link href="http://example.com/2022/03/28/2022-03-28-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E8%B4%AA%E5%BF%83/"/>
    <id>http://example.com/2022/03/28/2022-03-28-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E8%B4%AA%E5%BF%83/</id>
    <published>2022-03-28T03:17:01.000Z</published>
    <updated>2022-04-04T01:33:00.120Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>一些贪心的题：区间问题、Huffman树、排列不等式、其他类型</li></ul></li></ul><span id="more"></span><h1 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h1><font color="red">区间问题的贪心一般都是上来先按左端点or右端点排序</font><p>然后手动模拟一下贪心，找性质，多找几组样例试试</p><h2 id="AcWing905-区间选点"><a href="#AcWing905-区间选点" class="headerlink" title="AcWing905 区间选点"></a>AcWing905 区间选点</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定<strong>N个闭区间</strong>，在数轴上选择尽量少的点，使<strong>每个区间至少包含</strong>一个选出的点，求选择的点的<strong>最小数量</strong></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/d297674baef4ce99.png" alt=""></p><ul><li>将每个区间<strong>按右端点</strong>从小到大<font color="red">排序</font></li><li>按照这个顺序从小到大<strong>枚举每个区间</strong><ul><li>对于当前区间，比如首先选择区间①的右端点，区间②、③都<strong>包含</strong>该点，所以直接pass（不在②、③区间选择点），继续往后枚举</li><li>当枚举到区间④时，发现区间①的右端点<strong>不在</strong>区间④内，所以此时<strong>选择</strong>区间④的右端点</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>,INF=<span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>{</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="comment">//重载小于号，按r从小到大排序 </span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Range&amp;W)<span class="keyword">const</span>{</span><br><span class="line"><span class="keyword">return</span> r&lt;W.r;</span><br><span class="line">}</span><br><span class="line">}range[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;range[i].l&gt;&gt;range[i].r;</span><br><span class="line"><span class="built_in">sort</span>(range,range+n);</span><br><span class="line"><span class="keyword">int</span> ed=-INF;  <span class="comment">//ed：当前区间右端点，初始化为最小值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(ed&lt;range[i].l){ <span class="comment">//如果前一个区间的右端点＜当前区间的左端点 </span></span><br><span class="line">ans++;</span><br><span class="line">ed=range[i].r;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing908-最大不相交区间数量"><a href="#AcWing908-最大不相交区间数量" class="headerlink" title="AcWing908 最大不相交区间数量"></a>AcWing908 最大不相交区间数量</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定<strong>N个闭区间</strong>，在数轴上<strong>选择若干区间</strong>，之间<strong>互不相交</strong>，求可选区间的<strong>最大</strong>数量</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li><strong>实际上和上题一样</strong>，区间相交 == 这几个区间能被同一个点覆盖 == 就只能从这几个区间中选择一个区间</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><ul><li>和上题一模一样</li></ul><h2 id="AcWing906-区间分组"><a href="#AcWing906-区间分组" class="headerlink" title="AcWing906 区间分组"></a>AcWing906 区间分组</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><ul><li><p>简单的理解，就是一种可以<strong>自动排序</strong>的队列</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">priority_queue&lt;结构名,vector&lt;结构名&gt;,greater/less&lt;结构名&gt;&gt; 队列名</span><br><span class="line"><span class="comment">// greater代表升序,从小到大; less代表降序,从大到小</span></span><br><span class="line"><span class="comment">//比如小根堆:</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt;heap;</span><br><span class="line">heap.<span class="built_in">size</span>();</span><br><span class="line">heap.<span class="built_in">empty</span>();<span class="comment">//heap为空则返回1</span></span><br><span class="line">heap.<span class="built_in">push</span>(k);<span class="comment">//在heap队列中插入k</span></span><br><span class="line">heap.<span class="built_in">pop</span>();<span class="comment">//删除heap队列中的第一个元素,小根堆的话,就是删除最小的那个</span></span><br><span class="line">heap.<span class="built_in">top</span>();<span class="comment">//返回heap队列中的第一个元素,并不删除</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定<strong>N个闭区间</strong>，将其分组，使得<strong>每组</strong>里面的各个区间<strong>没有交集</strong>，求<strong>最小</strong>分组数量</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li><p>将所有区间按照<strong>左端点</strong> 从小到大<font color="red">排序</font></p></li><li><p>从前往后处理每个区间</p><ul><li><strong>判断能否将其放到</strong>某个 现有 的组中<code>L[i]＞MAX_r</code>：<strong>==</strong> 判断每一组的<strong>右端点最右</strong>的区间是否跟它<strong>有交集</strong> <ul><li>如果和每一个组都有交集，则开一个新的组，把当前区间放进去</li><li>如果和某一个组无交集，将当前组的<code>MAX_r</code>放进去，并更新<code>MAX_r</code></li></ul></li></ul></li><li><p>理解：循环到该区间时，在此之前有很多组，每组里面有很多个不相交的区间，<strong>每个组</strong>里面都有<strong>一个</strong>MAX_r；</p><p><img src="https://s3.bmp.ovh/imgs/2022/03/effb589caed4b102.png" style="zoom: 40%;"></p><p><img src="https://i.bmp.ovh/imgs/2022/03/6821c2d7023fdd3a.png" style="zoom:40%;"></p><p><img src="https://s3.bmp.ovh/imgs/2022/03/7e41023452060a5b.png" style="zoom:40%;"></p></li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Range</span>{</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Range&amp;M)<span class="keyword">const</span>{</span><br><span class="line"><span class="keyword">return</span> l&lt;M.l;</span><br><span class="line">}</span><br><span class="line">}range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> l,r; </span><br><span class="line">cin&gt;&gt;range[i].l&gt;&gt;range[i].r;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">sort</span>(range,range+n);</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(heap.<span class="built_in">empty</span>()||heap.<span class="built_in">top</span>()&gt;=range[i].l){<span class="comment">//第一个区间or当前区间左端点小于最小Max_r</span></span><br><span class="line">heap.<span class="built_in">push</span>(range[i].r);  <span class="comment">//新增一个</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">heap.<span class="built_in">pop</span>();  <span class="comment">//大于最小Max_r，就把堆顶那个最小Max_r弹出，更新为当前区间的r</span></span><br><span class="line">heap.<span class="built_in">push</span>(range[i].r);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;heap.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing907-区间覆盖"><a href="#AcWing907-区间覆盖" class="headerlink" title="AcWing907 区间覆盖"></a>AcWing907 区间覆盖</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p><strong>N个闭区间</strong>，一个线段区间[s,t] ，选择尽量<strong>少</strong>的区间，将指定<strong>线段区间完全覆盖</strong></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>将所有区间按<strong>左端点从小到大</strong>排序</li><li>从前往后依次枚举每个区间，<ul><li>在所有<strong>能覆盖s</strong>(左端点≤s的情况下)的区间中，选择一个<strong>右端点最大</strong>的区间</li><li>然后，将<strong>s更新</strong>为右端点的最大值</li><li><strong>直到</strong>右端点<strong>大于t</strong></li></ul></li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h1><h2 id="AcWing148-合并果子"><a href="#AcWing148-合并果子" class="headerlink" title="AcWing148 合并果子"></a>AcWing148 合并果子</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>N堆果子，每次<strong>任意合并两堆</strong>，每次合并消耗的体积等于这两堆重量之和，求合并完消耗的<strong>最小体力</strong></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>经典huffman模型，每次合并重量最小的两堆</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="comment">//定义小根堆：优先队列，对push进去的元素，会从小到大自动排序 </span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;heap;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> a;cin&gt;&gt;a;</span><br><span class="line">heap.<span class="built_in">push</span>(a);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(heap.<span class="built_in">size</span>()&gt;<span class="number">1</span>){</span><br><span class="line"><span class="comment">//每次取最小的两个合并 </span></span><br><span class="line"><span class="keyword">int</span> a=heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> b=heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line">ans+=(a+b);</span><br><span class="line"><span class="comment">//合并后再push到小根堆中 </span></span><br><span class="line">heap.<span class="built_in">push</span>(a+b);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h1><h2 id="AcWing913-排队打水"><a href="#AcWing913-排队打水" class="headerlink" title="AcWing913 排队打水"></a>AcWing913 排队打水</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p><strong>n个</strong>人排队打水，第i个人装满水的时间是ti，问如何排队使得所有人<strong>等待时间之和最小</strong></p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p><a href="https://imgtu.com/i/q6ydhj"><img src="https://s1.ax1x.com/2022/03/29/q6ydhj.png" alt="q6ydhj.png" style="zoom: 50%;"></a></p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[N];</span><br><span class="line">ll n,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">ans+=a[i]*(n-i<span class="number">-1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing104-货舱选址"><a href="#AcWing104-货舱选址" class="headerlink" title="AcWing104 货舱选址"></a>AcWing104 货舱选址</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p><a href="https://imgtu.com/i/q6hctK"><img src="https://s1.ax1x.com/2022/03/29/q6hctK.png" alt="q6hctK.png" style="zoom: 33%;"></a></p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h1><h2 id="AcWing104-货仓选址"><a href="#AcWing104-货仓选址" class="headerlink" title="AcWing104 货仓选址"></a>AcWing104 货仓选址</h2><h3 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h3><p>数轴上N个坐标，求一个坐标到每个坐标的距离之和最小，求距离最小值</p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>这个点在中间</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll n,ans;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">sort</span>(a,a+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++){</span><br><span class="line">ans+=<span class="built_in">abs</span>(a[n<span class="number">-1</span>-i]-a[i]);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h1 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h1><h2 id="AcWing1055-股票购买"><a href="#AcWing1055-股票购买" class="headerlink" title="AcWing1055 股票购买"></a>AcWing1055 股票购买</h2><h3 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h3><p>长度为 N数组，第 i个数字表示一个给定股票在第 i天的价格。</p><p>计算你所能获取的<strong>最大利润</strong>。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>低买高出就行</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;a[i+<span class="number">1</span>]){</span><br><span class="line">ans+=a[i+<span class="number">1</span>]-a[i];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;一些贪心的题：区间问题、Huffman树、排列不等式、其他类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>DIP-2-频率域滤波</title>
    <link href="http://example.com/2022/03/24/2022-03-06-DIP-2-%E5%82%85%E9%87%8C%E5%8F%B6/"/>
    <id>http://example.com/2022/03/24/2022-03-06-DIP-2-%E5%82%85%E9%87%8C%E5%8F%B6/</id>
    <published>2022-03-24T13:10:02.000Z</published>
    <updated>2022-03-25T08:29:20.564Z</updated>
    
    <content type="html"><![CDATA[<ul><li>关于一些 让我自己觉得<strong>我自己就是个智障</strong>QAQ的东西  瞎几把乱写的通俗理解</li></ul><span id="more"></span><ul><li>任何<strong>周期函数</strong>，都可以看作 不同振幅、不同相位<strong>正弦波的叠加</strong></li><li>滤波：从某条曲线中去除一些特定的频率成分</li><li><p>频率分量：不同频率的正弦波</p><ul><li>将角频率为ω0的正弦波cos（ω0）看作基础，那么频域的基本单元就是ω0</li></ul></li><li><p>cos(0t)也就是一条直线，可以理解成一个周期长的正弦波</p><ul><li>所以在频率域，0频率 称为 直流分量</li></ul></li><li>频域的基本单元也可以理解为<strong>一个始终在旋转的圆</strong></li><li>简单说就是如果从时间域分析信号时，时间是横坐标振幅是纵坐标。而在<strong>频率域</strong>分析的时候则是<strong>频率是横坐标</strong>，<strong>振幅是纵坐标</strong></li><li><p>频域图像，也就是俗称的<strong>频谱</strong></p></li><li><p>空间域就是你看到的一个个像素。频率域就是空间域经过傅立叶变换的信号</p></li><li>在 图像处理中，频域反应了图像在空域<strong>灰度变化剧烈程度</strong>，也就是图像<strong>灰度的变化速度</strong>，也就是图像的梯度大小。对图像而言，图像的边缘部分是突变部分，变化较 快，因此反应在频域上是高频分量；图像的噪声大部分情况下是高频部分；图像平缓变化部分则为低频分量。也就是说，傅立叶变换提供另外一个角度来观察图像， 可以将图像从灰度分布转化到频率分布上来观察图像的特征。书面一点说就是，傅里叶变换提供了一条从空域到频率自由转换的途径。</li></ul><hr><ul><li>二维傅里叶变换就是 <strong>将一个图像分解称若干个复平面波之和</strong></li></ul><p>二维连续傅里叶变换的公式：</p><script type="math/tex; mode=display">F（u,v)=\int_{-\infin}^{+\infin} \int_{-\infin}^{+\infin} f(x,y)e^{-j2\pi(ux+vy)}dxdy</script><p>将<strong>图像f</strong> 与<strong>每个不同频率的不同方向的复平面波</strong>做内积</p><p>给定一幅图像f, 能够算出<strong>每个平面波在图像中的成分是多少</strong></p><p>也就说，求这个图像 ，在<strong>基上的投影</strong></p><ul><li>傅里叶谱的<strong>每个位置存储的数</strong>代表了所在位置复平面波 在图像中的成分占多数，</li><li>每个位置存储的数* 该位置所代表的平面波求和得到原来的图像</li></ul><p>已知一幅图像f（x,y), 二维离散傅里叶变换公式，一对uv值对应了基底的一种形式，也就是对应了一个对应频率下的复平面波，那么F（u，v）的模就可以用来在这个频率下的复平面波对图像的影响，可以把它看作一个权重，表示该频率对图像的贡献程度，傅里叶谱</p><ul><li>傅里叶谱，中间部分代表低频，四周代表高频</li><li><p>不同的频率有不同的幅度，</p><ul><li>如果谱中 ，亮度越高 ，意味着频幅越大，亮度越按，意味着频幅越小</li><li>而这个频幅，又代表这对应的该频率对原图像的影响程度<ul><li>一幅图像分解成 若干个 不同频率的复平面波之和，这个之和 应该是带权相加，而那个频幅就相当于这个权</li></ul></li></ul></li><li><p>频谱图中的每一个点都与空域中的<strong>整幅图像相关</strong>，相当于每一个点都代表一个用于表示原图的波或者频率；这个点越亮，代表着用于表示原图的那个频率占比越重</p></li><li>频域是一个全局的概念。<strong>低频高频，都是对于整幅图片而言的</strong>。低频幅度大 是因为图片大部分区域都是缓慢变化的，而锐利的边缘则非常稀疏（即高频幅度小）</li><li>频谱上的点与空域上的点不是一一对应的。<strong>频谱上每一点都与空域所有点有关</strong>，反之，空域每一点都与频谱上所有点有关。这可以从傅里叶变换的公式直观看出来。</li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;关于一些 让我自己觉得&lt;strong&gt;我自己就是个智障&lt;/strong&gt;QAQ的东西  瞎几把乱写的通俗理解&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="数字图像处理Digital Image Processing" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86Digital-Image-Processing/"/>
    
  </entry>
  
  <entry>
    <title>【SE】软件设计模式</title>
    <link href="http://example.com/2022/03/22/2022-03-22-%E3%80%90SE%E3%80%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/03/22/2022-03-22-%E3%80%90SE%E3%80%91%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-03-22T14:45:34.000Z</published>
    <updated>2022-05-15T04:27:34.054Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>策略模式</li><li>装饰者模式、工厂模式、单件模式、命令模式</li><li>模板方法模式：封装算法</li><li>迭代器和组合模式：管理良好的集合</li><li>状态模式：事物的状态</li></ul></li><li><strong>参考学习资料</strong>：<strong>《HeadFirst 设计模式》</strong></li></ul><span id="more"></span><h1 id="设计原则总结"><a href="#设计原则总结" class="headerlink" title="设计原则总结"></a>设计原则总结</h1><h2 id="封装变化"><a href="#封装变化" class="headerlink" title="封装变化"></a>封装变化</h2><p>找出应用中<strong>可能需要变化之处</strong>，把它们<strong>独立</strong>出来，不要和那些不需要变化的代码混在一起</p><p>理解：</p><ul><li>变化的部分：每次有新的需求，会使<strong>某方面代码发生变化</strong></li><li>把这部分变化的<strong>抽取出来</strong></li><li>即：把会变化的部分取出并<strong>封装</strong>起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分</li><li>效果：代码变化引起的不经意的后果变少，系统变得更有<strong>弹性</strong></li></ul><h2 id="针对接口"><a href="#针对接口" class="headerlink" title="针对接口"></a>针对接口</h2><p><strong>针对接口编程</strong>，而不是针对实现编程</p><p>理解：</p><ul><li>实质就是，针对<strong>超类型编程</strong></li><li>明确地理解：变量的<strong>声明类型是超类型</strong>——抽象类或者接口</li></ul><p>区分</p><ul><li><p>针对实现编程</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog d = <span class="keyword">new</span> Dog(); <span class="comment">//Dog是抽象类Animal的具体实现</span></span><br><span class="line">d.bark();</span><br></pre></td></tr></tbody></table></figure></li><li><p>针对接口、超类型编程</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">animal.makeSound();  <span class="comment">//多态调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在运行时指定具体实现的对象:</span></span><br><span class="line">a = getAnimal();</span><br><span class="line">a.makeSound();</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="多用组合"><a href="#多用组合" class="headerlink" title="多用组合"></a>多用组合</h2><p><strong>多用组合、少用继承</strong></p><p>理解：</p><ul><li><p>比如在创建ModelDuck这个具体类时，在它的构造器里实例化了FlyBehavior和QuackBehavior这两个类（接口）；这就是使用了组合</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ModelDuck</span><span class="params">()</span> </span>{</span><br><span class="line">        flyBehavior = <span class="keyword">new</span> FlyNoWay();</span><br><span class="line">        quackBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//其他代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h2><blockquote><p>详细例子 见” 观察者模式 “  </p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>为了交互对象之间的松耦合设计而努力</p><hr><ul><li>松耦合的设计能够让我们建立有<strong>弹性</strong>的OO系统，能够应对变化，因为对象之间的<strong>互相依赖降到了最低</strong></li><li>当两个对象之间松耦合，它们依然<strong>可以交互</strong>，但是<strong>不太清楚</strong>彼此的细节；</li></ul><hr><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><ul><li>内容：<strong>类应该对扩展开放，对修改关闭</strong></li><li>允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为：<ul><li>这样设计具有弹性</li><li>可以应对改变</li><li>可以接受新的功能来应对改变的需求</li></ul></li></ul><hr><h2 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h2><h3 id="使用了好莱坞原则的模式："><a href="#使用了好莱坞原则的模式：" class="headerlink" title="使用了好莱坞原则的模式："></a><strong>使用了好莱坞原则的模式：</strong></h3><ul><li>工厂模式</li><li>观察者模式</li><li>模板方法模式</li></ul><hr><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>（高层组件对待低层组件的方式：）<strong>别调用我们，我们会调用你</strong></p><p>允许低层组件将自己挂钩到系统上，但<strong>高层</strong>组件会<strong>决定什么时候和怎样使用</strong>这些低层组件</p><p><img src="https://i.bmp.ovh/imgs/2022/04/09/1bc81e862f7a5d9d.png" style="zoom:50%;"></p><p>说明：低层组件<strong>并不是 不可以</strong>调用高层组件中的方法。</p><ul><li>事实上，在低层组件结束时，常常会调用从超类继承而来的方法</li><li>我们要做的是，<strong>避免</strong>高低层组件之间有<strong>明显的环状依赖</strong></li></ul><h3 id="好莱坞原则与依赖倒置原则的关系"><a href="#好莱坞原则与依赖倒置原则的关系" class="headerlink" title="好莱坞原则与依赖倒置原则的关系"></a>好莱坞原则与依赖倒置原则的关系</h3><ul><li>依赖倒置原则：避免使用具体类，<strong>多使用抽象</strong></li><li>好莱坞原则：用在<strong>创建框架or组件</strong>上的一种技巧，让<strong>低层组件能够被挂钩进计算</strong>中，而且不会让高层组件依赖低层组件<ul><li>创建一个弹性的设计，允许低层结构能够相互操作，而且又防止其他类太过依赖它们</li></ul></li><li><strong>二者都在解耦，依赖倒置原则更注重于避免依赖</strong></li></ul><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="依赖-use-a"><a href="#依赖-use-a" class="headerlink" title="依赖(use a)"></a>依赖(use a)</h2><p><img src="https://i.bmp.ovh/imgs/2022/05/11/94ce2459fc4a0dbe.png" style="zoom: 50%;"></p><p>A类只作为B类中方法的<strong>参数或返回值或局部变量或调用A的静态方法</strong></p><p>则A类与B类之间存在依赖关系</p>  <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B_Driver</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">(A_Car a)</span></span>{}<span class="comment">//作为方法的参数</span></span><br><span class="line">    <span class="function">A_Car <span class="title">method2</span><span class="params">()</span></span>{、</span><br><span class="line">        A_Car.method();<span class="comment">//调用静态方法</span></span><br><span class="line">        A_Car a = <span class="keyword">new</span> A_Car; <span class="comment">//作为局部变量</span></span><br><span class="line">        <span class="keyword">return</span> a; <span class="comment">//作为返回值</span></span><br><span class="line">    }</span><br><span class="line">}<span class="comment">//B依赖于A(B要用到A)</span></span><br></pre></td></tr></tbody></table></figure><p><strong>关联</strong><br><strong>A类作为B类的属性</strong>（成员变量），则A类与B类之间存在关联关系</p><h2 id="组合（整体-contains-a-部分）"><a href="#组合（整体-contains-a-部分）" class="headerlink" title="组合（整体 contains a 部分）"></a>组合（整体 contains a 部分）</h2><blockquote><p>整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期。这种关系比聚合更强，也称为强聚合。</p><p>如果<code>A</code><strong>contains a</strong> <code>B</code>，则<code>A</code>需要知道<code>B</code>的生存周期，即可能<code>A</code>负责生成或者释放<code>B</code>，或者<code>A</code>通过某种途径知道<code>B</code>的生成和释放。</p></blockquote><p><strong>组合关系也属于关联关系</strong>，A类作为B类的属性，并且在<strong>B类中包含了A类的实例化过程</strong>，则A类与B类之间存在组合关系。</p><ul><li><p>比如C类实例化B类时，B类会在构造方法中对A类进行实例化，A类与B类的产生和灭亡<strong>完全同步</strong>。组合关系下B类中的A属性不可能为null。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>{</span><br><span class="line">    <span class="keyword">new</span> B();</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">new</span> A;<span class="comment">//构造方法中对A类进行实例化</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="聚合（整体-has-a-部分"><a href="#聚合（整体-has-a-部分" class="headerlink" title="聚合（整体 has a 部分)"></a>聚合（整体 has a 部分)</h2><blockquote><p>此时整体与部分之间是可分离的，它们可以具有<strong>各自的生命周期</strong>，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。</p><p>例如，公司部门与员工的关系，一个员工可以属于多个部门，一个部门撤消了，员工可以转到其它部门。</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2022/05/11/95a2baf4660044c5.png" style="zoom:50%;"></p><p><strong>聚合关系属于关联关系</strong>，A类作为B类的属性，但<strong>A类的实例化不是在B类中实现</strong>的，则A类与B类之间存在聚合关系。</p><ul><li><p>比如在C类中实例化了A类，并将A类对象通过<strong>B类对象的set方法</strong>或B类的<strong>带参数构造器传入</strong>B中。聚合关系下B类中的A属性有可能为null。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>{</span><br><span class="line">    <span class="keyword">new</span> A();</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setXX</span><span class="params">(A)</span></span>{ XX=A};<span class="comment">//将A类对象通过B类对象的set方法传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A)</span></span>{} <span class="comment">//将A类对象通过B类的带参数构造器传入B中</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><p><img src="https://i.bmp.ovh/imgs/2022/04/11/b073f9f623e28513.png" style="zoom:50%;"></p><p>如上，<strong>使用继承</strong>来提供Duck的行为<strong>存在的缺点</strong>：</p><ul><li><strong>代码</strong>在多个子类中<strong>重复</strong><ul><li>有些子类的有些行为相同</li></ul></li><li>运行时的行为<strong>不容易改变</strong></li><li><strong>很难知道</strong>所有鸭子的全部行为<ul><li>每知道一个都要在父类中添加一个</li></ul></li><li>改变会<strong>牵一发动全身</strong>，造成不想要的改变<ul><li>比如，父类中添加一个fly，所有子类都继承fly，然而并不是所有鸭子都能fly</li></ul></li></ul><p>可见，因为<strong>鸭子的行为在子类中不断地 改变，让所有子类都拥有这些行为是不恰当的</strong></p><hr><p>那么，使用如下的接口呢？</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/ac498f3c0a5e6d15.png" style="zoom:67%;"></p><p>使用接口的话，子类的fly和quack中仍有很多重复代码，且<strong>代码无法复用</strong></p><hr><p>因为鸭子的<strong>行为是不断变化的</strong>，根据<strong>封装变化</strong>的原则，可以将鸭子的变化的行为从Duck类中<strong>抽取</strong>出来</p><ul><li>变化的行为：fly（）、quack（）；它们会<strong>随着鸭子的不同而改变</strong></li><li>把这两个行为抽取出来，<strong>建立两个新类各自代表这两个行为</strong></li></ul><p>同时，我们想要在运行时动态地改变某种鸭子的飞行行为，根据针对接口编程的原则：</p><ul><li><strong>每个接口代表每个行为</strong>，Duck类不负责实现接口，而是有<strong>行为类</strong>来实现接口</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/11/ff0a976277f80515.png" style="zoom:67%;"></p><p>这样设计，可以让这些动作被其他对象复用，因为上面<strong>这些东西实际上跟Duck类已经无关。</strong></p><p>也就是说，鸭子现在将fly和quack行为 <strong>委托给别人处理</strong>，而不是使用在Duck类或Duck的子类中的fly和quack</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><img src="https://s1.boluo.link/2022/04/11/4821dccd837d3a02f4caf03b72c999f7.png" style="zoom:67%;"></p><h2 id="策略模式定义"><a href="#策略模式定义" class="headerlink" title="策略模式定义"></a>策略模式定义</h2><p>策略模式定义了<strong>算法族、分别封装</strong>起来，让它们之间可以互相替换，此模式让算法的<strong>变化独立于</strong>算法的<strong>客户</strong></p><p>理解：</p><ul><li>定义了算法族：比如上面的实现FlyBehavior的一组行为类，这就是一个算法族，这个算法族里面的各种行为可以替换</li><li>FlyBehavior的变化和原来的Duck无关，被独立了出来</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/05/12/535f1ba33d843f5d.png" alt=""></p><ul><li><strong>Context类：</strong>它是使用算法的角色，它在解决某个问题（即实现某个方法）时可以<strong>采用多种策略</strong>。在Context类中维持一个<strong>对抽象策略类（Strategy）的引用实例</strong>，用于定义所采用的策略。</li><li><strong>Strategy（抽象策略类）：</strong>它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。Context类通过<strong>Strategy类中声明</strong>的方法 在<strong>运行时调用ConcreteStrategy类</strong>中实现的算法。</li><li><strong>ConcreteStrategy（具体策略类）：</strong>它实现了在抽象策略类中声明的算法，在运行时，具体策略类将<strong>覆盖</strong>在Context类中定义的抽象策略类对象，使用一<strong>种具体的算法实现</strong>某个业务处理。</li></ul><p>使用场景：</p><ul><li>有很多相关的类，具有不同的行为</li><li>算法有很多变种</li><li>算法使用的数据无需客户知晓</li><li>对很多行为有很多if-else语句</li></ul><p>好处</p><ul><li>提供一种替代继承的方法</li><li>去掉if-else语句</li><li>同种行为提供不同实现</li></ul><p>缺点</p><ul><li>客户应该知道所有策略</li><li>策略和Context之间的通信开销</li><li>太多策略的类</li></ul><hr><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="引例一"><a href="#引例一" class="headerlink" title="引例一"></a>引例一</h2><p>三种布告板：1.显示当前的状况、2.气象统计、3.简单预报</p><p>一个WeatherData能够<strong>追踪</strong>来自气象站的最新的<strong>数据</strong>，WeatherData会将<strong>三个布告板</strong>的显示<strong>更新</strong>。</p><p>具体流程：</p><ul><li>WeatherData有getter方法，取得来自气象站的测量值：温度、湿度、气压</li><li>一旦更新了新数据，一个measurementsChanged（）被调用<ul><li><strong>立即</strong>将三个布告板信息<strong>更新</strong></li></ul></li><li>该系统必须可货站，可以<strong>任意添加或删除</strong>任何布告板</li></ul><h2 id="引例二"><a href="#引例二" class="headerlink" title="引例二"></a>引例二</h2><p>报纸的订阅：</p><ul><li>报社出版报纸</li><li>客户向报社订阅报纸，只要报社有新报纸出版，就会送来。只要是订阅客户，就会一直收到报纸</li><li>不想看报纸，取消订阅，就不会收到报纸</li><li>只要报社孩子啊，就会有人向它订阅or取消订阅</li></ul><h2 id="出版者subject-订阅者subscriber-观察者模式"><a href="#出版者subject-订阅者subscriber-观察者模式" class="headerlink" title="出版者subject+订阅者subscriber=观察者模式"></a>出版者subject+订阅者subscriber=观察者模式</h2><h3 id="模式特点"><a href="#模式特点" class="headerlink" title="模式特点"></a>模式特点</h3><ul><li>subject管理某些数据<ul><li>subject数据改变，<strong>通知</strong>subscriber，新的数据会以某种形式送到subscriber</li></ul></li><li>subscriber（也就是observer） <strong>订阅</strong>subject，以便subject管理的数据改变时，subscriber能<strong>收到更新</strong><ul><li>如果没有订阅subject，就<strong>不是</strong>subscriber，当subject数据改变时就<strong>不会收到通知</strong></li></ul></li></ul><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>观察者模式定义了对象之间的<strong>一对多依赖</strong>，这样一来，当一<strong>个对象改变状态</strong>时，它的所有<strong>依赖者</strong>都会<strong>收到通知</strong>并且<strong>自动更新</strong>。</p><blockquote><p>一对多：这个一就是Subject，多就是Observer</p><p>实现观察者模式的方法不一种，但是以包含<strong>Subject和Observer接口</strong>的类的设计最常见</p></blockquote><p><img src="https://i.bmp.ovh/imgs/2022/04/16/a15dc0ac0d11cc06.png" style="zoom: 50%;"></p><ul><li>主题是<strong>具有状态</strong>（真正用于数据）的对象，并且可以控制这些状态</li><li>观察者<strong>使用</strong>这些状态，<strong>依赖主题</strong>告诉观察者状态何时改变</li></ul><h2 id="松耦合的体现"><a href="#松耦合的体现" class="headerlink" title="松耦合的体现"></a>松耦合的体现</h2><ul><li>ConcreteSubject只知道ConcreteObserver实现了Observer接口<ul><li>ConcreteSubject不需要直到ConcreteObserver的具体类是谁，做了啥等等</li></ul></li><li><p>可以随时增加或删除ConcreteObserver</p><ul><li>因为<strong>ConcreteSubjectt唯一依赖</strong>的是一个实现Observer接口的 <strong>对象列表</strong></li></ul></li><li><p>当增加新的ConcreteObserver时，ConcreteSubject无需修改；</p><ul><li>只要实现Obeserver接口，注册为ConcreteObserver即可</li><li><strong>改变其中任一方，并不会影响另一方</strong></li></ul></li><li>可以独立地复用ConcreteSubject和ConcreteObserver</li></ul><hr><h2 id="引例一的实现"><a href="#引例一的实现" class="headerlink" title="引例一的实现"></a>引例一的实现</h2><p><img src="https://i.bmp.ovh/imgs/2022/04/16/b9037905c9f224df.png" style="zoom:55%;"></p><ul><li><strong>每个ConcreteObserver都有一个ConcreteSubject的引用</strong>，这样之后想要取消注册的话就会很方便</li></ul><h2 id="Java内置的观察者模式"><a href="#Java内置的观察者模式" class="headerlink" title="Java内置的观察者模式"></a>Java内置的观察者模式</h2><p><img src="https://i.bmp.ovh/imgs/2022/04/16/0dbb9471c85354fd.png" style="zoom:67%;"></p><h2 id="观察者模式使用到的原则"><a href="#观察者模式使用到的原则" class="headerlink" title="观察者模式使用到的原则"></a>观察者模式使用到的原则</h2><ul><li>找出程序中<strong>变化</strong>的方面，然后将其和固定不变的方面向<strong>分离</strong><ul><li>会改变的时主题的状态，观察者的数目和类型</li><li>采用观察者模式可以改变依赖主题状态的对象的同时 不必改变主题</li></ul></li><li><strong>针对接口编程</strong>，不针对实现编程<ul><li>主题和观察者都使用接口</li><li>观察者利用主题 的接口向主题注册</li><li>主题利用 观察者接口 通知观察者</li><li>松耦合</li></ul></li><li><strong>多用组合</strong>，少用继承<ul><li>利用 组合，将许多观察者组合进主题中</li><li>对象之间 的依赖关系不是通过继承产生，而是运行时通过组合的方式产生</li></ul></li></ul><hr><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><ul><li>不用继承 如何达到复用？<ul><li><strong>组合和委托</strong> 可以在运行时具有继承行为的结果</li><li>利用继承设计子类的行为，是在编译时静态决定的，而且所有子类都会继承到相同的行为。</li><li>如果利用<strong>组合</strong> 扩展对象的行为，就可以在运行时动态扩展</li><li>通过<strong>动态地组合对象</strong>，可以写新的代码添加新功能 且 无需修改现有代码（符合开闭原则）</li></ul></li></ul><h2 id="认识装饰者模式"><a href="#认识装饰者模式" class="headerlink" title="认识装饰者模式"></a>认识装饰者模式</h2><ul><li>例如：以“饮料”为<strong>主体</strong>，在运行时以调料来“<strong>装饰</strong>”饮料</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/a0d7fddf8d6a7266.png" style="zoom: 67%;"><img src="https://i.bmp.ovh/imgs/2022/03/b5619a2a5ba71c61.png" alt=""></p><h2 id="一些要点"><a href="#一些要点" class="headerlink" title="一些要点"></a>一些要点</h2><ul><li>装饰者和被装饰者：<strong>相同的超类型</strong><ul><li>在任何需要<strong>原始对象</strong>（被包装）的场合，都可以用<strong>装饰过的对象</strong>代替它</li></ul></li><li><strong>一个 or 多个</strong>装饰者 包装一个对象</li><li>对象可以在<strong>任何时候</strong>被装饰<ul><li>运行时 <strong>动态地、不限量</strong>地装饰</li></ul></li><li><font color="red">装饰者可以在<strong>所委托</strong>的被装饰者的<strong>行为</strong>之前 与/或 之后，加上自己的<strong>行为</strong>，以达到特定目的</font><ul><li>这里的行为，或者说是<strong>责任</strong>，实际上指的就是…可以实现的一些<strong>功能</strong></li></ul></li></ul><h2 id="定义装饰者模式"><a href="#定义装饰者模式" class="headerlink" title="定义装饰者模式"></a>定义装饰者模式</h2><ul><li>定义：<font color="red">动态地将<strong>责任</strong> 附加到对象上。若要扩展功能，装饰者提供了比继承更有<strong>弹性</strong>的替代方案</font></li></ul><h2 id="装饰者模式的类图"><a href="#装饰者模式的类图" class="headerlink" title="装饰者模式的类图"></a>装饰者模式的类图</h2><p><img src="https://i.bmp.ovh/imgs/2022/03/54ca5a8ca57c2592.png" alt=""></p><ul><li><p>类图分析</p><ul><li><p><strong>Component</strong>：它的引入可以使客户端以<strong>一致的方式处理</strong>未被装饰以及装饰之后的对象，实现客户端的透明操作</p><blockquote><p>客户端不知道处理的未被装饰的对象，还是装饰过的对象</p></blockquote></li><li><p><strong>ConcreteComponent</strong>：定义具体的构件，实现了Component声明的方法，ConcreteDecorator可以给它增加额外的职责</p></li><li><p>Decorator：用于给ConcreteComponent增加职责，但是具体职责在子类中实现。</p><ul><li>它<strong>维护一个指向抽象构建对象的引用</strong></li><li>通过该引用可以调用装饰之前的构件对象的方法，并通过其扩展子类的方法，达到装饰的目的。</li></ul></li></ul></li><li><p><strong>重点说明</strong></p><ul><li>看似Decorator扩展子Component类，但是，重点在于：<font color="green">装饰者和被装饰者 必须类型一致</font>，也就是<font color="green">有共同的超类</font><ul><li>换言之，就是利用继承达到“<strong>类型匹配</strong>”，而<strong>不是利用继承获得“行为”</strong></li></ul></li><li>因为装饰者<strong>必须能取代</strong>被装饰者，所以它们必须有相同的“接口”</li><li>当装饰者与组件组合时，就是在加入新的行为，所得到的新的行为，<strong>并不继承子超类，而是由组合对象得来</strong><ul><li>行为如果不是来自超类，就是子类覆盖后的版本</li><li>可以在任何时候，实现新的装饰者增加新的行为</li></ul></li></ul></li></ul><h2 id="一个栗子实现"><a href="#一个栗子实现" class="headerlink" title="一个栗子实现"></a>一个栗子实现</h2><p><img src="https://i.bmp.ovh/imgs/2022/03/34829ab9f6f28015.png" style="zoom: 67%;"></p><h3 id="首先实现最上面的抽象类Beverage"><a href="#首先实现最上面的抽象类Beverage" class="headerlink" title="首先实现最上面的抽象类Beverage"></a>首先实现最上面的抽象类Beverage</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span></span>{</span><br><span class="line">    String discription = <span class="string">"Unknown Beverage"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDiscription</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> discription;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//cost必须在子类中实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="然后实现下面的抽象类Condiment"><a href="#然后实现下面的抽象类Condiment" class="headerlink" title="然后实现下面的抽象类Condiment"></a>然后实现下面的抽象类Condiment</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩展自Beverage，这样就能取代Beverage</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CondimentDecorator</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDiscription</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="写饮料的代码（具体组件（被装饰对象））"><a href="#写饮料的代码（具体组件（被装饰对象））" class="headerlink" title="写饮料的代码（具体组件（被装饰对象））"></a>写饮料的代码（具体组件（被装饰对象））</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span></span>{</span><br><span class="line">discription = <span class="string">"Espresso"</span>;</span><br><span class="line">    }<span class="comment">//实例变量discription继承自Beverage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.99</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="写调料代码（具体装饰者）"><a href="#写调料代码（具体装饰者）" class="headerlink" title="写调料代码（具体装饰者）"></a>写调料代码（具体装饰者）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mocha</span> <span class="keyword">extends</span> <span class="title">CondimentDecorator</span></span>{</span><br><span class="line">    <span class="comment">//要让Mocha引用一个Beverage</span></span><br><span class="line">    <span class="comment">//也就是之前所说的：每个装饰者都有一个组件（被装饰者），也就是说，装饰者有一个实例变量来保存某个Component的引用</span></span><br><span class="line">    Beverage beverage;</span><br><span class="line">    <span class="comment">//把饮料（被装饰者）当作构造器的参数，将其记录在实例变量中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mocha</span><span class="params">(Beverage beverage)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.beverage = beverage;<span class="comment">//运行时才知道</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//利用“委托”，得到被装饰者的Discription，再附加自己的“，Mocha”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDiscription</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> beverage.getDiscription() + <span class="string">",Mocha"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//利用“委托”，得到被装饰者的cost，再加上自己的cost</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.20</span>+beverage.cost();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>装饰者模式优缺点</strong><ul><li>优：比静态继承有更多的<strong>灵活</strong>性；在<strong>高层类中防止过多特征</strong></li><li>缺：太多<strong>小类</strong>（指的是 具体的装饰者类），导致复用变得复杂</li></ul></li><li><strong>装饰者模式使用时机</strong><ul><li>需要为一个对象<strong>动态的添加责任</strong>（功能），并且<strong>不影响其他</strong>对象</li><li>处理可撤销的责任（？啥意思）</li><li>当生成子类不可行的时候，比如需要大量子类来支持各种排列组合（<strong>类爆炸</strong>）</li></ul></li><li><strong>其他要点</strong><ul><li>继承是扩展的一种形式，但 并不是获得灵活性最好的方式</li><li><strong>组合 和 委托</strong> 可以用在动态时添加新行为</li><li>装饰者类 反映了它们所装饰对象的类型（装饰者类型 <strong>==</strong> 被装饰对象类型）</li><li>可以将一个组件<strong>用任意数量</strong>的装饰者包装</li></ul></li></ul><hr><h1 id="工厂模式——创建对象"><a href="#工厂模式——创建对象" class="headerlink" title="工厂模式——创建对象"></a>工厂模式——创建对象</h1><h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><blockquote><p>简单工厂 其实不是一个设计模式，而是一种<strong>编程习惯</strong></p></blockquote><ul><li>首先，看下面的代码，可以分析出<strong>变化 和不变</strong>的部分</li><li>变化的：<strong>new出来pizza的口味</strong> (type)：比如cheesePizza，pepperoniPizza，这些pizza可能根据实际情况而不断发生改变（增加or删除某些口味）</li><li>不变的：<strong>其他制作流程</strong>：<code>prepare,bake,cut...</code></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/e91c1e95a2bb31b1.png" style="zoom: 40%;"></p><ul><li>可见，创建pizza对象的部分是不断变化的，因此可以对 <strong>对象的创建 进行封装</strong><ul><li>将<strong>创建对象</strong>的代码从<code>orderPizza()</code>中<font color="red"><strong>抽离</strong></font>出来</li><li>把抽离出来的者部分代码<font color="red"><strong>搬到另一个新的对象</strong></font><code>SimplePizzaFactory</code>中，这个新对象<strong>只管</strong>如何创建pizza</li></ul></li><li>称这个新对象 为<font color="purple"><strong>“工厂”</strong></font></li></ul><h3 id="建立一个简单披萨工厂：用于创建pizza"><a href="#建立一个简单披萨工厂：用于创建pizza" class="headerlink" title="建立一个简单披萨工厂：用于创建pizza"></a>建立一个简单披萨工厂：用于创建pizza</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePizzaFactory</span></span>{</span><br><span class="line">    <span class="comment">//所有客户都用这个createPizza方法来实例化对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>{</span><br><span class="line">Pizza pizza = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//...中间则是从原来的orderPizza中抽离出来的代码</span></span><br><span class="line">        <span class="keyword">if</span>(type.equals=<span class="string">"cheese"</span>){</span><br><span class="line">pizza = <span class="keyword">new</span> CheesePizza();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>...</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">         <span class="keyword">return</span> pizza;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>这样做的<strong>好处</strong><ul><li><code>SimplePizzaFactory</code>可以<strong>有许多的客户</strong>，把<strong>创建pizza</strong>的代码封装到一个类里面，当以后实现改变时 (比如增加or删除某种口味的pizza)，<strong>只需要修改这一个类</strong>即可</li></ul></li></ul><h3 id="重做PizzaStore类"><a href="#重做PizzaStore类" class="headerlink" title="重做PizzaStore类"></a>重做PizzaStore类</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span></span>{</span><br><span class="line"><span class="comment">//对factory的引用</span></span><br><span class="line">    SimplePizzaFactory factory;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PizzaStore</span><span class="params">(SimplePizzaFactory factory)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.factory = factory;</span><br><span class="line">    }</span><br><span class="line">   <span class="comment">//orderPizza就成了SimplePizzaFactory的客户</span></span><br><span class="line">   <span class="comment">//意思就是 当客户orderPizza需要pizza时，就让factory做一个给它 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span>{</span><br><span class="line">        <span class="comment">//这里将原来的new出各种口味的pizza 替换成 工厂对象的创建方法 ，不再使用new具体实例化</span></span><br><span class="line">        <span class="comment">//使得orderPizza不再依赖于具体类型</span></span><br><span class="line">pizza = factory.createPizza(type);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//....后面是其他方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/73fcade61a39dfdb.png" style="zoom: 50%;"></p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote><p>内容太长不看总结版：</p><p>工厂方法模式 实际上就是，在 抽象超类 中<strong>写一个抽象</strong>（没有具体实现，只是个接口）的方法（工厂方法），它是用来<strong>创建对象</strong>的，这个超类中的<strong>其他方法</strong>会<strong>用到</strong>这个抽象方法<strong>创建的对象</strong>，但是其他方法用的时候并<strong>不关心</strong>这个对象究竟是什么类型的。</p><p>然后，继承这个超类的子类必须去<strong>实现这个抽象方法</strong>，来创建<strong>具体的对象</strong>（确定这个对象是啥类型的）</p><p>看懂 PizzaStore的框架和类图就懂辽</p></blockquote><ul><li><p>变化的是地区（风味）：比如虽说都是cheese披萨，但在不同的地区的风味不一样，有NY的cheese披萨，有Chicago的cheese披萨等等</p><blockquote><p>回顾：对比简单工厂模式，变化的是各种口味，比如cheese披萨，pepperoni披萨等等…</p></blockquote></li><li><p>我们希望：让pizza的制作活动局限于PizzaStore类（说人话：各地区加盟店pizza的制作<strong>流程固定</strong>不变），同时加盟店可以<strong>自由制作该区域的风味</strong></p></li></ul><h3 id="给PizzaStore（抽象类）使用的框架"><a href="#给PizzaStore（抽象类）使用的框架" class="headerlink" title="给PizzaStore（抽象类）使用的框架"></a>给PizzaStore（抽象类）使用的框架</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PizzaStore</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">orderPizza</span><span class="params">(String type)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        <span class="comment">//createPizza 从工厂对象中重新移回到PizzaStore里面</span></span><br><span class="line">        pizza = createPizza(type);</span><br><span class="line">        <span class="comment">/**************************************************/</span></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="comment">/*中间是制作流程，固定不变，希望所有加盟店的处理流程都一致*/</span></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//下面这就是咱们所谓的 "工厂方法"，抽象的，</span></span><br><span class="line">    <span class="comment">//因为我们希望加盟店能够自由制作风味，</span></span><br><span class="line">    <span class="comment">//所以方法具体的实现肯定在各地区的加盟店（就是PizzaStore的子类）来实现createPizza方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Pizza <span class="title">createPizza</span><span class="params">(String type)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>因此，将PizzaStore作为超类，每个地域的类型（NYPizzaStore、ChicagoPizzaStore…）<strong>继承</strong>PizzaStore，<strong>这样制作流程得以固定</strong>，而每个子类可以通过实现<code>createPizza</code>接口来<strong>自由决定如何制作比萨</strong></li></ul><h3 id="允许子类做决定"><a href="#允许子类做决定" class="headerlink" title="允许子类做决定"></a>允许子类做决定</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/ab9127afbb9517d2.png" style="zoom: 50%;"></p><p>超类的<code>orderPizza</code>方法<strong>并不知道</strong>正在创建的pizza是哪一种（因为人家的createPizza只是个接口）</p><p>所以在各地域的PizzaStore中分别<strong>实现</strong>各自这个createPizza接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在NYStylePizzaStore</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYStylePizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span></span>{</span><br><span class="line">    <span class="comment">//这个NYStylePizzaStore子类 全权负责实例化哪一个具体Pizza</span></span><br><span class="line">    <span class="comment">//扩展自PizzaStore，必须实现createPizza这个抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(type)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"cheese"</span>)){</span><br><span class="line">            pizza = <span class="keyword">new</span> NYStyleCheesePizza();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>.... </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//在ChicagoStylePizzaStore</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChicagoStylePizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pizza <span class="title">createPizza</span><span class="params">(type)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"cheese"</span>)){</span><br><span class="line">            pizza = <span class="keyword">new</span> ChicagoStyleCheesePizza();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>....</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p><code>orderPizza</code> 调用<code>createPizza</code>时，是由某个具体的<strong>披萨店子类</strong>（比如NYStyleStore..）创建披萨</p><ul><li><p><strong>子类并不是实时</strong>做出这样的决定的，但从<code>orderPizza</code>的角度来看，只要选择在<code>NYStylePizzaStore</code>订购披萨，<strong>那么就是<code>NYStylePizzaStore</code> 这个子类决定</strong></p><blockquote><p>严格来讲：并非由这个子类实际“做决定”，而是由顾客决定到哪一家的披萨店才决定了披萨的风味（听起来 嗯，听君一席话如听一席话般的废话….)</p></blockquote></li></ul></li></ul><h3 id="声明一个工厂方法"><a href="#声明一个工厂方法" class="headerlink" title="声明一个工厂方法"></a>声明一个工厂方法</h3><font color="red">工厂方法 用来**处理对象的创建**，并将这样的行为封装在子类中，这样，（好处：）客户程序中关于超类的代码 就和 子类对象创建的代码 解耦了</font><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> Product <span class="title">factoryMethod</span><span class="params">(String type)</span></span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>工厂方法 必须返回一个产品（比如pizza），而 超类中的其他方法 通常会使用到这个工厂方法的 返回值 （比如超类PizzaStore里的orderPizza中使用了返回的pizza）</li><li>工厂方法本质是一个<strong>抽象的方法</strong></li><li>理解上面红色的那段话：<ul><li>处理对象的创建：这个<strong>工厂方法就是用于创建一个对象</strong>的</li><li>并将这样的行为封装在子类中：因为工厂方法是抽象的，必须由<strong>子类来具体实现该方法</strong>，</li><li>客户程序中关于超类的代码：就是<strong>超类</strong>中的代码，比如<code>PizzaStore</code>中的<code>orderPizza</code></li><li>子类对象创建的代码：也就是实际了创建<strong>具体产品</strong>的代码，比如子类<code>NYStylePizzaStore</code>里面的<code>createPizza</code>创建产品</li><li>”解耦“ 的理解：在PizzaStore中，<code>orderPizza</code>对Pizza做了很多事(bake,cut等等)，但是Pizza是抽象的，<code>orderPizza</code><strong>并不知道实际哪些具体的类</strong>参与了进来，也就是 我们实现了<strong>面向抽象编程 而不是面向具体编程</strong></li></ul></li></ul><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><ul><li>关键把下面这张图的思路看懂</li></ul><h3 id="Pizza本身（抽象类）"><a href="#Pizza本身（抽象类）" class="headerlink" title="Pizza本身（抽象类）"></a>Pizza本身（抽象类）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span></span>{</span><br><span class="line">    String name;</span><br><span class="line">    String dough;</span><br><span class="line">        ....</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>{.....}</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bake</span><span class="params">()</span></span>{....}</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>{....}</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">box</span><span class="params">()</span></span>{.....}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体的Pizza子类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYStyleCheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NYStyleCheesePizza</span><span class="params">()</span></span>{</span><br><span class="line">name=<span class="string">"xx"</span>;dough=<span class="string">"xx"</span>;....</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">()</span></span>{<span class="comment">/*可以覆盖抽象类的方法*/</span>}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="这个栗子的类图"><a href="#这个栗子的类图" class="headerlink" title="这个栗子的类图"></a>这个栗子的类图</h3><ul><li>所有工厂模式 都是用来<strong>封装对象的创建</strong>，<strong>工厂方法模式</strong><font color="red">通过让<strong>子类决定该创建的对象</strong>是什么，来达到<strong>对象创建的过程封装</strong>的目的</font></li></ul><p><a href="https://imgtu.com/i/q3SWxP"><img src="https://s1.ax1x.com/2022/03/23/q3SWxP.png" alt="q3SWxP.png" style="zoom:50%;"></a></p><ul><li>从<strong>平行的类层级</strong>角度来看</li></ul><p><a href="https://imgtu.com/i/q3puIH"><img src="https://s1.ax1x.com/2022/03/23/q3puIH.png" alt="q3puIH.png" style="zoom:50%;"></a></p><h3 id="重点-定义工厂方法模式-类图（Factory-Method-Pattern）"><a href="#重点-定义工厂方法模式-类图（Factory-Method-Pattern）" class="headerlink" title="* 重点 * 定义工厂方法模式+类图（Factory Method Pattern）"></a>* 重点 * 定义工厂方法模式+类图（Factory Method Pattern）</h3><ul><li><p><strong>工厂方法模式</strong>：定义了一个<strong>创建对象</strong>的接口，但由<strong>子类决定要实例化的类</strong>是哪一个。工厂方法让类把<strong>实例化推迟到子类</strong></p><blockquote><p>理解：比如之前的栗子中，PizzaStore（超类）定义了一个<strong>抽象的接口</strong><code>createPizza</code>，它只是一个接口！！！我们只知道这个接口的目的是  告诉大家创建一个Pizza，但并没有实现！！！！</p><p>而Pizza具体怎么创建（即：new出来的Pizza究竟是啥类型的Pizza）就需要继承PizzaStore的<strong>子类</strong>来<strong>实现</strong>这个接口。</p><p>即：<code>NYStylePizzaStore</code>类中的<code>createPizza()</code>方法里面的 比如这句代码 <code>pizza = new NYStyleCheesePizza();</code> 才将Pizza给实例化成一个具体的<code>NYStyleCheesePizza</code></p></blockquote></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/281e12be43dbaa9e.png" style="zoom: 67%;"></p><ul><li><p>所谓<strong>“决定”</strong>，指的是 在编写创建者类（Creator）时，<strong>不需要知道实际创建的产品具体是啥</strong>。</p><blockquote><p>比如之前PizzaStore里面调用pizza.cut()，pizza.bake()等等，我们不需要知道这个pizza究竟哪种口味的pizza</p></blockquote></li><li><p>选择了<strong>使用哪个子类</strong>，自然就决定了实际创建的产品是什么</p><blockquote><p>因为我们的子类 把 工厂方法createPizza给具体实现了</p></blockquote></li><li><p>当只有一个ConcreteCreator时：工厂方法模式 能够将产品的<strong>“实现”</strong> 从<strong>“使用”</strong>中解耦，增加or改变产品的实现 Creator也不会受影响</p><blockquote><p>这里的“实现”，也就是 产品的创建</p></blockquote></li><li><p>工厂方法 和创建者 <strong>并不总是抽象</strong></p><ul><li>可以定义一个 默认的工厂方法 来生产某些具体的产品，这样即使创建者没有任何子类，依然可以创建产品（这是书上说的，？我暂时无法理解）</li></ul></li><li><p><font color="red">简单工厂和工厂方法的差异</font>：</p><ul><li>简单工厂 <strong>把全部的事情</strong>（比如创建不同口味的pizza）在<strong>一个地方</strong>处理完了（这个地方就是之前的SimplePizzaFactory）<ul><li>简单工厂可以将对象的创建 封装起来，但不具备工厂方法的弹性：简单工厂不能变更在创建的产品</li></ul></li><li>工厂方法，就是<strong>创建一个框架</strong>（抽象的方法），让子类决定如何实现（实现这个抽象方法）<ul><li>比如：超类PizzaStore里面的orderPizza提供了一般的框架；orderPizza以工厂方法createPizza来创建具体类，制造出实际的pizza</li></ul></li></ul></li><li><p>”工厂“ 的<strong>好处</strong></p><ul><li>避免代码重复，方便维护</li><li>客户在实例化对象时，<strong>只依赖接口</strong>，而不是具体类</li><li>代码更有<strong>弹性</strong>，应对未来的扩展</li></ul></li></ul><h3 id="对象依赖（依赖倒置原则）"><a href="#对象依赖（依赖倒置原则）" class="headerlink" title="对象依赖（依赖倒置原则）"></a>对象依赖（依赖倒置原则）</h3><ul><li><p>看下图代码，<code>DependentPizzaStore</code>这个<strong>类</strong>里面的<strong>一些方法的实现</strong> 需要<strong>用到</strong> 很多<strong>其他具体的类</strong>，即所说它 <strong>依赖</strong> 于其他具体的类</p><blockquote><p>比如 要实现createPizza，就需要使用各种具体的Pizza类，比如NYStyleCheesePizza等等；</p><p>所以坏就坏在，只要它DependentPizzaStore所依赖的这些具体的类有啥改动，就必须把DependentPizzaStore这个的代码翻出来进行改动</p></blockquote></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/b9c50c1050280077.png" style="zoom:50%;"></p><font color="red">**依赖倒置原则**：要依赖**抽象**，不要依赖具体类</font><ul><li><p>不能让高层组件依赖 低层组件，而且不管高低层，都应该<strong>依赖于抽象</strong></p><blockquote><p>高层组件：由<strong>其他低层组件</strong>定义其行为的类。比如PizzaStore是高层组件，它的行为是由Pizza定义的，（PizzaStore创建所有不同的Pizza对象）而Pizza本身是低层组件</p></blockquote></li></ul><p>一个PizzaStore可以制作不同类型的Pizza，这些不同类型的Pizza都是Pizza，所以可以让它们<strong>共享同一个Pizza接口</strong>，那么我们 就抽象出了一个Pizza类，而对于PizzaStore来讲，它只要制作出Pizza就行了，不用理会具体的Pizza类</p><p><img src="https://i.bmp.ovh/imgs/2022/03/6cd322f7cd1a5208.png" style="zoom:67%;"></p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><blockquote><p>首先，抛开前面的东西，现在的栗子虽然和上面都是采用Pizza，但是跟上面的那些东西毫无关系，不要把这个栗子和之前的栗子关联起来</p></blockquote><ul><li>每个不同的地区有不同的加盟店，每个加盟店都要制作Pizza，但是对于某一种比如cheese Pizza，虽然都是cheese Pizza，但是在不同加盟店<strong>所使用的原料的具体种类并不完全相同</strong>。</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/890301e4a420a3f1.png" style="zoom: 67%;"></p><h3 id="首先，建造出抽象出来的原料工厂"><a href="#首先，建造出抽象出来的原料工厂" class="headerlink" title="首先，建造出抽象出来的原料工厂"></a>首先，建造出抽象出来的原料工厂</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PizzaIngredientFactory</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cheese <span class="title">createCheese</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Clams <span class="title">createClam</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">}<span class="comment">//原料工厂都需要生产Dough、Sauce等等，但具体生产的啥Dough，啥Sauce 就用子类来实现</span></span><br></pre></td></tr></tbody></table></figure><ul><li>这个抽象的原料工厂（<strong>接口</strong>） 其实就相当于提供了一个大致的框架，每个区域的工厂（<strong>实现接口的类</strong>）把这个框架给具体实现</li><li>所以，接下来</li><li>为每个区域<strong>创建一个具体</strong>的工厂，<strong>继承</strong>自这个<code>PizzaIngredientFactory</code>，具体<strong>实现每一个</strong>create方法</li></ul><h3 id="创建纽约原料工厂"><a href="#创建纽约原料工厂" class="headerlink" title="创建纽约原料工厂"></a>创建纽约原料工厂</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaIngredientFactory</span> <span class="keyword">implements</span> <span class="title">PizzaIngredientFactory</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dough <span class="title">createDough</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThinCrustDough(); <span class="comment">//这个具体的原料工厂生产的Dough就是ThinCrustDough</span></span><br><span class="line">        <span class="comment">//要有一组原料类供工厂使用，这些类可以在合适的区域共享，</span></span><br><span class="line">        <span class="comment">//比如在NY可以使用ThinCrustDough，在Chicago也可以使用ThinCrustDough</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sauce <span class="title">createSauce</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MarinaraSauce();</span><br><span class="line">    }</span><br><span class="line">    ...<span class="comment">//同理，下面是其他的实现的接口方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="重做Pizza"><a href="#重做Pizza" class="headerlink" title="重做Pizza"></a>重做Pizza</h3><h4 id="抽象的Pizza"><a href="#抽象的Pizza" class="headerlink" title="抽象的Pizza"></a>抽象的Pizza</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span></span>{</span><br><span class="line">    <span class="comment">//每个pizza都持有一组在prepare时会用到的原料</span></span><br><span class="line">    Dough dough;</span><br><span class="line">    Sauce sauce;....</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="具体的Pizza"><a href="#具体的Pizza" class="headerlink" title="具体的Pizza"></a>具体的Pizza</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheesePizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span></span>{</span><br><span class="line">    PizzaIngredientFactory ingredientFactory;</span><br><span class="line">    <span class="comment">//要制作Pizza，必须要一个工厂来提供原料，所以每个Pizza都要获得一个工厂</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CheesePizza</span><span class="params">(PizzaIngredientFactory ingredientFactory)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//prepare一步步制作Pizza，每当使用原料，就从工厂要</span></span><br><span class="line">        dough = ingredientFactory.createDough();</span><br><span class="line">        sauce = ingredientFactory,createSauce();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Pizza店"><a href="#Pizza店" class="headerlink" title="Pizza店"></a>Pizza店</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NewYork的Pizza店</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NYPizzaStore</span> <span class="keyword">extends</span> <span class="title">PizzaStore</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Pizza <span class="title">createPizza</span><span class="params">(String item)</span></span>{</span><br><span class="line">        Pizza pizza = <span class="keyword">null</span>; </span><br><span class="line">        <span class="comment">//这家店由NewYork的原料工厂负责生产所有原料</span></span><br><span class="line">        PizzaIngredientFactory = <span class="keyword">new</span> NYPizzaIngredientFactory();</span><br><span class="line">        <span class="keyword">if</span>(items.equals(<span class="string">"cheese"</span>)){</span><br><span class="line">            <span class="comment">//将工厂传递给每个Pizza，Pizza从工厂中获取原料</span></span><br><span class="line">            pizza = <span class="keyword">new</span> CheesePizza(ingredientFactory);</span><br><span class="line">            <span class="comment">//....</span></span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> ...</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://i.bmp.ovh/imgs/2022/03/ed29a07c1bd29a7d.png" style="zoom: 67%;"></p><h3 id="总体实现"><a href="#总体实现" class="headerlink" title="总体实现"></a>总体实现</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PizzaStore nyPizzaStore = <span class="keyword">new</span> NYPizzaStore();<span class="comment">//要有一个NY的pizza店</span></span><br><span class="line">nyPizzaStore.orderPizza(<span class="string">"cheese"</span>);<span class="comment">//在店里店一个cheese Pizza</span></span><br><span class="line">Pizza pizza = createPizza(<span class="string">"cheese"</span>);<span class="comment">//orderPizza调用createPizza</span></span><br><span class="line"><span class="comment">//传入的参数是cheese，所有要生产一个cheesePizza，需要具体的原料工厂</span></span><br><span class="line">Pizza pizza = <span class="keyword">new</span> CheesePizza(nyIngredientFactory);</span><br><span class="line"><span class="comment">//pizza获得工厂后，pizza.prepare()就开始准备原料</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>{</span><br><span class="line">dough = factory.createDough();</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        }</span><br><span class="line"><span class="comment">//之后 pizza.bake(),cut()....</span></span><br></pre></td></tr></tbody></table></figure><h3 id="※-定义抽象工厂模式-类图"><a href="#※-定义抽象工厂模式-类图" class="headerlink" title="※ 定义抽象工厂模式+类图"></a>※ 定义抽象工厂模式+类图</h3><font color="red">抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类</font><p><img src="https://i.bmp.ovh/imgs/2022/03/2cde0ebb92239b6e.png" style="zoom:67%;"></p><p><img src="https://i.bmp.ovh/imgs/2022/03/40a969dfb82c50dc.png" style="zoom:67%;"></p><ul><li><p><strong>抽象工厂</strong>的方法 经常以<strong>工厂方法</strong>的形式实现</p><blockquote><p>理解：PizzaIngredientFactory里的所有create方法都是抽象的，没有具体实现，而是每个继承它的子类覆盖实现这些方法</p></blockquote></li></ul><h2 id="三种工厂模式的比较"><a href="#三种工厂模式的比较" class="headerlink" title="三种工厂模式的比较"></a>三种工厂模式的比较</h2><h3 id="三种类图对比总结"><a href="#三种类图对比总结" class="headerlink" title="三种类图对比总结"></a>三种类图对比总结</h3><ul><li>简单工厂：<strong>用来生产 同一等级结构中的任意产品（对于新加的产品，无能为力）</strong></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/355f4b3aa8a92aac.png" style="zoom:50%;"></p><ul><li><p>工厂方法：<strong>用来生产同一等级结构的固定产品（支持增加任意产品）</strong></p><p><img src="https://i.bmp.ovh/imgs/2022/03/3eb03ec2dbe04f8c.png" style="zoom:50%;"></p></li><li><p>抽象工厂：<strong>用来生产不同产品族的全部产品</strong>（对于新增加的产品，无能为力，支持增加产品族）</p></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/fac2ed68e7d0b475.png" style="zoom:50%;"></p><h3 id="抽象工厂-VS-工厂方法"><a href="#抽象工厂-VS-工厂方法" class="headerlink" title="抽象工厂 VS 工厂方法"></a>抽象工厂 VS 工厂方法</h3><ul><li><p>共同点：都是用来 <strong>创建对象</strong>的，把客户从所使用的具体实际产品中解耦</p></li><li><p>不同点</p><ul><li><p>工厂方法使用<strong>继承</strong></p><blockquote><p>利用工厂方法创建对象，需要扩展（继承）一个类，并覆盖它的工厂方法；</p></blockquote></li><li><p>抽象工厂：使用<strong>对象组合</strong>；使用时机：<strong>创建产品家族&amp;让制造的相关产品结合起来</strong></p><blockquote><p>它可以把<strong>一群相关的产品集合</strong>起来：</p><p>抽象工厂 提供一个用来创建<strong>一个产品家族</strong>的抽象类型，它的子类定义了具体产品实现</p></blockquote></li></ul></li></ul><hr><h1 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h1><ul><li><p>用来创建独一无二的，<strong>只能有一个实例</strong>的对象</p><blockquote><p>因为，<strong>有些对象我们只需要一个</strong>，如果制造多个会导致许多问题</p><p>可以确保程序中使用的全局资源只有一份，对资源敏感的对象特别重要</p></blockquote></li><li><p>单件模式可以确保<strong>只有一个示例</strong>被创建，并且可以在<strong>需要时</strong>才创建</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line"><span class="comment">// 利用静态变量 来记录这个 唯一的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">// 声明为私有：只有Singleton类内才可以调用它</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{};</span><br><span class="line">    <span class="comment">// 利用静态方法来实例化这个唯一的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>){</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>调用<code>Singleton</code>里面的静态方法：<code>Singleton.getInstance()</code></p><blockquote><p>getInstance()：静态方法，也就是类方法；对静态方法的调用要使用类名 </p></blockquote></li><li><p><strong>延迟实例化</strong>：如果不需要这个实例，它就永远不会产生</p></li><li><p>要想取得<code>Singleton</code>的一个实例，我们必须”请求“得到这么一个实例，而不是自行new 一个<code>Singleton</code>出来，（反正也new不出来，因为构造器是private）。所以我们可以，调用静态方法<code>getInstance</code>来请求得到 这个类的实例，这相当于一个<strong>全局访问点</strong></p><ul><li>从上面的代码易知：这个实例可能是在这次调用的时候被创建出来的，也可能是之前已经创建出来的。反正它只有一个</li></ul></li></ul><h2 id="一个栗子-1"><a href="#一个栗子-1" class="headerlink" title="一个栗子"></a>一个栗子</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChocolateBoiler</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChocolateBoiler uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> empty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> boiled;</span><br><span class="line">    <span class="keyword">private</span> ChocolateBoiler{</span><br><span class="line">         empty = <span class="keyword">true</span>;</span><br><span class="line">         boiled = <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChocolateBoiler <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>){</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> ChocolateBoiler();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 其他方法(){...}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定义单件模式"><a href="#定义单件模式" class="headerlink" title="定义单件模式"></a>定义单件模式</h2><font color="red">单件模式：确保一个类中只有一个实例，并提供一个全局访问点</font><p><img src="https://i.bmp.ovh/imgs/2022/03/a1995c3b195e07d2.png" style="zoom:50%;"></p><p>但是上面这种经典的单件模式在多线程的情况下会出现问题</p><p><img src="https://i.imgtg.com/2022/03/25/bDb6c.png" alt="bDb6c.png"></p><p>对于多线程的处理：把<code>getInstance()</code>变成<strong>同步方法</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{...}</span><br></pre></td></tr></tbody></table></figure><ul><li>这样，可以迫使每个线程进入该方法之前，需要等待别的线程离开该方法，保证不会有两个线程同时进入该方法</li><li>但是，只有在new uniqueInstance的时候才需要同步，所以这会拖垮性能</li></ul><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="getInstance的性能不是很关键，就不用解决"><a href="#getInstance的性能不是很关键，就不用解决" class="headerlink" title="getInstance的性能不是很关键，就不用解决"></a>getInstance的性能不是很关键，就不用解决</h4><ul><li>但如果<code>getInstance</code>使用在程序频繁运行的地方，就必须解决，否则运行效率会大幅下降</li></ul><h4 id="“急切”创建实例，而不用延迟实例化的做法"><a href="#“急切”创建实例，而不用延迟实例化的做法" class="headerlink" title="“急切”创建实例，而不用延迟实例化的做法"></a>“急切”创建实例，而不用延迟实例化的做法</h4><ul><li><p>如果总是创建并使用单件实例or在创建和运行时负担不繁重，可以急切创建此单件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line">    <span class="comment">//JVM在加载这个类的时候马上创建唯一的单件实例（静态初始化实例）</span></span><br><span class="line">    <span class="comment">//保证在任何线程访问uniqueInstance之前，一定先创建了它</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{};</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="双重检查加锁"><a href="#双重检查加锁" class="headerlink" title="双重检查加锁"></a>双重检查加锁</h4><ul><li><strong>首先检查</strong>实例是否已经创建，若<strong>未创建，才进行同步</strong>–&gt;保证只有第一次同步</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">// 检查实例，如果未创建，就进行同步</span></span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>){</span><br><span class="line"><span class="keyword">synchronized</span>(Singleton.class){ <span class="comment">//再检查一次</span></span><br><span class="line"><span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>){</span><br><span class="line">uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="命令模式——封装调用"><a href="#命令模式——封装调用" class="headerlink" title="命令模式——封装调用"></a>命令模式——封装调用</h1><blockquote><p>刚学这个模式的时候狠狠地难受到了，一开始始终理不清书上餐厅点餐和遥控器这个两个栗子的相通点，看了两遍书才看明白，啊啊啊啊，本 一学就废 的fw真的好羡慕世界上那些理解能力超强 一学就会 的人呐QAQ </p></blockquote><h2 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h2><ul><li><p>遥控器栗子：</p><p><img src="https://i.bmp.ovh/imgs/2022/03/fa998e3329087c97.png" style="zoom: 50%;"></p></li></ul><ul><li><p>请求者：<strong>遥控器</strong>；执行者：<strong>某个家电</strong></p></li><li><p>命令对象：封装的东西–&gt;  家电的具体的执行工作+家电</p><blockquote><p>比如，遥控器想要打开电灯，那么就把“电灯+电灯的打开动作“，<strong>封装</strong>成一个请求对象，也就是我们所说的“<strong>命令对象</strong>”；</p><p>换种理解方式就是：一个<strong>命令对象</strong> 封装了 命令的执行者（也就是<strong>“谁执行”</strong>）+执行者的执行动作（也就是<strong>“具体怎样执行”</strong>）</p><p>遥控器的<strong>每个按钮插槽都存储一个命令对象</strong>，只要按下，命令对象就执行封装在它里面的工作</p></blockquote></li><li><p>用一个餐厅的栗子来对比</p></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/7ef5a0a9067296db.png" style="zoom:50%;"></p><ul><li>命令模式 可以将<strong>“动作的请求者” 从“动作的执行者”</strong> 对象中解耦</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/b60131071f364eb0.png" style="zoom: 67%;"></p><h2 id="第一个命令对象"><a href="#第一个命令对象" class="headerlink" title="第一个命令对象"></a>第一个命令对象</h2><ul><li>为<strong>所有命令声明一个接口</strong>，只要命令execute，就可以让命令的接收者执行动作</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>首先实现一个打开电灯的<strong>命令</strong> (这个<code>LightOnCommand</code>命令就是一个<strong>命令对象</strong>)<ul><li>它封装了<strong>执行者<code>light</code>+具体动作<code>light.on()</code></strong>)</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    Light light;</span><br><span class="line">    <span class="comment">//传入执行“开灯”命令的执行者light </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//一旦调用，就由这个light接受命令，执行动作</span></span><br><span class="line">    <span class="comment">//execute封装了 执行命令的 执行者 所要执行的所有动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{</span><br><span class="line">        light.on();        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>使用</strong>命令对象（先假设遥控器上只有一个插槽</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRemoteControl</span></span>{</span><br><span class="line">    Command slot；<span class="comment">//一个插槽持有一个命令对象 用来控制一个设备</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRemoteControl</span><span class="params">()</span></span>{}</span><br><span class="line">    <span class="comment">//设置该插槽 持有的命令是什么；</span></span><br><span class="line">    <span class="comment">//比如传入ligthOn，就让这个插槽持有“开灯”这个命令，那么我按这个按钮，就是开灯，</span></span><br><span class="line">    <span class="comment">//如果传入lightOff，那么这个插槽就持有“关灯”这个命令，我按这个按钮，就变成了关灯；</span></span><br><span class="line">    <span class="comment">//所以可以传入不同的命令，实现按下当前按钮，执行不同的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span></span>{</span><br><span class="line">        slot = command;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//一旦按下按钮（发出请求），插槽持有的命令就可以执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buttonWasPressed</span><span class="params">()</span></span>{</span><br><span class="line">        slot.execute();</span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个测试 就是命令模式的客户</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControlTest</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        SimpleRemoteControl remote = <span class="keyword">new</span> SimpleRemoteControl();</span><br><span class="line">        <span class="comment">//new出来的这个light 就是请求的接收者(真正执行这个命令的东西)</span></span><br><span class="line">        Light light = <span class="keyword">new</span> light();</span><br><span class="line">        <span class="comment">//客户负责创建一个具体的命令对象，同时要设置这个命令的接收者</span></span><br><span class="line">        <span class="comment">//相当于：顾客下了一个订单，</span></span><br><span class="line">        LightOnCommand lightOn = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line">        <span class="comment">//remote就相当于服务员，服务员一天能接受很多很多的订单，相当于setComand可以接受不同的参数；此刻，当下，传入lightOn这个参数，代表服务员接受了lightOn这个订单</span></span><br><span class="line">        remote.setCommand(lightOn);</span><br><span class="line">        <span class="comment">//然后服务员知道所有订单都支持buttonWasPressed这个方法，一旦有订单，也就是有了一个命令，这个命令的执行只需要按一下按钮就彻底执行完毕了</span></span><br><span class="line">        remote.buttonWasPressed();</span><br><span class="line">        <span class="comment">//只要buttonWasPressed，这个button绑定的命令就立马执行</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="定义命令模式"><a href="#定义命令模式" class="headerlink" title="定义命令模式"></a>定义命令模式</h2><font color="red">命令模式：将“请求”封装成对象，以便使用不同的请求、队列、或者日志来参数化其他对象。命令模式也支持可撤销的操作</font><ul><li>理解<ul><li>参数化：比如遥控器的一个插槽，可以用 不用的请求(也就是命令) 当参数<code>remote.setCommand(参数)</code></li></ul></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/1bbbc28bdd1b10d9.png" style="zoom: 67%;"></p><ul><li>遥控器除了在按下按钮时，调用这个按钮对应的命令对象的execute方法之外<strong>其他什么都不知道</strong></li><li>当遥控器有两个按钮，希望可以控制客厅和厨房的电灯时，因为<strong>命令对象里可以封装这个命令的接收者</strong>，所以只需要创建两个LightCommand命令，一个绑定客厅的电灯，一个绑定厨房的电灯，按钮一按下，各自的execute就执行</li></ul><h3 id="将命令指定到插槽"><a href="#将命令指定到插槽" class="headerlink" title="将命令指定到插槽"></a>将命令指定到插槽</h3><ul><li>遥控器每个插槽 对应一个命令，当按下按钮，相应命令对象的execute就会被调用，execute方法中命令的接收者（家电）的动作就会被调用（具体见下列代码）</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span></span>{</span><br><span class="line">    Command[] onCommands;</span><br><span class="line">    COmmand[] offCommands;</span><br><span class="line">    <span class="keyword">public</span> RemoteControl{</span><br><span class="line">        onCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        offCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        COmmand noCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++){</span><br><span class="line">            onCommands[i] = noCommand;</span><br><span class="line">            offCommands[i] = noCommand;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> slot,Command onCommand,Command offCommand)</span></span>{</span><br><span class="line">        onCommands[slot] = onCommand;</span><br><span class="line">        offCOmmands[slot] = offCommand;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//调用下列方法就相当于按下按钮，那么这个按钮插槽绑定了的一个命令对象就会执行execute</span></span><br><span class="line">    <span class="comment">//这个命令对象就存储在onCommands[slot]</span></span><br><span class="line">    <span class="comment">//所调用的execute方法里面就写了 命令的执行者和执行者的动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span></span>{</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span></span>{</span><br><span class="line">        offCommands[slot].execute();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实现命令"><a href="#实现命令" class="headerlink" title="实现命令"></a>实现命令</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOffCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOffCommand</span><span class="params">(Light light)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{</span><br><span class="line">        light.off();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>NoCommand是一个<strong>空对象</strong>——什么事都不做：当不想返回一个有意义的对象就可以使用。</li><li>也可以将处理null的责任转移给空对象</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{}  <span class="comment">//实现一个什么都不做的命令</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteLoader</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line">        <span class="comment">//首先，创建所有的家电</span></span><br><span class="line">        Light livingRoomLight = <span class="keyword">new</span> Light(<span class="string">"Living Room"</span>);</span><br><span class="line">        <span class="comment">//...创建其他家电...</span></span><br><span class="line">        <span class="comment">//创建所有家电的命令对象</span></span><br><span class="line">        LightOnCOmmand livingRoomLightOn = <span class="keyword">new</span> LightOnCommand(livingRoomLight);</span><br><span class="line">        <span class="comment">//...创建其他命令对象...</span></span><br><span class="line">        <span class="comment">//将创建完的命令对象加载到遥控器插槽中</span></span><br><span class="line">        remoteControl.setCommand(<span class="number">0</span>,livingRommLightOn,livingRoomLightOff);</span><br><span class="line">        <span class="comment">//...其他...</span></span><br><span class="line">        <span class="comment">//上述准备完毕，按下每个插槽的开关按钮就行</span></span><br><span class="line">        remoteControl.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        remoteControl.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//...按下其他开关按钮...  </span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://i.bmp.ovh/imgs/2022/03/71c71a9f6056631a.png" style="zoom: 67%;"></p><h2 id="实现撤销"><a href="#实现撤销" class="headerlink" title="实现撤销"></a>实现撤销</h2><ul><li>撤销最近的那个动作</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>实现具体类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{</span><br><span class="line">        light.on();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>{</span><br><span class="line">        light.off();<span class="comment">//execute是打开，所以undo该是关闭</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>修改遥控器类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControlWithUndo</span></span>{</span><br><span class="line">    Command[] onCommands;</span><br><span class="line">    Command[] offCommands;</span><br><span class="line">    Command undoCommand; <span class="comment">//加入undoCommand这个实例变量，用来追踪最后被调用的命令</span></span><br><span class="line">    <span class="comment">//不管何时撤销按钮被按下，都可以取出这个命令（在执行撤销命令之前的最后那个非撤销命令）并调用它undo方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RemoteControlWithUndo</span><span class="params">()</span></span>{</span><br><span class="line">        onCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        offCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">        Command noCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++){</span><br><span class="line">            OnCommands[i] = noCommand;</span><br><span class="line">            OffCommands[i] = noCommand;</span><br><span class="line">        }</span><br><span class="line">        undoCommand = noCommand;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> slot,Command onCommand,Command offCommand)</span></span>{</span><br><span class="line">        onCommands[slot] = onCommand;</span><br><span class="line">        offCommands[slot] = offCommand;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonWasPushed</span><span class="params">(<span class="keyword">int</span> slot)</span></span>{</span><br><span class="line">        onCommands[slot].execute();</span><br><span class="line">        undoCommand = onCommands[slot];<span class="comment">//当按下当前按钮时，记录当前按钮绑定的命令 到undoCommand中</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undoButtonWasPushed</span><span class="params">()</span></span>{</span><br><span class="line">        undoCommand.undo(); <span class="comment">//当按下撤销按钮时，可以撤销最近的一个命令</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="使用状态实现撤销"><a href="#使用状态实现撤销" class="headerlink" title="使用状态实现撤销"></a>使用状态实现撤销</h2><ul><li>吊扇允许<strong>多种转速</strong>，允许被关闭</li><li>在吊扇的命令类中加入“撤销” ：实现追踪吊扇的<strong>最后设置的速度</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CeilingFanHighCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    CeilingFan ceilingFan;</span><br><span class="line">    <span class="keyword">int</span> prevSpeed;  <span class="comment">//这就是增加的状态，来追踪吊扇之前的速度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CeilingFanHighCommand</span><span class="params">(CeilingFan ceilingFan)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.ceilingFan = ceilingFan;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{</span><br><span class="line">        prevSpeed = ceilingFan.getSpeed();<span class="comment">//在改变吊扇速度之前，先保存速度</span></span><br><span class="line">        ceilingFan.high();</span><br><span class="line">    }</span><br><span class="line">    <span class="function">pubilc <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(prevSpeed  == CeilingFan.HIGH){</span><br><span class="line">            ceilingFan.high();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(prevSpeed == CeilingFan.Medium){</span><br><span class="line">            ceilingFan.medium();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(prevSpeed == CeilingFan.LOW){</span><br><span class="line">            ceilingFan.low();</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(prevSpeed == CeilingFan.OFF){</span><br><span class="line">            ceilingFan.off();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteLoader</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        RemoteControlWithUndo remoteControl = <span class="keyword">new</span> RemoteControlWithUndo();</span><br><span class="line">        CeilingFan ceilingFan = <span class="keyword">new</span> CeilingFan(<span class="string">"Living Room"</span>);</span><br><span class="line">        CeilingFanHighCommand ceilingFanHigh = <span class="keyword">new</span> CeilingFanHighCommand(ceilingFan);</span><br><span class="line">        <span class="comment">//..同理，再创建一个中速命令（省略）</span></span><br><span class="line">        remoteControl.setCommand(<span class="number">1</span>,ceilingFanHigh,ceilingFanOff);</span><br><span class="line">        <span class="comment">//..先开启中速度，然后关闭</span></span><br><span class="line">        remoteControl.onButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        remoteControl.offButtonWasPushed(<span class="number">0</span>);</span><br><span class="line">        remoteControl.undoButtonWasPushed();<span class="comment">//撤销，回到中速</span></span><br><span class="line">        remoteControl.onButtonWasPushed(<span class="number">1</span>);<span class="comment">//开启高速</span></span><br><span class="line">        remoteControl.undoButtonWasPushed();<span class="comment">//撤销高速，回到中速</span></span><br><span class="line">    </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果希望能够按下按钮多次，撤销很早以前的状态，就可以使用一个<strong>堆栈</strong>记录操作命令的每一个过程；一旦按下撤销按钮，就可以从堆栈中取出最上层的命令，调用undo方法</li></ul><h3 id="使用宏命令"><a href="#使用宏命令" class="headerlink" title="使用宏命令"></a>使用宏命令</h3><ul><li><p>我们想要在不改变遥控器的情况下，只按一个按钮，就能控制所有装置（同时打开电灯、电视等等）</p></li><li><p>宏命令</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>{</span><br><span class="line">    Command[] commands;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MacroCommand</span><span class="params">(Command[] commands)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.commands = commands;<span class="comment">//宏命令存储一堆命令</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>{ <span class="comment">//宏命令执行时，数组存储的命令一次性全部执行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;commands.length();i++){</span><br><span class="line">        commands[i].execute();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//当然也可以撤销，按下撤销按钮，宏命令内所有命令都被撤销</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;commands.length();i++){</span><br><span class="line">            commands[i].undo();</span><br><span class="line">        } </span><br><span class="line">      }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>首先，创建想要进入宏的命令集合</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建所有装置</span></span><br><span class="line">Light light = <span class="keyword">new</span> Light(<span class="string">"Living Room"</span>);</span><br><span class="line">TV tv = <span class="keyword">new</span> TV(<span class="string">"Living Room"</span>);</span><br><span class="line"><span class="comment">//创建所有on命令</span></span><br><span class="line">LightOnCommand lightOn = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line">TVOnCommand tvOn = <span class="keyword">new</span> TVOnCommand(tv);</span><br><span class="line"><span class="comment">//...创建所有off命令...</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>创建两个数组，一个记录所有开启命令，一个记录所有关闭命令</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Command[] partyOn = {lightOn,tvOn};</span><br><span class="line">Command[] partyOff = {lightOff,tvOff};</span><br><span class="line"><span class="comment">//创建对应的宏持有这两个数组</span></span><br><span class="line">MacroCommand partyOnMarcro = <span class="keyword">new</span> MacroCommand(partyOn);</span><br><span class="line">MacroCommand partyOffMacro = <span class="keyword">new</span> MacroCommand(partyOff);</span><br></pre></td></tr></tbody></table></figure></li><li><p>将宏命令指定给按钮</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remoteControl.setCommand(<span class="number">0</span>,partyOnMacro,partyOffMacro);</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="命令模式的更多用途：队列请求"><a href="#命令模式的更多用途：队列请求" class="headerlink" title="命令模式的更多用途：队列请求"></a>命令模式的更多用途：队列请求</h2><p>老师没讲，暂时不看</p><h2 id="命令模式的更多用途：日志请求"><a href="#命令模式的更多用途：日志请求" class="headerlink" title="命令模式的更多用途：日志请求"></a>命令模式的更多用途：日志请求</h2><p>老师没讲，暂时不看</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>命令模式</strong>将 <strong><u>发出请求的对象</u></strong> 和 <strong><u>执行请求的对象</u></strong>解耦</li><li>发出请求的对象和执行请求的对象 通过 <strong><u>命令对象</u></strong> 沟通</li><li>命令对象 <strong>封装</strong>了 <strong><u>命令的接收者</u></strong> 和 <u><strong>一个or一组动作</strong></u></li><li>调用命令对象的<code>excute()</code>发出请求，接收者的<strong>动作被调用</strong></li></ul><hr><h1 id="适配器模式与外观模式"><a href="#适配器模式与外观模式" class="headerlink" title="适配器模式与外观模式"></a>适配器模式与外观模式</h1><blockquote><p>包装某些对象，让它们的接口看起来不像自己 而是像别的东西；</p><p>这样就可以在设计中，将类的接口转换成想要的接口，以便实现不同的接口</p></blockquote><ul><li>适配器：将一<strong>个接口转换成另一个接口</strong>，以符合客户的期望</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/03/5bd9aaff0bcdbcaa.png" style="zoom:33%;"></p><ul><li>面向对象适配器<img src="https://i.bmp.ovh/imgs/2022/03/a2c5343156e97baf.png" style="zoom:33%;"></li></ul><h2 id="披着鸭子皮的火鸡"><a href="#披着鸭子皮的火鸡" class="headerlink" title="披着鸭子皮的火鸡"></a>披着鸭子皮的火鸡</h2><ul><li><p>鸭子类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>火鸡类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">}<span class="comment">//被适配者</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>假设<strong>缺鸭子</strong>对象，<strong>用火鸡冒充</strong>，但是接口不同，所以先写个适配器吧</p></li><li><p><strong>适配器</strong>（TurkeyAdapter）将 <strong>被适配者</strong>（Turkey） 适配成 <strong>目标</strong>接口（Duck）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们需要的是duck，但是现在只有turkey，所以这个适配器需要实现duck的接口</span></span><br><span class="line"><span class="comment">//可见：适配器实现了目标接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span></span>{</span><br><span class="line">    Turkey turkey;<span class="comment">//利用对象组合，用Turkey的实现来满足客户对鸭子的需求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.turkey = turkey; <span class="comment">//可见：适配器持有 被适配者turkey的实例</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>{<span class="comment">//实现duck的所有方法(适配器实现了目标接口)</span></span><br><span class="line">        turkey.gobble();  <span class="comment">//具体实现其实是turkey的方法，把它封装到duck的quack里而已</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) turkey.fly();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>测试适配器</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckTestDrive</span></span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">       MallardDuck duck = <span class="keyword">new</span> MallardDuck();</span><br><span class="line">       WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">       <span class="comment">//把这个火鸡包装进适配器中，让它看起来像鸭子</span></span><br><span class="line">       Duck turkeyAdapter = <span class="keyword">new</span> TurkeyAdapter(turkey);</span><br><span class="line">       testDuck(turkeyAdapter);</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">//testDuck相当于客户，依据目标接口（Duck）实现的：duck.quack,fly</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testDuck</span><span class="params">(Duck duck)</span></span>{</span><br><span class="line">       duck.quack();</span><br><span class="line">       duck.fly();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="适配器模式解析"><a href="#适配器模式解析" class="headerlink" title="适配器模式解析"></a>适配器模式解析</h2><p><img src="https://i.bmp.ovh/imgs/2022/03/6c4883665ec5904d.png" style="zoom:67%;"></p><ul><li><p>客户通过<font color="red">目标接口</font> 调用 <font color="red">适配器</font>的方法 对适配器发出请求</p></li><li><p>适配器 使用 <font color="red">被适配者接口</font>，把请求转换成 被适配者的一个或多个调用接口</p></li><li><p>客户接受到调用的结果，但未察觉适配器在起转换作用</p></li></ul><h2 id="定义适配器模式-类图"><a href="#定义适配器模式-类图" class="headerlink" title="定义适配器模式+类图"></a>定义适配器模式+类图</h2><font color="red">适配器模式：将一个类的接口，转换成客户期望的另一个类的接口。适配器让原本接口不兼容的类可以合作无间</font><ul><li><p>通过<strong>创建适配器</strong> 进行接口转换</p></li><li><p>好处</p><ul><li>适配器 将客户（比如testDuck）从实现的接口<strong>解耦</strong></li><li>如果想改变接口，适配器可以<strong>将改变的部分封装</strong>起来</li></ul></li><li><p><strong>对象</strong>适配器</p><p>适配器 和 被适配者 使用<strong>对象组合</strong>：被适配者的<strong>子类</strong>都可以<strong>搭配适配器</strong>使用</p><p><img src="https://i.bmp.ovh/imgs/2022/03/ea2903ba5f12223a.png" style="zoom:67%;"></p></li><li><p><strong>类</strong>适配器</p><p>（Java 不支持多重继承</p><p><img src="https://i.bmp.ovh/imgs/2022/03/06a0ea3bb86ade77.png" style="zoom:80%;"></p></li></ul><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>最初的茶和咖啡各自的四个步骤里面包括了</p><ul><li><strong>同样</strong>的方法：把水煮沸、倒进杯子</li><li><strong>相似</strong>的方法：沸水冲泡茶叶&amp;沸水冲泡咖啡粉、加柠檬&amp;加牛奶</li><li>同样的<strong>执行步骤</strong>：执行顺序相同</li></ul><p>因此，可以将其抽象泛化成一个模板方法</p><p><img src="https://i.bmp.ovh/imgs/2022/04/09/bb395cb66de3b8bb.png" style="zoom: 50%;"></p><h2 id="模板方法定义"><a href="#模板方法定义" class="headerlink" title="模板方法定义"></a>模板方法定义</h2><p><a href="https://github.com/z-y-LiaN/Software-Design-Pattern/tree/master/Template">Github：课本代码实现总结</a></p><p><strong>模板方法模式</strong> 在一个<strong>方法</strong>中定义一个<font color="red">算法的骨架</font>，而将一些步骤<font color="red">延迟到子类</font>中。模板方法使得子类可以在<strong>不改变算法结构</strong>的情况下，<strong>重新定义</strong>算法中的<strong>某些</strong>步骤</p><p>理解</p><ul><li>所谓模板，本质是个方法，一个用<strong>一组步骤</strong>来定义算法的方法<ul><li>保证由<strong>子类提供算法某一部分的实现</strong>，而算法结构保持不变</li></ul></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/09/9e1722efc57cbd1b.png" style="zoom: 43%;"></p><h2 id="对模板方法进行挂钩"><a href="#对模板方法进行挂钩" class="headerlink" title="对模板方法进行挂钩"></a>对模板方法进行挂钩</h2><p>钩子：声明在<strong>抽象类</strong>中的（具体）方法，<strong>只有空的或者默认</strong>的实现。</p><p>有了钩子，子类可以自主决定要不要覆盖这个钩子，如果不覆盖，抽象类会提供一个默认的实现</p><font color="green">何时使用抽象方法，何时使用钩子：</font><ul><li>子类<strong>必须提供</strong>算法中某个方法或步骤的<strong>实现</strong>：抽象方法</li><li>不是必须，而是<strong>可选</strong>的：钩子</li></ul><hr><p>子类必须实现抽象类中的<strong>所有抽象方法</strong></p><h2 id="好莱坞原则与模板方法"><a href="#好莱坞原则与模板方法" class="headerlink" title="好莱坞原则与模板方法"></a>好莱坞原则与模板方法</h2><p><img src="https://i.bmp.ovh/imgs/2022/04/09/6420977290ad11c0.png" style="zoom:50%;"></p><h2 id="模板方法和策略模式的对比"><a href="#模板方法和策略模式的对比" class="headerlink" title="模板方法和策略模式的对比"></a>模板方法和策略模式的对比</h2><ul><li>策略模式定义了一个算法族，分别封装起来，让它们之间可以相互替换。每个算法都被封装，客户可以很方便的使用不同的算法，而且将算法的变化独立于客户</li><li>模板方法模式定义了一个算法的框架，将一些步骤延迟到子类。这样对于算法的某个步骤就有不同的，但仍能控制整个算法的结构</li><li>策略模式和模板方法模式都是封装算法；<ul><li>策略模式采用<strong>对象组合</strong>，更加<strong>灵活</strong>，依赖性比模板方法模式弱</li><li>模板方法模式采用<strong>继承</strong>，对算法有<strong>更强的控制</strong>，所以依赖性比策略模式强；<strong>没有重复代码</strong>，对象更少，更<strong>高效</strong></li></ul></li><li>注意：工厂方法模式是模板方法模式的一个特例</li></ul><h2 id="模板方法的例题"><a href="#模板方法的例题" class="headerlink" title="模板方法的例题"></a>模板方法的例题</h2><font color="red">关键词：步骤、流程、某些流程不一样</font><hr><p>1.对数据库的操作一般包括连接、打开、使用、关闭等<strong>步骤</strong>，在数据库操作模板类中我们定义了connDB（）,openDB（）,useDB()，closeDB（）四个方法分别对应这<strong>四个步骤</strong>，对于不同类型的数据库（如SQLserver和Oracle），<strong>其操作步骤都一致</strong>，只是连接数据库connDB（）方法有所区别，现使用模板方法模式对其进行设计</p><hr><p>2.某软件公司欲为某银行的业务支撑系统开发一个利息计算模块，利息计算<strong>流程</strong>如下：<br>(1) 系统根据账号和密码验证用户信息，如果用户信息错误，系统显示出错提示；（<strong>具体方法）</strong><br>(2) 如果用户信息正确，则根据<strong>用户类型的不同使用不同的利息计算公式</strong>计算利息（如活期账户和定期账户具有不同的利息计算公式）；<strong>（这是个不同的步骤，抽象方法）</strong><br>(3) 系统显示利息。<strong>（具体方法）</strong><br>试使用模板方法模式设计该利息计算模块。</p><p><img src="https://i.bmp.ovh/imgs/2022/04/09/271f71928f6d6291.png" style="zoom: 33%;"></p><hr><p>3.某软件公司欲为销售管理系统提供一个数据图表显示功能，该功能的实现包括如下<strong>几个步骤</strong>：<br>(1) 从数据源获取数据；<br>(2) 将数据转换为XML格式；<br>(3) 以某种图表方式显示XML格式的数据。<br>该功能支持<strong>多种数据源和多种图表</strong>显示方式，但所<strong>有的图表显示操作都基于XML格式的数据，因此可能需要对数据进行转换</strong>，如果从数据源获取的数据已经是XML数据则无须转换</p><hr><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>让客户<strong>遍历</strong>你的对象而无法窥视你存储对象的方式</p><p><img src="https://i.bmp.ovh/imgs/2022/04/10/9e3c335e18674026.png" alt=""></p><p>显然，这两种不同的菜单表现方式会让事情变得复杂化，我们需要实现一个<strong>同时使用这两个菜单</strong>的客户代码 </p><ul><li><p>比如一个waitress类（客户）需要遍历打印菜单中的每一项 printMenu()</p></li><li><p>但是这两份存储菜单项的菜单里所<strong>使用的数据结构不同</strong></p></li><li><p>导致printMenu()要分别遍历每份菜单，比如</p><p><img src="https://i.bmp.ovh/imgs/2022/04/10/8044cb7679393e81.png" style="zoom: 50%;"></p></li></ul><p>考虑让这两个菜单<strong>实现一个相同的接口</strong>：</p><ul><li><p>可以看到 <strong>发生变化的部分</strong>是不同集合类型所造成的遍历，因此可以<strong>考虑封装遍历</strong></p></li><li><p>因此，创建一个对象：迭代器，利用它来封装“<strong>遍历</strong>集合内的每个对象的过程”</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = dinerMenu.createIterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()){</span><br><span class="line">    MenuItem menuItem = (MenuItem)iterator.next();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>所以，接下来的具体实现是：</p><ul><li>定义一个<strong>迭代器接口</strong>Iterator </li><li>为每个菜单各自定义<strong>实现一个具体的Iterator类</strong>：DinerMenuIterator、PancakeHouseMenuIterator</li><li><p>改写原菜单：<strong>遍历菜单时需要获得它的迭代器</strong>，所以原菜单要有一个createIterator()方法来获取对应的迭代器</p></li><li><p>waitress（客户代码）想要遍历所有菜单里面的所有菜单项，只需要获取到对应的迭代器，利用迭代器的方法遍历就行。</p></li></ul><hr><p><img src="https://i.bmp.ovh/imgs/2022/04/10/3def41655a370abf.png" style="zoom: 67%;"></p><h2 id="利用Java-util-Iterator来清理"><a href="#利用Java-util-Iterator来清理" class="headerlink" title="利用Java.util.Iterator来清理"></a>利用Java.util.Iterator来清理</h2><ul><li>PancakeHouseMenu：对于ArrayList不需要创建自己的迭代器，直接调用iterator()方法即可</li><li>DinerMenu：写一个具体的迭代器实现Iterator</li><li>让waitress不依赖于具体的DinerMenu和PancakeHouseMenu类：<ul><li>添加一个Menu接口，只有createIterator（）方法</li><li>具体的Menu去实现这个Menu接口类</li><li>这样waitress可以<strong>针对抽象</strong>（Menu）编程，而<strong>不是针对具体编程</strong>，实现解耦</li></ul></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/10/742898cea6ea5dda.png" style="zoom: 67%;"></p><h2 id="定义迭代器模式"><a href="#定义迭代器模式" class="headerlink" title="定义迭代器模式"></a>定义迭代器模式</h2><p>迭代器模式 提供一种方法<strong>顺序访问</strong>每一个聚合对象中的各个元素，而不暴露其内部的表示</p><hr><ul><li>迭代器模式把元素之间游走的责任交给迭代器实现，而不是句合对象。</li><li>使我们能够游走（遍历）聚合内的每一个元素，而又不保留其内部的表示</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/10/5c5d97f561d6df88.png" style="zoom: 50%;"></p><h2 id="单一责任原则"><a href="#单一责任原则" class="headerlink" title="单一责任原则"></a>单一责任原则</h2><p><strong>一个类应该只有一个引起变化的原因</strong></p><hr><p>理解</p><ul><li><p>当我们允许一个类不但要完成自己的事情（管理某种集合），还同时担负起更多的责任（例如遍历）时，我们就给了这个类两个变化的原因：</p><ul><li>集合改变、类随之改变</li><li>遍历方式改变、类随之改变</li></ul><p>比如最初的没有使用迭代器模式的<code>DinerMenu</code>和<code>PancakeHouseMenu</code>；<code>DinerMenu</code>既需要管理存储菜单项的数组，又需要参与到数组遍历中</p></li><li><p><strong>类的每个责任都有改变的潜在区域</strong>，超过一个责任，意味着超过一个改变的区域</p></li></ul><p>内聚：度量一个类或模块紧密地达到单一目的或责任</p><ul><li>具有<strong>高内聚</strong>的模块或类：只支持一组相关的功能</li><li>具有<strong>低内聚</strong>的模块或类：支持一组不相干的功能</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/10/42177f8fd9fba002.png" style="zoom:67%;"></p><p><img src="https://i.bmp.ovh/imgs/2022/04/10/8ac487f1936f16df.png" style="zoom:62%;"></p><hr><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>基于上面的例子，我们希望在DinerMenu中添加一个甜点的子菜单</p><p><img src="https://i.bmp.ovh/imgs/2022/04/10/9e6b14f2808ab76e.png" style="zoom:50%;"></p><p>因此，我们需要：</p><ul><li>需要某种<strong>树形结构</strong>，可以容纳菜单、子菜单、菜单项</li><li>需要确定<strong>能够在每个菜单的各个项之间的游走</strong>，而且至少要像现在用迭代器一样方便</li><li>需要<strong>更有弹性</strong>地在菜单项之间游走：可以只遍历甜点菜单，可以遍历餐厅整个菜单</li></ul><h2 id="组合模式定义"><a href="#组合模式定义" class="headerlink" title="组合模式定义"></a>组合模式定义</h2><p>组合模式允许你 将组合对象 <strong>组合成树形结构</strong> 来表现 “整体/部分“层次结构。组合能让客户以<strong>一致的方式</strong>处理<strong>个别</strong>对象以及对象<strong>组合</strong></p><hr><ul><li>组合模式让我们能够用<strong>树形的方式</strong>创建对象的结构，树里面包含了<strong>组合以及个别的对象</strong></li><li>使用组合结构，我们能把<strong>相同的操作</strong>应用在组合和个别对象上；<ul><li>即：大多数情况下，可以<strong>忽略</strong>对象组合和个别对象的<strong>差别</strong></li></ul></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/05/14/5e0b935975b7340f.png" style="zoom:80%;"></p><h2 id="利用组合设计菜单"><a href="#利用组合设计菜单" class="headerlink" title="利用组合设计菜单"></a>利用组合设计菜单</h2><ul><li>创建一个<strong>组件接口</strong>，作为菜单和菜单项的<strong>共同接口</strong>，这样就能用统一的做法来处理菜单和菜单项。</li></ul><ul><li>实现菜单组件：MenuComponent<ul><li>它的目的是为叶节点和组合节点提供一个共同的接口</li><li>它的方法要<strong>提供默认的实现</strong>，这样菜单项或菜单不想实现某些方法 就可以不实现</li></ul></li></ul><hr><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p><a href="https://github.com/z-y-LiaN/Software-Design-Pattern/tree/master/State">Github：状态模式课本代码实现总结</a></p><p>针对一种像这种状态机的模型</p><p><img src="https://www.hualigs.cn/image/6252e3a06ba5f.jpg" style="zoom:50%;"></p><p>我们把每个状态的<strong>行为都放在</strong>各自的<strong>状态类</strong>中，每个状态只要实现它的动作就行</p><p>所以用户施加在糖果机上的<strong>动作</strong>，只需要<strong>委托给代表当前状态的状态对象</strong>就行===》多用组合，少用继承</p><p><img src="https://i.bmp.ovh/imgs/2022/05/13/ffc03cadd6316732.png" style="zoom: 33%;"></p><ul><li>将每个状态的行为局部化到它自己的类中</li><li>将容易产生问题的if语句删除，方便维护</li><li>让每个状态<strong>对修改关闭</strong>，让糖果机<strong>对扩展开放</strong>，因此可以加入新的状态类</li></ul><h2 id="定义状态模式"><a href="#定义状态模式" class="headerlink" title="定义状态模式"></a>定义状态模式</h2><p>状态模式  允许对象在<strong>内部状态改变</strong>时<strong>改变</strong>它的<strong>行为</strong>，对象看起来<strong>好像修改</strong>了它 的<strong>类</strong></p><p>理解：</p><ul><li>将状态<strong>封装成</strong>独立的<strong>类</strong>，并将动作<strong>委托</strong>到代表<strong>当前状态的对象</strong>，行为随着内部状态而改变<ul><li>比如：糖果机处于不同状态，对它执行相同动作，得到的结果可能不同</li></ul></li><li>从客户的视角，如果说你<strong>使用的对象能够改变它的行为</strong>，那你就会觉得，这个对象实际上是从别的类实例化而来的，而实际上是使用<strong>组合</strong>通过简单<strong>引用</strong>不同的 状态对象造成的假象</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/11/97377ff0ed4987fb.png" style="zoom:67%;"></p><h2 id="状态模式和策略模式对比"><a href="#状态模式和策略模式对比" class="headerlink" title="状态模式和策略模式对比"></a>状态模式和策略模式对比</h2><font color="red">它俩类图一样，但是意图不一样</font><blockquote><p>所以说，千万不要从类图上区分模式，要从它的用途和目的去区分</p></blockquote><ul><li><p><font color="red">状态模式</font>：将 <strong>一群行为封装在状态对象</strong>中，行为对于客户来说是<strong>透明</strong>的。正常情况下，客户<strong>不知道</strong>状态对象的存在</p><blockquote><p>Contex的行为可以随时委托给那些状态对象中第一个，随着时间流逝</p><p>当前<strong>状态在状态对象集合中游走改变</strong>，以反映出context内部的状态，因此 context的行为也会跟着改变</p><p>但是！！！！context的客户对于状态对象了解不多，<strong>甚至浑然不觉</strong></p><p>可以把状态模式想成是不用在context中放置许多条件判断的替代方案</p><p>通过将<strong>行为包装进状态对象</strong>，可以通过在context内简单地<strong>改变状态对象</strong>来<strong>改变context的行为</strong></p></blockquote></li><li><p><font color="red">策略模式</font>中，客户通常<strong>委托所要组合</strong>的对象<strong>改变行为，由客户决定做改变</strong></p><blockquote><p>客户通常 <strong>主动指定</strong>Context所要组合的<strong>策略对象</strong>是哪一个</p><p>可以把策略模式想成除了<strong>继承之外的 一种弹性替代</strong>方案</p><ul><li>如果使用继承定义了一个类的行为，可能被整个行为困住</li><li>但通过策略模式，可以<strong>通过组合不同的对象</strong>来改变行为</li></ul></blockquote></li><li><p><strong>代码对比</strong></p></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/823ae8b39805c03c.png" style="zoom:50%;"></p><ul><li>例如上图<strong>策略模式</strong>的客户代码，客户是<strong>明确知道</strong>拥有的策略对象，可以由客户自己<strong>随意指定</strong></li><li>例如下图<strong>状态模式</strong>的客户代码，客户只知道要进行这些操作，而这些操作的具体实现是委托给具体的状态的，<strong>客户根本不知道当前的状态对象</strong></li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/f6bffdd837e284cd.png" style="zoom:50%;"></p><ul><li>即是：状态模式中，客户调用<code>gumballMachine.insertQuarter()</code>方法，实际上会<strong>委托</strong>给持有的<code>state</code>状态对象<code>insertQuarter</code>来执行，从而进行状态转换</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/13/5783f145b9bc36e1.png" style="zoom:60%;"></p><h2 id="状态转换由谁执行"><a href="#状态转换由谁执行" class="headerlink" title="状态转换由谁执行"></a>状态转换由谁执行</h2><p><a href="https://github.com/z-y-LiaN/Software-Design-Pattern/tree/master/State/StateChange">Github：一个代码例子</a></p><ul><li>当状态转换是<strong>固定</strong>的，就适合放<strong>在Context类</strong>中</li><li>当状态转换是更<strong>动态</strong>的，通常会放在<strong>状态类</strong>中<ul><li>缺点：状态间产生了依赖</li></ul></li></ul><h2 id="一个练习"><a href="#一个练习" class="headerlink" title="一个练习"></a>一个练习</h2><p>信用卡业务系统</p><p>​    Sunny软件公司欲为某银行开发一套信用卡业务系统，银行账户(Account)是该系统的核心类之一，通过分析，Sunny软件公司开发人员发现在该系统中，账户存在<strong>三种状态</strong>，且在不同状态下账户存在不同的行为，具体说明如下：</p><ul><li><p>如果账户中余额大于等于0，则账户的状态为<strong><em>\</em>正常状态(Normal State)**</strong>，此时用户既可以向该账户<strong><em>\</em>存款**</strong>也可以从该账户<strong><em>\</em>取款**</strong>；</p></li><li><p>如果账户中余额小于0，并且大于-2000，则账户的状态为<strong><em>\</em>透支状态(Overdraft State)**</strong>，此时用户既可以向该账户存款也可以从该账户取款，但需要<strong><em>\</em>按天计算利息**</strong>；</p></li><li><p>如果账户中余额等于-2000，那么账户的状态为<strong><em>\</em>受限状态(Restricted State)**</strong>，此时用户只能向该账户存款，不能再从中取款，同时也将按天计算利息；</p></li></ul><p>根据余额的不同，以上<strong><em>\</em>三种状态可发生相互转换**</strong>。</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/d5e795f6c10a3d81.png" alt=""></p><p>stateCheck()用于在每一次执行存款和取款操作后<strong>根据余额来判断是否要进行状态转换并实现状态转换</strong>，相同的方法在不同的状态中可能会有不同的实现。</p><p>上面的例子通过<strong>具体状态类来实现状态的转换</strong>，在每一个具体状态类中都包含一个stateCheck()方法，在该方法内部实现状态的转换。</p><p>除此之外，我们还可以通过<strong>Context类来实现状态转换</strong>，Context类作为一个状态管理器，统一实现各种状态之间的转换操作</p><hr><h2 id="多个Context类共享-状态"><a href="#多个Context类共享-状态" class="headerlink" title="多个Context类共享 状态"></a>多个Context类共享 状态</h2><p>在有些情况下，<strong>多个</strong>Context可能需要<strong>共享同一个状态</strong></p><ul><li><p>如果希望在系统中实现多个Context共享一个或多个状态对象</p></li><li><p>则可以<strong>将这些State定义为Context的静态成员对象</strong>。</p><blockquote><p>即，想要共享状态，需要把每个状态都指定到静态的实例变量中，如果状态需要用到Context的方法或者实例变量，还必须在handler()方法中传入一个context的引用</p></blockquote></li></ul><hr><p>关于为什么定义为静态成员对象：</p><ul><li><p>属于类，<strong>独立于对象</strong>，即使未创建对象，也可以通过类调用静态的属性和方法</p></li><li><p>由于static成员<strong>为所有实例对象所共享</strong>，当业务需求出现<strong>某个成员需要被所有实例对象所需要</strong>时，应将其设为static，<strong>当类的任何对象访问它时，存取到的都是相同的值</strong></p><ul><li>某个成员：可以对应某个状态</li><li>被所有实例对象所需要：这个状态被多个Context共享</li></ul></li><li><p>static变量只会在类加载时被分配一次且一次空间，而实例对象会在每次创建新对象时都会为其分配一次新的空间</p></li></ul><ul><li><p><strong>static成员可以通过类名访问，也可以通过对象名访问</strong></p></li><li><p>static方法中只允许访问static属性或方法，不允许访问非static成员（因为非static成员在初次类加载时并未初始化）</p></li></ul><hr><p>例如：如果某系统要求两个开关对象（Context）要么<strong>都</strong>处于开的状态，要么都处于关的状态，在使用时它们的状态必须保持一致，开关可以由开转换到关，也可以由关转换到开。</p><p>分析：</p><ul><li>两个开关对象——两个Context</li><li>都处于开，都处于关——共享开状态和共享关状态</li><li>因此，需要把这两个state定义为context的静态成员对象</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;策略模式&lt;/li&gt;
&lt;li&gt;装饰者模式、工厂模式、单件模式、命令模式&lt;/li&gt;
&lt;li&gt;模板方法模式：封装算法&lt;/li&gt;
&lt;li&gt;迭代器和组合模式：管理良好的集合&lt;/li&gt;
&lt;li&gt;状态模式：事物的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参考学习资料&lt;/strong&gt;：&lt;strong&gt;《HeadFirst 设计模式》&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="软件工程" scheme="http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
    <category term="软件设计模式" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【题解】搜索与图论</title>
    <link href="http://example.com/2022/03/22/2022-03-22-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/"/>
    <id>http://example.com/2022/03/22/2022-03-22-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</id>
    <published>2022-03-22T01:55:34.000Z</published>
    <updated>2022-05-19T14:45:36.591Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>BFS、DFS、Flood Fill</li></ul></li></ul><span id="more"></span><h1 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h1><h2 id="AcWing843-n皇后问题"><a href="#AcWing843-n皇后问题" class="headerlink" title="AcWing843 n皇后问题"></a>AcWing843 n皇后问题</h2><ul><li><p>对于第r行第i列所在的对角线和反对角线</p><p><strong>对角线</strong> <code>dg[r+i]</code>，<strong>反对角线</strong><code>udg[n−r+i]</code>中的下标  <code>r+i</code>和  <code>n−r+i</code>  表示的是<strong>截距</strong></p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> dg[N],udg[N],col[N];</span><br><span class="line"><span class="comment">//dfs(r)在第r行上放皇后 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(r==n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">puts</span>(a[i]);<span class="comment">//cout&lt;&lt;a[i]&lt;&lt;endl; </span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>); <span class="comment">//换行 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//针对当前第r行，枚举 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!col[i] &amp;&amp; !dg[r + i] &amp;&amp; !udg[n - r + i]){</span><br><span class="line">a[r][i]=<span class="string">'Q'</span>;</span><br><span class="line">col[i] = dg[r + i] = udg[n - r + i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(r+<span class="number">1</span>);</span><br><span class="line">col[i] = dg[r + i] = udg[n - r + i] = <span class="literal">false</span>; </span><br><span class="line">a[r][i]=<span class="string">'.'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) a[i][j]=<span class="string">'.'</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="宽度优先搜索BFS"><a href="#宽度优先搜索BFS" class="headerlink" title="宽度优先搜索BFS"></a>宽度优先搜索BFS</h1><ul><li><p>队列queue、O(2^h)、最短路(只有所有边权都是1 的时候才可以用BFS做最短路问题)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queue←初始</span><br><span class="line"><span class="keyword">while</span> queue非空{</span><br><span class="line">t←队头；扩展队头<span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="AcWing844-走迷宫"><a href="#AcWing844-走迷宫" class="headerlink" title="AcWing844 走迷宫"></a>AcWing844 走迷宫</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];<span class="comment">//存储图 </span></span><br><span class="line"><span class="keyword">int</span> d[N][N];<span class="comment">//存储图中每个点到起始点的距离 </span></span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>},dy[]={<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>{</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);<span class="comment">//首先初始化为-1表示没有走过</span></span><br><span class="line"></span><br><span class="line">d[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">// ==0表示走过 </span></span><br><span class="line">q.<span class="built_in">push</span>({<span class="number">0</span>,<span class="number">0</span>});<span class="comment">//加入第一个点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();<span class="comment">//返回队列的第一个</span></span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//删除原队列中的第一个</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="comment">//判断坐标不越界，且该点可以走 且该点之前没走过 </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m&amp;&amp;g[x][y]==<span class="number">0</span>&amp;&amp;d[x][y]==<span class="number">-1</span>){</span><br><span class="line">d[x][y]= d[t.first][t.second]+<span class="number">1</span>; </span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) cin&gt;&gt;g[i][j];</span><br><span class="line">cout&lt;&lt;<span class="built_in">bfs</span>()&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1101-献给阿尔吉侬的花束"><a href="#AcWing1101-献给阿尔吉侬的花束" class="headerlink" title="AcWing1101 献给阿尔吉侬的花束"></a>AcWing1101 献给阿尔吉侬的花束</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n,r,c;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(PII st,PII ed)</span></span>{</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line">d[st.first][st.second]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;r&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;c&amp;&amp;g[x][y]!=<span class="string">'#'</span>&amp;&amp;d[x][y]==<span class="number">-1</span>){</span><br><span class="line">d[x][y]=d[t.first][t.second]+<span class="number">1</span>;</span><br><span class="line">PII xy={x,y};</span><br><span class="line"><span class="keyword">if</span>(xy==ed) <span class="keyword">return</span> d[x][y];</span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">PII st,ed;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++){</span><br><span class="line">cin&gt;&gt;g[i][j]; </span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'S'</span>) st={i,j};</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'E'</span>) ed={i,j};</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">int</span> ans=<span class="built_in">bfs</span>(st,ed);</span><br><span class="line"><span class="keyword">if</span>(ans!=<span class="number">-1</span>) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"oop!"</span>&lt;&lt;endl; </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1113-红与黑"><a href="#AcWing1113-红与黑" class="headerlink" title="AcWing1113 红与黑"></a>AcWing1113 红与黑</h2><h3 id="BFS写法"><a href="#BFS写法" class="headerlink" title="BFS写法"></a>BFS写法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> w,h;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(PII st)</span></span>{</span><br><span class="line">d[st.first][st.second]=<span class="number">1</span>;</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;h&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;w&amp;&amp;d[x][y]==<span class="number">-1</span>&amp;&amp;g[x][y]==<span class="string">'.'</span>){</span><br><span class="line">d[x][y]=<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">cin&gt;&gt;w&gt;&gt;h;<span class="keyword">if</span>(w==<span class="number">0</span>&amp;&amp;h==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">PII st;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w;j++){</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'@'</span>) st={i,j};</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">bfs</span>(st);</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w;j++){</span><br><span class="line"><span class="keyword">if</span>(d[i][j]==<span class="number">1</span>) cnt++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="DFS写法"><a href="#DFS写法" class="headerlink" title="DFS写法"></a>DFS写法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>},dy[]={<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">g[x][y]=<span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> a=x+dx[i],b=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;n&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;m&amp;&amp;g[a][b]==<span class="string">'.'</span>){</span><br><span class="line">res+=<span class="built_in">dfs</span>(a,b);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;m&gt;&gt;n,n||m){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;g[i];</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'@'</span>){</span><br><span class="line">x=i,y=j;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;<span class="built_in">dfs</span>(x,y)&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1096-地牢大师（三维）"><a href="#AcWing1096-地牢大师（三维）" class="headerlink" title="AcWing1096 地牢大师（三维）"></a>AcWing1096 地牢大师（三维）</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>发现有时候代码写不对注意检查：初始点的状态设置是否遗漏，bfs里面坐标的判断有无遗漏，标志数组是否遗漏</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Coo</span>{</span></span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">};<span class="comment">//存储xyz坐标 </span></span><br><span class="line"><span class="keyword">char</span> g[N][N][N]; <span class="comment">//xyz</span></span><br><span class="line"><span class="keyword">int</span> d[N][N][N];<span class="comment">//存储走到xyz的距离 </span></span><br><span class="line"><span class="keyword">int</span> l,r,c;</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},dy[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>},dz[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Coo st,Coo ed)</span></span>{</span><br><span class="line">d[st.x][st.y][st.z]=<span class="number">0</span>;</span><br><span class="line">queue&lt;Coo&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.x+dx[i],y=t.y+dy[i],z=t.z+dz[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;r&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;c&amp;&amp;z&gt;=<span class="number">0</span>&amp;&amp;z&lt;l){<span class="comment">//坐标合法 </span></span><br><span class="line"><span class="keyword">if</span>(d[x][y][z]==<span class="number">-1</span>&amp;&amp;g[x][y][z]!=<span class="string">'#'</span>){<span class="comment">//且没有被走过且可以走 </span></span><br><span class="line">d[x][y][z]=d[t.x][t.y][t.z]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({x,y,z});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(d[ed.x][ed.y][ed.z]!=<span class="number">-1</span>) cout&lt;&lt;<span class="string">"Escaped in "</span>&lt;&lt;d[ed.x][ed.y][ed.z]&lt;&lt;<span class="string">" minute(s)."</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"Trapped!"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">Coo st,ed;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;c);<span class="keyword">if</span>(l==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;r;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;c;k++){</span><br><span class="line">cin&gt;&gt;g[j][k][i];</span><br><span class="line"><span class="keyword">if</span>(g[j][k][i]==<span class="string">'S'</span>) st={j,k,i};</span><br><span class="line"><span class="keyword">if</span>(g[j][k][i]==<span class="string">'E'</span>) ed={j,k,i};</span><br><span class="line">} </span><br><span class="line"><span class="built_in">bfs</span>(st,ed); </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="树与图的DFS"><a href="#树与图的DFS" class="headerlink" title="树与图的DFS"></a>树与图的DFS</h1><ul><li>有向图存储<ul><li>邻接矩阵（用的比较少，g[a] [b])，不能存储重边</li><li><strong>邻接表</strong>：每个节点开了一个表，存着<strong>这个点可以走到哪个点</strong>（内部点的存储次序无关紧要）</li></ul></li></ul><h2 id="AcWing846-树的重心"><a href="#AcWing846-树的重心" class="headerlink" title="AcWing846 树的重心"></a>AcWing846 树的重心</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一颗树，包含 <strong>n个结点</strong>（编号 1∼n）和 n−1 条<strong>无向边</strong>。</p><p>找树的重心，并输出将重心删除后，<strong>剩余各个连通块中节点数</strong>的<strong>最大值</strong>。</p><p>重心定义：重心是指树中的一个结点，如果将这个点删除后，<strong>剩余各个连通块中点数的最大值最小</strong>，那么这个节点被称为树的重心。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>无向图：建立边的时候两个方向都要建边</li><li>枚举删掉每一个点剩余连通块的节点数量的最大值，从各个最大值中找到最小值</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> ans=N,n;</span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//标记是否被遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">idx=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//插入一条a到b的边：</span></span><br><span class="line"><span class="comment">//在a所对应的邻接表里面插入一个节点b(头插) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//从节点u深搜，返回size:以u为根的树中 点的数量 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">st[u]=<span class="literal">true</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> size=<span class="number">1</span>,res=<span class="number">0</span>;<span class="comment">//sum：删掉这个点的连通块大小的最大值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]){<span class="comment">//遍历u节点的子节点</span></span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line"><span class="keyword">int</span> s=<span class="built_in">dfs</span>(j);<span class="comment">//s：当前子树的大小 </span></span><br><span class="line">size+=s;<span class="comment">//</span></span><br><span class="line">res=<span class="built_in">max</span>(res,s);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//和删除该点后的父节点的连通块大小 比较 </span></span><br><span class="line">res=<span class="built_in">max</span>(res,n-size);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,res); </span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="树与图的BFS"><a href="#树与图的BFS" class="headerlink" title="树与图的BFS"></a>树与图的BFS</h1><h2 id="AcWing847-图中点的层次"><a href="#AcWing847-图中点的层次" class="headerlink" title="AcWing847 图中点的层次"></a>AcWing847 图中点的层次</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//d[i]存储1号点走到i号点的距离 </span></span><br><span class="line"><span class="comment">//插入每条边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);<span class="comment">//-1标记没走过 </span></span><br><span class="line">d[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//初始化，然后入队 </span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//扩展 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];<span class="comment">//通过索引i找到t能到的节点编号 </span></span><br><span class="line"><span class="keyword">if</span>(d[j]==<span class="number">-1</span>){</span><br><span class="line">d[j]=d[t]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line">cout&lt;&lt;d[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing848-有向图的拓扑序列"><a href="#AcWing848-有向图的拓扑序列" class="headerlink" title="AcWing848 有向图的拓扑序列"></a>AcWing848 有向图的拓扑序列</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定有向图（可能有重边和自环）</p><p>若存在拓扑序列，则输出；不存在则输出-1</p><p>若一个由图中<strong>所有点</strong>构成的序列 A满足：对于图中的每条边 <strong>(x,y)</strong>，x 在 序列A 中都出现在 y <strong>之前</strong>，则称 A 是该图的一个拓扑序列。（即：所有的边都是从前指向后的）</p><p><strong>有向无环图一定存在拓扑序列：拓扑图</strong></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>入度=0：<strong>没有任何一条边指向它</strong>，所以可以排在当前最前面的位置：将其<strong>入队</strong></li><li>宽搜，枚举所有出边，t→j ，删掉t→j，j的入度-1，</li><li>如果j的入度=0，说明j前面的都排好序了，所以j可以入队</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;top;<span class="comment">//存放最终序列 </span></span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//入度 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span>{</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="comment">//把所有入度为0的点插入队列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!d[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">top.<span class="built_in">push</span>(t);</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//扩展队头元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];<span class="comment">//出边的点</span></span><br><span class="line">d[j]--; </span><br><span class="line"><span class="keyword">if</span>(d[j]==<span class="number">0</span>) q.<span class="built_in">push</span>(j);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断是否所有点都入队</span></span><br><span class="line"><span class="keyword">return</span> top.<span class="built_in">size</span>()==n;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="comment">//初始化 </span></span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="comment">//邻接表建图 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b);</span><br><span class="line">d[b]++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">topsort</span>()){</span><br><span class="line"><span class="keyword">while</span>(!top.<span class="built_in">empty</span>()){</span><br><span class="line">cout&lt;&lt;top.<span class="built_in">front</span>()&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">top.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}<span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Flood-Fill算法"><a href="#Flood-Fill算法" class="headerlink" title="Flood Fill算法"></a>Flood Fill算法</h1><ul><li>针对网格图的题，找连通的块的数目</li><li>dfs，bfs；dfs有时候可能会有爆栈的风险；都能实现的话用dfs更加方便</li><li>bfs：</li></ul><hr><h2 id="AcWing1233-全球变暖"><a href="#AcWing1233-全球变暖" class="headerlink" title="AcWing1233 全球变暖"></a>AcWing1233 全球变暖</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ul><li>多少个连通块，遍历<ul><li>找连通块：遍历BFSorDFS 、或者 并查集</li></ul></li><li>多少个连通块会被淹没掉<ul><li>如何判断被淹没：一共有多少个单元totoal，多少个单元在边界bound上</li><li>等价于==》 total=bound</li></ul></li></ul><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];<span class="comment">//当前点是否被搜索过 </span></span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>},dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> sx,<span class="keyword">int</span> sy,<span class="keyword">int</span> &amp;total,<span class="keyword">int</span> &amp;bound)</span></span>{</span><br><span class="line">PII pi={sx,sy};</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(pi);</span><br><span class="line">st[sx][sy]=<span class="literal">true</span>;<span class="comment">//当前第一个点被遍历 记得要标记 </span></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">total++;</span><br><span class="line"><span class="keyword">int</span> is_bound=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//判断当前t是否临海 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line">            <span class="comment">//当前t周围的点的坐标合法，且岛屿没有被遍历过</span></span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n&amp;&amp;(!st[x][y])){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'.'</span>) is_bound=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'#'</span>){</span><br><span class="line">st[x][y]=<span class="literal">true</span>; q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">bound+=is_bound;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;g[i];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;<span class="comment">//被淹没的 岛屿的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line"><span class="keyword">if</span>(!st[i][j]&amp;&amp;g[i][j]==<span class="string">'#'</span>){</span><br><span class="line"><span class="keyword">int</span> total=<span class="number">0</span>,bound=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//从当前点开始，统计这个点所在的连通块 </span></span><br><span class="line"><span class="built_in">bfs</span>(i,j,total,bound);</span><br><span class="line"><span class="keyword">if</span>(total==bound) cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,cnt); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1097-池塘计数"><a href="#AcWing1097-池塘计数" class="headerlink" title="AcWing1097 池塘计数"></a>AcWing1097 池塘计数</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ul><li>dfs：遍历每个W，标记，从当前W开始八个方向深搜；每次从一个W搜完，与之相连的W都变成. </li><li>bfs：遍历每个W，标记，从当前W开始八个方向宽搜。。。。。</li></ul><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">g[a][b]=<span class="string">'.'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=a+dx[i],y=b+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'W'</span>)</span><br><span class="line"><span class="built_in">dfs</span>(x,y);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//cin&gt;&gt;g[i];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) cin&gt;&gt;g[i][j];</span><br><span class="line">    <span class="comment">//连通块问题，从每个点开始bfs or dfs</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'W'</span>){</span><br><span class="line"><span class="built_in">dfs</span>(i,j);</span><br><span class="line">cnt++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p><strong>标记数组的位置很重要，一定要放在入队（q.push())之前</strong>，不然会T掉！<br>    在bfs中，如果对于之后的某个合法位置，应该入队，那么标记数组会有两种方法，第一种是在每次取队首元素的时候，标记已经遍历过当前点了，还有一种方法是在入队之前就马上标记。之前没太注意这个，但是是完全不一样的，对于8个方向，比如向<strong>左走一步是合法</strong>的，然后不马上标记的话，例如当前<strong>向下和向左</strong>都是合法的，那么当<strong>向下走时候(比如向下先入队了)，那么向左走还会被记录一次</strong>，这个很难debug出来，很奇怪的感觉</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">PII pi={a,b};</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(pi);</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//g[t.first][t.second]='.'; 不要在这个位置标记</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'W'</span>){</span><br><span class="line">                    g[x][y]=<span class="string">'.'</span>;<span class="comment">//要在这个位置标记！！！！！！！！！！！</span></span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'W'</span>){</span><br><span class="line"><span class="built_in">bfs</span>(i,j);</span><br><span class="line">cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="最短路介绍"><a href="#最短路介绍" class="headerlink" title="最短路介绍"></a>最短路介绍</h1><p>难点在于 建 图</p><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><p>求一个点到其他所有点的最短距离</p><p>​    分类：</p><ul><li><p><strong>所有边权都是正数</strong></p><ul><li>朴素Dijkstra算法：O(n^2)  （n点数，m边数）、稠密图；用邻接矩阵</li><li>堆优化版的Dijkstra算法：O(mlogn)、稀疏图；用邻接表</li></ul></li><li><p><strong>存在负权边</strong></p><ul><li>Bellman-Ford：O(nm)</li><li>SPFA：一般情况下O(m)，最坏O(nm)；</li></ul></li></ul><h2 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h2><ul><li>Floyd算法：O(n^3)</li></ul><hr><h1 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h1><p>从<strong>1号点到其他所有点</strong>的最短距离</p><h2 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a>朴素版</h2><ul><li><strong>初始化距离</strong>：dist[1] = 0, dist[i]= +∞：1号点到起点的距离是1，其他所有点到起点的距离是+∞</li><li>集合S：当前<strong>已经确定</strong>的最短距离的点</li><li>for i 从 <strong>0</strong> 到 n：<ul><li>找到不在S中的<strong>距离最近的点 t</strong></li><li>把t加入S</li><li>用t更新其他点的距离<ul><li>从t出去所有的边能不能</li></ul></li></ul></li></ul><blockquote><p>给定一个 n个点 m条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 1 号点到 n号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];<span class="comment">//邻接矩阵存图,g[i][j]:从点i到点j的权重是g[i][j] </span></span><br><span class="line"><span class="keyword">int</span> dist[N];<span class="comment">//dist[i]:从第一个点到第i个点的最短距离 </span></span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//st[i]:标记第i个点是否在S中 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//第一个点到起点的距离为0 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//迭代n次 </span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){<span class="comment">//找 不在S中距离的 到第一个点的距离最短的那个点 </span></span><br><span class="line"><span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[j]&lt;dist[t]))</span><br><span class="line">t=j;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//用这个点 去更新其他点到第一个点的距离 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">}</span><br><span class="line">st[t]=<span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">g[a][b]=<span class="built_in">min</span>(g[a][b],c);<span class="comment">//处理重边 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">dijkstra</span>();</span><br><span class="line">cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="堆优化版"><a href="#堆优化版" class="headerlink" title="堆优化版"></a>堆优化版</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">150005</span>,M=<span class="number">150005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>{</span><br><span class="line">e[idx]=y,ne[idx]=h[x],w[idx]=z,h[x]=idx,idx++;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;</span><br><span class="line"><span class="comment">//heap维护的是 不在S中的点以及它们离起点最近的距离 </span></span><br><span class="line">heap.<span class="built_in">push</span>({<span class="number">0</span>,<span class="number">1</span>});<span class="comment">//dist=0 point=1；</span></span><br><span class="line"><span class="keyword">while</span>(heap.<span class="built_in">size</span>()){</span><br><span class="line">PII k=heap.<span class="built_in">top</span>();</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> ver=k.second,distance=k.first;</span><br><span class="line"><span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver]=<span class="literal">true</span>;</span><br><span class="line"><span class="comment">//用当前点更新其他点的距离 </span></span><br><span class="line"><span class="comment">// i是头结点的为h[ver]的那条链上的所有边的下标，w[i]就是边ver到边i的距离</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;distance+w[i]){</span><br><span class="line">dist[j]=distance+w[i];</span><br><span class="line">heap.<span class="built_in">push</span>({dist[j],j});<span class="comment">//小根堆每次取出的队头元素都是最小的 </span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="built_in">add</span>(x,y,z);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n次</span><br><span class="line">    <span class="keyword">for</span> 所有m条边a-b：w</span><br><span class="line">        dist[b]=<span class="built_in">min</span>(dist[b],dist[a]+w);</span><br></pre></td></tr></tbody></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="AcWing1224-交换瓶子"><a href="#AcWing1224-交换瓶子" class="headerlink" title="AcWing1224 交换瓶子"></a>AcWing1224 交换瓶子</h2><h3 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h3><p>N个随机排列的数字，编号1-N，<strong>每次交换任意两个数字</strong>，直到最后序号为1-N的升序，求最小交换次数</p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><ul><li><p>把每个瓶子看成一个点，将每个瓶子向它应该在的位置的编号</p><p><img src="https://i.bmp.ovh/imgs/2022/04/03/194ca1fb2eaee9a7.png" style="zoom: 33%;"></p></li></ul><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        {</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; !st[j]; j = b[j])</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/174698/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></tbody></table></figure><p>另外，暴力出奇迹</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,cnt=<span class="number">0</span>;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]!=i){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line"><span class="keyword">if</span>(a[j]==i){</span><br><span class="line"><span class="built_in">swap</span>(a[i],a[j]);cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;BFS、DFS、Flood Fill&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="图论" scheme="http://example.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="搜索" scheme="http://example.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>【题解】数据结构</title>
    <link href="http://example.com/2022/03/22/2022-03-22-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/03/22/2022-03-22-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-22T01:55:34.000Z</published>
    <updated>2022-07-13T10:08:48.861Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>链表</li><li>哈希表</li><li>并查集：在近乎<strong>O(1)</strong>的情况下，<ul><li>关键：p[N]初始化，find(int a)：返回a所在集合的编号</li><li><strong>合并 </strong>两集合 </li><li><strong>询问</strong> 两元素是否在同一集合</li></ul></li></ul></li></ul><span id="more"></span><h1 id="链表与邻接表"><a href="#链表与邻接表" class="headerlink" title="链表与邻接表"></a>链表与邻接表</h1><h2 id="数组模拟单链表（邻接表）"><a href="#数组模拟单链表（邻接表）" class="headerlink" title="数组模拟单链表（邻接表）"></a>数组模拟单链表（邻接表）</h2><ul><li>邻接表：常用于存储图和树</li></ul><h3 id="AcWing826-单链表（模板题）"><a href="#AcWing826-单链表（模板题）" class="headerlink" title="AcWing826 单链表（模板题）"></a>AcWing826 单链表（模板题）</h3><ul><li>一般来说，如果想删除链表第一个节点，会说“删除头结点”，如果想删除整个链表，会直接说“删除整个链表”~ head是指向头结点的指针，它本身是不存节点的，只是<strong>指向了整个链表的第一个节点</strong>。</li><li>初始化：head=-1；idx=0；</li><li>头插法：赋值、指向当前head的next、更新head，idx++</li><li>插到指定位置k后面：赋值，更新next</li><li>删除位置k的元素：将k的next指向k的next的next</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="comment">//head=头结点下标</span></span><br><span class="line"><span class="comment">//e[i]:节点i的值</span></span><br><span class="line"><span class="comment">//ne[i]:节点i的下一个的坐标</span></span><br><span class="line"><span class="comment">//idx:指向当前即将处理的点的坐标 </span></span><br><span class="line"><span class="keyword">int</span> head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">head=<span class="number">-1</span>;</span><br><span class="line">idx=<span class="number">0</span>;</span><br><span class="line">} </span><br><span class="line"><span class="comment">//将x插入到头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">e[idx]=x,ne[idx]=head,head=idx,idx++;</span><br><span class="line">} </span><br><span class="line"><span class="comment">//将x插到下标是k的点的后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">e[idx]=x,ne[idx]=ne[k],ne[k]=idx,idx++;</span><br><span class="line">} </span><br><span class="line"><span class="comment">//将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">ne[k]=ne[ne[k]];</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> m; cin&gt;&gt;m;</span><br><span class="line"><span class="built_in">init</span>(); <span class="comment">//!!!!!!!!别忘记初始化</span></span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> k,x;</span><br><span class="line"><span class="keyword">char</span> op; cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'H'</span>){</span><br><span class="line">cin&gt;&gt;x;<span class="built_in">add_to_head</span>(x);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'D'</span>){</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>) head=ne[head];</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">remove</span>(k<span class="number">-1</span>);</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">cin&gt;&gt;k&gt;&gt;x; <span class="built_in">add</span>(k<span class="number">-1</span>,x);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head;i!=<span class="number">-1</span>;i=ne[i]) cout&lt;&lt;e[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数组模拟双链表"><a href="#数组模拟双链表" class="headerlink" title="数组模拟双链表"></a>数组模拟双链表</h2><ul><li>双链表：用来优化某些题</li></ul><p><a href="https://www.acwing.com/problem/content/829/">827. 双链表 - AcWing题库</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> l[M],r[M],e[M],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">r[<span class="number">0</span>]=<span class="number">1</span>;l[<span class="number">1</span>]=<span class="number">0</span>;idx=<span class="number">2</span>; <span class="comment">//0左边界、1右边界</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>{<span class="comment">//第k个插入的数后面插入v</span></span><br><span class="line">e[idx]=v;</span><br><span class="line">l[idx]=k,r[idx]=r[k];</span><br><span class="line">l[r[k]]=idx,r[k]=idx;</span><br><span class="line">idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span>{</span><br><span class="line">l[r[k]]=l[k];</span><br><span class="line">r[l[k]]=r[k];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> m;cin&gt;&gt;m;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line">string s;<span class="keyword">int</span> k,x; cin&gt;&gt;s;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">"L"</span>){</span><br><span class="line">cin&gt;&gt;x; <span class="built_in">insert</span>(<span class="number">0</span>,x);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"R"</span>){</span><br><span class="line">cin&gt;&gt;x; <span class="built_in">insert</span>(l[<span class="number">1</span>],x);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"D"</span>){</span><br><span class="line">cin&gt;&gt;k; <span class="built_in">remove</span>(k+<span class="number">1</span>);</span><br><span class="line">}<span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="string">"IL"</span>){</span><br><span class="line">cin&gt;&gt;k&gt;&gt;x; <span class="built_in">insert</span>(l[k+<span class="number">1</span>],x);</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">cin&gt;&gt;k&gt;&gt;x; <span class="built_in">insert</span>(k+<span class="number">1</span>,x);  <span class="comment">//k-1+2</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=r[<span class="number">0</span>];i!=<span class="number">1</span>;i=r[i])  <span class="comment">//遍历</span></span><br><span class="line">cout&lt;&lt;e[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="数组模拟栈"><a href="#数组模拟栈" class="headerlink" title="数组模拟栈"></a>数组模拟栈</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> st[N], top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--){</span><br><span class="line">        string s; cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"push"</span>){</span><br><span class="line">            <span class="keyword">int</span> a; cin &gt;&gt; a;</span><br><span class="line">            st[++top] = a;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"pop"</span>) top --;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"query"</span>) cout &lt;&lt; st[top] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">"empty"</span>) cout &lt;&lt; (top == <span class="number">-1</span> ? <span class="string">"YES"</span> : <span class="string">"NO"</span>) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- ){</span><br><span class="line">        string op;</span><br><span class="line">        <span class="keyword">int</span> x; cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"push"</span>){</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            q[ ++ tt] = x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"pop"</span>) hh ++ ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"empty"</span>) cout &lt;&lt; (hh &lt;= tt ? <span class="string">"NO"</span> : <span class="string">"YES"</span>) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; q[hh] &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><a href="https://www.acwing.com/problem/content/832/">830. 单调栈 - AcWing题库</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;stk;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="keyword">int</span> x;cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">while</span>(stk.<span class="built_in">size</span>()&amp;&amp;stk.<span class="built_in">top</span>()&gt;=x) stk.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(!stk.<span class="built_in">size</span>()) cout&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="string">' '</span>;</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">cout&lt;&lt;stk.<span class="built_in">top</span>()&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">}</span><br><span class="line">stk.<span class="built_in">push</span>(x);</span><br><span class="line">}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>求滑动窗口的max、min</p><p><img src="https://s2.loli.net/2022/07/13/SVzKWucn3aB7kDs.png" alt="image.png" style="zoom:33%;"></p><p><a href="https://www.acwing.com/problem/content/156/">154. 滑动窗口 - AcWing题库</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],q[N];</span><br><span class="line"><span class="comment">//q存储的是下标不是值 </span></span><br><span class="line"><span class="keyword">int</span> hh,tt=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>); ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="comment">//min</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt&amp;&amp;i-k+<span class="number">1</span>&gt;q[hh]) hh++;</span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&gt;=a[i]) tt--;</span><br><span class="line">q[++tt]=i; </span><br><span class="line"><span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="string">' '</span>; </span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//max</span></span><br><span class="line">hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt&amp;&amp;i-k+<span class="number">1</span>&gt;q[hh]) hh++;</span><br><span class="line"><span class="keyword">while</span>(hh&lt;=tt&amp;&amp;a[q[tt]]&lt;=a[i]) tt--;</span><br><span class="line">q[++tt]=i; </span><br><span class="line"><span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="string">' '</span>; </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>用到哈希表的情况：把一个大的空间<strong>映射</strong>到一个小的空间</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li>存储结构<ul><li><strong>开放寻址法</strong></li><li>拉链法：开一个一维数组，存储所有的哈希值</li></ul></li><li>字符串哈希方式</li></ul><p>离散化可以看成是一种特殊的哈希，之前的那个离散化要保证顺序</p><h2 id="AcWing840-模拟散列表"><a href="#AcWing840-模拟散列表" class="headerlink" title="AcWing840 模拟散列表"></a>AcWing840 模拟散列表</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>维护一个<strong>集合</strong>，支持下列操作：</p><ul><li>lx：  <strong>插入</strong>一个数</li><li>Qx：<strong>询问</strong>x是否在集合中出现过</li></ul><p>对于N次操作，输出询问结果</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>N行：N个操作，虽然<code>-10^9 &lt;= x &lt;= 10^9</code> 但是，N最大取到10^5，所以实际<strong>只涉及10^5个数</strong>；</p></li><li><p>题目操作<strong>只有插入和查询</strong>而已，没有说要插入到哪个位置，而只是插入到了一个无序的集合中，<strong>并且没有顺序</strong>要求。</p></li><li><p>对于插入操作，我们可以把要插入的每个数存到一个哈希表里里面</p></li><li><p>x mod 10^5 </p><ul><li>一般来说，取模的这个数要是<strong>质数</strong>，且离2的整数次幂远</li><li>因此确定数组大小后，首先找一个<strong>大于最大数据范围的一个质数</strong></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找第一个大于dest的质数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=dest;;i++){</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j*j&lt;=i;j++){</span><br><span class="line">        <span class="keyword">if</span>(i%j==<span class="number">0</span>){</span><br><span class="line">            flag=<span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(flag){</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;<span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>冲突：把两个不一样的数映射成同一个数；处理冲突：开放寻址or拉链法</p></li><li><p>拉链法：开一个一维数组；每个位置可以看成一个槽，存储当前槽上已有的数；</p><ul><li>期望算法，每条链（单链表）的长度可以看成常数；一般哈希表的算法题<strong>只有添加和查找</strong>操作，没有删除操作；如果要实现删除，并不是真的删掉，而是打一个标记</li></ul><p><img src="https://i.bmp.ovh/imgs/2022/04/01/42a9f53c1acb8955.png" style="zoom:33%;"></p></li></ul><h3 id="代码-拉链法"><a href="#代码-拉链法" class="headerlink" title="代码(拉链法)"></a>代码(拉链法)</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100003</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> k=(x%N+N)%N;<span class="comment">//保证余数是整数</span></span><br><span class="line">e[idx]=x,ne[idx]=h[k],h[k]=idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[k];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line"><span class="keyword">if</span>(e[i]==x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="comment">//要读如字符，但用的是scanf的话尽量读入的是一个字符串</span></span><br><span class="line"><span class="comment">//因为这样scanf会自动把空格、回车等给忽略掉 </span></span><br><span class="line"><span class="comment">//降低出错的概率 </span></span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,op,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(*op==<span class="string">'I'</span>) <span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="代码（开放寻址法比较nice）"><a href="#代码（开放寻址法比较nice）" class="headerlink" title="代码（开放寻址法比较nice）"></a>代码（开放寻址法比较nice）</h3><p>开放寻址法：只开了一个一维数组，一般要开到题目数据范围的<strong>2-3倍</strong>（首先要找到这个大于最大数据范围的一个质数）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">200003</span>,null=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="comment">//将x映射到数组下标内 </span></span><br><span class="line"><span class="keyword">int</span> k=(x%N+N)%N;</span><br><span class="line"><span class="comment">//如果不存在，则返回的是它应该存储的位置 </span></span><br><span class="line"><span class="keyword">while</span>(h[k]!=null&amp;&amp;h[k]!=x){</span><br><span class="line">        <span class="comment">//如果当前数组已经放了数据且数据不等于x</span></span><br><span class="line"><span class="comment">//就一直往后找 </span></span><br><span class="line">k++;</span><br><span class="line"><span class="keyword">if</span>(k==N) k=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//如果x在哈希表中已经存在，则返回x所在的位置</span></span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n; </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];<span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d"</span>,op,&amp;x);</span><br><span class="line"><span class="keyword">int</span> k=<span class="built_in">find</span>(x);</span><br><span class="line"><span class="keyword">if</span>(*op==<span class="string">'I'</span>){</span><br><span class="line">h[k]=x;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(h[k]!=null) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="字符串哈希（前缀）"><a href="#字符串哈希（前缀）" class="headerlink" title="字符串哈希（前缀）"></a>字符串哈希（前缀）</h2><ul><li></li></ul><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>用于（近乎<strong>O（1）</strong>）快速地：</p><ol><li>将两个集合<strong>合并</strong></li><li><strong>询问</strong>两个元素是否在一个集合当中</li></ol><p><strong>基本原理</strong>：</p><ul><li>每个集合用一颗<strong>树</strong>维护，每棵树<strong>的根节点</strong>的编号即当前集合的编号</li><li>对于每个点，都存储<strong>它的父节点</strong>是谁 ：p[x]表示x的父节点</li><li>当要找某个点是否属于某个集合时，就<strong>往上找</strong>到根节点</li></ul><p><strong>如何判断树根：</strong></p><ul><li><code>if(p[x]==x)</code></li></ul><p><strong>如何求x的集合编号</strong></p><ul><li><code>while(p[x]!=x) x=p[x]</code>;</li><li>复杂度优化（路径压缩）：当x往上找的时候，一旦找到根节点，就把这条路径上的所有节点的父节点都指向根节点；基本上就能看成O（1）</li></ul><p><strong>如何合并两个集合</strong></p><ul><li>p[x]是x的集合编号，p[y]是y的集合编号：<code>p[x]=y</code></li></ul><hr><h2 id="AcWing836-合并集合（模板题）"><a href="#AcWing836-合并集合（模板题）" class="headerlink" title="AcWing836 合并集合（模板题）"></a>AcWing836 合并集合（模板题）</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>进行 m个操作，操作有两种：</p><ol><li><code>M a b</code>，将编号为 a和 b的两个数所在的集合<strong>合并</strong>，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，<strong>询问</strong>编号为 a和 b 的两个数是否在<strong>同一个集合</strong>中；</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];<span class="comment">//p[i]:编号为i的节点的父节点 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关键方法find：返回x所在集合的编号（祖宗节点）+路径压缩 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="comment">//如果x不是祖宗节点的话，就让它的父节点=它父节点的祖宗节点：往上递归</span></span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]); </span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">char</span> op;<span class="keyword">int</span> a,b;cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'M'</span>) p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b); <span class="comment">//合并两个集合</span></span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"No"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h2 id="AcWing837-连通块中点的数量"><a href="#AcWing837-连通块中点的数量" class="headerlink" title="AcWing837 连通块中点的数量"></a>AcWing837 连通块中点的数量</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定一个包含 n个点（编号为 1∼n1∼n）的<strong>无向</strong>图，初始时图中<strong>没有</strong>边。</p><p>进行 m 个操作，操作共有三种：</p><ol><li><code>C a b</code>，在点 a 和点 b间<strong>连一条边</strong>，a和 b 可能相等；</li><li><code>Q1 a b</code>，<strong>询问</strong>点 a 和点 b 是否在<strong>同一个</strong>连通块中，a和 b可能相等；</li><li><code>Q2 a</code>，询问点 a <strong>所在</strong>连通块中<strong>点的数量</strong>；</li></ol><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>两个点之间连一条边==合并两个集合；</li><li>只是多了一个统计集合中点的数量的操作而已</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N],cnt[N];</span><br><span class="line"><span class="comment">//cnt[i]表示的是 根节点i 所在集合的大小 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">p[i]=i;</span><br><span class="line">cnt[i]=<span class="number">1</span>;</span><br><span class="line">} <span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line">string op;<span class="keyword">int</span> a,b;cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">"C"</span>){</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//下面这两行顺便别颠倒了 </span></span><br><span class="line">cnt[<span class="built_in">find</span>(b)]+=cnt[<span class="built_in">find</span>(a)]; </span><br><span class="line">p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"Q1"</span>){</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"No"</span>&lt;&lt;endl;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">cout&lt;&lt;cnt[<span class="built_in">find</span>(a)]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;哈希表&lt;/li&gt;
&lt;li&gt;并查集：在近乎&lt;strong&gt;O(1)&lt;/strong&gt;的情况下，&lt;ul&gt;
&lt;li&gt;关键：p[N]初始化，find(int a)：返回a所在集合的编号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合并 &lt;/strong&gt;两集合 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;询问&lt;/strong&gt; 两元素是否在同一集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【题解】一些总结</title>
    <link href="http://example.com/2022/03/18/2022-03-18-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/"/>
    <id>http://example.com/2022/03/18/2022-03-18-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E/</id>
    <published>2022-03-18T11:08:20.000Z</published>
    <updated>2022-07-12T10:56:46.520Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容<ul><li>没有主要的，全是次要的小东西</li></ul></li></ul><span id="more"></span><h1 id="多点测试的几种输入方式"><a href="#多点测试的几种输入方式" class="headerlink" title="多点测试的几种输入方式"></a>多点测试的几种输入方式</h1><ul><li><p>没有说明有多少数据需要读入时；<code>ctrl Z+Enter</code>结束</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) != EOF){}</span><br><span class="line"><span class="comment">//scanf返回：成功读入参数的个数；读入失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">gets</span>(str) != <span class="literal">NULL</span>){}<span class="comment">//谨此纪念因为把这个给忘了导致buaa机试爆零的惨痛教训QAQ</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>输入数据满足某个条件时停止输入</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b) != EOF){ </span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">    ... </span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b)!=EOF,a||b){ }</span><br></pre></td></tr></tbody></table></figure></li><li><p>给出测试数据的组数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(T--){}</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="常用头文件"><a href="#常用头文件" class="headerlink" title="常用头文件"></a>常用头文件</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">}  </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="cin读入加速"><a href="#cin读入加速" class="headerlink" title="cin读入加速"></a>cin读入加速</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//之前做过一道题，即使加速了仍然可能tle，数据真的较大的话还是用scanf和printf吧</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="int最大值最小值"><a href="#int最大值最小值" class="headerlink" title="int最大值最小值"></a>int最大值最小值</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> maximum=INT_MAX;</span><br><span class="line"><span class="keyword">int</span> minimum=INT_MIN;</span><br></pre></td></tr></tbody></table></figure><h1 id="输出long-long"><a href="#输出long-long" class="headerlink" title="输出long long"></a>输出long long</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,x);</span><br></pre></td></tr></tbody></table></figure><p>long long的最大值最小值</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LONG_LONG_MAX</span><br><span class="line">LONG_LONG_MIN</span><br></pre></td></tr></tbody></table></figure><h1 id="scanf读单个字符"><a href="#scanf读单个字符" class="headerlink" title="scanf读单个字符"></a>scanf读单个字符</h1><p>如果直接读入char字符的话，scanf的%c可能会读入一些空格回车等莫名其妙的 东西，用%s的话就会自动忽略那些莫名其妙的空格回车</p><p>所以用scanf读字符的话，建议读成字符串的形式，过滤掉空格回车</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op);<span class="comment">//a</span></span><br><span class="line">cout&lt;&lt;op[<span class="number">0</span>];   <span class="comment">//a</span></span><br></pre></td></tr></tbody></table></figure><h2 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h2><p>读入单个字符,包括换行</p><h1 id="读取一行字符串"><a href="#读取一行字符串" class="headerlink" title="读取一行字符串"></a>读取一行字符串</h1><h2 id="char"><a href="#char" class="headerlink" title="char[]"></a>char[]</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">1001</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(s,<span class="number">1000</span>);<span class="comment">//第二个参数为 允许输入的最大长度</span></span><br></pre></td></tr></tbody></table></figure><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin,s);</span><br></pre></td></tr></tbody></table></figure><p>当同时使用<code>cin&gt;&gt;</code>和<code>getline(cin,str)</code>的时候，在<code>cin&gt;&gt;</code>输入完成之后，<code>getline(cin,str)</code>(str是真正想要的串)之前，需要<strong>先</strong><code>getline(cin,str)</code>（这个str是一个打算用来存储回车符的串）；</p><p>将回车符从输入流缓存中清除</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;string line;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="built_in">getline</span>(cin,line);<span class="comment">//去掉换行</span></span><br><span class="line"><span class="built_in">getline</span>(cin,line);<span class="comment">//真正读取这一串字符</span></span><br></pre></td></tr></tbody></table></figure><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><h2 id="右对齐"><a href="#右对齐" class="headerlink" title="右对齐"></a>右对齐</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%5d"</span>,a);<span class="comment">//补空格</span></span><br><span class="line"><span class="comment">//输出:  123</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%05d"</span>,a);<span class="comment">//补0</span></span><br><span class="line"><span class="comment">//输出:00123</span></span><br></pre></td></tr></tbody></table></figure><h2 id="保留小数"><a href="#保留小数" class="headerlink" title="保留小数"></a>保留小数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d=<span class="number">12.3456</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1f"</span>,d);<span class="comment">//保留一位小数:采用"四舍六入五成双"规则</span></span><br><span class="line"><span class="comment">//输出:12.2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">round</span>(<span class="keyword">double</span> x) <span class="comment">//四舍五入,返回double类型</span></span><br></pre></td></tr></tbody></table></figure><h1 id="常用math函数"><a href="#常用math函数" class="headerlink" title="常用math函数"></a>常用math函数</h1><h2 id="绝对值"><a href="#绝对值" class="headerlink" title="绝对值"></a>绝对值</h2><p><code>fabs(double x)</code></p><h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><p><code>floor(double x)</code> 下取整,返回double类型</p><p><code>ceil(double x)</code>上取整,返回double类型</p><h2 id="次方"><a href="#次方" class="headerlink" title="次方"></a>次方</h2><p><code>pow(double r,double p)</code>: 返回$r^p$</p><h2 id="平方"><a href="#平方" class="headerlink" title="平方"></a>平方</h2><p><code>sqrt(double x)</code> 返回double类型</p><h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><p><code>log(double x)</code> ,求以<strong>自然对数</strong>为底的对数,  返回double类型</p><p>换地公式  $log_{a}b=log_{e}b/log_{e}a$</p><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sin</span>(<span class="keyword">double</span> x),<span class="built_in">cos</span>(<span class="keyword">double</span> x),<span class="built_in">tan</span>(<span class="keyword">double</span> x);<span class="comment">//弧度制,返回double</span></span><br><span class="line"><span class="built_in">asin</span>(<span class="keyword">double</span> x),<span class="built_in">acos</span>(<span class="keyword">double</span> x),<span class="built_in">atan</span>(<span class="keyword">double</span> x)</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容&lt;ul&gt;
&lt;li&gt;没有主要的，全是次要的小东西&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
  </entry>
  
</feed>
