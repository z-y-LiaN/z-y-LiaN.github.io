<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiaN</title>
  
  <subtitle>是一只废物捏</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-04T11:44:50.646Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>LiaN</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【机器学习】逻辑回归模型Logistic</title>
    <link href="http://example.com/2022/09/04/2022-09-04-%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8BLogistic/"/>
    <id>http://example.com/2022/09/04/2022-09-04-%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8BLogistic/</id>
    <published>2022-09-04T11:44:01.000Z</published>
    <updated>2022-09-04T11:44:50.646Z</updated>
    
    <content type="html"><![CDATA[<p>logistic 逻辑回归模型</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;logistic 逻辑回归模型&lt;/p&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习】朴素贝叶斯</title>
    <link href="http://example.com/2022/09/04/2022-09-04-%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <id>http://example.com/2022/09/04/2022-09-04-%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</id>
    <published>2022-09-04T07:52:21.000Z</published>
    <updated>2022-09-04T11:54:23.216Z</updated>
    
    <content type="html"><![CDATA[<p>朴素贝叶斯</p><span id="more"></span><blockquote><p>参考文献链接：</p><p><a href="https://blog.csdn.net/sinat_30353259/article/details/80932111">机器学习之朴素贝叶斯算法详解_平原2018的博客</a></p><p><a href="https://www.bilibili.com/video/BV1a4411B7B4?spm_id_from=333.337.search-card.all.click&amp;vd_source=29f5937d4c8dc6b894a81d48deba4d66">「一个模型」教你搞定贝叶斯和全概率公式_哔哩哔哩_bilibili</a></p><p><a href="https://zhuanlan.zhihu.com/p/150641206">为什么朴素贝叶斯定理会被叫做朴素的？ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/weixin_40849273/article/details/83651201?ops_request_misc=%7B%22request%5Fid%22%3A%22166227509316782246465759%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166227509316782246465759&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-5-83651201-null-null.nonecase&amp;utm_term=贝叶斯&amp;spm=1018.2226.3001.4450">贝叶斯算法_水月清的博客</a></p><p><a href="https://blog.csdn.net/asialee_bird/article/details/81486700">TF-IDF算法介绍及实现_Asia-Lee的博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/97273457">TF-IDF 原理与实现 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/wenkang2261/article/details/107592416">文本主题分类（TFIDF-朴素贝叶斯分类）_一只躺在风口的�的博客</a></p></blockquote><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul><li><p><strong>先验概率</strong>：$P(A)$：在不考虑任何情况下，事件A发生的概率</p></li><li><p><strong>联合概率</strong>：$P(AB)$：两个（或更多）不同事件同时发生的概率，即两个（或更多）同时发生的事件</p></li><li><p><strong>条件概率</strong>：$P(A|B)$：在事件B已发生的情况下，事件A发生的概率</p><p>若只有事件A和B，因为：$\mathrm{P}(\mathrm{AB})=\mathrm{P}(\mathrm{A} \mid \mathrm{B}) \mathrm{P}(\mathrm{B})=\mathrm{P}(\mathrm{B} \mid \mathrm{A}) \mathrm{P}(\mathrm{A})$，因此，得到贝叶斯公式：</p><script type="math/tex; mode=display">\mathrm{P}(\mathrm{A} \mid \mathrm{B})=\frac{\mathrm{P}(\mathrm{B} \mid \mathrm{A}) * \mathrm{P}(\mathrm{A})}{\mathrm{P}(\mathrm{B})}</script></li></ul><p>  <img src="https://s2.loli.net/2022/09/04/2vthPXDwLnl6SIM.png" alt="image.png" style="zoom: 43%;"></p><h2 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h2><script type="math/tex; mode=display">P(B)=P\left(A_{1}\right) P\left(B \mid A_{1}\right)+P\left(A_{2}\right) P\left(B \mid A_{2}\right)+\ldots+P\left(A_{n}\right) P\left(B \mid A_{n}\right)</script><h2 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h2><script type="math/tex; mode=display">P\left(A_{i} \mid B\right)=\frac{P\left(A_{i}\right) P\left(B \mid A_{i}\right)}{\sum_{j=1}^{n} P\left(A_{j}\right) P\left(B \mid A_{j}\right)}=\frac{P\left(A_{i}\right) P\left(B \mid A_{i}\right)}{P\left(A_{1}\right) P\left(B \mid A_{1}\right)+\ldots+P\left(A_{n}\right) P\left(B \mid A_{n}\right)}</script><p>对于上式，分母是一个<strong>固定值</strong>，只需要比较分子大小即可。把$P(A_i)$称为先验概率，$P(A_i|B)$称为后验概率，$P(B|A_i)$称为似然函数：<strong>先验 * 似然 = 后验</strong></p><h2 id="生成模型-vs-判别模型"><a href="#生成模型-vs-判别模型" class="headerlink" title="生成模型 vs 判别模型"></a>生成模型 vs 判别模型</h2><p>生成模型</p><ul><li>由数据学得联合概率分布，求出条件概率分布P(Y|X)的预测模型；</li></ul><p>判别模型</p><ul><li>由数据学得决策函数或条件概率分布作为预测模型</li></ul><h2 id="最大似然-vs-奥卡姆剃刀"><a href="#最大似然-vs-奥卡姆剃刀" class="headerlink" title="最大似然 vs 奥卡姆剃刀"></a>最大似然 vs 奥卡姆剃刀</h2><p><strong>最大似然</strong></p><ul><li>最符合观测数据的最有优势</li><li>根据观测的数据找出哪些是最有优势的，比如投一个硬币就投一次，观测到的为正，那么根据最大似然估计可以预测下一次投正的概率为1，这只是投一次的情况，如果投很多次，那也能预测出投正的概率大概为0.5，简单来说，最大似然估计原理就是根据投掷结果来预测以后</li></ul><p><strong>奥卡姆剃刀</strong></p><ul><li>认为<strong>先验概率较大</strong>的具有较大的优势，追寻的是实际中什么东西最常见什么东西就是越好的。</li></ul><h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><p>🔴 <strong>概括</strong>：朴素贝叶斯是<strong>生成模型</strong>，基于很强的条件独立假设（在已知分类c的条件下，各个特征变量取值是<strong>相互独立</strong>的），根据<strong>已有样本</strong>学习出先验概率$p(c)$，和 条件概率$p(\boldsymbol x|c$)，计算出联合概率$p(\boldsymbol x,c)$，再利用贝叶斯定理求出条件概率$p(c|\boldsymbol x)$。</p><p>🔴 <strong>为什么说“朴素”？</strong>：因为朴素贝叶斯分类假定<strong>所有的特征</strong>在数据集中的作用是<strong>同样重要和独立</strong>的，而这个假设在现实世界中是很不真实的（确切的说，应该是很“天真”，英文：“naive bayes”），毕竟现实世界中，特征之间存在一定的<strong>依赖</strong>关系</p><p>特征条件独立假设 在分类问题中，常常需要把一个事物分到某个类别中。已知一个事物有许多属性$\boldsymbol x=(x_1,x_2,\dots,x_n)$，求其属于类别$c$的概率</p><p>朴素贝叶斯的假设函数：</p><script type="math/tex; mode=display">h(\boldsymbol{x})=p(c \mid \boldsymbol{x})=\frac{p(\boldsymbol{x}, c)}{p(\boldsymbol{x})}=\frac{p(\boldsymbol{x} \mid c) p(c)}{p(\boldsymbol{x})}=\frac{p(c) \prod_{i=1}^{n} p\left(x_{i} \mid c\right)}{p(\boldsymbol{x})}</script><p>分母$p(\boldsymbol{x})$是常数，分子中，由于假设特征<strong>独立分布</strong>（各个条件之间互不影响），所以$p(\boldsymbol{x} \mid c) =\prod_{i=1}^{n} p\left(x_{i} \mid c\right)$，因此有：</p><script type="math/tex; mode=display">\hat{y}=\underset{c}{\operatorname{argmax}} p(\widehat{\boldsymbol{x}}, c)=\underset{c}{\operatorname{argmax}} {\color{Purple} p(c)}  \prod_{i=1}^{n} p\left(\hat{x}_{i} \mid c\right)</script><p>朴素贝叶斯分类器的训练过程就是 基于训练集来估计 <strong>类先验概率</strong>$p(c)$ 的每个特征的<strong>条件概率</strong>$p(x_i|c)$</p><p>根据极大似然估计</p><script type="math/tex; mode=display">\begin{array}{ll}p(c)=\frac{\left|D_{c}\right|}{|D|} & \left|D_{c}\right| \text { : 第 } c \text { 类的样本数 } \\& |D| \text { : 样本总数 }\end{array}</script><script type="math/tex; mode=display">p\left(x_{i} \mid c\right)=\frac{\left|D_{c, x_{i}}\right|}{\left|D_{c}\right|} \quad\left|D_{c, x_{i}}\right| \text { :第c类的样本中 } x_{i} \text { 取值出现的样本数 }</script><p><strong>总结</strong>：朴素贝叶斯就是在统计数据的基础上，依据条件概率公式，计算当前特征的样本属于各个分类的概率，哪个最大，就认为此待分类项属于哪个类别。</p><p><strong>对数据的处理</strong>：</p><ul><li><p><strong>离散</strong>数据：取值类别有限或可数的特征，计算概率十分简单就是数数，计算在某一条件下某一个特征出现的概率即为求解条件概率。</p></li><li><p><strong>连续</strong>数据：取值连续的特征，朴素贝叶斯在处理时<strong>默认各个连续特征都服从正态分布</strong>，根据训练数据计算每个特征的均值和方差，做测试集预测时，带入正态分布的概率密度公直接计算概率密度值作为该特征出现的概率。如果最终的分类数有N种，那么对每个连续特征而言就有N套（均值，方差）分别对应不同的分类类别。</p><p><img src="https://s2.loli.net/2022/09/04/IeTLHNyrid1XBx4.png" alt="image.png" style="zoom:33%;"></p></li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><p>优点</p><ul><li>对小规模数据表现良好、适合多分类任务、增量式训练</li></ul><p>缺点</p><ul><li>对数据数据的表达形式敏感（离散、连续、极大极小）</li></ul><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><h2 id="例1-瓜的预测"><a href="#例1-瓜的预测" class="headerlink" title="例1:瓜的预测"></a>例1:瓜的预测</h2><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">色泽$x_1$</th><th style="text-align:center">敲声$x_2$</th><th style="text-align:center">纹理$x_3$</th><th style="text-align:center">好瓜$y$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">绿</td><td style="text-align:center">响</td><td style="text-align:center">清晰</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">黑</td><td style="text-align:center">闷</td><td style="text-align:center">清晰</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">黑</td><td style="text-align:center">响</td><td style="text-align:center">模糊</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">绿</td><td style="text-align:center">脆</td><td style="text-align:center">清晰</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">黑</td><td style="text-align:center">响</td><td style="text-align:center">清晰</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">绿</td><td style="text-align:center">闷</td><td style="text-align:center">模糊</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center"><font color="red">黑</font></td><td style="text-align:center"><font color="red">响</font></td><td style="text-align:center"><font color="red">模糊</font></td><td style="text-align:center"><font color="red">?</font></td></tr></tbody></table></div><script type="math/tex; mode=display">p(\boldsymbol{x}, c)=p(c) \prod_{i=1}^{n} p\left(x_{i} \mid c\right)</script><p>根据上式，有：$p(是|黑,响,模糊)=p(是)\times [p(x_1=黑|是)\times p(x_2=响|是)\times p(x_3=模糊|是)]$</p><p>计算得到$3/6\times 2/3\times 2/3\times 1/3=4/54$</p><h2 id="拉普拉斯平滑"><a href="#拉普拉斯平滑" class="headerlink" title="拉普拉斯平滑"></a>拉普拉斯平滑</h2><p>如果将上表中第3条数据的纹理属性值改为“清晰”，那么计算的结果会是0，显然有问题。因此，为了解决零概率问题，需要做<strong>加法平滑</strong>，也就是拉普拉斯平滑。</p><p>假定训练样本很大时，每个分量$x$的计数加1造成的估计概率变化可以忽略不计，但可以方便有效的避免零概率问题。</p><p>在分子、分母上各加一个数值，下式中，$N$是<strong>训练集中的类别总数</strong></p><script type="math/tex; mode=display">\tilde{p}(c)=\frac{\left|D_{c}\right|+1}{|D|+N}</script><p>下式中，$N_i$是 <strong>第</strong>$i$<strong>个特征可能的取值数</strong></p><script type="math/tex; mode=display">\tilde{p}\left(x_{i} \mid c\right)=\frac{\left|D_{c, x_{i}}\right|+1}{\left|D_{c}\right|+N_{i}}</script><h2 id="例2-文本分类"><a href="#例2-文本分类" class="headerlink" title="例2:文本分类"></a>例2:文本分类</h2><h3 id="文本分类的多项式模型：重复词语视为出现多次"><a href="#文本分类的多项式模型：重复词语视为出现多次" class="headerlink" title="文本分类的多项式模型：重复词语视为出现多次"></a>文本分类的多项式模型：重复词语视为出现多次</h3><div class="table-container"><table><thead><tr><th style="text-align:center">文档</th><th style="text-align:center">文本</th><th style="text-align:center">标签$y$</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Chinese，Beijing，Chinese</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Chinese，Chinese，Shanghai</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Chinese，Macao</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Tokyo，Japan，Chinese</td><td style="text-align:center">J</td></tr><tr><td style="text-align:center"><font color="red">5</font></td><td style="text-align:center"><font color="red">Chinese，Chinese，Chinese，Tokyo，Japan</font></td><td style="text-align:center"><font color="red">？</font></td></tr></tbody></table></div><p>构建词向量</p><div class="table-container"><table><thead><tr><th>$w_1$</th><th>$w_2$</th><th>$w_3$</th><th>$w_4$</th><th>$w_5$</th><th>$w_6$</th></tr></thead><tbody><tr><td>Beijing</td><td>Chinese</td><td>Japan</td><td>Macao</td><td>Shanghai</td><td>Tokyo</td></tr></tbody></table></div><p>对训练集中 词语的<strong>出现次数</strong> 进行统计</p><div class="table-container"><table><thead><tr><th>N(doc)</th><th>$w_1$</th><th>$w_2$</th><th>$w_3$</th><th>$w_4$</th><th>$w_5$</th><th>$w_6$</th><th>$y$</th></tr></thead><tbody><tr><td>3</td><td>1</td><td>5</td><td>0</td><td>1</td><td>1</td><td>0</td><td>C</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>J</td></tr></tbody></table></div><p>根据公式计算条件概率：$\tilde{p}\left(w_{i} \mid c\right)=\frac{\left|D_{c, w_{i}}\right|+1}{\left|D_{c}\right|+N}$，（$N=6$：因为$w$有6种取值），得到下表：</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:center">$p(doc)$</th><th>$w_1$</th><th>$w_2$</th><th>$w_3$</th><th>$w_4$</th><th>$w_5$</th><th>$w_6$</th></tr></thead><tbody><tr><td>$p(w_i\vert y=C)$</td><td style="text-align:center">$\frac{3}{4}$</td><td>$\frac{2}{14}$</td><td>$\frac{6}{14}$</td><td>$\frac{1}{14}$</td><td>$\frac{2}{14}$</td><td>$\frac{2}{14}$</td><td>$\frac{1}{14}$</td></tr><tr><td>$p(w_i\vert y=J)$</td><td style="text-align:center">$\frac{1}{4}$</td><td>$\frac{1}{9}$</td><td>$\frac{2}{9}$</td><td>$\frac{2}{9}$</td><td>$\frac{1}{9}$</td><td>$\frac{1}{9}$</td><td>$\frac{2}{9}$</td></tr></tbody></table></div><p>因此，对文档5进行预测，比较概率大小，可得属于C类：</p><script type="math/tex; mode=display">\begin{array}{l}p\left(y=\mathrm{C} \mid w_{2} w_{2} w_{2} w_{6} w_{3}\right) \\=p(\text { doc } \mid y=\mathrm{C}) \times{\left[p\left(w_{2} \mid y=\mathrm{C}\right)\right]^{3} \times p\left(w_{6} \mid y=\mathrm{C}\right) \times p\left(w_{3} \mid y=\mathrm{C}\right)} \\=\frac{3}{4} \times\left(\frac{6}{14}\right)^{3} \times \frac{1}{14} \times \frac{1}{14} \approx 3.0 \times 10^{-4}\end{array}</script><script type="math/tex; mode=display">\begin{array}{l}p\left(y=\mathrm{J} \mid w_{2} w_{2} w_{2} w_{6} w_{3}\right) \\=p(\text { doc } \mid y=\mathrm{J}) \times{\left[p\left(w_{2} \mid y=\mathrm{J}\right)\right]^{3} \times p\left(w_{6} \mid y=\mathrm{J}\right) \times p\left(w_{3} \mid y=\mathrm{J}\right)} \\=\frac{1}{4} \times\left(\frac{2}{9}\right)^{3} \times \frac{2}{9} \times \frac{2}{9} \approx 1.4 \times 10^{-4}\end{array}</script><h1 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h1><blockquote><p>在看朴素贝叶斯的文本分类的例子时，无意间看到这个算法，之前听说过，但没仔细看过，nlp相关的，就顺便学一下，虽然这个和朴素贝叶斯没啥关系的样子</p></blockquote><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p> <strong>TF-IDF（term frequency–inverse document frequency，词频-逆向文件频率）</strong>是一种用于信息检索（information retrieval）与文本挖掘（text mining）的常用<strong>加权技术</strong>。</p><p>用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。</p><p><strong>字词的重要性</strong>随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。</p><p>🔴 <strong>TF-IDF的主要思想</strong>：如果某个单词在一篇文章中出现的频率高（IF），并且在其他文章中很少出现（IDF），则认为此词或者短语具有<strong>很好的类别区分能力，适合用来分类</strong>。</p><h2 id="TF：词频（Term-Frequency）"><a href="#TF：词频（Term-Frequency）" class="headerlink" title="TF：词频（Term Frequency）"></a>TF：词频（Term Frequency）</h2><blockquote><p>词条在文本中出现的频率，一般会被归一化（词频 / 文字总词数），以防止它偏向长的文件</p></blockquote><script type="math/tex; mode=display">T F_{i, j}=\frac{n_{i, j}}{\sum_{k} n_{k, j}}</script><p>其中，$n_{i,j}$表示词条$t_i$在文档 $d_j$ 中出现的次数，$TF_{i,j}$ 表示 词条$t_i$在文档$d_j$ 中出现的频率。</p><h2 id="IDF：逆文件频率（Inverse-Document-Frequency）"><a href="#IDF：逆文件频率（Inverse-Document-Frequency）" class="headerlink" title="IDF：逆文件频率（Inverse Document Frequency）"></a>IDF：逆文件频率（Inverse Document Frequency）</h2><blockquote><p>所有统计的文章中，一些词只是在其中很少几篇文章中出现，那么这样的词对文章的主题的作用很大，这些词的权重应该设计的较大。IDF就是在完成这样的工作。</p></blockquote><p><strong>IDF</strong>表示关键词的普遍程度。如果<strong>包含词条 i 的文档越少， IDF越大</strong>，则说明该词条具有很好的类别区分能力。某一特定词语的IDF，可以由<strong>总文档数目</strong>除以<strong>包含该词语的文件的数目</strong>，再将得到的商<strong>取对数</strong>得到</p><script type="math/tex; mode=display">I D F_{i}=\log \frac{|D|}{1+\left|j: t_{i} \in d_{j}\right|}</script><p>其中，$|D|$总文档数目，$\left|j: t_{i} \in d_{j}\right|$ 包含词条$t_i$的文档数目，加1 防止包含词条$t_i$的 文档数目为0导致运算错误。</p><h2 id="TF-IDF-1"><a href="#TF-IDF-1" class="headerlink" title="TF-IDF"></a>TF-IDF</h2><p>某一特定文件内的高词语频率，以及该词语在整个文件集合中的低文件频率，可以产生出高权重的TF-IDF。因此，TF-IDF倾向于<strong>过滤掉常见的词语，保留重要的词语</strong>，表达为</p><script type="math/tex; mode=display">TF-IDF=TF\cdot IDF</script><p> TF-IDF算法非常容易理解，很容易实现，但是其简单结构并没有考虑词语的语义信息，<strong>无法处理一词多义与一义多词的情况</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;朴素贝叶斯&lt;/p&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习】k-means聚类算法</title>
    <link href="http://example.com/2022/09/02/2022-09-02-%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91k-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/09/02/2022-09-02-%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91k-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</id>
    <published>2022-09-02T11:15:32.000Z</published>
    <updated>2022-09-04T06:58:47.189Z</updated>
    
    <content type="html"><![CDATA[<p>K-means聚类算法</p><span id="more"></span><blockquote><p>参考文献链接：</p><p><a href="https://blog.csdn.net/u013850277/article/details/88411966?ops_request_misc=%7B%22request%5Fid%22%3A%22166220862116782390535767%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166220862116782390535767&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-88411966-null-null.nonecase&amp;utm_term=kmeans算法&amp;spm=1018.2226.3001.4450">KMeans 算法（一）_在屋顶听歌的博客</a></p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>聚类（Clustering）</strong>：</p><p>样本集$D=\left\{x^{(1)}, x^{(2)}, \ldots, x^{(m)}\right\} $，包含$m$个无标记样本，每个样本$x^{(i)}=\left[x_{1}^{(i)}, x_{2}^{(i)}, \ldots, x_{n}^{(i)}\right]^{T} $是一个n维特征向量，则聚类算法将样本集$D$划分为$k$个<strong>不相交</strong>的簇$\left\{C^{(l)} \mid l=1,2, \ldots, k\right\}$</p><h1 id="K-means算法"><a href="#K-means算法" class="headerlink" title="K-means算法"></a>K-means算法</h1><p>k-means（k均值）聚类 属于 原型聚类，无监督学习</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p><strong>概括</strong>：随机地从数据集中选取K个点作为聚类中心，计算各个样本到聚类中心的距离，把样本归到离它最近的那个聚类中心所在的类；计算新形成的每一个聚类的数据对象的平均值，得到新的聚类中心，然后再迭代地分配点和更新据诶中心，直到聚类中心变化很小，或达到指定迭代次数。</p><p>▶ <strong>Input：</strong></p><ul><li>训练集Traning set ：$\{x_1,x_2,\dots,x_n\}$</li><li>聚类数量K：number of clusters</li></ul><p>▶ <strong>Step-1</strong>：</p><ul><li><strong>Randomly</strong> initialize K cluster <strong>centroids</strong> ${c_1,c_2,\dots,c_k}$（随机初始化K个聚类中心）</li></ul><p>▶ <strong>Step-2</strong>：</p><ul><li><p>Repeat until convergence</p><p>for each point $x_i$：（为点赋类）</p><ul><li>find the <strong>nearest</strong> centroid $c_j$ （nearest度量准则：距离、相似度）</li><li><strong>assign</strong> the point $x_i$ to cluster $j$</li></ul><p>for each cluster $j\in[1,K]$：（调整中心）</p><ul><li>new centroid $c_j$ = mean of all point $x_i$ assgined to cluster $j$</li></ul></li><li><p>stop when the assignments no longer change.</p></li></ul><p><strong>需要考虑的几点：</strong></p><ul><li><p><strong>K值的选择</strong>： k 值对最终结果的影响至关重要，而它却要预先给定。给定合适的 k 值，需要先验知识，凭空估计很困难，或者可能导致效果很差。</p></li><li><p><strong>异常点的存在</strong>：在迭代的过程中使用<u>所有点的均值</u>作为新的质点(中心点)，如果簇中存在异常点，将导致<strong>均值偏差</strong>比较严重。</p><blockquote><p>比如一个簇中有2、4、6、8、100五个数据，则新的质点为24，显然这个质点离绝大多数点都较远；当前情况下，使用中位数6可能比使用均值更好，使用<strong>中位数</strong>的聚类方式叫做K-Mediods聚类(K中值聚类)。</p></blockquote></li><li><p><strong>初值敏感</strong>：选择不同的初始值可能导致不同的簇划分规则。为避免这种敏感性导致的最终结果异常性，可以采用<strong>初始化多套初始节点</strong>构造不同的分类规则，然后选择最优的构造规则。</p><blockquote><p>针对这点后面因此衍生了：二分K-Means算法、K-Means++算法、K-Means||算法、Canopy算法等。</p><p>详见：<a href="https://blog.csdn.net/u013850277/article/details/88411966?ops_request_misc=%7B%22request%5Fid%22%3A%22166220862116782390535767%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166220862116782390535767&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-88411966-null-null.nonecase&amp;utm_term=kmeans算法&amp;spm=1018.2226.3001.4450">KMeans 算法（一）_在屋顶听歌的博客</a></p></blockquote></li></ul><h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><blockquote><p>使目标函数极小化</p></blockquote><p>选取<strong>欧式距离</strong>作为相似度指标，聚类目标是使得各类的距离平方和最小，定义样本点与所属聚类中心之间的距离总和为损失函数</p><script type="math/tex; mode=display">W(C)=\sum_{k=1}^{K} \sum_{x \in C_{k}}\left\|x-\mu_{k}\right\|^{2}</script><p>其中，$K$是聚类个数，$\mu _k$ 是第$k$个类的均值。因此，目标函数为：</p><script type="math/tex; mode=display">C^*=\mathop{\arg\min}\limits_{C}W(C)</script><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>原理简单、实现容易，收敛速度快</li><li>适用于高维数据</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>初始聚类中心不好把握</li><li>迭代→局部最优</li><li>对噪音和异常点敏感</li><li>不能处理非球形簇的聚类问题</li></ul><h1 id="距离和相似度"><a href="#距离和相似度" class="headerlink" title="距离和相似度"></a>距离和相似度</h1><h2 id="闵可夫斯基距离（Minkowski-distance）"><a href="#闵可夫斯基距离（Minkowski-distance）" class="headerlink" title="闵可夫斯基距离（Minkowski distance）"></a>闵可夫斯基距离（Minkowski distance）</h2><p>给定样本集合$X$，$X$是n维实数向量空间$R^n$中点的集合，其中</p><script type="math/tex; mode=display">x^{(i)}=\left[\begin{array}{llllll}x_{1}^{(i)}, & x_{2}^{(i)}, & \cdots & x_{n}^{(i)}\end{array}\right]^{T} \quad x^{(j)}=\left[\begin{array}{llll}x_{1}^{(j)}, & x_{2}^{(j)}, & \cdots & x_{n}^{(j)}\end{array}\right]^{T} \in R^{n}</script><p>样本$x^{(i)}$和样本$x^{j}$的闵可夫斯基距离定义为：</p><script type="math/tex; mode=display">\operatorname{dis}\left(x^{(i)}, x^{(j)}\right)=\left(\sum_{k=1}^{n}\left|x_{k}^{(i)}-x_{k}^{(j)}\right|^{p}\right)^{\frac{1}{p}} \quad p \geq 1</script><ul><li>$p=1$：曼哈顿距离：$\operatorname{dis}\left(x^{(i)}, x^{(j)}\right)=\sum_{k=1}^{n}\left|x_{k}^{(i)}-x_{k}^{(j)}\right|$</li><li>$p=2$：欧氏距离：$\operatorname{dis}\left(x^{(i)}, x^{(j)}\right)=\left(\sum_{k=1}^{n}\left|x_{k}^{(i)}-x_{k}^{(j)}\right|^{2}\right)^{\frac{1}{2}}$</li><li>$p=\infty$：切比雪夫距离：$\operatorname{dis}\left(x^{(i)}, x^{(j)}\right)=\max _{k}\left|x_{k}^{(i)}-x_{k}^{(j)}\right|$</li></ul><h2 id="马氏距离（Mahalanobis-distance"><a href="#马氏距离（Mahalanobis-distance" class="headerlink" title="马氏距离（Mahalanobis distance)"></a>马氏距离（Mahalanobis distance)</h2><h2 id="相关系数-correlation-coefficient"><a href="#相关系数-correlation-coefficient" class="headerlink" title="相关系数(correlation coefficient)"></a>相关系数(correlation coefficient)</h2><p>相关系数的绝对值越接近于1，样本越相似，越接近于0，越不相似</p><script type="math/tex; mode=display">\begin{array}{c}r\left(x^{(i)}, x^{(j)}\right)=\frac{\sum_{k=1}^{n}\left(x_{k}^{(i)}-\mu_{i}\right)\left(x_{k}^{(j)}-\mu_{j}\right)}{\left[\sum_{k=1}^{n}\left(x_{k}^{(i)}-\mu_{i}\right)^{2} \sum_{k=1}^{n}\left(x_{k}^{(j)}-\mu_{j}\right)^{2}\right]^{\frac{1}{2}}} \\\mu_{i}=\frac{1}{n} \sum_{k=1}^{n} x_{k}^{(i)} \quad \mu_{j}=\frac{1}{n} \sum_{k=1}^{n} x_{k}^{(j)}\end{array}</script><h2 id="夹角余弦相似度"><a href="#夹角余弦相似度" class="headerlink" title="夹角余弦相似度"></a>夹角余弦相似度</h2><p>余弦相似度的绝对值越接近于1，样本越相似，越接近0，越不相似</p><p>余弦相似度定义：</p><script type="math/tex; mode=display">\cos \left(x^{(i)}, x^{(j)}\right)=\frac{\left(x^{(i)}\right)^{T} x^{(j)}}{\left|x^{(i)}\right|\left|x^{(j)}\right|} \quad \in[-1,1]</script><p>归一化的余弦相似度：</p><script type="math/tex; mode=display">\operatorname{sim}_{\cos }=1-\left(\frac{\cos ^{-1}\left(x^{(i)}, x^{(j)}\right)}{\pi}\right) \in[0,1]</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;K-means聚类算法&lt;/p&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【SE】高等数学</title>
    <link href="http://example.com/2022/09/02/2022-09-02-%E3%80%90SE%E3%80%91%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    <id>http://example.com/2022/09/02/2022-09-02-%E3%80%90SE%E3%80%91%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/</id>
    <published>2022-09-02T01:55:34.000Z</published>
    <updated>2022-09-04T06:33:46.015Z</updated>
    
    <content type="html"><![CDATA[<p>高数基础知识</p><span id="more"></span><h1 id="重点部分"><a href="#重点部分" class="headerlink" title="重点部分"></a><strong>重点部分</strong></h1><ul><li>可导、可微、连续、可积之间的关系（一元函数+二元函数）。✅</li><li>三个中值定理的区别、联系和物理意义（罗尔、拉格朗日、柯西），微分中值定理是啥？</li><li>如何求梯度？梯度、方向导数与梯度。✅</li><li>定积分如何求？定积分的意义？</li><li>给你一个物体表面离散的一堆点，如何求任意表面的法向量？</li><li>凸函数的定义，凸函数的局部最优解一定是全局最优解吗，为什么呢？</li><li>什么是数列的极限，也就是说一个数列xn，收敛于a，你如何定义它？</li><li>用数学语言描述极限</li><li>一阶导，二阶导的物理意义，几何意义</li><li>傅里叶级数和傅里叶变换的关系</li></ul><h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="可微、可导、可积、连续"><a href="#可微、可导、可积、连续" class="headerlink" title="可微、可导、可积、连续"></a>可微、可导、可积、连续</h3><blockquote><p><a href="https://blog.csdn.net/SP_FA/article/details/117473545?ops_request_misc=%7B%22request%5Fid%22%3A%22165969690516782350825991%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165969690516782350825991&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-117473545-null-null.nonecase&amp;utm_term=可导与连续的关系&amp;spm=1018.2226.3001.4450">参考阅读： 可微，可导，可积与连续的关系</a></p></blockquote><h4 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h4><p>🔴 $\textcolor{red}{连续}$</p><p>设$y=f(x)$在$x_{0}$的某一邻域内有定义，若$\lim_{x \to \infty}f(x)= f(x_{0})$，则称$f(x)$在点$x_{0}$处连续</p><ul><li><strong>三个条件</strong><ul><li>函数在该点<strong>有定义</strong></li><li>函数在该点极限$\lim_{x \to \infty}f(x)$<strong>存在</strong></li><li><strong>极限值 =  函数值</strong>：$\lim_{x \to \infty}f(x)= f(x_{0})$</li></ul></li></ul><p>🔴 $\textcolor{red}{可导}$</p><p>设$y=f(x)$在$x_{0}$的某一邻域$U(x_{0})$内有定义，当自变量$x$在$x_{0}$取得增量$\Delta x(x\neq 0) $，且$x_0 +\Delta x \in U(x_0)$时，相应的函数增量 $ \Delta y=f(x_0+\Delta x)-f(x_0)$，若极限</p><script type="math/tex; mode=display">\lim _{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}=\lim _{\Delta x \rightarrow 0} \frac{f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)}{\Delta x}</script><p>存在，则称函数在$x_0$处可导，并称这个极限值为函数在该点处的导数</p><p>🔴 $\textcolor{red}{可微}$</p><blockquote><p>参考阅读：<a href="https://zhuanlan.zhihu.com/p/38967869">如何通俗理解全微分 - 知乎 (zhihu.com)</a></p></blockquote><p>设函数$y=f(x)$ 在区间内有定义，$x_{0}$及$x_{0}+\Delta x$在区间内：</p><ul><li>若增量 $ \Delta y=f(x_0+\Delta x)-f(x_0)$可表示为$\Delta y=A\Delta x+o(\Delta x)$</li><li>其中$A$是不依赖于$\Delta x$的常数，那么称函数$y=f(x)$ 在点$x_0$处可微。</li><li>$A\Delta x$ 叫做函数$y=f(x)$在点 $x_0$处相应于$\Delta x$的微分，记作$ \mathrm dy$</li></ul><p>🔴 $\textcolor{red}{可积}$</p><ul><li>$f(x)$在区间$[a,b]$上<strong>连续</strong>，则在$[a,b]$上可积</li><li>$f(x)$在区间$[a,b]$上<strong>有界，且只有有限个间断点</strong>，则在$[a,b]$上可积</li></ul><h4 id="联系【一元函数】"><a href="#联系【一元函数】" class="headerlink" title="联系【一元函数】"></a>联系【一元函数】</h4><p>⭕ <strong>可导 必然 连续，连续 不一定 可导</strong></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/64324578">证明：连续性和可导性</a></p><p>例子：魏尔施特拉斯函数：<strong>处处连续而处处不可导</strong>：</p></blockquote><p><img src="https://s2.loli.net/2022/08/05/QLWHksud7xAlJjU.png" alt="image.png" style="zoom: 50%;"></p><p>⭕ <strong>可导 和 可微 等价</strong></p><blockquote><p><a href="https://www.zhihu.com/question/319299307#:~:text=一元函数可导，表示曲线可作切线，表示曲线光滑。. （这个没有理解难度吧！. ）. 可导表示可作切线. 一元函数可微，表示曲线段的Y增量可以用直线段的Y增量代替。. 可微表示允许以直代曲.,曲线段PC的X增量是 ，直线段PB的X增量是 。. 两者相等. 曲线段PC的Y增量是 ，直线段PB的Y增量是 。.">一元函数和二元函数，可微和可导有什么区别？ - 知乎 (zhihu.com)</a></p></blockquote><p>⭕ <strong>连续必然可积，可积不一定连续</strong></p><blockquote><p>想想可积和连续的几何意义就理解了</p></blockquote><p>⭕ <strong>可导必然可积，可积不一定可导</strong></p><blockquote><p>可导👉连续👉可积，所以可导必可积。</p><p>可积不一定连续👉不一定可导，所以可积不一定可导。</p></blockquote><h4 id="联系【多元函数】"><a href="#联系【多元函数】" class="headerlink" title="联系【多元函数】"></a>联系【多元函数】</h4><p>🔺 <strong>可导不一定连续，连续不一定可导</strong></p><blockquote><p>可导指的是<strong>可偏导</strong>，所以<strong>并不能推出在所有方向上函数连续</strong></p></blockquote><p>🔺 <strong>可微必然可导，可导不一定可微</strong></p><blockquote><p>一元函数👉可导：存在导数，可微：存在微分。</p><p>多元函数👉可导：存在<strong>偏导数</strong>，可微：存在<strong>全微分</strong>。</p></blockquote><p>🔺<strong>可微必然连续，连续不一定可微</strong></p><p>🔺<strong>偏导数连续必然可微，可微不一定偏导数连续</strong></p><blockquote><p>一个形象的角度理解：<a href="https://zhuanlan.zhihu.com/p/42504140">多元函数可微、可导、连续的关系 - 知乎 (zhihu.com)</a></p><p><strong>连续</strong>：在定义范围内曲面上没有窟窿、断崖（但可以有尖点，有折痕）</p><p><strong>(偏)导函数存在，即可导</strong>：曲面和某个切面相交的那条切线是光滑的（但是偏导函数可以在这点不连续，即极限存在但无定义)</p><p><strong>可微</strong>：曲面是光滑的(想象一个穹顶)</p></blockquote><hr><h3 id="偏导数、方向导数、梯度"><a href="#偏导数、方向导数、梯度" class="headerlink" title="偏导数、方向导数、梯度"></a>偏导数、方向导数、梯度</h3><blockquote><p>参考阅读：</p><p><a href="https://www.cnblogs.com/shine-lee/p/11715033.html">直观理解梯度，以及偏导数、方向导数和法向量等 - shine-lee - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/CSDN_SUSAN/article/details/90166474">导数，偏导数，方向导数，梯度的理解—-微积分数学基础SUSAN的博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/488961148">通俗理解方向导数与梯度 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/31942912">多元函数的偏导数、方向导数、梯度以及微分之间的关系思考 - 知乎 (zhihu.com)</a></p></blockquote><p>🔴 $\textcolor{red}{偏导数}$</p><p>对于多元函数，求导数其实也是要求一个切线的斜率，但是由于曲面上的一个点的切线有<strong>无数条</strong>，那么取那条切线的斜率？引入： <strong>偏导数</strong>。</p><p><strong>偏导数</strong>：可以理解成<strong>多元函数“退化”成一元函数时的导数</strong> ；“退化”：固定其他变量的值，只保留一个变量，依次保留每个变量，则$N$元函数有$N$个偏导数。</p><ul><li><strong>几何意义</strong>：也是切线斜率， 由于曲面上一点的切线有无数条（所有切线组成一个<strong>切面</strong>），偏导数选取的是<font color="red">垂直于各坐标轴</font>的几条特殊切线的<strong>斜率</strong>。</li><li><strong>物理意义</strong>：表示函数沿着<font color="red">某个坐标轴方向上</font>的<strong>变化率</strong></li></ul><p>以二元函数$z=f(x,y)$为例，求$(x_0,y_0,z_0)$的偏导数：</p><ul><li>对$x$的偏导数：过点$(x_0,y_0,z_0)$且垂直于$y$轴的曲线（相当于固定$y$值），在该点切线的斜率</li><li>对$y$的偏导数：过点$(x_0,y_0,z_0)$且垂直于$x$轴的曲线（相当于固定$x$值），在该点切线的斜率</li></ul><p><img src="https://s2.loli.net/2022/08/05/rkE4F6G1TfhS38i.png" alt="image.png" style="zoom:40%;"></p><p>🔴 $\textcolor{red}{方向导数}$</p><p>偏导数计算的是垂直于各坐标轴的几条特殊切线的斜率，某点的切线沿着不同方向有无数条 👉想求某点沿着<font color="red">任意方向</font>的切线斜率？引入：<strong>方向导数</strong>（补充：既然切线都分布在一个平面上，并且每一条切线都代表着函数朝着某一方向的变化率，那么在这个平面上就<strong>必定会存在唯一的一条切线的方向导数最大</strong>。（梯度为0的情况除外）</p><p>以二元函数$z=f(x,y)$为例，求$(x_0,y_0,z_0)$的某方向导数：（<a href="https://www.geogebra.org/m/Bx8nFMNc">下图动态演示地址</a>）</p><ul><li>$x$轴和$y$轴决定的平面上选择某一个方向向量（图中斜着的红色箭头），该方向所在的这个黄色平面 与 蓝色曲面相交 决定了一条过$(x_0,y_0,z_0)$的曲线（隐隐约约的红色细线描出来的部分），点在该曲线上的这条黑色切线斜率即为方向导数</li></ul><p><img src="https://s2.loli.net/2022/08/05/uRhCXbatP98DTxe.png" alt="image.png" style="zoom:33%;"></p><ul><li>设一个方向向量为$\overrightarrow{\mathrm{u}}=(\cos \alpha, \sin \alpha)$ （$\alpha$和$\beta$分别为该方向向量与$x$轴和$y$轴的夹角），则方向导数定义如下，它是个标量：<script type="math/tex; mode=display">\mathrm{D}_{\mathrm{u}} \mathrm{f}(\mathrm{x}, \mathrm{y})=\mathrm{f}_{\mathrm{x}}(\mathrm{x}, \mathrm{y}) \cos \alpha+\mathrm{f}_{\mathrm{y}}(\mathrm{x}, \mathrm{y}) \sin \alpha</script>进一步地，设偏导向量$\overrightarrow{\mathrm{A}}=\left(\mathrm{f}_{\mathrm{x}}(\mathrm{x}, \mathrm{y}), \mathrm{f}_{\mathrm{y}}(\mathrm{x}, \mathrm{y})\right)$，则上述方向导数可以改写为：<script type="math/tex; mode=display">\mathrm{D}_{\mathrm{u}} \mathrm{f}(\mathrm{x}, \mathrm{y})=\overrightarrow{\mathrm{A}} * \overrightarrow{\mathrm{u}}=|\overrightarrow{\mathrm{A}}| *|\overrightarrow{\mathrm{u}}| * \cos (\theta)</script>$ \theta$ 是偏导向量和方向向量之间的夹角。当$\theta=0$即二者同向时，方向导数$D_{u} f(x, y)$取得<strong>正</strong>最大值。反向时，则<strong>负</strong>最大值。</li></ul><p>🔴 $\textcolor{red}{梯度}$</p><p><strong>梯度：</strong>是一个矢量，函数在某点 无数个变化方向中 <strong>变化最快</strong>的 <u><strong>那个方向</strong></u></p><blockquote><p>即：偏导数构成的向量；由此：方向导数 = 梯度 * 方向向量</p></blockquote><p>函数只要<strong>每一个变量</strong>都沿着关于这个变量的<strong>偏导所指定的方向</strong>来变化，函数的整体变化就能达到最快（变化的绝对值最大）</p><p><strong>梯度的几何意义</strong>：</p><ol><li>当前位置的<strong>梯度方向</strong>，为函数在该位置处<strong>方向导数最大的方向</strong>，也是函数值<strong>上升最快的方向</strong>，反方向为下降最快的方向；</li><li>当前位置的<strong>梯度长度（模）</strong>，为最大方向导数的值</li><li>梯度（下降）的方向与<strong>等高线的切线方向垂直</strong></li></ol><p>以二元函数$z=f(x,y)$为例，其方向导数定义如下：</p><script type="math/tex; mode=display">\nabla f\left(x_{0}, y_{0}\right)=\left.\left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\right)\right|_{\left(x_{0}, y_{0}\right)}</script><hr><h2 id="微积分基础"><a href="#微积分基础" class="headerlink" title="微积分基础"></a>微积分基础</h2><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/BV1U94y1R71P?p=11&amp;spm_id_from=pageDriver&amp;vd_source=29f5937d4c8dc6b894a81d48deba4d66">3-定积分_哔哩哔哩_bilibili</a></p></blockquote><p>🔴 $\textcolor{red}{区分\Delta y和dy}$</p><p><img src="https://s2.loli.net/2022/08/06/1PtNzyeOvaKbkRV.png" alt="image.png" style="zoom:50%;"></p><h3 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h3><p>🔴 $\textcolor{red}{定义}$</p><p><img src="https://s2.loli.net/2022/08/06/O7ZjLAptkUSNln3.png" alt="image.png" style="zoom: 50%;"></p><p>🔴 $\textcolor{red}{积分上限函数}$</p><p>函数$f(x)$在区间$[a,b]$上连续，对于定积分$\int_{a}^{x} f(x) d x$每一个取值$x$都有一个对应的定积分值，记作$\Phi(x)= \int_{a}^{x} f(t) dt$</p><p>若函数$f(x)$在区间$[a,b]$上连续，则积分上限函数就是$f(x)$在$[a,b]$上的原函数</p><h3 id="两大积分中值定理"><a href="#两大积分中值定理" class="headerlink" title="两大积分中值定理"></a>两大积分中值定理</h3><p>🔴 $\textcolor{red}{第一中值定理}$</p><p>如果函数$f(x)$在闭区间$[a,b]$上连续，则在积分区间$[a,b]$上，至少存在一个点$\xi$，使$\int_{a}^{b} f(x) d x=f(\xi)(b-a) . \quad(a \leq \xi \leq b)$</p><p><img src="https://s2.loli.net/2022/08/06/7iEsOulChydFNkU.png" alt="image.png" style="zoom:50%;"></p><p>🔴 $\textcolor{red}{第二中值定理}$</p><h3 id="三大微分中值定理"><a href="#三大微分中值定理" class="headerlink" title="三大微分中值定理"></a>三大微分中值定理</h3><h3 id="牛顿-莱布尼兹公式"><a href="#牛顿-莱布尼兹公式" class="headerlink" title="牛顿-莱布尼兹公式"></a>牛顿-莱布尼兹公式</h3><p>🔴 $\textcolor{red}{定义}$</p><p>如果$F(x)$是连续函数$f(x)$在区间$[a,b]$上的一个原函数，则$\int_{a}^{b} f(x) d x=F(a)-F(b)$。</p><blockquote><p>即：一个连续函数在区间$[a,b]$上的定积分等于它的任意一个原函数在区间$[a,b]$上的增量</p></blockquote><p>🔴 $\textcolor{red}{几何解释}$</p><p>可得：$f(b)-f(a)=\sum dy$，由于$dy=f’(x)dx$，$f(b)-f(a)=\sum f’(x)dx= \int_{a}^{b}f’(x)dx $</p><p><img src="https://s2.loli.net/2022/08/06/R1O8iWub7dXer62.png" alt="image.png" style="zoom:40%;"></p><hr><h2 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h2><blockquote><p>用简单的熟悉的多项式来近似代替复杂的函数</p></blockquote><p>🔴 $\textcolor{red}{泰勒多项式}$</p><p>$f(x)$在$x_0$关于$(x-x_0)$的n阶泰勒多项式：</p><script type="math/tex; mode=display">\begin{array}{l}P_{n}(x)=f\left(x_{0}\right)+f^{\prime}\left(x_{0}\right)\left(x-x_{0}\right)+\frac{f^{\prime \prime}\left(x_{0}\right)}{2 !}\left(x-x_{0}\right)^{2}+ \cdots \quad+\frac{f^{(n)}\left(x_{0}\right)}{n !}\left(x-x_{0}\right)^{n}\end{array}</script><p>🔴 $\textcolor{red}{麦克劳林公式}$</p><p>令$x_0=0$：</p><script type="math/tex; mode=display">\begin{aligned}f(x)=& f(0)+f^{\prime}(0) x+\frac{f^{\prime \prime}(0)}{2 !} x^{2}+\cdots+\frac{f^{(n)}(0)}{n !} x^{n}+\frac{f^{(n+1)}(\theta x)}{(n+1) !} x^{n+1}(0<\theta<1)\end{aligned}</script><p>🔴 $\textcolor{red}{泰勒多项式中 阶数的作用}$</p><ul><li>阶数越高，增长速度越快；越高次项在越偏右侧影响越大</li><li>对于一个复杂函数，低阶项能更好地描述当前点附近，对于之后的走势就越来越依靠高阶项</li></ul><hr><h2 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h2><h2 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h2><blockquote><p>寻找变量受一个或多个条件限制的多元函数的极值</p><p>参考阅读：</p><p><a href="https://www.zhihu.com/question/38586401">如何理解拉格朗日乘子法？ - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/weixin_44378835/article/details/110732412?utm_source=app">【线性分类器】（四）万字长文解释拉格朗日乘子与支持向量机_二进制人工智能的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/frostime/article/details/90291392?ops_request_misc=%7B%22request%5Fid%22%3A%22166219600716781790779835%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166219600716781790779835&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-90291392-null-null.nonecase&amp;utm_term=拉格朗日对偶&amp;spm=1018.2226.3001.4450">【数学】拉格朗日对偶，从0到完全理解_frostime的博客</a><strong>（←这篇博客写得超级超级好！）</strong></p></blockquote><h3 id="高数中的拉格朗日乘子"><a href="#高数中的拉格朗日乘子" class="headerlink" title="高数中的拉格朗日乘子"></a>高数中的拉格朗日乘子</h3><p><strong>条件极值：</strong>对函数的自变量还有附加条件的极值</p><p>求解条件极值：<strong>拉格朗日乘子法</strong></p><p><img src="https://s2.loli.net/2022/08/06/JqrMlxpIzNFVwRS.png" alt="image.png" style="zoom: 30%;"></p><p>例如对于一个二元函数函数：$z=f(x,y)$在条件$\varphi(x, y)=0$下的极值，构造拉格朗日函数$F(x,y)=f(x,y)+\lambda \varphi(x, y)$，其中$\lambda$为拉格朗日乘数，构造下列函数求得极值点坐标：</p><script type="math/tex; mode=display">\left\{\begin{array}{c}f_{x}(x, y)+\lambda \varphi_{x}(x, y)=0 \\f_{y}(x, y)+\lambda \varphi_{y}(x, y)=0 \\\varphi(x, y)=0\end{array}\right.</script><hr><h3 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h3><h4 id="凸函数、凹函数、仿射函数"><a href="#凸函数、凹函数、仿射函数" class="headerlink" title="凸函数、凹函数、仿射函数"></a>凸函数、凹函数、仿射函数</h4><p>左图是凸函数，右图是凹函数；</p><p>凹凸可以转化：对于凹函数f，− f即为凸函数。</p><p><img src="https://s2.loli.net/2022/09/03/84FjIcap5LxvrCB.png" alt="image.png" style="zoom: 80%;"></p><p>凸函数：</p><script type="math/tex; mode=display">\forall \mathrm{x}, \mathrm{y} \in \operatorname{dom} \mathrm{f}, \quad \forall \theta \in[0,1] \\\mathrm{f}(\theta \mathrm{x}+(1-\theta) \mathrm{y}) \leqslant \theta \mathrm{f}(\mathrm{x})+(1-\theta) \mathrm{f}(\mathrm{y})</script><p>凹函数</p><script type="math/tex; mode=display">\forall \mathrm{x}, \mathrm{y} \in \operatorname{dom} \mathrm{f}, \quad \forall \theta \in[0,1] \\\mathrm{f}(\theta \mathrm{x}+(1-\theta) \mathrm{y}) \geqslant \theta \mathrm{f}(\mathrm{x})+(1-\theta) \mathrm{f}(\mathrm{y})</script><p><strong>仿射函数既凹又凸</strong>：</p><script type="math/tex; mode=display">\mathrm{f}(\theta \mathrm{x}+(1-\theta) \mathrm{y}) = \theta \mathrm{f}(\mathrm{x})+(1-\theta) \mathrm{f}(\mathrm{y})</script><script type="math/tex; mode=display">\overrightarrow{\mathrm{x}} \rightarrow \mathrm{A} \overrightarrow{\mathrm{x}}+\overrightarrow{\mathrm{b}}\quad被称为\quad  \mathbb{R}^{\mathrm{n}} \rightarrow \mathbb{R}^{\mathrm{m}}  的仿射变换，这一过程被称为仿射函数。\\f(x)=A x+b, x \in \mathbb{R}^{n}\\比如最简单的:\mathrm{a}_{1} \mathrm{x}_{1}+\mathrm{a}_{2} \mathrm{x}_{2}+\cdots+\mathrm{a}_{\mathrm{n}} \mathrm{x}_{\mathrm{n}}+\mathrm{b}就是一个仿射函数。</script><hr><h4 id="凸优化-1"><a href="#凸优化-1" class="headerlink" title="凸优化"></a><strong>凸优化</strong></h4><p>凸优化问题就是满足特定条件的优化问题，任意位置的<strong>局部最优解同时也是全局最优解</strong></p><p>凸优化问题的基本形式描述：</p><script type="math/tex; mode=display">\begin{array}{ll}\min _{\mathrm{x} \in \mathbb{R}^{\mathrm{n}}} \mathrm{f}(\mathrm{x}) \\\text { s.t } & \mathrm{c}_{\mathrm{i}}(\mathrm{x}) \leqslant 0, \mathrm{i} \in[1, \mathrm{k}] \\& \mathrm{h}_{\mathrm{j}}(\mathrm{x})=0, \mathrm{j} \in[1,l]\end{array}</script><p>要求<strong>满足</strong>：</p><ul><li>$f(x)$ 是凸函数</li><li>$c_i(x)$是凸函数</li><li>$h_j(x)$是仿射函数</li></ul><hr><h3 id="从广义拉格朗日函数到拉格朗日对偶函数"><a href="#从广义拉格朗日函数到拉格朗日对偶函数" class="headerlink" title="从广义拉格朗日函数到拉格朗日对偶函数"></a>从广义拉格朗日函数到拉格朗日对偶函数</h3><h4 id="原问题"><a href="#原问题" class="headerlink" title="原问题"></a>原问题</h4><script type="math/tex; mode=display">\begin{array}{ll}\min _{\mathrm{x} \in \mathbb{R}^{\mathrm{n}}} \mathrm{f}(\mathrm{x}) \\\text { s.t } & \mathrm{c}_{\mathrm{i}}(\mathrm{x}) \leqslant 0, \mathrm{i} \in[1, \mathrm{k}] \\& \mathrm{h}_{\mathrm{j}}(\mathrm{x})=0, \mathrm{j} \in[1,l]\end{array}</script><p>针对上述原问题，首先约定：</p><ul><li>不假定$f(x)$的凹凸性，可以非凹非凸</li><li>原问题的定义域：$\mathrm{D}=(\operatorname{dom} \mathrm{f}) \cap\left(\bigcap_{\mathrm{i}=1}^{\mathrm{k}} \mathrm{c}_{\mathrm{i}}\right) \cap\left(\bigcap_{\mathrm{i}=1}^{\mathrm{l}} \mathrm{h}_{\mathrm{i}}\right) \neq \empty$</li><li>最终求出的最优结果表示：$p^ * $</li></ul><p><strong>对于该原问题，不太好解，难点在于</strong>：</p><ul><li>约束条件多：$k+l$ 个约束</li><li>$f(x)$凹凸性不明确，意味着无法运用凸优化的方法</li></ul><p>因此，考虑采用<strong>拉格朗日对偶</strong>的方式求解，<strong>优点在于</strong>：</p><blockquote><p>对偶：实质相同，但同不同角度提出不同提法的一对问题</p></blockquote><ul><li>只有<strong>一个约束</strong></li><li>拉格朗日对偶问题一定是<strong>凹</strong>的</li></ul><p>将<strong>非凸目标函数的极小化转换成凹目标函数的极大化</strong>，局部极值点便是全局极值点</p><hr><h4 id="广义拉格朗日函数"><a href="#广义拉格朗日函数" class="headerlink" title="广义拉格朗日函数"></a>广义拉格朗日函数</h4><script type="math/tex; mode=display">\begin{array}{l}\mathcal{L}: \mathbb{R}^{\mathrm{n}} \times \mathbb{R}^{\mathrm{k}} \times \mathbb{R}^{l} \rightarrow \mathrm{R} \\\mathcal{L}(\mathrm{x}, \lambda, \mu)=\mathrm{f}(\mathrm{x})+\sum_{\mathrm{i}=1}^{\mathrm{k}} \lambda_{\mathrm{i}} \mathrm{c}_{\mathrm{i}}(\mathrm{x})+\sum_{\mathrm{j}=1}^{l} \mu_{\mathrm{j}} \mathrm{h}_{\mathrm{j}}(\mathrm{x}) \\\overrightarrow{\mathrm{x}} \in \mathbb{R}^{\mathrm{n}}, \vec{\lambda} \in \mathbb{R}^{\mathrm{k}}, \vec{\mu} \in \mathbb{R}^{l}\end{array}</script><hr><h4 id="拉格朗日对偶函数"><a href="#拉格朗日对偶函数" class="headerlink" title="拉格朗日对偶函数"></a>拉格朗日对偶函数</h4><p>🔸 不管原函数$f$的凹凸性，它的对偶函数$g$一定是一个<strong>凹函数</strong></p><blockquote><p>相关证明详见：<a href="https://blog.csdn.net/frostime/article/details/90291392?ops_request_misc=%7B%22request%5Fid%22%3A%22166219600716781790779835%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166219600716781790779835&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-90291392-null-null.nonecase&amp;utm_term=拉格朗日对偶&amp;spm=1018.2226.3001.4450">【数学】拉格朗日对偶，从0到完全理解_frostime的博客</a></p></blockquote><script type="math/tex; mode=display">\begin{aligned}\mathrm{g}(\lambda, \mu) &=\inf _{\mathrm{x} \in \mathrm{D}} \mathcal{L}(\mathrm{x}, \lambda, \mu) \\&=\inf _{\mathrm{x} \in \mathrm{D}}\left(\mathrm{f}(\mathrm{x})+\sum_{\mathrm{i}=1}^{\mathrm{k}} \lambda_{\mathrm{i}} \mathrm{c}_{\mathrm{i}}(\mathrm{x})+\sum_{\mathrm{j}=1}^{l} \mu_{\mathrm{j}} \mathrm{h}_{\mathrm{j}}(\mathrm{x})\right) \\\lambda \geqslant 0\end{aligned}</script><blockquote><p>inf：下确界，和<strong>min</strong>类似，但细节部分略不同</p></blockquote><p>这个对偶函数 能<strong>给出原问题最优解的下确界</strong>：</p><blockquote><p>相关证明详见：<a href="https://blog.csdn.net/frostime/article/details/90291392?ops_request_misc=%7B%22request%5Fid%22%3A%22166219600716781790779835%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166219600716781790779835&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-90291392-null-null.nonecase&amp;utm_term=拉格朗日对偶&amp;spm=1018.2226.3001.4450">【数学】拉格朗日对偶，从0到完全理解_frostime的博客</a></p></blockquote><script type="math/tex; mode=display">\forall \lambda \geqslant 0 \Rightarrow \mathrm{g}(\lambda, \mu) \leqslant \mathrm{p}^{*}</script><p>🔸 也就是说，无论如何，$p^<em>$ 都   <em>*不会小于</em></em>  $max g(\lambda,\mu)$</p><p><img src="https://s2.loli.net/2022/09/03/yDLFtOzeBWS6oXx.png" alt="image.png" style="zoom: 33%;"></p><p>最初的目的是找到<strong>原问题的最优解</strong> $p^ * $，但有时候该解并不一起能解出来，因此希望可以给出一个尽可能逼近</p><p> $p^ * $的值：$\max \operatorname{g}(\lambda, \mu)(\text { s.t } \lambda \geqslant 0)$</p><hr><h4 id="总结：原问题vs对偶问题"><a href="#总结：原问题vs对偶问题" class="headerlink" title="总结：原问题vs对偶问题"></a>总结：原问题vs对偶问题</h4><p>🔸 原问题（Primal Problem），结果记为$p^ * $</p><script type="math/tex; mode=display">\begin{array}{ll}\min _{\mathrm{x} \in \mathbb{R}^{\mathrm{n}}} \mathrm{f}(\mathrm{x}) \\\text { s.t } & \mathrm{c}_{\mathrm{i}}(\mathrm{x}) \leqslant 0, \mathrm{i} \in[1, \mathrm{k}] \\& \mathrm{h}_{\mathrm{j}}(\mathrm{x})=0, \mathrm{j} \in[1,l]\end{array}</script><p>🔸 拉格朗日对偶问题（Lagrange Dual Problem），结果记为$d^*$</p><script type="math/tex; mode=display">\begin{array}{ll}转换为\mathcal{L}(\mathrm{x}, \lambda, \mu)=\mathrm{f}(\mathrm{x})+\sum_{\mathrm{i}=1}^{\mathrm{k}} \lambda_{\mathrm{i}} \mathrm{c}_{\mathrm{i}}(\mathrm{x})+\sum_{\mathrm{j}=1}^{l} \mu_{\mathrm{j}} \mathrm{h}_{\mathrm{j}}(\mathrm{x})\\求\max _{\lambda, \mu} g(\lambda, \mu)=\max _{\lambda, \mu} \inf _{\mathrm{x} \in \mathrm{D}} \mathcal{L}(\mathrm{x}, \lambda, \mu)\\s.t  \quad \lambda_{\mathrm{i}} \geqslant 0, \mathrm{i}=1,2, \ldots, \mathrm{k}\end{array}</script><blockquote><p>希望求p*  ，但不好求，因此求d*</p><p>因为 d* ≤ p* $，至少说明能求得 $ p*的下界，如果在非常理想，或者说，满足具体特定条件时，等式就成立了</p></blockquote><hr><h3 id="强、弱对偶"><a href="#强、弱对偶" class="headerlink" title="强、弱对偶"></a>强、弱对偶</h3><p>弱对偶—— d* ≤ p* ：</p><ul><li>最优对偶间隙（Optimal Duality Gap）：p* -d*</li></ul><p><img src="https://s2.loli.net/2022/09/03/Twt9XhJUVOS4uW5.png" alt="image.png" style="zoom: 33%;"></p><p>强对偶——d*= p*：</p><ul><li>如果满足强对偶，只要求出了d*，就相当于求出了p*</li><li><strong>必须满足一定的条件</strong>，强对偶才可能成立（使满足强对偶的条件有多种）</li></ul><p><img src="https://s2.loli.net/2022/09/03/EQNwDmacLsvCg3V.png" alt="image.png" style="zoom:33%;"></p><hr><h3 id="关于强对偶和最优的条件"><a href="#关于强对偶和最优的条件" class="headerlink" title="关于强对偶和最优的条件"></a>关于强对偶和最优的条件</h3><h4 id="Convex-Slater"><a href="#Convex-Slater" class="headerlink" title="Convex+Slater"></a>Convex+Slater</h4><blockquote><p>满足强对偶的一个充分条件</p></blockquote><p>🔴 即：原问题是<strong>凸优化 且满足 Slater条件</strong>，则<strong>一定满足强对偶</strong></p><ul><li>Slater条件：</li></ul><script type="math/tex; mode=display">\begin{array}{l}\exists \mathrm{x} \in \mathrm{D} \\\mathrm{c}_{\mathrm{i}}(\mathrm{x})<0, \mathrm{i} \in[1, \mathrm{k}] \\\mathrm{Ax}=\mathrm{b}\end{array}</script><hr><h4 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h4><h5 id="非凸问题下的KKT"><a href="#非凸问题下的KKT" class="headerlink" title="非凸问题下的KKT"></a>非凸问题下的KKT</h5><p>暂略…</p><h5 id="凸问题下的KKT"><a href="#凸问题下的KKT" class="headerlink" title="凸问题下的KKT"></a>凸问题下的KKT</h5><blockquote><p>凸问题下，满足 KKT 条件的点一定是原问题和对偶问题的最优解；</p><p><strong>KKT 条件成了强对偶和最优解的充要条件</strong></p></blockquote><p>🔴也就是说：</p><ul><li><p>若原问题是凸（Convex）的</p><script type="math/tex; mode=display">\mathcal{L}(\mathrm{x}, \lambda, \mu)=\mathrm{f}(\mathrm{x})+\sum_{\mathrm{i}=1}^{\mathrm{k}} \lambda_{\mathrm{i}} \mathrm{c}_{\mathrm{i}}(\mathrm{x})+\sum_{\mathrm{j}=1}^{l} \mu_{\mathrm{j}} \mathrm{h}_{\mathrm{j}}(\mathrm{x})</script></li><li><p>$\exists \hat{\mathrm{x}}, \hat{\lambda}, \hat{\mu}$，满足：</p><script type="math/tex; mode=display">\begin{array}{lr}(1)\quad\mathrm{c}_{\mathrm{i}}(\hat{\mathrm{x}}) \leqslant 0 & \mathrm{i}=1, \ldots, \mathrm{k} \\(2)\quad\mathrm{h}_{\mathrm{i}}(\hat{\mathrm{x}})=0 & \mathrm{i}=1, \ldots, l \\(3)\quad\hat{\lambda}_{\mathrm{i}} \geqslant 0 & \mathrm{i}=1, \ldots, \mathrm{k} \\(4)\quad\hat{\lambda}_{\mathrm{i}} \mathrm{c}_{\mathrm{i}}(\hat{\mathrm{x}})=0 & \mathrm{i}=1, \ldots, \mathrm{k} \\(5)\quad\nabla \mathrm{f}(\hat{\mathrm{x}})+\sum_{\mathrm{i}=1}^{\mathrm{k}} \hat{\lambda}_{\mathrm{i}} \nabla \mathrm{c}_{\mathrm{i}}(\hat{\mathrm{x}})+\sum_{\mathrm{i}=1}^{l} \hat{\mu}_{\mathrm{i}} \nabla \mathrm{h}_{\mathrm{i}}(\hat{\mathrm{x}})=0 &\end{array}</script><blockquote><p>(1)（2）：满足原问题的等式和不等式约束（原问题可行）</p><p>(3)：满足非负性（弱对偶的必要条件）（对偶问题可行）</p><p>(4)：互补松弛条件，防止出现$\mathrm{c}_{\mathrm{i}}(\hat{\mathrm{x}})&gt;0$</p><p>(5)：$x$* 是最优点，理所当然的，原问题 $\mathcal{L}$ 关于 $x$* 的导数必须等于 0。</p></blockquote></li><li><p>那么，$\hat{\mathrm{x}}, \hat{\lambda}, \hat{\mu}$都是原问题和对偶问题的最优解，且最优对偶间隙为0，满足强对偶性。</p></li></ul><hr><h3 id="矩阵分析中的拉格朗日乘子"><a href="#矩阵分析中的拉格朗日乘子" class="headerlink" title="矩阵分析中的拉格朗日乘子"></a>矩阵分析中的拉格朗日乘子</h3><h4 id="含有一个等式约束的最优化"><a href="#含有一个等式约束的最优化" class="headerlink" title="含有一个等式约束的最优化"></a>含有一个等式约束的最优化</h4><p>实函数$f(w)$是参数向量$w$ 的函数，约束条件：$w^Tx=b$，其中$x$是已知向量，$b$是常数，令$h(w)=w^Tx-b=0$，最小化问题可以描述为</p><script type="math/tex; mode=display">minf(w) \quad s.t.\quad h(w)=0</script><p>引入拉格朗日乘子，将上述约束最小化问题转化为无约束问题，定义新函数，利用偏导求参即可：</p><script type="math/tex; mode=display">\mathrm{L}(\mathrm{w}, \lambda)=\mathrm{f}(\mathrm{w})+\lambda \mathrm{h}(\mathrm{w})</script><h4 id="含有多个等式约束的最优化"><a href="#含有多个等式约束的最优化" class="headerlink" title="含有多个等式约束的最优化"></a>含有多个等式约束的最优化</h4><p>实函数$f(w)$是参数向量$w$的二次函数，约束条件：$w^Tx_k=b_k,k=1,2,\dots K$，其中$x$是已知向量，$b_k$是常数，令$h_k(w)=w^Tx_k-b_k=0$，最小化问题描述为：</p><script type="math/tex; mode=display">minf(w)\quad s.t.\quad h_k(w)=0,k=1,2,\dots K</script><p>将上述最小化问题转化为无约束问题，定义一个新的实函数：</p><script type="math/tex; mode=display">\mathrm{L}(\mathrm{w}, \lambda)=\mathrm{f}(\mathrm{w})+\sum_{\mathrm{k}=1}^{\mathrm{K}} \lambda_{\mathrm{k}} \mathrm{h}_{\mathrm{k}}(\mathrm{w})</script><h4 id="拉格朗日对偶问题"><a href="#拉格朗日对偶问题" class="headerlink" title="拉格朗日对偶问题"></a>拉格朗日对偶问题</h4><p>函数$f(x)=max\{x_1,x_2,\dots,x_n\}$是$R^n$上的<strong>凸函数</strong></p><p>函数$f(x)=min\{x_1,x_2,\dots,x_n\}$是$R^n$上的<strong>凹函数</strong></p><p>约束优化的<strong>原始问题</strong>模型：</p><script type="math/tex; mode=display">\min _{x} f_{0}(x)\\s.t.\quad \mathrm{f}_{\mathrm{i}}(\mathrm{x}) \leq 0, \mathrm{i}=1, \ldots \mathrm{m} \\\quad\quad  \mathrm{h}_{\mathrm{i}}(\mathrm{x})=0, \mathrm{i}=1, \ldots \mathrm{q}</script><p>利用<strong>拉格朗日乘子法</strong>可以松弛为<strong>无约束</strong>优化问题（<strong>对偶问题</strong>）：</p><script type="math/tex; mode=display">\min \mathrm{L}(\mathrm{x}, \lambda, \mathrm{v})=\mathrm{f}_{0}(\mathrm{x})+\sum_{\mathrm{i}=1}^{\mathrm{m}} \lambda_{\mathrm{i}} \mathrm{f}_{\mathrm{i}}(\mathrm{x})+\sum_{\mathrm{i}=1}^{\mathrm{q}} \mathrm{v}_{\mathrm{i}} \mathrm{h}_{\mathrm{i}}(\mathrm{x})</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;高数基础知识&lt;/p&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【机器学习】支持向量机SVM</title>
    <link href="http://example.com/2022/09/01/2022-09-01-%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM/"/>
    <id>http://example.com/2022/09/01/2022-09-01-%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM/</id>
    <published>2022-09-01T01:55:34.000Z</published>
    <updated>2022-09-03T16:22:07.196Z</updated>
    
    <content type="html"><![CDATA[<p>支持向量机</p><span id="more"></span><h1 id="SVM（支持向量机）"><a href="#SVM（支持向量机）" class="headerlink" title="SVM（支持向量机）"></a>SVM（支持向量机）</h1><blockquote><p>参考文献链接：</p><p><a href="https://www.bilibili.com/video/BV1qf4y1x7kB?p=6&amp;vd_source=29f5937d4c8dc6b894a81d48deba4d66">2.1.1]—支持向量机（线性可分定义）_哔哩哔哩_bilibili</a> （b站上 浙江大学胡浩基老师的讲解视频）</p><p><a href="https://zhuanlan.zhihu.com/p/77750026">【机器学习】支持向量机 SVM（非常详细） - 知乎 (zhihu.com)</a> </p><p><a href="https://blog.csdn.net/qq_31347869/article/details/88071930?ops_request_misc=%7B%22request%5Fid%22%3A%22166211843916781790711325%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=166211843916781790711325&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-88071930-null-null.nonecase&amp;utm_term=svm&amp;spm=1018.2226.3001.4450">机器学习算法（一）SVM_yaoyz105的博客</a></p><p><a href="https://blog.csdn.net/Mr_Robert/article/details/88958629">【机器学习算法笔记系列】支持向量机(SVM)算法详解和实战_fpzRobert的博客</a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>机器学习的一般框架：<br>训练集 =&gt; 提取特征向量 =&gt; 结合一定的算法（分类器：比如决策树、KNN）=&gt;得到结果</p></blockquote><h3 id="阐述"><a href="#阐述" class="headerlink" title="阐述"></a>阐述</h3><p>SVM是<strong>二分类</strong>模型，将实例的特征向量 映射成空间中的一些点，寻找一个超平面来对样本点进行分割，分割的原则是间隔最大化，最终转化为一个凸二次规划问题来求解，若出现新的点，这个超平面也能做出很好的分类</p><ul><li>当训练样本<strong>线性可分</strong>时，通过<strong>硬间隔最大化</strong>，学习一个<strong>线性可分支持向量机</strong></li><li>当训练样本<strong>近似线性可分</strong>时，通过<strong>软间隔最大化</strong>，学习一个<strong>线性支持向量机</strong></li><li>当训练样本<strong>线性不可分</strong>时，通过<strong>核技巧和软间隔最大化</strong>，学习一个<strong>非线性支持向量机</strong></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong></p><ul><li>决策函数只由<strong>少数的支持向量决定</strong>，计算的复杂性取决于支持向量的数目，而不是样本空间的维数，这在某种意义上避免了维数灾难。</li><li>可进行<strong>小样本</strong>学习：支持向量机(SVM)本质上是非线性方法，在样本量比较少的时候，容易抓住数据与特征之间的非线性关系，因此可以解决非线性问题、可以避免神经网络结构选择和局部极小值点问题、可以提高泛化能力、可以解决高维问题。（<strong>分类鲁棒性高、全局最优解</strong>）</li></ul><p><strong>缺点</strong></p><ul><li>对<strong>大规模训练样本难以实施</strong>，由于SVM是借助二次规划来求解支持向量，而求解二次规划将涉及m阶矩阵的计算（m为样本的个数），当m数目很大时该矩阵的存储和计算将耗费大量的机器内存和运算时间。</li><li>原始分类器<strong>不加修改仅适用于处理二分类</strong>问题（改进：通过多个二类支持向量机的组合来解决等等）</li><li>对缺失数据敏感，对参数调节和核函数的选择敏感。对非线性问题没有通用解决方案，必须<strong>谨慎选择核函数</strong>来处理。</li></ul><h2 id="线性可分、不可分"><a href="#线性可分、不可分" class="headerlink" title="线性可分、不可分"></a>线性可分、不可分</h2><p>在二维空间下，</p><ul><li><strong>线性可分</strong>Liner Separable</li></ul><p><img src="https://s2.loli.net/2022/09/02/9V6P3GvbKCcqft2.png" alt="image.png" style="zoom:50%;"></p><ul><li><p><strong>非线性可分</strong>NonLinear Separable：不存在一条直线</p><p><img src="https://s2.loli.net/2022/09/02/QDen6Xw4SVYvsLB.png" alt="image.png" style="zoom:50%;"></p></li></ul><p>同理，在三维空间下，</p><p><img src="https://s2.loli.net/2022/09/02/MWLvkJxys9p6HZf.png" alt="image.png" style="zoom:50%;"></p><p>接下来看下图，</p><p><img src="https://s2.loli.net/2022/09/02/ROEFc1fKxIDMAT9.png" alt="image.png" style="zoom:50%;"></p><p>用数学严格定义训练样本以及他们的标签，假设，有N个训练样本及其标签$\left\{\left(X_{1}, y_{1}\right),\left(X_{2}, y_{2}\right), \ldots,\left(X_{N}, y_{N}\right)\right\}$，其中</p><script type="math/tex; mode=display">\begin{aligned}X_{i} &=\left[x_{i 1}, x_{i 2}\right]^{T} \\y_{i} &=\{+1,-1\}\end{aligned}</script><p>人为规定，如果$X_i$属于$C_1$，则$y_i$等于+1，若属于$C_2$，等于-1。</p><p><strong>线性可分的严格定义：</strong></p><p>​    一个训练样本集$\left\{\left(X_{1}, y_{1}\right),\left(X_{2}, y_{2}\right), \ldots,\left(X_{N}, y_{N}\right)\right\}$，在$i=1 \to N$ 线性可分，是指存在$（w_1,w_2,b）$，使得</p><ol><li>若 $y_i = +1$ ，则 $\omega_{1} \mathrm{x}_{i 1}+\omega_{2} \mathrm{x}_{i 2}+\mathrm{b}&gt;0$</li><li>若 $y_i = -1$ ，则 $\omega_{1} \mathrm{x}_{i 1}+\omega_{2} \mathrm{x}_{i 2}+\mathrm{b}&lt;0$</li></ol><p>若用<strong>向量形式</strong>来定义，$X_{i}=\left[\begin{array}{l}<br>x_{i 1} \\<br>x_{i 2}<br>\end{array}\right]$，$\omega=\left[\begin{array}{l}<br>\omega_{1} \\<br>\omega_{2}<br>\end{array}\right]$，则有，</p><ol><li>若 $y_i = +1$ ，则 $\omega^{T} X_{i}+\mathrm{b}&gt;0$</li><li>若 $y_i = - 1$ ，则 $\omega^{T} X_{i}+\mathrm{b}&lt;0$</li></ol><p>最终线性可分的判定<strong>简化为</strong>：</p><script type="math/tex; mode=display">\mathrm{y}_{i}\left(\omega^{T} X_{i}+b\right)>0</script><p>在二分类的情况下，如果<strong>一个数据集是线性可分</strong>的，即存在一个超平面将两个类别完全分开，那么一定存在<strong>无数多个超平面</strong>将这两个类别完全分开。</p><blockquote><p><strong>Q：为什么要叫作“超平面”呢？</strong><br><strong>A：</strong>样本的特征很可能是高维的，此时样本空间的划分就不是一条线</p></blockquote><p><img src="https://s2.loli.net/2022/09/02/cskYAMujJ7mDSKw.png" alt="image.png" style="zoom:33%;"></p><p>ヾ(,,・∇・,, 那么， <strong>哪一个超平面最好呢？</strong></p><blockquote><p><strong>Q：画线的标准是什么？/ 什么才叫这条线的效果好？/ 哪里好？</strong><br><strong>A：</strong>SVM 将会寻找可以<strong>区分两个类别并且能使间隔（margin）最大</strong>的划分超平面。比较好的划分超平面，样本局部扰动时对它的影响最小、产生的分类结果最鲁棒、对未见示例的泛化能力最强。</p><p><strong>Q：间隔（margin）是什么？</strong><br><strong>A：</strong>对于任意一个超平面，其两侧数据点都距离它有一个最小距离（垂直距离），这两个最小距离的和就是间隔。</p><p><strong>Q：为什么要让 margin 尽量大？</strong><br><strong>A：</strong>因为大 margin 犯错的几率比较小，也就是更鲁棒啦。</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>1、解决线性可分问题</p><p>2、将线性可分问题中获得的结论推广到线性不可分情况</p></blockquote><p>将位于 上下两边的这两条平行线上的<strong>样本</strong>，称为 “支持向量”</p><p>这两条平行线之间的距离，称为“间隔”（Margin）</p><p>我们要找的，就是使得 <strong>间隔最大</strong> 的那条直线</p><p><img src="https://s2.loli.net/2022/09/02/aIMwlgpoYdm1UHf.png" alt="image.png" style="zoom:50%;"></p><p>但是，使用“间隔最大”这条准则，并不能唯一的确定一条直线，因此，还需规定：这条线<strong>在上下两个平行线的中间</strong></p><p>因此，SVM寻找的<strong>最优分类直线应该满足三个条件</strong>：</p><ul><li>该直线<strong>分开</strong>了两类</li><li>该直线<strong>最大化间隔</strong></li><li>该直线处于间隔的<strong>正中间</strong>，到所有支持向量距离相等</li></ul><p>在线性可分的条件下，<strong>有且仅有唯一一条直线</strong>，满足上面三个条件。在高维空间中，直线就变成了<strong>超平面</strong></p><h2 id="优化问题（硬间隔）"><a href="#优化问题（硬间隔）" class="headerlink" title="优化问题（硬间隔）"></a>优化问题（硬间隔）</h2><blockquote><p>用严格的数学，将寻找<strong>最优分类超平面</strong>的过程写成一个最优化问题</p></blockquote><p>描述任意一个超平面：$w^{T} x+b=0$</p><p>$\omega=\left[\begin{array}{c}<br>\omega_{1} \\<br>\omega_{2} \\<br>\vdots \\<br>\omega_{m}<br>\end{array}\right]$，$|\omega|^{2}=\omega_{1}^{2}+\omega_{2}^{2} \ldots+\omega_{m}^{2}=\sum_{i=1}^{m} \omega_{i}^{2}$</p><p><strong>点到直线距离</strong>：</p><ul><li><p>二维空间：点 $(x,y)$ 到直线 $Ax+By+C=0$ 的距离：$\frac{|A x+B y+C|}{\sqrt{A^{2}+B^{2}}}$</p></li><li><p>n维空间：点$x=\left(x_{1}, x_{2} \ldots x_{n}\right)$，到直线$w^{T} x+b=0$的距离：$\frac{\left|w^{T} x+b\right|}{|w|}$，其中$|w|=\sqrt{w_{1}^{2}+\ldots w_{n}^{2}}$</p></li></ul><p>因此，<strong>支持向量到超平面的距离 </strong>若为$r$，则其它点到超平面的距离必然大于$r$。因此，对于所有样本点$x$：</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\frac{w^{T} x+b}{\|w\|} \geq r \quad y=1 \\\frac{w^{T} x+b}{\|w\|} \leq-r \quad y=-1\end{array}\right.</script><p>$|w|r$为正数，暂且令为$|w|r = 1$（方便推导，且对目标函数优化没有影响）</p><p>则为了$r$最大，则等价于：</p><script type="math/tex; mode=display">\max _{w, b} \frac{1}{\|w\|} \Leftrightarrow \max _{w, b} \frac{1}{\|w\|^{2}} \Leftrightarrow \min _{w, b}\|w\|^{2} \Leftrightarrow \min _{w, b} \frac{1}{2}\|w\|^{2}</script><p>使得</p><script type="math/tex; mode=display">\left\{\begin{array}{l}w^{T} x+b \geq 1 \quad y=1 \\w^{T} x+b \leq-1 \quad y=-1\end{array}\right.</script><p>上面这个方程组合并，简写为：</p><script type="math/tex; mode=display">y\left(w^{T} x+b\right) \geq 1</script><p>故<strong>SVM最优化问题</strong>总结为：</p><p><strong>已知：</strong>训练样本集$\{(X_i,y_i)\},i=1\to m$</p><p><strong>待求</strong>：$(w,b)$</p><p><strong>则可以表示为</strong>：$\min \frac{1}{2}|w|^{2} \text { s.t. } \quad y_{i}\left(w^{T} x_{i}+b\right) \geq 1 \quad i\in[1,m]$</p><blockquote><p>凸优化（Convex Optimization）中的二次规划问题：</p><p>（1）目标函数是二次项</p><p>（2）限制条件是一次项</p><p>凸优化问题只有唯一一个全局极值，可用梯度下降求得</p></blockquote><p>🔸 利用<strong>拉格朗日乘子法转换为对偶问题</strong> 求解超平面</p><p>原问题 写成 拉格朗日函数：</p><script type="math/tex; mode=display">L(\omega, b, \alpha)=\frac{1}{2}\|\omega\|^{2}+\sum_{i=1}^{m} \alpha_{i}\left(1-y_{i}\left(\omega^{T} x_{i}+b\right)\right)</script><p>转换为  <strong>对偶问题</strong></p><script type="math/tex; mode=display">\max _{\alpha} \min _{w, b}L(w, b, \alpha) \quad s.t.  \alpha_{i} \geq 0, \forall i \in\{1, \ldots m\}</script><p>同时要满足<strong>KKT条件</strong>（原问题可行、对偶问题可行、互补松弛）：</p><script type="math/tex; mode=display">\begin{array}{cc}1-y^{(i)}\left(\left(w^{*}\right)^{T} x^{(i)}+b^{*}\right) \leq 0 & \forall i \in\{1, \ldots m\} \\\alpha_{i} \geq 0 & \forall i \in\{1, \ldots m\} \\\alpha_{i}\left(1-y^{(i)}\left(\left(w^{*}\right)^{T} x^{(i)}+b^{*}\right)\right)=0 & \forall i \in\{1, \ldots m\}\end{array}</script><p><strong>求解对偶问题</strong>：</p><ul><li><p><strong>拉格朗日函数最小化</strong></p><script type="math/tex; mode=display">\begin{array}{c}\frac{\partial L(w, b, \alpha)}{\partial w}=w-\sum_{i=1}^{m} \alpha_{i} y^{(i)} x^{(i)}=0 \Rightarrow w=\sum_{i=1}^{m} \alpha_{i} y^{(i)} x^{(i)} \\\frac{\partial L(w, b, \alpha)}{\partial b}=\sum_{i=1}^{m} \alpha_{i} y^{(i)}=0\end{array}</script><p>然后把上述结果带回到拉格朗日函数中，得到</p><script type="math/tex; mode=display">\min _{w, b} L(w, b, \alpha)=-\frac{1}{2} \sum_{i, j=1}^{m} y^{(i)} y^{(j)} \alpha_{i} \alpha_{j}\left(x^{(i)}\right)^{T} x^{(j)}+\sum_{i=1}^{m} \alpha_{i}</script></li><li><p><strong>最大化 最小拉格朗日函数</strong></p><script type="math/tex; mode=display">\begin{array}{c}\max _{\boldsymbol{\alpha}} \min _{\boldsymbol{w}, b} L(w, b, \alpha)=\max _{\alpha}\left(-\frac{1}{2} \sum_{i, j=1}^{m} y^{(i)} y^{(j)} \alpha_{i} \alpha_{j}\left(x^{(i)}\right)^{T} x^{(j)}+\sum_{i=1}^{m} \alpha_{i}\right) \\\text { s.t. } \alpha_{i} \geq 0, \forall i \in\{1, \ldots m\} \\\sum_{i=1}^{m} \alpha_{i} y^{(i)}=0\end{array}</script><p>通过序列最小优化SMO求解最优$\alpha^*$，则有：</p><script type="math/tex; mode=display">\boldsymbol{w}^{*}=\sum_{i=1}^{m} \alpha_{i}^{*} y^{(i)} x^{(i)}</script><p>“有用的” $a^*&gt;0$，根据KKT的互补松弛条件：</p><script type="math/tex; mode=display">\alpha_{i}^{*}\left(1-y^{(i)}\left(\left(w^{*}\right)^{T} x^{(i)}+b^{*}\right)\right)=0</script><p>可知$1-y^{(i)}\left(\left(w^{<em>}\right)^{T} x^{(i)}+b^{</em>}\right)=0$，$(x^{(i)},y^{(i)})$一定是约束边界上的点，记为：$(\tilde{x},\tilde{y})$，因此有：</p><script type="math/tex; mode=display">b^{*}=\tilde{y}-w^{* T} \tilde{x}</script><p>所以，SVM的决策函数为：</p></li></ul><script type="math/tex; mode=display">\hat{y}=\operatorname{sgn}\left(h_{w^{*}, b^{*}}(x)\right)=\operatorname{sgn}\left(\left(w^{*}\right)^{T} x+b\right)=\operatorname{sgn}\left(\sum_{i=1}^{m} \alpha_{i}^{*} y^{(i)}\left(x^{(i)}\right)^{T} x^{(i)}+b^{*}\right)</script><p><img src="https://s2.loli.net/2022/09/02/UbEvK62S9Yud5Cj.png" alt="svm.png" style="zoom: 33%;"></p><ul><li><strong>支持向量</strong>：满足$w^{T} x+b=1 \quad或\quad  w^{T} x+b=-1$ 的点</li><li><p>每个<strong>支持向量到超平面</strong>的距离：$d=\frac{\left|w^{T} x+b\right|}{|w|}$</p></li><li><p>多维空间中<strong>任意平行的超平面</strong>间的距离：$\frac{|d_1-d_2|}{|w|}$</p></li><li><p><strong>辅助决策边界距离</strong>：$2\frac{1}{|w|}$</p></li></ul><h2 id="线性不可分的情况（软间隔）"><a href="#线性不可分的情况（软间隔）" class="headerlink" title="线性不可分的情况（软间隔）"></a>线性不可分的情况（软间隔）</h2><p>通常情况下，线性不可分的训练数据有一些特异点，去掉这些特异点后，剩下的大部分的样本点组成的集合是线性可分的。线性不可分意味着某些样本点不能满足间隔大于等于1的条件，样本点落在超平面与边界之间。</p><p>因此，需<strong>要适当放松限制条件</strong>，对于每个训练样本及标签，为每一个样本点设置<strong>松弛变量</strong>（slack variable）$\delta_{i}$</p><p>因此，限制条件改写为：</p><script type="math/tex; mode=display">y_{i}\left(\omega^{T} X_{i}+b\right) \geq 1-\delta_{i},(i=1 \sim m)</script><p>再加入新的限制条件，防止松弛变量无限大，改造后SVM最优化版本如下：</p><p><strong>最小化:</strong>  $\frac{1}{2}|\omega|^{2}+C \sum_{i=1}^{N} \delta_{i}  或  \frac{1}{2}|\omega|^{2}+C \sum_{i=1}^{N} \delta_{i}^{2}$</p><p><strong>限制条件</strong></p><ol><li>$\delta_{i} \geq 0 .(i=1 \sim m)$</li><li>$y_{i}\left(\omega^{T} X_{i}+b\right) \geq 1-\delta_{i},(i=1 \sim m)$</li></ol><blockquote><p>比例因子C是人为设定的——超参数</p></blockquote><h2 id="低维到高维的映射"><a href="#低维到高维的映射" class="headerlink" title="低维到高维的映射"></a>低维到高维的映射</h2><blockquote><p>把线性不可分转换成线性可分</p><p>把特征空间从低维映射到高维，用线性超平面对数据进行分类</p></blockquote><p>对于原始样本空间不是线性可分的情况，可将样本从原始空间<strong>映射到一个更高维</strong>的特征空间，使得样本在这个特征空间内线性可分。如果原始空间是有限维，即属性数有限，那么一定存在一个高维特征空间使样本可分。</p><h2 id="核函数的定义"><a href="#核函数的定义" class="headerlink" title="核函数的定义"></a>核函数的定义</h2><p>核函数Kernel Function：</p><script type="math/tex; mode=display">K\left(X_{1}, X_{2}\right)=\varphi\left(X_{1}\right)^{T} \varphi\left(X_{2}\right)</script><p>假设，$\varphi\left(X\right)$ 是一个将<strong>二维</strong>向量映射到<strong>三维</strong>向量的映射：</p><script type="math/tex; mode=display">\begin{array}{c}X=\left[x_{1}, x_{2}\right]^{T} \\\varphi(X)=\varphi\left(\left[x_{1}, x_{2}\right]^{T}\right)=\left[x_{1}^{2}, x_{1} x_{2}, x_{2}^{2}\right]\end{array}</script><p>假设有两个二维向量  $X_{1}=\left[x_{11}, x_{12}\right]^{T} \quad X_{2}=\left[x_{21}, x_{22}\right]^{T}$，根据上述定义，则有：</p><script type="math/tex; mode=display">\varphi\left({X}_{1}\right)=\left[{x}_{11}^{2}, {x}_{11} {x}_{12}, {x}_{12}^{2}\right]\\\varphi\left({X}_{2}\right)=\left[{x}_{21}^{2}, {x}_{21} {x}_{22}, {x}_{22}^{2}\right]</script><p>那么：</p><script type="math/tex; mode=display">\begin{aligned}K\left(X_{1}, X_{2}\right) &=\varphi\left(X_{1}\right)^{T} \varphi\left(X_{2}\right) \\&=\left[x_{11}^{2}, x_{11} x_{12}, x_{12}^{2}\right]\left[x_{21}^{2}, x_{21} x_{22} x_{22}^{2}\right]^{T} \\&=x_{11}^{2} x_{21}^{2}+x_{11} x_{12} x_{21} x_{22}+x_{12}^{2} x_{22}^{2}\end{aligned}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;支持向量机&lt;/p&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【SE】MindSpore开源创新实践课程笔记</title>
    <link href="http://example.com/2022/08/31/2022-08-12-%E3%80%90SE%E3%80%91%E5%8D%8E%E4%B8%BA%E6%98%87%E8%85%BEMindSpore%E5%BC%80%E6%BA%90%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/08/31/2022-08-12-%E3%80%90SE%E3%80%91%E5%8D%8E%E4%B8%BA%E6%98%87%E8%85%BEMindSpore%E5%BC%80%E6%BA%90%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2022-08-31T01:55:34.000Z</published>
    <updated>2022-09-02T16:07:29.632Z</updated>
    
    <content type="html"><![CDATA[<p>毕业实习中 关于华为 昇腾MindSpore开源创新实践课程内容部分学习笔记</p><span id="more"></span><h1 id="Python编程基础"><a href="#Python编程基础" class="headerlink" title="Python编程基础"></a>Python编程基础</h1><h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><h3 id="工具包的导入"><a href="#工具包的导入" class="headerlink" title="工具包的导入"></a>工具包的导入</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入整个模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getcwd()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入模块中的指定函数</span></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getcwd()</span><br><span class="line">getcwd()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 名字较为复杂，用as取别名</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></tbody></table></figure><h3 id="变量范围"><a href="#变量范围" class="headerlink" title="变量范围"></a>变量范围</h3><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment"># 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    b = <span class="number">3</span> <span class="comment"># 函数内部，局部变量</span></span><br><span class="line">c = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a+c) <span class="comment"># √</span></span><br><span class="line"><span class="built_in">print</span>(b+c) <span class="comment"># ×</span></span><br></pre></td></tr></tbody></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数值和字符串"><a href="#数值和字符串" class="headerlink" title="数值和字符串"></a>数值和字符串</h3><p>python3支持int、float、bool、complex（复数）几种类型的数值</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a/b) <span class="comment">#2.5</span></span><br><span class="line"><span class="built_in">print</span>(a**b) <span class="comment">#平方，25</span></span><br></pre></td></tr></tbody></table></figure><p>python中没有字符，单个字符被认作长度为1的字符串；</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">"python"</span></span><br><span class="line">s2 = <span class="string">'python'</span> <span class="comment"># 单引号和双引号完全一样，没有区别</span></span><br><span class="line">s3 = <span class="string">'''</span></span><br><span class="line"><span class="string">python</span></span><br><span class="line"><span class="string"> '''</span>   <span class="comment"># 三引号字符串 可以是多行字符串</span></span><br></pre></td></tr></tbody></table></figure><p>原始字符串，在字符串前面加入字母r，屏蔽掉字符串中的所有转义字符</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">r"p\y\tho\n"</span> <span class="comment"># print: p\y\tho\n</span></span><br></pre></td></tr></tbody></table></figure><p>字符串有序不可变</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"python"</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>])</span><br><span class="line">s[<span class="number">0</span>]=<span class="string">"a"</span> <span class="comment"># 报错，不可修改</span></span><br></pre></td></tr></tbody></table></figure><p>字符串的运算</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"hello"</span></span><br><span class="line">b = <span class="string">"world"</span></span><br><span class="line">c = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a+b) <span class="comment"># helloworld</span></span><br><span class="line"><span class="built_in">print</span>(a*<span class="number">2</span>) <span class="comment"># hellohello</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>字符串常用的操作，包括切割、大小写替换、拼接等，这些操作没有修改原来的字符串，而是生成了新的字符串</p><figure class="highlight py"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"python"</span></span><br><span class="line"><span class="comment"># 切割,str.split(str1): 以str1 为分隔符 对字符串进行分割</span></span><br><span class="line">s.split(<span class="string">'h'</span>)  <span class="comment"># ['pyt','on']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换,str.replace(str1, str2): 将字符串中的str1 替换为 str2生成新的字符串</span></span><br><span class="line">s.replace(<span class="string">'py'</span>,<span class="string">'PY'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大小写替换</span></span><br><span class="line"><span class="comment"># str.lower(): 字符串中的大写转小写</span></span><br><span class="line"><span class="comment"># str.upper(): 字符串中的小写转大写</span></span><br><span class="line">s = <span class="string">"PYthon"</span></span><br><span class="line">s.lower() <span class="comment"># python</span></span><br><span class="line">s.upper() <span class="comment"># PYTHON</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接</span></span><br><span class="line"><span class="comment"># str.join(iter):将所给参数中的每个元素以指定字符连接成一个新字符串</span></span><br><span class="line"><span class="string">"-"</span>.join(<span class="string">"python"</span>) <span class="comment"># p-y-t-h-o-n</span></span><br></pre></td></tr></tbody></table></figure><p>格式化输出</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"my name is %s,age is %d"</span> %(<span class="string">'AI'</span>,<span class="number">63</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="列表和元组"><a href="#列表和元组" class="headerlink" title="列表和元组"></a>列表和元组</h3><p>列表：有序，其中元素可以是任意数据类型，可随时添加或删除元素</p><p>List[obj1，obj2，… ]</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">#创建列表</span></span><br><span class="line">L[<span class="number">1</span>]  <span class="comment"># 访问元素</span></span><br><span class="line">L[<span class="number">1</span>] = <span class="number">0</span> <span class="comment"># 修改元素</span></span><br></pre></td></tr></tbody></table></figure><p>列表中的操作</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">animals = [<span class="string">'cat'</span>,<span class="string">'dog'</span>,<span class="string">'monkey'</span>]</span><br><span class="line">animals.append(<span class="string">'fish'</span>) <span class="comment"># 追加元素</span></span><br><span class="line">animals.remove(<span class="string">'fish'</span>) <span class="comment"># 删除指定数据；</span></span><br><span class="line"><span class="comment"># 若有多个fish，只会删除第一个fish</span></span><br><span class="line"></span><br><span class="line">anmials.insert(<span class="number">1</span>,<span class="string">'fish'</span>) <span class="comment"># 在下标1的地方插入fish</span></span><br><span class="line">animals.pop(<span class="number">1</span>) <span class="comment"># 删除下标为1 的元素，返回值为删除的这个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历元素 并获取对应索引</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">enumerate</span>(animals):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># list.sort(cmp=None,key=None,reverse=False)</span></span><br><span class="line"><span class="comment"># cmp为可选参数，若指定该参数，会使用该参数的方法进行排序</span></span><br><span class="line"><span class="comment"># key是用来比较的元素</span></span><br><span class="line"><span class="comment"># reverse为排序规则，False默认升序</span></span><br></pre></td></tr></tbody></table></figure><p>切片和索引</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">l[<span class="number">3</span>][<span class="number">0</span>]<span class="comment"># 索引访问从0~n-1，所有有序序列都能使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片，list[start:end:step] </span></span><br><span class="line"><span class="comment"># start为0,end为n-1，step为1时 可省略</span></span><br><span class="line">l=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">l[::] <span class="comment"># 0,1,2,3,4</span></span><br><span class="line">l[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>] <span class="comment"># 1,3</span></span><br></pre></td></tr></tbody></table></figure><p>元组：不可变 的有序序列，元素可以是任意对象，小括号包裹元素</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>],<span class="string">'python'</span>)</span><br><span class="line"><span class="comment"># 创建单个元组</span></span><br><span class="line">t1=(<span class="number">5</span>)  <span class="comment"># t1&lt;class,'int'&gt;</span></span><br><span class="line">t2=(<span class="number">5</span>,) <span class="comment"># 创建单个元组需要用逗号来表明是元素 t2&lt;class,'tuple'&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="字典和集合"><a href="#字典和集合" class="headerlink" title="字典和集合"></a>字典和集合</h3><p>字典的每个元素由两部分组成：键+值；（key，vale）</p><p>键：不可变且唯一；如果字典有相同的键，则后面的键对应的值会将前面的值覆盖，数据量大时，字典数据 的访问速度比列表快</p><p>字典的三种赋值操作</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = {<span class="string">'food'</span>:<span class="string">'Spam'</span>,<span class="string">'quantity'</span>:<span class="number">4</span>,<span class="string">'color'</span>:<span class="string">'pink'</span>}</span><br><span class="line">x2 = <span class="built_in">dict</span>(food=<span class="string">'Spam'</span>,quantity=<span class="number">4</span>,color=<span class="string">'pink'</span>)</span><br><span class="line">x3 = <span class="built_in">dict</span>([(<span class="string">'food'</span>,<span class="string">'Spam'</span>),(<span class="string">'quantity'</span>,<span class="number">4</span>),(<span class="string">'color'</span>,<span class="string">'pink'</span>)])</span><br></pre></td></tr></tbody></table></figure><p>获取字典数据</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x[<span class="string">'food'</span>]) <span class="comment"># 若访问不存在的键，会报错</span></span><br><span class="line"><span class="built_in">print</span>(x.get(<span class="string">'food'</span>))</span><br><span class="line"><span class="built_in">print</span>(x.get(<span class="string">'x'</span>))  <span class="comment"># None</span></span><br><span class="line"><span class="comment"># 使用get获取数据 ，若键不存在会返回指定的str</span></span><br><span class="line"><span class="built_in">print</span>(x.get(<span class="string">'x'</span>),<span class="string">'x不存在'</span>) <span class="comment"># x不存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有键</span></span><br><span class="line"><span class="built_in">print</span>(x.keys())</span><br><span class="line"><span class="built_in">print</span>(x.values())</span><br><span class="line"><span class="built_in">print</span>(x.items()) <span class="comment"># 键值对</span></span><br></pre></td></tr></tbody></table></figure><p>插入和修改</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="string">'x'</span>]=<span class="string">'x'</span></span><br><span class="line">x[<span class="string">'x'</span>]=<span class="number">0</span></span><br></pre></td></tr></tbody></table></figure><p>集合中的元素唯一，花括号包裹元素，可以被修改，无序</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sample_set={<span class="string">'Prince'</span>,<span class="string">'Techs'</span>}</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Data'</span>,<span class="keyword">in</span> sample_set) <span class="comment"># False: in检查集合中是否某一元素</span></span><br><span class="line">sample_set.add(<span class="string">'Data'</span>)</span><br><span class="line">sample_set.remove(<span class="string">'Data'</span>)</span><br></pre></td></tr></tbody></table></figure><p>列表去重</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(list1))) <span class="comment"># 1,2,3</span></span><br><span class="line">sample_set = <span class="built_in">frozenset</span>(sample_set) <span class="comment"># 不可变集合</span></span><br></pre></td></tr></tbody></table></figure><h3 id="运算符和数据拷贝"><a href="#运算符和数据拷贝" class="headerlink" title="运算符和数据拷贝"></a>运算符和数据拷贝</h3><p>浅拷贝：对数据的表面结构进行拷贝，如果数据是嵌套的结构，则嵌套结构里的元素是对之前数据的引用。修改之前的数据会影响拷贝得到的数据</p><p><strong>深拷贝</strong>：解决了嵌套结构中深层结构只是引用的问题；对所有数据进行一次复制，<strong>修改之前的数据则不会改变拷贝得到的数据</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">b=a   <span class="comment"># 赋值</span></span><br><span class="line">c=a.copy() <span class="comment"># 浅拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">d = copy.deepcopy(a) <span class="comment"># 深拷贝</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">6</span> <span class="comment"># 修改a的值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">然后打印abcd</span></span><br><span class="line"><span class="string">    a=[6,2,3,[4,5]]</span></span><br><span class="line"><span class="string">    b=[6,2,3,[4,5]]</span></span><br><span class="line"><span class="string">    c=[1,2,3,[4,5]]</span></span><br><span class="line"><span class="string">    d=[1,2,3,[4,5]]</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">a[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">7</span> <span class="comment"># 修改嵌套列表的值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">然后打印abcd：</span></span><br><span class="line"><span class="string">a=[6,2,3,[7,5]]</span></span><br><span class="line"><span class="string">b=[6,2,3,[7,5]]</span></span><br><span class="line"><span class="string">c=[1,2,3,[7,5]]</span></span><br><span class="line"><span class="string">d=[1,2,3,[4,5]]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></tbody></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>if-elif-else的形式；判断条件中的0，None，空值等默认为False，其余为True</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">input</span>(<span class="string">"score:"</span>)</span><br><span class="line">a = <span class="built_in">float</span>(a)</span><br><span class="line"><span class="keyword">if</span> <span class="number">100</span>&gt;=a&gt;=<span class="number">60</span>：</span><br><span class="line">...</span><br><span class="line"><span class="keyword">elif</span> <span class="number">0</span>&lt;=a&lt;<span class="number">60</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure><p>Python中的for语句可以接受 可迭代对象作为参数，每次迭代一个</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"循环第%d次"</span>%(i))</span><br><span class="line"><span class="keyword">else</span>： <span class="comment"># 在循环正常结束后执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"循环结束"</span>)</span><br></pre></td></tr></tbody></table></figure><p>Python中没有do-while，while循环也可以添加else</p><h2 id="函数和对象"><a href="#函数和对象" class="headerlink" title="函数和对象"></a>函数和对象</h2><h3 id="自定义函数def"><a href="#自定义函数def" class="headerlink" title="自定义函数def"></a>自定义函数def</h3><p>自定义函数，打印不同方式传入的参数</p><ul><li>必备参数：必备参数须以正确的顺序传入函数，调用时的数量必须和声明时一样</li><li>关键字参数：函数调用时使用等号赋值的形式传入参数</li><li>默认参数：调用函数时，缺省参数的值如果没有传入，则被认为是默认值</li><li>不定长参数：有时可能需要一个函数能处理比当初声明更多的参数，这些不定长参数声明时不会命名。args，<em>kwargs：加了型号的变量args会存放所有未命名的变量参数，args为元组，而加\</em> 的变量kwargs会存放命名参数，形如key=value的参数，kwargs为字典</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a=<span class="number">1</span>, b=<span class="number">2</span>, *args</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a+b)</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 必备参数</span></span><br><span class="line">func(<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关键字参数</span></span><br><span class="line">func(b=<span class="number">4</span>,a=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不定长参数</span></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>lambda创建匿名函数，相比普通函数而言，匿名函数只是一个表达式，函数体比def简单很多，</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">lambda</span> x,y:x+y <span class="comment"># lambda 参数：表达式</span></span><br><span class="line">a(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># 调用函数</span></span><br></pre></td></tr></tbody></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>Python中创建类使用关键字class，并且具有封装、继承、多态的特点</p><ul><li>封装：把方法、数学、事件集中到一个统一的类中，对使用者屏蔽其中的细节</li><li>继承：在现有类的基础上，进行扩展生成新的子类</li><li>多态：一个同样的函数对于不同的对象可以有不同的实现</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span> <span class="comment"># py3中 所有类默认继承object</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_init_</span>(<span class="params">self,age,name</span>):</span> <span class="comment">#self：指实例化的对象</span></span><br><span class="line">        <span class="comment">#_init_ 对象初始化时调用的方法</span></span><br><span class="line">        self._age=age <span class="comment">#类属性</span></span><br><span class="line">        self.name=name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"xxx"</span>)</span><br><span class="line">        </span><br><span class="line">p1=Person(age=<span class="string">"18"</span>,name=<span class="string">"zyl"</span>)</span><br><span class="line">p1.func()</span><br></pre></td></tr></tbody></table></figure><p>Python是一门动态语言</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p1.ID=<span class="number">9191</span></span><br><span class="line"><span class="built_in">print</span>(p1.ID) <span class="comment"># 9191，ID这个属性是添加到这个对象的，而不是类的</span></span><br><span class="line"><span class="built_in">print</span>(Person.ID) <span class="comment"># 报错 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>(<span class="params">Person</span>):</span> <span class="comment"># 继承Person类</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></tbody></table></figure><p>默认情况下，属性在Python中都是public，类所在模块和导入了类所在模块的其他模块都可以访问到。</p><p>如果类中的某些属性不想被外界访问或者继承，可以对其私有化：</p><ul><li>在属性或方法前加上一个下划线，可以防止模块的属性用 “from mymodule import” 来加载，它只可以在本模块中使用</li><li>在方法或属性前加 双下划线，可以实现完全私有化</li></ul><h2 id="IO操作和异常捕获"><a href="#IO操作和异常捕获" class="headerlink" title="IO操作和异常捕获"></a>IO操作和异常捕获</h2><h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>Python中内置了读写文件的函数，open，返回文件对象</p><p>open（filename，mode，encoding）</p><p>——filename：包含要访问的文件名称的字符串值</p><p>——mode：决定了打开文件的模式（r：只读，w：写入，a：追加，b：二进制的形式操作）</p><p>——encoding：打开文件的编码格式，默认utf8</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="built_in">open</span>(<span class="string">"text.txt"</span>,<span class="string">'w'</span>) <span class="comment"># 若文件不存在会新建一个</span></span><br><span class="line">Str=<span class="built_in">input</span>(<span class="string">"Please input..."</span>)</span><br><span class="line">f.write(Str)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f.<span class="built_in">open</span>(<span class="string">"text.txt"</span>,<span class="string">'r'</span>)</span><br><span class="line"><span class="built_in">print</span>(f.read(<span class="number">6</span>)) <span class="comment"># 读取6个字符，当前光标后移6个字符</span></span><br><span class="line"><span class="built_in">print</span>(f.read()) <span class="comment"># 读取光标所在位置至最后</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用（上下文管理器）with语句进行文件写入，不需要close语句</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"text.txt"</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">"python文件操作"</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"text1.txt"</span>,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></tbody></table></figure><h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>——编码错误</p><p>——异常：运行时出错</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e) <span class="comment">#捕获</span></span><br></pre></td></tr></tbody></table></figure><h2 id="常用工具库"><a href="#常用工具库" class="headerlink" title="常用工具库"></a>常用工具库</h2><ul><li>标准库：安装Python后可以直接使用，例如os，sys，time等模块</li><li>第三方库：需要安装后才可以使用的库，如numpy（用于科学计算），pandas（用于数据处理），scikit-learn（机器学习库）</li></ul><h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3><p>负责程序与Python解释器的交互，提供了一系列的函数和变量，用于操控Python运行时的环境</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sys.exit([n])：此方法可以使当前程序退出，n=0表示正常退出，其他值表示异常退出</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">5</span>:</span><br><span class="line">sys.exit(<span class="number">0</span>) <span class="comment"># 执行到这里时，当前程序就停止了，后面的代码不会执行</span></span><br><span class="line">        </span><br><span class="line">sys.path <span class="comment"># 捕获模块搜索路径</span></span><br><span class="line">sys.platform <span class="comment"># 获取当前系统平台</span></span><br></pre></td></tr></tbody></table></figure><h3 id="os模块的使用"><a href="#os模块的使用" class="headerlink" title="os模块的使用"></a>os模块的使用</h3><p>负责程序和os的交互，提供了访问os底层的接口</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getpid() <span class="comment"># 获取当前进程id</span></span><br><span class="line">os.getcwd() <span class="comment"># 获取当前所在路径</span></span><br><span class="line">os.chdir(<span class="string">"C:\\"</span>) <span class="comment"># 更改当前工作目录</span></span><br></pre></td></tr></tbody></table></figure><h1 id="MindSpore框架简介"><a href="#MindSpore框架简介" class="headerlink" title="MindSpore框架简介"></a>MindSpore框架简介</h1><h1 id="机器学习概览"><a href="#机器学习概览" class="headerlink" title="机器学习概览"></a>机器学习概览</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>利用历史数据训练得到模型，再利用这个模型去处理新的数据，预测未来属性</p><p>基于规则的方法：使用显性编程解决问题，规则可以被人工明确</p><p>机器学习：使用样本训练，决策的规则复杂或者难以描述，由机器自动学习规则</p><p><strong>使用机器学习的情况</strong>：</p><ul><li>问题解决方案复杂，或者问题可能涉及到大量数据却没有明确的数据分布函数</li><li>规则十分复杂 或者无法描述：人脸识别、语音识别</li><li>任务的规则会随时间改变：生产线上的瑕疵检测</li><li>数据分布本身随时间变化，需要程序不停的重新适应：预测 商品销售的趋势</li></ul><p><strong>机器学习解决的主要问题</strong>：</p><ul><li><p>分类</p><blockquote><p>程序需要指定输入属于k类中的哪一类。学习算法通常会输出一个函数，$f:R^n\rightarrow (1,2,\dots,k)$ ，比如cv中的图像分类算法解决的就是一个分类任务</p></blockquote></li><li><p>回归</p><blockquote><p>程序会对给定输入 预测输出数值，学习算法通常会输出一个函数$f:R^n\rightarrow R$，比如预测投保人的索赔金额，预测证券未来的价格</p></blockquote></li><li><p>聚类</p><blockquote><p>对大量未知标注的数据集，按数据内在相似性，将数据划分为多个类别，类别内的数据相似度较大，类别间的相似性较小，比如图片检索，用户画像</p></blockquote></li></ul><p>分类和回归是预测问题的两种主要类型，分类的输出是离散的类别值，而回归的输出是连续数值</p><h2 id="机器学习分类"><a href="#机器学习分类" class="headerlink" title="机器学习分类"></a>机器学习分类</h2><p><strong>监督学习</strong></p><ul><li>利用<strong>已知类别</strong>的样本，训练学习得到一个最优模型，使其达到所要求性能</li><li>再利用这个训练所得模型，将所有的出入映射为相应的输出，对输出进行简单的判断，从而实现分类的目的，即：对未知数据进行分类</li><li>解决回归问题，回归——拟合出一个趋势</li><li>解决分类问题</li></ul><p><strong>无监督学习</strong></p><ul><li>对没有标记的样本，学习算法直接对输入数据集进行建模，例如聚类。把相似度高的东西放在一起，对于新来的样本，计算相似度后，按相似程度进行归类</li><li>用户画像</li><li>聚类：k-means</li></ul><p><strong>半监督学习</strong></p><ul><li>试图让学习器自动地对大量未标记数据进行利用以辅助少量有标记数据进行学习</li><li>分类：有标记的数据训练模型</li><li>聚类</li><li>回归</li></ul><p><strong>强化学习</strong></p><ul><li>学习系统从环境到行为映射的学习，以使奖励信号（强化信号）函数值最大，强化学习不同于连接主义学习中的监督学习，主要表现在教师信号上，强化学习中由环境提供的强化信号 是对产生动作的好坏作一种评价（通常为标量信号），而不是告诉强化学习系统如何去产生正确的动作</li><li>模型感知环境，做出行动，根据状态和奖惩做出调整和选择</li><li>强化学习总是在寻找什么样的行动才是最佳的，比如，自动驾驶汽车遇到黄灯开始闪了，是刹车还是加速通过；对于吸尘机器人，是继续吸尘还是回去充电</li></ul><h2 id="机器学习算法总体流程"><a href="#机器学习算法总体流程" class="headerlink" title="机器学习算法总体流程"></a>机器学习算法总体流程</h2><p>数据收集 ——数据清洗——特征提取与选择——模型训练——</p><p>数据集：机器学习任务中使用的一组数据，每个数据称为一个样本，反映样本在某方面的表现或性质的事项或属性称为特征。</p><p>训练集：训练过程中使用的数据集。从数据中学得模型的过程称为学习（训练）</p><p>测试集：学得模型后，对其进行预测，使用的数据集。</p><p><strong>训练集和测试集不可以有交集</strong></p><p>数据预处理</p><blockquote><p>数据清理：填充缺失值，发现并清除造成数据集异常点</p><p>数据降维：简化数据属性，避免维度爆炸</p><p>数据标准化：减少噪声，提高模型准确性</p></blockquote><p>脏数据</p><blockquote><p>不完整：数据中缺少属性 或 包含一些确实的值</p><p>多噪音：包含错误的记录或异常点</p><p>不一致：存在矛盾的、有差异的记录</p></blockquote><p>过拟合的原因——误差</p><ul><li><p>最终预测的总误差 = 偏差² + 方差 + 不可消解的误差</p></li><li><p>方差（Variance）</p><blockquote><p>模型的预测结果 在均值附近 的偏移的幅度</p><p>来源于莫小在训练集上对小波动的敏感性的误差</p></blockquote></li><li><p>偏差（Bias）</p><blockquote><p>模型的预期（或平均）预测值与试图预测的正确值之间的差异</p></blockquote></li></ul><p>随着模型复杂度上升，训练误差逐渐减小；同时测试误差会随着复杂度的增大而减小都某一点，继而反向增大，凸曲线</p><p>机器学习的性能评估——回归</p><ul><li><p>MAE（Mean Absolute Error）平均绝对误差，越趋于0，表示模型越拟合训练数据（$y_i$真实值，$\hat{y}_{i}$ 预测值）</p><script type="math/tex; mode=display">M A E=\frac{1}{\mathrm{~m}} \sum_{i=1}^{m}\left|y_{i}-\hat{y}_{i}\right|</script></li><li><p>MSE（Mean Square Error）</p><script type="math/tex; mode=display">M A E=\frac{1}{\mathrm{~m}} \sum_{i=1}^{m}\left|y_{i}-\hat{y}_{i}\right|^2</script></li><li><p>$R^2$ 取值范围（负无穷，1 ]，值越大，表示模型越拟合训练数据，TSS表示样本之间的差异情况，RSS表示预测值与样本值之间的差异情况</p><script type="math/tex; mode=display">R^{2}=1-\frac{R S S}{T S S}=1-\frac{\sum_{i=1}^{m}\left(y_{i}-\hat{y}_{i}\right)^{2}}{\sum_{i=1}^{m}\left(y_{i}-\bar{y}_{i}\right)^{2}}</script></li></ul><h2 id="机器学习的重要方法"><a href="#机器学习的重要方法" class="headerlink" title="机器学习的重要方法"></a>机器学习的重要方法</h2><h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><ul><li><p>批量梯度下降法（BGD）</p><p>使用<strong>所有</strong>数据集中的样本（共m个）在当前点的梯度之和来对权重参数进行更新</p><script type="math/tex; mode=display">w_{k+1}=w_{k}-\eta \frac{1}{m} \sum_{i=1}^{m} \nabla f_{w_{k}}\left(x^{i}\right)</script></li><li><p>随机梯度下降法（SGD）</p><p>随机选取一个数据集中的样本在当前的梯度来对权重参数进行更新操作</p><script type="math/tex; mode=display">w_{k+1}=w_{k}-\eta \nabla f_{w_{k}}\left(x^{i}\right)</script></li></ul><ul><li><p>小批量梯度下降法（MBGD）</p><p>结合BGD和SGD，每次选择数据集中n个样本的梯度来对权重参数进行更新</p><script type="math/tex; mode=display">w_{k+1}=w_{k}-\eta \frac{1}{n} \sum_{i=1}^{t+n-1} \nabla f_{w_{k}}\left(x^{i}\right)</script></li></ul><h3 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h3><p>参数：模型自动学习</p><p>超参数：人工手动设定</p><blockquote><p>模型从超参数 常用于<strong>估计模型参数</strong>的过程中</p><p>通常根据给定的预测建模问题而调整</p></blockquote><p>常见的模型超参数</p><blockquote><p>Lasso、Ridge回归中的λ</p><p>训练神经网络的学习速率，迭代次数、批次大小、激活函数、神经元数量</p><p>支持向量机的C和σ超参数</p><p>KNN中的K</p></blockquote><p>超参数搜索的一般过程</p><blockquote><p>将数据集</p></blockquote><h3 id="网格搜索"><a href="#网格搜索" class="headerlink" title="网格搜索"></a>网格搜索</h3><h3 id="随机搜索"><a href="#随机搜索" class="headerlink" title="随机搜索"></a>随机搜索</h3><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><h2 id="机器学习的常见算法"><a href="#机器学习的常见算法" class="headerlink" title="机器学习的常见算法"></a>机器学习的常见算法</h2><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h1 id="深度学习概览"><a href="#深度学习概览" class="headerlink" title="深度学习概览"></a>深度学习概览</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;毕业实习中 关于华为 昇腾MindSpore开源创新实践课程内容部分学习笔记&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="MindSpore" scheme="http://example.com/tags/MindSpore/"/>
    
  </entry>
  
  <entry>
    <title>【SE】C++常见问题</title>
    <link href="http://example.com/2022/08/12/2022-08-12-%E3%80%90SE%E3%80%91C++/"/>
    <id>http://example.com/2022/08/12/2022-08-12-%E3%80%90SE%E3%80%91C++/</id>
    <published>2022-08-12T01:55:34.000Z</published>
    <updated>2022-08-18T23:40:22.383Z</updated>
    
    <content type="html"><![CDATA[<p>一些C++面试常见问题</p><span id="more"></span><h1 id="原理类"><a href="#原理类" class="headerlink" title="原理类"></a>原理类</h1><h2 id="C-虚函数的原理（讲一下C-里面的虚函数）"><a href="#C-虚函数的原理（讲一下C-里面的虚函数）" class="headerlink" title="C++虚函数的原理（讲一下C++里面的虚函数）"></a>C++虚函数的原理（讲一下C++里面的虚函数）</h2><blockquote><p>参考：<a href="https://blog.csdn.net/aaqian1/article/details/86564817?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=虚函数&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-8-86564817.142^v40^pc_rank_34_2,185^v2^control&amp;spm=1018.2226.3001.4450">虚函数 2 之虚函数的定义_aaqian1的博客</a></p></blockquote><p>✅ <strong>定义</strong>：</p><ul><li><p>虚函数：在<strong>基类</strong>中被关键字 <code>virtual</code> 说明，并在<strong>派生类</strong>中<strong>重新定义</strong>的成员函数。</p></li><li><p>作用：允许在派生类 中  重新定义与基类同名的函数，并且可以通过<strong>基类指针或引用</strong>来访问基类和派生类中的同名函数。</p><blockquote><p>此虚函数就可 在一个或多个派生类中<strong>被重新定义</strong>。</p><p>虚函数声明只能出现在类定义中的函数原型声明中，不能在成员函数实现的时候。</p><p>在派生类中重新定义时，其函数原型，包括函数类型、函数名、参数个数、参数类型的顺序，都必与基类中的原型完全相同。</p></blockquote></li></ul><p>🔴  使用  <strong>对象名和点运算符</strong>  的方式  调用虚函数是在<strong>编译</strong>时进行的，<strong>是静态联编</strong>，没有利用虚函数的特性。</p><p>🔴  只有通过  <strong>基类指针访问虚函数</strong>  时   才能获得   <strong>运行时的多态性</strong>。</p><ul><li>运行期多态发生的三个条件：<strong>继承关系、虚函数覆盖、父类指针或引用指向子类对象</strong>。</li></ul><p><strong>✅  虚函数 与 函数重载 的关系</strong></p><ul><li>在一个派生类中重新定义基类的虚函数是函数重载的另一种形式，但它不同于一般的函数重载。</li><li>当普通的函数重载时，其函数的 参数 或 参数类型 有所不同，函数的 返回类型 也可以不同。</li><li>但是，当重载一个虚函数时，即在派生类中重新定义虚函数时，要求函数名、返回类型、参数个数、参数的类型和顺序与<strong>基类中的虚函数原型完全相同</strong>。①如果仅仅返回类型不同，其余均相同，系统会给出错误信息；②若仅仅函数名相同，而参数的个数，类型或顺序不同，系统将它作为普通的函数重载，<strong>虚函数的特性将丢失</strong></li></ul><p>✅ <strong>作用</strong></p><p>虚函数是运行时多态的一种实现方式，基类中的成员函数被定义为虚函数，派生类对相应的虚函数进行了重写，使用的时候，可以使用基类指针指向派生类对象，通过这个基类指针能够访问到派生类中重写的函数，这样，通过基类的指针就可以使属于不同派生类的不同对象产生不同的行为，从而实现运行时的多态。程序能够完成同样的消息被不同的类型的对象接收时导致不同的行为，能够用更加一般化的操作方式操作部分具体的对象。</p><p>✅ <strong>虚函数的实现原理</strong></p><p>重点理解！！！！！！</p><blockquote><p>参考：</p><p><a href="https://www.cnblogs.com/malecrab/p/5572730.html">C/C++杂记：虚函数的实现的基本原理 - malecrab - 博客园 (cnblogs.com)</a></p><p><a href="https://leehao.blog.csdn.net/article/details/50688337?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-50688337-blog-110404856.t0_layer_searchtargeting_sa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-50688337-blog-110404856.t0_layer_searchtargeting_sa&amp;utm_relevant_index=2">C++虚函数表剖析_haozlee的博客-CSDN博客</a></p></blockquote><h2 id="c语言编译的过程中，const是怎么保证静态的？"><a href="#c语言编译的过程中，const是怎么保证静态的？" class="headerlink" title="c语言编译的过程中，const是怎么保证静态的？"></a>c语言编译的过程中，const是怎么保证静态的？</h2><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/qq_37957347/article/details/115465983"> C语言const是如何保证变量不被修改的?_Xilaii的博客-CSDN博客</a></p></blockquote><h2 id="C-的重载需要注意什么问题？"><a href="#C-的重载需要注意什么问题？" class="headerlink" title="C++的重载需要注意什么问题？"></a>C++的重载需要注意什么问题？</h2><h2 id="C-是怎么实现多态和继承"><a href="#C-是怎么实现多态和继承" class="headerlink" title="C++是怎么实现多态和继承?"></a>C++是怎么实现多态和继承?</h2><h2 id="指针是构造类型还是基础类型，为什么？"><a href="#指针是构造类型还是基础类型，为什么？" class="headerlink" title="指针是构造类型还是基础类型，为什么？"></a>指针是构造类型还是基础类型，为什么？</h2><h1 id="介绍类"><a href="#介绍类" class="headerlink" title="介绍类"></a>介绍类</h1><h2 id="从高级语言到机器语言要经历那几个过程"><a href="#从高级语言到机器语言要经历那几个过程" class="headerlink" title="从高级语言到机器语言要经历那几个过程"></a>从高级语言到机器语言要经历那几个过程</h2><h2 id="c-内存泄漏，for循环如何加快"><a href="#c-内存泄漏，for循环如何加快" class="headerlink" title="c++内存泄漏，for循环如何加快"></a>c++内存泄漏，for循环如何加快</h2><h2 id="什么是STL，有哪些部分组成及主要应用？"><a href="#什么是STL，有哪些部分组成及主要应用？" class="headerlink" title="什么是STL，有哪些部分组成及主要应用？"></a>什么是STL，有哪些部分组成及主要应用？</h2><p><strong>STL</strong>：全称Standard Template Library，是C++的标准模板库。</p><p><strong>组成部分</strong>：容器、迭代器和算法。</p><ul><li>容器：顺序容器，关联容器；</li><li>迭代器：输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器；</li><li>算法：不可变序列算法、可变序列算法、排序和搜索算法、数值算法。</li></ul><p><strong>核心作用</strong></p><p>使开发者能够有效地利用已有的成果，将经典的、优秀的算法标准化、模块化，从而提高软件的生产效率。</p><h2 id="举例说明const和static"><a href="#举例说明const和static" class="headerlink" title="举例说明const和static"></a>举例说明const和static</h2><h2 id="C语言的局部变量（栈）和全局变量存储位置（堆）"><a href="#C语言的局部变量（栈）和全局变量存储位置（堆）" class="headerlink" title="C语言的局部变量（栈）和全局变量存储位置（堆）"></a>C语言的局部变量（栈）和全局变量存储位置（堆）</h2><h2 id="内存的分配方式有几种？"><a href="#内存的分配方式有几种？" class="headerlink" title="内存的分配方式有几种？"></a>内存的分配方式有几种？</h2><ul><li>从<strong>静态存储区域</strong>分配。内存在程序编译时就已分配好，这块内存在程序的整个运行期间都存在。如全局变量。</li></ul><ul><li>在<strong>栈</strong>上创建。在执行函数时，<strong>函数内局部变量</strong>的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li></ul><ul><li>从<strong>堆</strong>上分配，亦称<strong>动态内存分配</strong>。程序在运行的时候用 <strong>malloc 或 new</strong> 申请任意多少的内存，程序员自己负责在何时用 free 或delete 释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</li></ul><h2 id="C-的类中的成员变量-如何初始化（顺序）的？"><a href="#C-的类中的成员变量-如何初始化（顺序）的？" class="headerlink" title="C++的类中的成员变量 如何初始化（顺序）的？"></a>C++的类中的成员变量 如何初始化（顺序）的？</h2><p>① 基类的 静态或全局变量</p><p>②派生类的 静态或全局变量</p><p>③基类的 成员变量</p><p>④派生类的 成员变量</p><h2 id="为什么说”继承是C-面向对象的一个主要特征之一”"><a href="#为什么说”继承是C-面向对象的一个主要特征之一”" class="headerlink" title="为什么说”继承是C++面向对象的一个主要特征之一”?"></a>为什么说”继承是C++面向对象的一个主要特征之一”?</h2><p>继承是软件重用的一种形式，继承机制允许程序员在保持原有类特征的基础上，进行更具体、更详细的类的定义，以原有的类为基础产生新的类，提高了代码的重用性和可扩充性。通过继承可以充分利用别人做过一些类似的研究，和已有的一些分析、解决方案。进一步提高程序的抽象程度，同时虚函数的多态性也是在继承功能的基础之上展开的。</p><h2 id="什么是友元，有什么利弊？"><a href="#什么是友元，有什么利弊？" class="headerlink" title="什么是友元，有什么利弊？"></a>什么是友元，有什么利弊？</h2><p><strong>利</strong>：友元可以是一个函数也可以是一个类，提供了不同类的成员函数之间、类的成员函数与普通函数之间的数据共享，通过友元关系，普通函数或者另一个类中的成员函数可以访问当前类中的私有成员和保护成员，能够减少通过函数接口调用的开支，提高程序运行效率，实现信息共享。</p><p><strong>弊：</strong>友元关系会破坏类的封装性和隐藏性，使其内部的数据成员暴露出来，加大维护的难度。</p><blockquote><p>1.先回到第一个问题，当我们需要提高效率或者为了方便，我们会使用它。因为普通函数无法访问私有的成员，除非全部声明为共有的。但是有了友元这个机制，我们就可以访问到对象的私有成员和数据了。</p><p>2.好处上面已经说了，是为了方便和快速。但是它明显的带来了一定的坏处，那就是破坏了类的封装性。（我校招的时候，某金融企业面试官问我继承的缺点，实际上我想，继承本身是为了构建父子关系，但是它从一定程度上讲，确实是破坏了子类的封装性，因为一个类被封装了之后就表面其内容对其他类是不可见的，但是继承却可以通过不同的方式看到父类的一些信息。当然，这只是我个人体会的）。</p></blockquote><h2 id="面向对象的三大特征？实现方式？"><a href="#面向对象的三大特征？实现方式？" class="headerlink" title="面向对象的三大特征？实现方式？"></a>面向对象的三大特征？实现方式？</h2><p><strong>封装</strong>：将对象中不需要让外界访问的成员变量和方法私有化，只提供符合开发者意愿的公有方法来访问这些数据和逻辑，保证了数据的安全和程序的稳定。</p><p><strong>继承</strong>：当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法了，只需要通过extend语句继承父类即可，这样，子类就会自动拥有父类定义的属性和方法，达到代码复用的效果。Java 是单继承，一个类只能继承一个父类。</p><p><strong>多态</strong>：指同一个行为具有多种不同的表现形式，有三种方式来实现多态：子类继承父类，子类重写父类的方法，父类型的引用指向子类型的对象。主要的应用有：方法的重载和重写。好处是使代码具有可替换性、扩展性、降低耦合、接口性、灵活性、简化性。在调用的时候只需将子类对象传递给基类对象，编译器将会根据具体类的对象调用相应对象的方法，从而简便了编程</p><p>多态：指同样的消息被不同类型的对象接收时导致不同的行为。从实现的角度可以分为编译时多态和运行时多态。前者是在编译过程中确定同名操作的具体操作对象，主要是通过所声明的类型匹配相应操作，例如函数的重载，后者则是在程序运行过程中才动态地确定操作所针对的具体对象，例如虚函数，其主要是通过虚表实现。</p><h2 id="⭕什么是ADT，比较“数据抽象”和“信息隐藏”？"><a href="#⭕什么是ADT，比较“数据抽象”和“信息隐藏”？" class="headerlink" title="⭕什么是ADT，比较“数据抽象”和“信息隐藏”？"></a>⭕什么是ADT，比较“数据抽象”和“信息隐藏”？</h2><p><strong>ADT</strong>：Abstract Data Type，抽象数据类型，是具有<strong>类似行为的 特定类别</strong>的数据结构的数据模型，或者具有<strong>类似语义</strong>的一种或多种 程序设计语言的<strong>数据类型</strong>它通常是对数据的某种抽象，定义了数据的取值范围及其结构形式，以及对数据操作的集合</p><p><strong>数据抽象</strong>：指定义数据成员和函数成员的能力，从实际问题中抽象出所关心的共同特征，忽略非本质的细节，把这些特性用各种概念精确地加以描述组成某种模型。以数据为中心，把数据及在数据上的操作作为一个整体来进行描述。</p><p><strong>信息隐藏</strong>：通过<strong>封装</strong>实现，将类外部的接口放在类的公有部分，数据放在类的私有部分，防止用户在类外直接访问数据，并且屏蔽了类的具体实现细节。</p><h2 id="哪些运算符必须重载，哪些不能重载？"><a href="#哪些运算符必须重载，哪些不能重载？" class="headerlink" title="哪些运算符必须重载，哪些不能重载？"></a>哪些运算符必须重载，哪些不能重载？</h2><p>当运算符的操作数中有自定义类型的时候，需要将相关运算符重载。</p><p>不能重载：类属关系运算符“.”、成员指针运算符“.*”、作用域分辨符“::”和三目运算符“?:”</p><p>必须重载为成员函数的运算符：赋值运算符“=”、取下标运算符“[]”、成员访问运算符“-&gt;”，函数运算符“()”。</p><h2 id="运算符重载是什么，它如何增强C-的扩展性？"><a href="#运算符重载是什么，它如何增强C-的扩展性？" class="headerlink" title="运算符重载是什么，它如何增强C++的扩展性？"></a>运算符重载是什么，它如何增强C++的扩展性？</h2><p><strong>定义</strong></p><p>运算符重载就是对已有的运算符赋予多重含义，使同一个运算符作用于不同类型的数据时导致不同的行为。运算符重载使C++中的同样的运算符能够支持对多种类型的操作，甚至是自定义类型的的操作，扩展了C++运算符的含义。同时，运算符重载是在编译过程中完成，属于编译时多态。</p><p><strong>重载规则</strong></p><p>C++标准规定，不能重载的运算符有：类属关系运算符“.”、成员指针运算符“.*”、作用域分辨符“::”和三目运算符“?:”。必须重载为成员函数的运算符有：赋值运算符“=”、取下标运算符“[]”、成员访问运算符“-&gt;”和函数运算符“()”。</p><h2 id="面向对象的程序”接口与实现方法分离”的优点？"><a href="#面向对象的程序”接口与实现方法分离”的优点？" class="headerlink" title="面向对象的程序”接口与实现方法分离”的优点？"></a>面向对象的程序”接口与实现方法分离”的优点？</h2><p>接口定义并标准化了客户使用该类功能的使用方法，而这些功能的具体实现对于客户而言是不可见的，达到了信息隐藏，使得客户不会写出依赖于类的实现细节的客户代码。同时，程序维护更加方便，只要类的接口不变，类的实现的改变不会影响客户。</p><h1 id="对比类"><a href="#对比类" class="headerlink" title="对比类"></a>对比类</h1><h2 id="Java-🆚-C"><a href="#Java-🆚-C" class="headerlink" title="Java 🆚 C++"></a>Java 🆚 C++</h2><ul><li><p>Java在编译时会先转换为<strong>字节码</strong>文件，然后经<strong>解释器解释得到机器码</strong>；C++在编译的过程中链接得到机器码；</p><blockquote><p>java是解释性语言,java程序在运行时类加载器从类路经中加载相关的类,然后java虚拟机读取该类文件的字节,执行相应操作.而C++编译的 时候将程序编译成本地机器码.一般来说java程序执行速度要比C++慢10-30倍.即使采用just-in-time compiling (读取类文件字节后,编译成本地机器码)技术,速度也要比C++慢好多.</p></blockquote></li><li><p>Java是<strong>纯面向对象</strong>的语言，C++既有<strong>面向对象又有面向过程</strong>的部分；</p></li><li><p>Java的类<strong>不支持多继承</strong>，C++支持；</p></li><li><p>C++运行<strong>速度比Java快</strong>，Java具有比C++更好的<strong>跨平台性</strong>；</p></li><li><p>Java没有<strong>指针</strong>，C++有。</p></li><li><p>Java 支持<strong>自动垃圾回收</strong>；C++ 需要手动回收</p></li></ul><h2 id="面向对象-🆚-面向过程"><a href="#面向对象-🆚-面向过程" class="headerlink" title="面向对象 🆚  面向过程"></a>面向对象 🆚  面向过程</h2><ul><li><p><strong>面向对象</strong>：将客观事物看作具有<strong>属性和行为</strong>的对象，通过抽象找出同一类对象的<strong>共同</strong>属性和行为，封装成类。通过继承与多态可以很方便地实现代码重用，容易维护、扩展，缩短软件开发周期，并使软件风格统一。但消耗资源，性能低。</p><blockquote><p>把<strong>数据和方法</strong> 组织为一个整体，更能够贴近事物的自然运行模式。</p></blockquote></li><li><p><strong>面向过程</strong>：分析出实现需求所需的步骤，通过函数一步一步实现这些步骤，接着依次调用。易性能好，但不易维护、复用和扩展。</p><blockquote><p>将解决问题的<strong>重点放在如何实现过程的细节方面</strong>，把数据和对数据进行操作的函数分离，以数据结构为核心，围绕着<strong>功能的实现或操作流程</strong>来设计程序，安全性较低、扩展升级麻烦，当问题的规模变大时，编程将很复杂。</p></blockquote></li></ul><h2 id="指针-🆚-引用"><a href="#指针-🆚-引用" class="headerlink" title="指针 🆚  引用"></a>指针 🆚  引用</h2><p>(1)指针是实体，引用是别名，没有空间。本质上的区别就是指针是一个新的变量，只是这个变量存放着另一个变量的地址，而引用是变量本身</p><p>(2)引用定义时必须初始化，指针不用。</p><p>(3)指针可以改变它指向的对象，而引用不可以。</p><p>(4)引用不能为空，不能有NULL引用，引用必须与一块合法的存储单元关联。指针可以。</p><p>(5)Sizeof(引用)计算的是它引用的对象的大小，而sizeof(指针)计算的是指针本身的大小。</p><p>(6)给引用赋值修改的是该引用与对象所关联的值，而不是与引用关联的对象。</p><p>(7)如果返回的是动态分配的内存或对象，必须使用指针，使用引用会产生内存泄漏。</p><p>(8)对引用的操作即是对变量本身的操作。</p><p>(9)指针和引用的自增（++）运算意义不一样。</p><h2 id="10-指针可以有多级，但是引用只有一级（int-p是合法的，int-amp-amp-q是不合法的"><a href="#10-指针可以有多级，但是引用只有一级（int-p是合法的，int-amp-amp-q是不合法的" class="headerlink" title="(10)指针可以有多级，但是引用只有一级（int**p是合法的，int&amp;&amp;q是不合法的"></a>(10)指针可以有多级，但是引用只有一级（int**p是合法的，int&amp;&amp;q是不合法的</h2><p>版权声明：本文为CSDN博主「victimsss」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_42094283/article/details/108035873">https://blog.csdn.net/qq_42094283/article/details/108035873</a></p><h2 id="malloc-🆚-new"><a href="#malloc-🆚-new" class="headerlink" title="malloc 🆚  new"></a>malloc 🆚  new</h2><blockquote><p>参考：</p><p><a href="https://www.cnblogs.com/qg-whz/p/5140930.html">细说new与malloc的10点区别 - melonstreet - 博客园 (cnblogs.com)</a></p></blockquote><p>malloc在哪分配内存，以及怎么释放内存，malloc具体怎么分配的</p><p><strong>最大的区别</strong>：new在申请空间的时候会调用<a href="https://so.csdn.net/so/search?q=构造函数&amp;spm=1001.2101.3001.7020">构造函数</a>，malloc不会调用<br><strong>申请失败返回</strong>：new在申请空间失败后返回的是错误码bad_alloc，malloc在申请空间失败后会返回NULL<br><strong>属性上</strong>：new/delete是C++关键字需要编译器支持，maollc是<a href="https://so.csdn.net/so/search?q=库函数&amp;spm=1001.2101.3001.7020">库函数</a>，需要添加头文件<br><strong>参数</strong>：new在申请<a href="https://so.csdn.net/so/search?q=内存&amp;spm=1001.2101.3001.7020">内存</a>分配时不需要指定内存块大小，编译器会更具类型计算出大小，malloc需要显示的指定所需内存的大小<br><strong>成功返回类型</strong>：new操作符申请内存成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，因此new是类型安全性操作符。malloc申请内存成功则返回void<em>，需要强制类型转换为我们所需的类型<br><strong>自定义类型</strong>：new会先调operator new函数，申请足够的内存（底层也是malloc实现），然后调用类的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数来释放内存（底层是通过free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构函数<br><em>*重载</em></em>：C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回地址。malloc不允许重载。</p><h2 id="C-和-java-的面向对象多态性的区别"><a href="#C-和-java-的面向对象多态性的区别" class="headerlink" title="C++ 和 java 的面向对象多态性的区别"></a>C++ 和 java 的面向对象多态性的区别</h2><h2 id="C-Release版本🆚-Debug版本的底层代码区别"><a href="#C-Release版本🆚-Debug版本的底层代码区别" class="headerlink" title="C++Release版本🆚 Debug版本的底层代码区别"></a>C++Release版本🆚 Debug版本的底层代码区别</h2><h2 id="全局变量-🆚-局部变量"><a href="#全局变量-🆚-局部变量" class="headerlink" title="全局变量 🆚 局部变量"></a>全局变量 🆚 局部变量</h2><ul><li><p><strong>生命周期</strong>不同：</p><ul><li>全局变量 随主程序创建和创建，随主程序销毁而销毁</li><li>局部变量 在局部函数内部，甚至局部循环体等内部存在，退出就不存在。</li></ul></li><li><p><strong>使用方式</strong>不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。</p></li></ul><p> 操作系统和编译器通过<strong>内存分配的位置</strong>来知道的，全局变量分配在<strong>全局数据段</strong>并且在程序开始运行的时候被加载。局部变量则<strong>分配在堆栈里面</strong> </p><h2 id="const-🆚-define"><a href="#const-🆚-define" class="headerlink" title="const 🆚 #define"></a>const 🆚 #define</h2><ul><li>const 常量有<strong>数据类型</strong>，而宏常量没有数据类型。</li><li><p>编译器可以对前者进行<strong>类型安全检查</strong>。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。</p></li><li><p>有些集成化的调试工具可以对 const 常量进行调试，但是<strong>不能对宏常量进行调试</strong>。</p></li></ul><h2 id="重载-🆚-重写"><a href="#重载-🆚-重写" class="headerlink" title="重载 🆚 重写"></a>重载 🆚 重写</h2><ul><li>重载：是一个类中多态性的一种表现。同一个类中的方法，方法名相同，参数列表不同。</li><li>重写：是父类与子类之间多态性的一种表现。子类继承父类，重写父类的方法，要求方法名、参数列表相同、返回类型都相同。子类的 访问权限 &gt;= 父类，抛出异常 &lt;= 父类。</li></ul><h2 id="函数模板🆚函数重载"><a href="#函数模板🆚函数重载" class="headerlink" title="函数模板🆚函数重载"></a>函数模板🆚函数重载</h2><p><strong>区别</strong></p><ol><li>函数模板本身在编译时不会生成任何目标代码，只有由模板生成的实例会生成目标代码；函数重载会生成目标代码；</li><li>被多个源文件引用的函数模板，应当连同函数体一同放在头文件中，不能像普通函数那样只将声明放在头文件中；函数重载的时候可以将声明和定义分别放在头文件和源文件中；</li><li>函数指针只能指向该模板的实例，不能指向模板本身；函数指针可以指向重载的函数；</li></ol><p><strong>联系</strong></p><p>从函数模板产生的相关函数都是同名的，编译器用重载的方法调用相应的函数，函数模板本身也可以用多种方式重载。</p><h2 id="函数模板🆚模板函数"><a href="#函数模板🆚模板函数" class="headerlink" title="函数模板🆚模板函数"></a>函数模板🆚模板函数</h2><p><strong>区别</strong></p><p>函数模板重点在于模板，其处理的数据类型是参数化的类型，函数模板本身在编译时不会生成任何目标代码。模板函数重点在于函数，编译器以函数模板为样板，生成了一个函数，这个函数就是模板函数，这个实例化的过程会生成目标代码。</p><p><strong>联系</strong></p><p>函数模板是数据类型参数化的函数定义，是一个函数族，代表了操作算法相同的一类函数，而模板函数则只是这个函数族中的一个具体函数。</p><h2 id="虚函数-🆚-纯虚函数"><a href="#虚函数-🆚-纯虚函数" class="headerlink" title="虚函数 🆚 纯虚函数"></a>虚函数 🆚 纯虚函数</h2><p>两者在声明的时候形式不同，如下所示：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtual void <span class="function"><span class="title">fun</span><span class="params">()</span></span>;    <span class="comment">// 虚函数</span></span><br><span class="line">virtual void <span class="function"><span class="title">fun</span><span class="params">()</span></span> = <span class="number">0</span>;<span class="comment">// 纯虚函数</span></span><br></pre></td></tr></tbody></table></figure><p>同时，纯虚函数根本没有函数体，但是基类中仍然允许对虚函数给出实现，而即使给出实现，也必须由派生类覆盖，否则无法实例化；对比之下，虚函数是有函数体的，只是函数体可以为空。</p><p>两者的作用有所不同。带有纯虚函数的类是抽象类，其主要作用是通过它为一个类族建立一个公共的接口，使他们能够更有效地发挥多态特性，抽象类声明了一个类族派生类的共同接口，而接口的完整实现，即纯虚函数的函数体，需要派生类自己定义；虚函数的主要作用是实现运行时多态，通过基类指针或引用与派生类对象建立联系，就可以使同样的消息对于不同派生类的不同对象产生不同的行为。</p><h2 id="数据类型-🆚-抽象数据类型"><a href="#数据类型-🆚-抽象数据类型" class="headerlink" title="数据类型 🆚 抽象数据类型"></a>数据类型 🆚 抽象数据类型</h2><p><strong>数据类型</strong></p><p>数据类型是一组性质相同的具有一定范围的值集合以及定义在这个值集合上的一组操作。数据类型既有内部数据类型，如int、char、float、bool等，也有自定义外部数据类型，如枚举类型、结构类型、联合类型、类类型等。</p><p><strong>ADT</strong></p><p>ADT即Abstract Data Type（抽象数据类型），是基于已有类型组合而组成的复合数据类型，类就是抽象数据类型的一种描述形式。</p><h1 id="类作用域🆚文件作用域"><a href="#类作用域🆚文件作用域" class="headerlink" title="类作用域🆚文件作用域"></a>类作用域🆚文件作用域</h1><p><strong>类作用域</strong></p><p>类作用域定义在类内，在类作用域之内，如果没有声明同名的标识符，可以直接访问；在类作用域之外，相应的数据成员和函数成员就被隐藏起来了，普通的数据和函数成员只能由ptr-&gt;m或x.m这样的表达式访问，类的静态成员可以使用X::m的方式访问。（其中X为类名，x为类X的对象，m为类X的数据成员）</p><p><strong>文件作用域</strong></p><p>在任何函数外声明的标识符的作用域为文件作用域，可以从声明标识符的位置开始，一直到文件末尾处的任何函数中访问。</p><p><strong>函数原型作用域</strong></p><p>在函数原型声明时形式参数的作用范围就是函数原型作用域。</p><p><strong>局部作用域</strong></p><ol><li>函数形参列表中的形参的作用域，从形参列表中的声明处开始，到整个函数体结束之处为止；</li><li>函数体内声明的变量，其作用域从声明处开始，一直到声明所在块结束的大括号为止。</li></ol><h2 id="指针和数组的关系和区别；浅拷贝和深拷贝等"><a href="#指针和数组的关系和区别；浅拷贝和深拷贝等" class="headerlink" title="指针和数组的关系和区别；浅拷贝和深拷贝等"></a>指针和数组的关系和区别；浅拷贝和深拷贝等</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些C++面试常见问题&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【SE】Java</title>
    <link href="http://example.com/2022/08/12/2022-08-12-%E3%80%90SE%E3%80%91Java/"/>
    <id>http://example.com/2022/08/12/2022-08-12-%E3%80%90SE%E3%80%91Java/</id>
    <published>2022-08-12T01:55:34.000Z</published>
    <updated>2022-08-18T23:39:11.084Z</updated>
    
    <content type="html"><![CDATA[<p>一些Java语言问题</p><span id="more"></span><h1 id="JVM的优点，"><a href="#JVM的优点，" class="headerlink" title="JVM的优点，"></a>JVM的优点，</h1><p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够<strong>“一次编译，到处运行”</strong>的原因</p><p>创建类型和引用类型有什么区别（我不知道他那两个词指的是什么 后来感觉更像是变量初始化和引用变量？） 还有类型转换需要考虑什么 这个应该是自下而上的转换</p><p>继承与重写</p><p>java中重载和重构的区别？</p><h1 id="java中抽象类和接口的区别？"><a href="#java中抽象类和接口的区别？" class="headerlink" title="java中抽象类和接口的区别？"></a>java中抽象类和接口的区别？</h1><p><strong>相同点</strong></p><p>（1）都不能被实例化 （2）接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p><p><strong>不同点</strong></p><p>（1）接口只有定义，不能有方法的实现，java 1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。</p><p>（2）实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。</p><p>（3）接口强调特定功能的实现，而抽象类强调所属关系。</p><p>（4）接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。</p><h1 id="Java为什么能在各个平台使用？"><a href="#Java为什么能在各个平台使用？" class="headerlink" title="Java为什么能在各个平台使用？"></a>Java为什么能在各个平台使用？</h1><p>因为它有虚拟机（JVM），JAVA程序不是直接在电脑上运行的，是在虚拟机上进行的，每个系统平台都是有自己的虚拟机（JVM），所以<a href="https://www.baidu.com/s?wd=JAVA语言&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1dBnHfkPAF9PHbvnjnvuHFb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjf3PHbzrjm">JAVA语言</a>能跨平台。<br>1， java代码不是直接运行在CPU上，而是运行在java虚机（简称JVM)上的。<br>2，java是先把java文件编译成二进制字节码的<a href="https://www.baidu.com/s?wd=class文件&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1dBnHfkPAF9PHbvnjnvuHFb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjf3PHbzrjm">class文件</a>，jvm就<a href="https://www.baidu.com/s?wd=解释执行&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1dBnHfkPAF9PHbvnjnvuHFb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjf3PHbzrjm">解释执行</a><a href="https://www.baidu.com/s?wd=class文件&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1dBnHfkPAF9PHbvnjnvuHFb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjf3PHbzrjm">class文件</a>。<br>3，就是因为java是运行在jvm上的，所以它的代码就能不经修改，就能在不同平台的jvm上运行(在UNIX用UNIX的jvm,在linux上用linux的jvm，在windows上用windows的jvm）<br>假如用windows移植到UNIX，只需把java文件是UNIX的jvm上编译成<a href="https://www.baidu.com/s?wd=class文件&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1dBnHfkPAF9PHbvnjnvuHFb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EPjf3PHbzrjm">class文件</a>，然后用jvm运行就可以了</p><h1 id="Java是否会资源泄露"><a href="#Java是否会资源泄露" class="headerlink" title="Java是否会资源泄露"></a>Java是否会资源泄露</h1><h1 id="Java的final和static解释一下？"><a href="#Java的final和static解释一下？" class="headerlink" title="Java的final和static解释一下？"></a>Java的final和static解释一下？</h1><h1 id="java的多态怎么实现？"><a href="#java的多态怎么实现？" class="headerlink" title="java的多态怎么实现？"></a>java的多态怎么实现？</h1><p>“java”中的多态是通过动态绑定来实现的，即在执行期间判断所引用对象的实际类型，然后根据其实际的类型调用其相应的方法。多态存在需要三个必要条件，分别是：一、要有继承；二、要有重写；三、父类引用指向子类对象。</p><p><em>1、 继承的存在；（继承是多态的基础，没有继承就没有多态）。</em></p><p><em>2、子类重写父类的方法。（多态下会调用子类重写后的方法）。</em></p><p><em>3、父类引用变量指向子类对象。（涉及子类到父类的类型转换</em></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些Java语言问题&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【SE】机器学习</title>
    <link href="http://example.com/2022/08/12/2022-08-12-%E3%80%90SE%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/08/12/2022-08-12-%E3%80%90SE%E3%80%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-08-12T01:55:34.000Z</published>
    <updated>2022-09-02T10:23:49.607Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习，去年学的，学了没用过，今年忘了，有空抽时间复习一遍OwO</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><blockquote><p>参考阅读：</p><p><a href="https://zhuanlan.zhihu.com/p/27159928">什么是机器学习 - 知乎 (zhihu.com)</a></p></blockquote><p>🔷 <strong>机器学习的三要素</strong>：数据、算法、模型</p><blockquote><p>机器学习研究的是从<strong>数据</strong>中通过选取合适的<strong>算法</strong>，自动的归纳逻辑或规则，并根据归纳的结果(<strong>模型</strong>)与新数据来进行<strong>预测</strong></p><p>计算机利用已有的数据 👉 得出某种模型 👉 并利用此模型预测未来</p></blockquote><p><img src="https://s2.loli.net/2022/08/15/2G8iOjLrKMyvHId.png" alt="image.png"></p><h2 id="监督学习、无监督学习"><a href="#监督学习、无监督学习" class="headerlink" title="监督学习、无监督学习"></a>监督学习、无监督学习</h2><blockquote><p>参考阅读：</p><p><a href="https://blog.csdn.net/u010420283/article/details/83758378">有监督学习与无监督学习_Briwisdom的博客-CSDN博客</a></p></blockquote><ul><li><p><strong>监督学习</strong></p><blockquote><p>向计算机提供数据和这些数据所对应<strong>“标签”</strong>（label），</p><p>监督学习中的 “ 标签 ” 就是起到一个监督的作用</p><p>例如：线性回归、神经网络、决策树、支持向量机、KNN、朴素贝叶斯算法</p></blockquote></li><li><p><strong>非监督学习</strong></p><blockquote><p>不提供数据所对应的标签信息，计算机通过观察各种数据之间的特性，发现特性背后的规律</p><p>例如：主成分分析法（PCA）、异常检测法、自编码算法、深度信念网络、赫比学习法、生成式对抗网络、自组织映射网络</p></blockquote></li><li><p><strong>半监督学习</strong></p><blockquote><p>综合监督学习和非监督学习的特征。它主要考虑如何使用<strong>少量的 有标签样本</strong> 和 <strong>大量的没有标签的样本</strong> 进行训练和分类。</p></blockquote></li></ul><h2 id="聚类、分类、回归"><a href="#聚类、分类、回归" class="headerlink" title="聚类、分类、回归"></a>聚类、分类、回归</h2><h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><p><strong>什么是聚类？</strong></p><blockquote><p>在没有训练的条件下，对一些没有标签的数据进行归纳分类。根据<strong>相似性</strong>对数据进行分组，以便对数据进行概括。</p></blockquote><p>聚类的时候，并不关心某一类是什么，实现的只是<strong>将相似的东西聚在一起</strong>。</p><blockquote><p>总的来说，聚类就是对大量未知标注的数据集，按数据<strong>内在的相似性</strong>将数据集划分为多个类别，使类别内的数据相似度较大，类别间的数据相似度较小。</p><p>无监督学习</p></blockquote><p><strong>聚类的目标</strong></p><blockquote><p>同一类中，类内对象是相似的（或是相关的）；不同类中的对象是不同的（不相关的）。</p></blockquote><p><strong>聚类方法好坏的判定：</strong></p><blockquote><p>产生高质量的聚类结果——簇。簇内有高相似性，簇间有低的相似性。</p><p>取决于聚类方法采用的<strong>相似性评估方法</strong>以及该方法的具体实现。</p><p>取决于聚类方法能否<strong>发现某些/所有的隐含模式</strong>。</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>什么是分类?</strong></p><blockquote><p>监督学习，根据一些给定的已知类别的样本（即有标签的数据），使计算机能够对未知类别的样本进行分类。分类要求必须<strong>事先明确知道各类别</strong>的信息，是一种对<strong>离散型</strong>随机变量建模或预测的监督学习算法。</p></blockquote><p><strong>分类算法的局限</strong></p><blockquote><p>要求：必须事先明确指导各个类别的信息，并且所有待分类样本都要有一个类别与之对应。</p><p>但是很多时候这些条件并不能满足，尤其是在<strong>处理海量数据</strong>时，如果通过预处理使得数据满足分类算法的要求，代价会非常大，这时候可以考虑使用聚类算法。</p></blockquote><p><strong>聚类与分类的区别</strong></p><blockquote><p>首先，聚类是<strong>非监督学习</strong>，分类是<strong>监督学习</strong>。</p><p>二者的本质区别就是</p><ul><li><p>对于聚类来说，是不知道样本的类别信息的，只能凭借<strong>样本在特征空间的分布</strong>来分析样本的属性；</p></li><li><p>对于分类来说，知道样本的类别信息是必要的，根据<strong>已知训练样本的类别信息</strong>，让计算机自己学着知道每个类别的特点，然后对未知类别的数据进行分类。</p></li></ul></blockquote><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p><strong>什么是回归？</strong></p><blockquote><p>监督学习，也需要先向计算机输入数据的训练样本让计算机学习。</p><p>与分类的区别是：回归方法是一种对<strong>数值型连续随机变量</strong>进行预测和建模的监督学习算法，产生的结果一般也是数值型的</p></blockquote><p><strong>回归任务的特点</strong></p><blockquote><p>标注的数据集具有数值型的目标变量。</p><p>也就是说，每一个观察样本都有一个数值型的标注真值以监督算法。</p></blockquote><p>🔴<strong>简单的判别方法</strong>：给定一个样本特征，希望预测其对应的属性值</p><ul><li><p>如果是离散的，那么就是分类问题。</p></li><li><p>如果是连续的数据，就是回归问题。</p></li><li><p>给定一组样本特征，没有对应的属性值，而是想发觉这组样本的空间分布</p><ul><li>比如分析哪些样本靠的更近，那些样本之间里的很远，这就是聚类问题。</li></ul></li></ul><p>机器学习在实际生活中有哪些应用？</p><h1 id="基础机器学习算法"><a href="#基础机器学习算法" class="headerlink" title="基础机器学习算法"></a>基础机器学习算法</h1><p><img src="https://s2.loli.net/2022/09/02/aNUb9ulHTsBOcZ4.png" alt="image.png" style="zoom:50%;"></p><p>简单说说一些数据挖掘的算法，就决策树，朴素贝叶斯，K-means，KNN这些</p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><h2 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h2><h2 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h2><p>k-means的优点和缺点</p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><h2 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h2><h2 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;机器学习，去年学的，学了没用过，今年忘了，有空抽时间复习一遍OwO&lt;/p&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="机器学习" scheme="http://example.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【阅读笔记】在线社交网络方向相关</title>
    <link href="http://example.com/2022/08/08/2022-08-08-%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E5%9C%A8%E7%BA%BF%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E6%96%B9%E5%90%91%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2022/08/08/2022-08-08-%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E5%9C%A8%E7%BA%BF%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E6%96%B9%E5%90%91%E7%9B%B8%E5%85%B3/</id>
    <published>2022-08-08T01:55:34.000Z</published>
    <updated>2022-08-16T11:47:45.959Z</updated>
    
    <content type="html"><![CDATA[<p> 记一记</p><span id="more"></span><h1 id="复杂网络"><a href="#复杂网络" class="headerlink" title="复杂网络"></a>复杂网络</h1><p>小世界特性(Small world)：即网络中点与点之间的特征路径长度值小,接近随机网络,但网络的聚合系数却很高,接近规则网络。</p><ul><li><p>“六度分割理论（Six Degrees of Separation）”, 即任意两个都可通过平均五个人熟人相关联起来</p><blockquote><p>小世界现象在在线社交网络中得到了很好地验证，根据2011年 Facebook 数据分析小组的报告， Facebook 约7.2亿用户中任意两个用户间的平均路径长度仅为4.74，而这一指标在推特中为4.67。可以说，在五步之内，任何两个网络上的个体都可以互相连接。</p></blockquote></li></ul><p>无标度特性(Scale-free),即在网络中<strong>少数节点的度值会很大,而大部分节点却很小</strong>,节点的度值分布符合<strong>幂率</strong>分布规律”。</p><p>社团结构特性，复杂网络中的节点往往会呈现出集群特性，即社团区域内部节点之间的联系非常强,而社团内节点与社团外节点的联系明显减弱</p><ul><li><p><strong>虚拟社区</strong>基于子图局部性的定义：社区结构是复杂网络节点集合的若干子集，每个子集内部的节点之间的连接相对非常紧密，而不同子集节点之间的连边相对稀疏。</p><blockquote><p>　　在社交网络中发现虚拟社区有助于理解网络拓扑结构特点，理解社区内个体关系。为信息检索、信息推荐、信息传播控制和公共事件管控提供有力支撑。虚拟社区发现存在着许多经典的算法，这些算法用于挖掘不同规模的虚拟社区，算法在追求高精度的同时力求提高效率（降低时间复杂度）</p></blockquote></li></ul><p>聚集系数</p><p>复杂网络里，一个节点的邻居节点之间连边的数目占这些邻居节点之间最大可能连边数目的比例就是节点的聚集系数。网络中所有节点聚集系数的平均值就是网络的聚集系数，它反映了网络中节点的聚集情况即网络的聚集性。</p><blockquote><p>用于描述网络中与同一节点相连的节点间也互为相邻节点的程度。其用于刻画社交网络中一个人朋友们之间也互相是朋友的概率，反应了社交网络中的聚集性。</p></blockquote><p>一个节点$i$的度为$k_i$，$E_i$ 是节点$i$ 的$k_i$ 个邻接点之间实际存在的边数；</p><script type="math/tex; mode=display">C_{i}=\frac{E_{i}}{k_{i}\left(k_{i}-1\right) / 2}</script><p>网络的聚集系数为所有节点聚集系数的平均值</p><h1 id="社交网络群体行为形成与互动规律"><a href="#社交网络群体行为形成与互动规律" class="headerlink" title="社交网络群体行为形成与互动规律"></a>社交网络群体行为形成与互动规律</h1><blockquote><p><a href="https://www.cnblogs.com/alan-blog-TsingHua/p/10620752.html">一文读懂社交网络分析（附应用、前沿、学习资源） - Alan_Fire - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt; 记一记&lt;/p&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="http://example.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="在线社交网络" scheme="http://example.com/tags/%E5%9C%A8%E7%BA%BF%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【SE】数学基础知识</title>
    <link href="http://example.com/2022/08/02/2022-08-02-%E3%80%90SE%E3%80%91%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2022/08/02/2022-08-02-%E3%80%90SE%E3%80%91%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2022-08-02T01:55:34.000Z</published>
    <updated>2022-09-03T07:49:12.772Z</updated>
    
    <content type="html"><![CDATA[<ul><li>高数、线代、概率论一些常用基础知识点复习</li></ul><span id="more"></span><h1 id="重点复习"><a href="#重点复习" class="headerlink" title="重点复习"></a>重点复习</h1><ul><li><p><strong>线代部分</strong></p></li><li><p>矩阵中秩和迹是如何计算的，物理意义分别是什么？秩是什么？什么是矩阵满秩？怎么求矩阵的秩？</p></li><li>什么是线性变换？什么是线性空间？</li><li>什么是全等变换？</li><li>什么是极大无关组？</li><li>什么是矩阵相似？</li><li>正定矩阵是什么？</li><li>正交矩阵的定义</li><li>什么是矩阵合同</li><li>对称矩阵是什么？</li><li>特征值和特征向量几何含义？它们的意义以及之间的关系</li><li>矩阵可逆的条件？</li><li>子空间是什么？</li><li>描述一下特征值分解？</li><li>行列式的几何意义？</li><li>线代：如何理解矩阵的秩？简述向量组线性无关的含义？解释正定矩阵以及半正定矩阵？特征值的含义以及矩阵分解的物理意义？</li></ul><p><strong>概率论部分</strong></p><ul><li>解释什么是大数定理，有什么用，什么时候用？</li><li>解释什么是中心极限定理，有什么用，怎么用？数据如何处理？</li><li>全概率公式怎么写？</li><li>贝叶斯公式与应用？</li><li>介绍下正态分布，正态分布的和还是正态分布吗，正态分布性质与独立同分布）</li><li>解释下相关系数、协方差。相关系数或协方差为0的时候能否说明两个分布无关？为什么？</li><li>极大似然估计</li><li>独立和不相关的区别</li></ul><p><strong>离散数学部分</strong></p><ul><li>偏序关系和等价关系</li><li>解释下等价关系和等价类</li><li>双射</li><li>什么是覆盖和划分、偏序集合、强弱连通图</li><li></li></ul><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><blockquote><p>参考阅读：</p><p><a href="https://zhuanlan.zhihu.com/p/327042762">矩阵乘法核心思想（1）：列空间 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>🔴 $\textcolor{red}{线性变换}$</p><script type="math/tex; mode=display">\begin{array}{c}L(\overrightarrow{\mathbf{v}}+\overrightarrow{\mathbf{w}})=L(\overrightarrow{\mathbf{v}})+L(\overrightarrow{\mathbf{w}}) \\L(c \overrightarrow{\mathbf{v}})=c L(\overrightarrow{\mathbf{v}})\end{array}</script><p><strong>几何角度理解</strong>：它是网格线保持平行且等距分布的变换（1）直线在变换后仍保持直线，不弯曲 （2）原点必须固定</p><p>一种矩阵相乘的几何理解方式👉<strong>线性变换作用于给定向量</strong>：把矩阵的列看作<strong>变换后的基向量</strong>，矩阵向量乘法看作它们的线性组合</p><p><img src="https://s2.loli.net/2022/08/07/AiGpU7y1XshJtE4.png" alt="image.png" style="zoom:33%;"></p><h2 id="线性相关和线性无关"><a href="#线性相关和线性无关" class="headerlink" title="线性相关和线性无关"></a>线性相关和线性无关</h2><p>🔴 $\textcolor{red}{张成空间}$</p><p>所有可以表示为给定向量 线性组合 的向量的集合，被称为给定向量的张成空间</p><blockquote><p>仅通过向量加法和数乘，所能获得的可能向量的集合</p></blockquote><p>🔴 $\textcolor{red}{线性组合}$</p><p>m个n维向量$\alpha_{1},\alpha_{2},…,\alpha_{m}$，及m个数$k_{1},k_{2},…,k_{m}$，则向量$k_{1}\alpha_{1}+k_{2}\alpha_{2}+…+k_{m}\alpha_{m}$称为向量$\alpha_{1},\alpha_{2},…,\alpha_{m}$的一个线性组合</p><blockquote><p>多个数乘向量的和</p><p><strong>线性</strong>是指向量乘以一个标量，沿着向量的方向缩放，方向不变；<strong>组合</strong>是把多个向量加起来</p></blockquote><p>🔴 $\textcolor{red}{线性相关和线性无关}$</p><p>对m个n维向量$\alpha_{1},\alpha_{2},…,\alpha_{m}$，若<strong>存在不全为0</strong>的数$k_{1},k_{2},…,k_{m}$，使得$k_{1}\alpha_{1}+k_{2}\alpha_{2}+…+k_{m}\alpha_{m}=0$成立，则称$\alpha_{1},\alpha_{2},…,\alpha_{m}$<strong>线性相关</strong>，否则称线性无关</p><blockquote><p>或者说，一个向量可以表示为其他向量的线性组合，那么这些向量线性相关</p></blockquote><p><strong>几何角度理解</strong>：</p><ul><li><p><strong>线性相关</strong>：一组向量中至少有一个是<strong>多余</strong>的，没有对张成空间做出贡献，可以移除其中一个而不减小张成空间</p></li><li><p><strong>线性无关</strong>：一组向量中的所有向量都给张成空间<strong>增添了新的维度</strong></p><blockquote><p>比如对于$\vec a$ 和$\vec b$ 张成的二维平面，若$\vec c$  刚好落在该平面中，那么$\vec c$ 的加入对张成空间没有任何贡献，仍然是一个二维平面，说明它们三个是线性相关的；如果$\vec c$ 没有落在那个二维平面，而使得张成空间变成一个三维空间了，说明它们三个是线性无关的</p></blockquote></li><li><p><strong>或者说</strong>：一组矢量的线性相关性本质上，是描述他们所张成的<strong>广义平行四边形体积是否为零</strong>。N个向量线性无关👉他们所张成的N维体的体积不为零。于是有：<strong>线性无关矢量</strong>组成的矩阵的<strong>行列式不为零</strong>；线性相关矢量组成的矩阵的行列式必为零。</p></li></ul><p>🔴 $\textcolor{red}{空间中的一组基}$</p><p>向量空间中的一组基是<strong>张成该空间</strong>的一个<strong>线性无关</strong>的<strong>向量集合</strong></p><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p>🔴 $\textcolor{red}{行列式的几何意义}$</p><p>可以理解为<strong>线性变换的比例</strong>，如果是负数，说明变换后的<strong>空间定向</strong>发生改变</p><blockquote><p>例如，一个线性变换作用于一个2x2矩阵，该线性变换的行列式是1/2，那么变换后的区域的面积变成了原来的1/2（三维则是体积的缩放）；</p></blockquote><p>若一个二维线性变换的<strong>行列式为0</strong>，说明它将整个平面<strong>压缩到一条线，甚至一个点</strong>上，👉根据行列式是否=0，就能知道这个矩阵所代表的变换是否将空间压缩到更小的维度上</p><blockquote><p>或者理解为：<strong>向量围成空间的面积或体积</strong>；行列式就是在给定一组基下，N个向量张成的一个N维广义四边形的体积。2阶行列式代表的是平面内的面积；3阶行列式自然而然就是3维空间内的体积；4阶行列式是4维空间里的超体积</p></blockquote><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>🔴 $\textcolor{red}{逆矩阵}$</p><p><strong>理论定义</strong>：</p><p><strong>理解</strong>：$Ax=v $  ⇨ $A^{-1}Ax=A^{-1}v$  ⇨ $x=A^{-1}v$</p><p>寻找一个向量$x$，使得它在经过线性变换$A$ 之后与 $v$ 重合：$Ax=v$</p><ul><li>若行列式$|A|=0$，说明线性变换$A$ 将<strong>空间压缩</strong>到了<strong>更低</strong>维度→ <strong>不存在</strong>$A^{-1}$</li><li>若$|A|\neq 0$（<strong>← 矩阵可逆的充要条件</strong>），说明原来的空间<strong>没被挤压</strong>，在这种情况下，有且仅有一个向量$x$在变换后与$v$重合</li></ul><p>即便不存在$A^{-1}$，<strong>解仍然可能存在</strong>：$A$将空间压缩为一条直线，而原本的$v$也刚好落在这条直线上</p><p>🔴 $\textcolor{red}{秩}$</p><p><strong>理论定义</strong>：</p><p><strong>几何角度理解</strong>：代表<strong>变换后的维数</strong></p><blockquote><p>若一个线性变换作用的结果是一维的，则这个变换的秩是1，二维的则是2… </p><p>一个3x3的矩阵，秩=2，说明空间被压缩</p></blockquote><p>🔴 $\textcolor{red}{列空间}$</p><p>所有可能的输出向量$Av$构成的集合称作$A$的列空间（矩阵的列所张成的空间）；</p><p>更精确地讲，秩是列空间的维数</p><blockquote><p>用于线性变换的矩阵的列 可以看作 变换后的基向量，这些变换后的基向量张成的空间就是所有可能的变换结果</p></blockquote><p>🔴 $\textcolor{red}{满秩}$</p><p>对于一个满秩变换：唯一能在变换后落在原来的点就是零向量本身；</p><p>对于非满秩变换，它将空间压缩到一个更低的维度上⇨ 会有一系列在变换后称为零向量</p><blockquote><p>一个二维线性变换将空间压缩到一条直线上，那么沿着某个不同于该直线的方向的所有向量都被压缩到原点</p></blockquote><p><strong>零空间</strong>（核）：变换后会落在原点的向量的集合；对于$Ax=0$，零空间给出了这个向量方程所有可能的解</p><h3 id="各种矩阵"><a href="#各种矩阵" class="headerlink" title="各种矩阵"></a>各种矩阵</h3><p>🔴 $\textcolor{red}{正定矩阵}$</p><p>🔴 $\textcolor{red}{正交矩阵}$</p><p>🔴 $\textcolor{red}{对称矩阵}$</p><p>🔴 $\textcolor{red}{矩阵合同}$</p><p>🔴 $\textcolor{red}{相似矩阵}$</p><h2 id="内积和外积"><a href="#内积和外积" class="headerlink" title="内积和外积"></a>内积和外积</h2><blockquote><p>点积（点乘），叉积（叉乘）</p></blockquote><h3 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h3><p>🔴 $\textcolor{red}{定义}$</p><p>设有$n$维向量，$x=\begin{pmatrix}x_1\\ x_2\\ \vdots\\ x_n\end{pmatrix}$，$y=\begin{pmatrix}y_1 \\y_2\\ \vdots \\y_n\end{pmatrix}$，$x$和$y$的内积 $x  \bullet y$ 如下：</p><script type="math/tex; mode=display">x^{T} y=\left(x_{1}, x_{2}, \cdots, x_{n}\right)\left(\begin{array}{c}y_{1} \\y_{2} \\\vdots \\y_{n}\end{array}\right)=x_1y_1+x_2y_2+...+x_ny_n</script><p>🔴 $\textcolor{red}{几何意义}$</p><p>$v\cdot w$的结果：$w$在$v$上的投影长度 乘 $v$的长度： $|w||v|cos \theta$</p><p><img src="https://s2.loli.net/2022/08/07/IaBn9Uf7jOD3PFV.png" alt="image.png" style="zoom: 33%;"></p><h3 id="外积"><a href="#外积" class="headerlink" title="外积"></a>外积</h3><p>外积的结果是<strong>一个向量</strong>，并非一个数 </p><p>以二维为例，结果就是两个向量围成的平行四边形的<strong>面积</strong></p><p><img src="https://s2.loli.net/2022/08/07/QUa8VjlWvgfxrZO.png" alt="image.png" style="zoom:33%;"></p><p>面积的计算可以考虑行列式、$|v\times w| =|v||w|sin\theta$</p><p>方向的确定（基向量的确定就是定向的基础）：</p><p><img src="https://s2.loli.net/2022/08/07/pHjM3ktqFQcrzKa.png" alt="image.png" style="zoom:33%;"></p><font color="red">真正的叉积是两个三维向量生成一个新的三维向量</font><p>方向的确定（右手定则）：</p><p><img src="https://s2.loli.net/2022/08/07/Gow7FAyfa5RbxHi.png" alt="image.png" style="zoom:33%;"></p><p>计算：</p><p><img src="https://s2.loli.net/2022/08/07/K7Bk1T4mO8gcPsi.png" alt="image.png" style="zoom:33%;"></p><h2 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h2><p>🔴 $\textcolor{red}{定义}$</p><p>给定一个矩阵$A$，寻找一个常数$\lambda$和一个非零向量$x$ ，使得向量$x$被矩阵$A$作用后所得到的向量$Ax$ 与 原向量$x$ 平行，并且满足$Ax = \lambda x$ 。那么，$\lambda$：特征值，$x$：特征向量。</p><p><strong>求特征向量</strong>：$Ax=\lambda Ix$ （$I$是单位对角阵），$(A-\lambda I)x=0$，$x$是非零向量，因为当且仅当矩阵代表的变换将空间压缩到更低维度时，才会存在一个非零向量，使得矩阵和它的乘积为0，所以最终就是求行列式$|A-\lambda I|=0$</p><p>🔴 $\textcolor{red}{理解}$</p><p><strong>几何角度理解</strong>：</p><ul><li>将一个线性变换施加在一个基上，线性变换后<strong>仍然留在</strong>原来的基所张成的空间里的向量，就是这个线性变换的特征向量，任何其他向量在变换中都有或多或少的旋转→离开它原来张成的那条直线。</li><li>每个特征向量都有一个所属的值：特征值，它是用来衡量特征向量在线性变换中拉伸或压缩比例的因子。</li></ul><blockquote><p>例如某特征向量的特征值是-1/2，意味着原向量被反向且压缩为原来的1/2，但它仍然留在原来张成的直线上，并为发生旋转。</p><p>考虑一个三维空间的旋转，若能找到这个旋转的特征向量，也就相当于找到了它的旋转轴，这种情况下，相应的特征值=1：旋转不缩放任何一个向量</p></blockquote><p><strong>特征值越大</strong>，我们可以认为<strong>对应的特征向量越重要</strong>。既然特征值表达了重要程度且和特征向量所对应，那么特征值大的就是主要信息，基于这点我们可以提取各种有价值的信息。</p><p>🔴 $\textcolor{red}{特征空间}$</p><p>特征空间包含了所有的特征向量</p><p>🔴 $\textcolor{red}{基变换}$</p><p>数据与第一个基做内积运算，结果为第一个新的坐标分量，依次类推，例如数据$(3,2)$映射到给定的一个基上的坐标：</p><script type="math/tex; mode=display">\begin{pmatrix}1/\sqrt2  &1/\sqrt2 \\-1/\sqrt2  &1/\sqrt2\end{pmatrix}\begin{pmatrix}3 \\2\end{pmatrix}=\begin{pmatrix}5/\sqrt[]{2}   \\-1/\sqrt[]{2} \end{pmatrix}</script><h2 id="特征值分解"><a href="#特征值分解" class="headerlink" title="特征值分解"></a>特征值分解</h2><hr><h1 id="概率论与梳理统计"><a href="#概率论与梳理统计" class="headerlink" title="概率论与梳理统计"></a>概率论与梳理统计</h1><h2 id="大数定律和中心极限定理"><a href="#大数定律和中心极限定理" class="headerlink" title="大数定律和中心极限定理"></a>大数定律和中心极限定理</h2><p>中心极限定理是说<font color="red">无论抽样分布如何 均值服从正态分布 </font>，而大数定律根本和正态分布无关 是说样本大了抽样分布近似总体分布</p><blockquote><p>参考阅读：</p><p><a href="https://blog.csdn.net/haoso2/article/details/85290720?ops_request_misc=%7B%22request%5Fid%22%3A%22165976780516782395311447%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165976780516782395311447&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-85290720-null-null.nonecase&amp;utm_term=大数定理&amp;spm=1018.2226.3001.4450"> 大数定理的通俗理解_haso的博客-CSDN博客</a></p><p><a href="https://www.zhihu.com/question/22913867">怎样理解和区分中心极限定理与大数定律？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/question/19911209/answer/245487255">大数定律具体是个什么概念？ - 知乎 (zhihu.com)</a></p></blockquote><h3 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h3><p>🔴 $\textcolor{red}{关键理解}$</p><ul><li><p>小数定律：如果统计数据很少，那么事件就表现为各种极端情况，而这些情况都是偶然事件，跟它的期望值一点关系都没有</p></li><li><p>大数定律：在试验不变的条件下，重复试验多次，那么随机事件出现的<strong>频率</strong>就能无限接近它的<strong>期望值（概率）</strong>。因此我们可以用样本均值来估计总体的期望。</p></li></ul><p>🔴 $\textcolor{red}{切比雪夫大数定律(一般情形)}$</p><p>设$ X_{1}, X_{2}, \ldots, X_{n}, \ldots $是由两两不相关（或两两独立）的随机变量所构成的序列, 分别具有 数学期望$E\left(X_{1}\right), E\left(X_{2}\right), \ldots, E\left(X_{n}\right), \ldots $和方差$D\left(X_{1}\right), D\left(X_{2}\right), \ldots D\left(X_{n}\right), \ldots ,$ 并且方差 有公共上界, 即存在正数  $M$ , 使得 $D\left(X_{n}\right) \leq M, n=1,2, \ldots ,$则对于任意给定的正数 $\varepsilon$ 总有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|\frac{1}{n} \sum_{k=1}^{n} X_{k}-\frac{1}{n} \sum_{k=1}^{n} E X_{k}\right|<\varepsilon\right\}=1</script><blockquote><p>这些变量的均值 依概率收敛为 这些期望的均值</p></blockquote><p>🔴 $\textcolor{red}{独立同分布的切比雪夫大数定律(特殊情形)}$</p><p>设随机变量$X_{1}, X_{2}, \ldots, X_{n}, \ldots$<strong>相互独立, 服从相同的分布</strong>, 具有数学期望$E\left(X_{n}\right)=\mu$ 和 方差$D\left(X_{n}\right)=\sigma^{2}(n=1,2, \ldots)$，则对于任意给定的正数$\varepsilon$，总有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|\frac{1}{n} \sum_{k=1}^{n} X_{k}-\mu\right|<\varepsilon\right\}=1,即随机变量序列  \overline{X_{n}}=\frac{1}{n} \sum_{k=1}^{n} X_{k} \stackrel{P}{\longrightarrow} \mu .</script><p>🔴 $\textcolor{red}{辛钦大数定律}$</p><p>设随机变量$X_{1}, X_{2}, \ldots, X_{n}, \ldots$<strong>相互独立, 服从相同的分布</strong>，具有数学期望$E\left(X_{n}\right)=\mu (n=1,2, \ldots)$，则对于任意给定的正数$\varepsilon$，总有</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|\frac{1}{n} \sum_{k=1}^{n} X_{k}-\mu\right|<\varepsilon\right\}=1</script><p>🔴 $\textcolor{red}{伯努利大数定律}$</p><blockquote><p>它的直观表达就是只要做的试验够多，出现的次数 除以 总次数的结果 接近 统计概率p</p></blockquote><p>设在每次实验中$A$发生的概率$P(A)=p$，在$n$次独立重复实验中，事件$A$发生的频率为$f_n(A)$，则对任意正数$\varepsilon$，总有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\left|f_n(A)-p\right|<\varepsilon\right\}=1</script><h3 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h3><blockquote><p>参考视频：<a href="https://www.bilibili.com/video/BV1ah411q7tp/?spm_id_from=333.788&amp;vd_source=29f5937d4c8dc6b894a81d48deba4d66">中心极限定理的直观理解_哔哩哔哩_bilibili</a></p></blockquote><p>🔴 $\textcolor{red}{关键理解}$</p><ul><li><p>中心极限定理告诉我们，当样本量足够大时<strong>，样本均值的抽样分布</strong>慢慢趋近于<strong>正态分布</strong></p></li><li><p>不管总体是什么分布，任意一个<strong>总体的样本</strong>平均值都会围绕在<strong>总体的整体平均值</strong>周围，并且呈正态分布</p></li></ul><p>🔴 $\textcolor{red}{棣莫弗-拉普拉斯中心极限定理}$</p><p>设随机变量$X_n$服从参数$n$和$p$的二项分布，即$X_n\sim B(n,p)(0&lt;p&lt;1,n=1,2,\dots)$，则对于任意实数$x$，有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\frac{X_{n}-n p}{\sqrt{n p(1-p)}} \leq x\right\}=\Phi(x)</script><p>$\Phi(x)$为标准正态分布的分布函数</p><p>🔴 $\textcolor{red}{列维-林德伯格中心极限定理}$</p><p>设随机变量$X_{1}, X_{2}, \ldots, X_{n}, \ldots$<strong>相互独立, 服从相同的分布</strong>, 具有数学期望$E\left(X_{n}\right)=\mu$ 和 方差$D\left(X_{n}\right)=\sigma^{2}(n=1,2, \ldots)$，则对于任意实数$x$，有：</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\frac{\sum_{k=1}^{n} X_{k}-n \mu}{\sqrt{n} \sigma} \leq x\right\}=\Phi(x)</script><p>$\Phi(x)$为标准正态分布的分布函数</p><h2 id="全概率公式和贝叶斯公式"><a href="#全概率公式和贝叶斯公式" class="headerlink" title="全概率公式和贝叶斯公式"></a>全概率公式和贝叶斯公式</h2><h2 id="各种分布"><a href="#各种分布" class="headerlink" title="各种分布"></a>各种分布</h2><h2 id="协方差和相关系数"><a href="#协方差和相关系数" class="headerlink" title="协方差和相关系数"></a>协方差和相关系数</h2><h1 id="离散数学"><a href="#离散数学" class="headerlink" title="离散数学"></a>离散数学</h1><h2 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h2><blockquote><p>参考阅读：</p><p><a href="https://zhuanlan.zhihu.com/p/376118280">【群论入门】(2)：模算术 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/377775196">【群论入门】(3): 群的定义 - 知乎 (zhihu.com)</a></p><p><a href="https://www.bilibili.com/video/BV1qf4y1m7K1?spm_id_from=333.337.search-card.all.click&amp;vd_source=29f5937d4c8dc6b894a81d48deba4d66">【近代应用数学-南京大学】给非数学系的基础入门款 群论/实变/点集拓扑/泛函_哔哩哔哩_bilibili</a></p></blockquote><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>🔴 $\textcolor{red}{代数运算}$</p><p>设$A$非空集合，引入一个法则，使得$A$中任意两个元素与$A$中另一个元素唯一对应，那么可以把这个法则称为$A$上的一个代数运算</p><blockquote><p>例如：A是实数集合$\mathbb{R}$，法则→加法$+$；$\forall x,y\in \mathbb{R}$，$x+y\in \mathbb{R}$。</p><p>又如：向量的内积就不是一个代数运算，$\vec a,\vec b\in V$，$\vec a \cdot \vec b \in \mathbb{R}$，也就是说$V\cdot V\to \mathbb{R}$</p></blockquote><p>🔴 $\textcolor{red}{半群}$</p><p>设$(S，∗)$ 是一个代数系统，“∗”是非空集合S上的一个代数运算。若</p><p>​    （1）“∗”具有<strong>封闭性</strong>，即∗是S上的闭运算；    （2）“∗”满足<strong>结合律</strong>。</p><p>则称(S，∗)是一个半群。</p><blockquote><p>比如，G={2，4，6，8，…}，（G,+)就是一个半群，只满足结合律，没有幺元<u>0</u>，也没有逆元<u>负数</u></p></blockquote><p>🔴 $\textcolor{red}{幺元}$</p><p>设$(S，∗)$是一个代数系统，      </p><p>（1）若存在$e_右∈S$，使得对于任意的$x∈S$，有$x∗e_右=x$，则称$e_右$是<strong>右幺元</strong>。      </p><p>（2）若存在$e_左∈S$，使得对于任意的$x∈S$，有$e_左∗x=x$，则称$e_ 左$是<strong>左幺元</strong>。     </p><p>（3）若存在一个元素e∈S，它<strong>既是左幺元，又是右幺元</strong>，则称e是<strong>幺元（又称单位元）</strong>。</p><p><strong>若有幺元，则幺元唯一</strong>。    </p><blockquote><p> 证明：设$e_左，e_右∈S$分别是左幺元和右幺元，则有$e_左=e_左∗e_右=e_右$</p><p> 若有$e_1，e_2∈S$，且均是幺元，则有$e_1=e_1∗e_2=e_2$通常用$e$表示么元</p></blockquote><p>🔴 $\textcolor{red}{含幺半群}$</p><p>称含有<strong>幺元的半群</strong>为含幺半群。     </p><blockquote><p>比如 0是半群$(N，+)$的幺元，而1是半群$(N，×)$的幺元。$(N，+)$和$(N，×)$都是含幺半群</p></blockquote><p><strong>子半群</strong>：设$(S，∗)$是一个半群，$∅≠A⊆S$，若$(A，∗)$<strong>本身是一个半群</strong>，则称$(A，∗)$是$(S，∗)$的子半群</p><blockquote><p>比如：G={0，2，4，6，8，…}，（G,+)就是一个幺半群，满足结合律，<strong>有</strong>幺元<u>0</u>，也没有逆元<u>负数</u></p><p>若，G={0，±1，±2，…}，(G,+)就是一个群；</p><p>最小的群：（G,$\circ$) = {e}</p></blockquote><p>🔴 $\textcolor{red}{逆元}$</p><p>设$(S，∗)$是一个代数系统，$e∈S$是<strong>幺元</strong>，$a∈S$。     </p><p>（1）若存在$b∈S$，使得$a∗b=e$，则称$b$是$a$的<strong>右逆元</strong>；     </p><p>（2）若存在$d∈S$，使得$d∗a=e$，则称$d$是$a$的<strong>左逆元</strong>；     </p><p>（3）若存在$a^′∈S$，使得$a^′$既是$ a$的<strong>左逆元</strong>，又是$a$的<strong>右逆元</strong>，则称$a^′$是$a$的逆元。</p><blockquote><p>设(S，∗)是一个代数系统，∗满足结合律，e∈S是幺元，a∈S是任意的元素，则     </p><p>（1）若a既有左逆元，又有右逆元，则a的<strong>左逆元等于右逆元</strong>，即为a的逆元。    </p><p>（2）a的逆元<strong>若存在，则唯一</strong>。</p></blockquote><p>🔴 $\textcolor{red}{群的定义}$</p><p>$(S，∗)$是一个代数系统，若$(S，∗)$满足以下四条：       </p><p>（1）”∗”是$S$上的<strong>闭运算</strong>；       </p><p>（2）”∗”适合<strong>结合律</strong>；       </p><p>（3）存在<strong>幺元</strong>$e∈S$（又称之为单位元）；       </p><p>（4）对于$S$中的任意元素$a$，存在<strong>逆元</strong>$a^{−1}∈S$。</p><p>则称$(S，∗)$是一个群。</p><p><strong>半群</strong>：(1)+(2)；<strong>幺半群</strong>：(1)+(2)+(3)</p><p>🔴 $\textcolor{red}{左右消去律}$</p><p>设$(S，∙)$是一个代数系统。若对于任意的$x，y，z∈S$，满足       </p><p>如果$x∙y=x∙z$，那么$y=z$，则称“$∙$”运算满足左消去律；        </p><p>如果$y∙x=z∙x$，那么$y=z$，则称“$∙$”运算满足右消去律。 </p><p>设$(G，∙)$是一个群，则“$∙$”运算分别满足左、右消去律</p><p>🔴 $\textcolor{red}{群的性质}$</p><p>🔸 群$(G,\circ)$，若$a,b\in G$，$b\circ a=e$，则$a\circ b=e$</p><p>🔸 群$(G,\circ)$，$e$，$\forall a\in G$，$e\circ a=a\circ e =a$</p><p>🔸 群$(G,\circ)$ 的幺元 $e$ 是唯一的</p><p>🔸 群$(G,\circ)$ ，$\forall a\in G$，$a$ 的逆元是唯一的</p><p>🔴 $\textcolor{red}{幂}$</p><p>$a\in G,n\in \mathbb{N},a^n=a…a,\quad a^0=e,a^{-1}=a的逆元，(a^{-1})^n = a^{-n}$</p><p>∴ $a^{m+n}=a^m \circ a^n,m、n\in \mathbb{Z}$</p><p>∴ $(a^n)^m = a^{nm}$</p><p>🔴 $\textcolor{red}{阶}$</p><p>群$(G,\circ)$，$a\in G$，$a^m=e$的最小的$m\in \mathbb{N}$，$m$称为$a$的阶，若找不到$m\in \mathbb{N}$，称$a$的阶为0</p><h3 id="群的同态和同构"><a href="#群的同态和同构" class="headerlink" title="群的同态和同构"></a>群的同态和同构</h3><p>🔴 $\textcolor{red}{同态和同构}$</p><p>设$(S_1，∗)$，$(S_2，∙)$是两个代数系统，“∗” 是$S_1$上的一个二元运算，“∙” 是$S_2$上的一个二元运算。设$f$是$S_1$到$S_2$的一个映射，即$f：S_1→S_2$。若对于$S_1$中的任意两个元素$x_1，x_2$，有$f(x_1∗x_2)=f(x_1)∙f(x_2)$，则称映射$f$是$S_1到S_2$的一个同态映射。      </p><ul><li>若$f$是单射，则称$f$是一个单一同态映射；     </li><li>若$f$是满射，则称$f$是一个满同态映射；      </li><li>若$f$是<strong>双射</strong>，则称$f$是一个<strong>同构映射</strong>。 </li></ul><p>若两个代数系统之间存在一个同构映射，则称这两个代数系统是同构的。</p><p>群的同构作为群的关系，是一个等价关系：满足自反性、对称性、传递性</p><p>🔴 $\textcolor{red}{例子}$</p><p><img src="https://s2.loli.net/2022/08/08/rnCjQweYhBoMd1a.png" alt="image.png" style="zoom: 43%;"></p><p><img src="https://s2.loli.net/2022/08/08/ljGVHB5L9Xe2kAv.png" alt="image.png" style="zoom:33%;"></p><p><img src="https://s2.loli.net/2022/08/08/XRTjeDCtJnuImdL.png" alt="image.png" style="zoom: 33%;"></p><h3 id="无限群和有限群"><a href="#无限群和有限群" class="headerlink" title="无限群和有限群"></a>无限群和有限群</h3><p>🔴 $\textcolor{red}{定义}$</p><p>设$(G，∙)$是一个群，     </p><p>若$G$是<strong>无限集</strong>，则称$(G，∙)$是无限群。      </p><p>若$G$是<strong>有限集</strong>，且$|G|=n$，则称$(G，∙)$是$n$阶有限群。      </p><p>🔴 $\textcolor{red}{阶}$</p><p><img src="https://s2.loli.net/2022/08/08/G14mgtHl9iCP6XW.png" alt="image.png" style="zoom:40%;"></p><blockquote><p> 比如：在整数加群$(Z，+$)中，对于任意的$a∈Z(a≠0)$，因为对于任意的正整数n，有$a+a+⋯+a(n个a)=na≠0$      所以，$o(a)=∞$</p></blockquote><p>设$(G，∙)$是一个交换群，对于任意的$ a，b∈G$，有$(a∙b)^n=a^n∙b^n$。</p><h3 id="交换群（阿贝尔群）"><a href="#交换群（阿贝尔群）" class="headerlink" title="交换群（阿贝尔群）"></a>交换群（阿贝尔群）</h3><p>对于$G$中任意两个元素$a，b∈G$，若满足交换律$，a∙b=b∙a$，则称$(G，∙)$是<strong>交换群</strong>，又称阿贝尔（Abel）群</p><h3 id="变换群-置换群-循环群"><a href="#变换群-置换群-循环群" class="headerlink" title="变换群 置换群 循环群"></a>变换群 置换群 循环群</h3><p>🔴 $\textcolor{red}{集合的变换}$</p><p>$A$非空集合，称由$A$到<strong>自身的映射</strong>$\tau：A\to A$ 称为集合上的一个变换，记为：$a\in A\to \tau(a)\in A$</p><p>满变换、单变换、一一变换</p><p>把集合$A$上的全体变换作成集合$S=\{\tau,\lambda,\mu,\dots\}$，规定$S$上的一个代数运算$\circ$，$\forall \tau,\lambda\in  S，\tau :a\to\tau(a);\lambda:a\to\lambda(a)$， 将$\lambda \circ \tau$定义为：$a\to \lambda(\tau(a))$。（也就是两个变换的复合）</p><p>这个“乘法“满足结合律：$\forall \tau,\lambda,\mu\in S，\tau(\lambda\mu)=(\tau\lambda)\mu $</p><p>🔴 $\textcolor{red}{变换群}$</p><p>设$A$是一个非空集合，$G$是由$A$到$A$的<strong>一些映射构成的集合</strong>，若$G$是关于运算“$∘$”构成的一个群，则称$(G，∘)$是集合$A$上的一个<strong>变换群</strong>。</p><p>🔴 $\textcolor{red}{Cayley定理}$</p><p>任何一个群都与一个变换群同构</p><p>🔴 $\textcolor{red}{置换群}$</p><p>设$A$是一个非空有限集，则    </p><p>（1）称$A$上的一个变换群为$A$上的一个置换群。    </p><p>（2）对于任意的$f∈∪(A^A)$，称$f$为集合$A$上的一个置换。     </p><p>🔴 $\textcolor{red}{循环群}$</p><p>设$(G，∙)$是一个群，$g∈G$。若$G$中每一个元素都是$g$的<strong>乘方</strong>，则称$G$为<strong>循环群</strong>，称$g$为<strong>生成元</strong>，并且用符号$G=(g)$表示，即$G=(g)={g^n│n∈Z}$。</p><blockquote><p>设$(G，∙)$是一个群，$g∈G$ ，</p><p>显然有$g^2∈G，g^3∈G，⋯$，即对于任意的正整数$n$，有$g^n∈G$；      </p><p>显然有$g^{−1}∈G，g^{−2}∈G，⋯$，即对于任意的正整数$n$，有$g^−n∈G$；      </p><p>规定$g^0∈G$是$G$中幺元。 </p><p>综上所述，对于任意整数$n∈Z，g^n∈G$。     显然，$({g^n│n∈Z}，∙)$是一个群。</p></blockquote><p>设$G=(g)$是一个循环群，如果$o(g)=n$，则$|G|=n$，且$G=(g)=\{g^0=e，g，g^2，⋯，g^{n−1}\}$</p><p>（1）若$o(g)=n$，则称$G$是$n$阶<strong>有限循环群</strong>。     （2）若$o(g)=∞$，则称$G$是<strong>无限循环群</strong></p><h3 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h3><p>🔴 $\textcolor{red}{子群定义}$</p><p>设$(G，∙)$是一个群，$∅≠A⊆G$，若$(A，∙)$也是一个群，则称$(A，∙)$$是(G，∙)$的子群。</p><h3 id="子群的陪集"><a href="#子群的陪集" class="headerlink" title="子群的陪集"></a>子群的陪集</h3><p>🔴 $\textcolor{red}{右陪集}$</p><p>设$(G，∙)$是一个群，$(H，∙)$是$(G，∙)$的一个子群，$a∈G$。称$H∙a=\{ℎ∙a|ℎ∈H\}$为子群$H$的<strong>右陪集</strong></p><p>🔴 $\textcolor{red}{左陪集}$</p><p>设$(G，∙)$是一个群，$(H，∙)$是$(G，∙)$的一个子群，$a∈G$。称$a∙H=\{a∙h|ℎ∈H\}$为子群$H$的<strong>左陪集</strong></p><h3 id="正规子群和商群"><a href="#正规子群和商群" class="headerlink" title="正规子群和商群"></a>正规子群和商群</h3><p>🔴 $\textcolor{red}{正规子群}$</p><p>设$G$是一个群，$H$是$G$的一个子群。若对于<strong>任意</strong>一个$a∈G$，有$a∙H=H∙a$即$a$关于$H$的<strong>左陪集等于右陪集</strong>，则称$H$是$G$的<strong>正规子群</strong>，或者称为不变子群</p><p>🔴 $\textcolor{red}{商群}$</p><p>设$G$是一个群，$H$是$G$的正规子群，$G/H=\{aH|a∈G\}$，对于任意的$aH$，$bH∈G/H$，$(aH)⊙(bH)=(ab)H$。则$(G/H，⊙)$是一个群。该群称为$G$的<strong>商群</strong>。</p><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;高数、线代、概率论一些常用基础知识点复习&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】并查集</title>
    <link href="http://example.com/2022/08/02/2022-08-02-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://example.com/2022/08/02/2022-08-02-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2022-08-02T01:55:34.000Z</published>
    <updated>2022-08-03T02:22:53.917Z</updated>
    
    <content type="html"><![CDATA[<ul><li>主要内容：并查集</li></ul><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>用于（近乎$O(1)$）快速地：</p><ol><li>将两个集合<strong>合并</strong></li><li><strong>询问</strong>两个元素是否在一个集合当中</li></ol><p><strong>基本原理</strong>：</p><ul><li>每个集合用一颗<strong>树</strong>维护，每棵树<strong>的根节点</strong>的编号即当前集合的编号</li><li>对于每个点，都存储<strong>它的父节点</strong>是谁 ：p[x]表示x的父节点</li><li>当要找某个点是否属于某个集合时，就<strong>往上找</strong>到根节点</li></ul><p><strong>如何判断树根：</strong></p><ul><li><code>if(p[x]==x)</code></li></ul><p><strong>如何求x的集合编号</strong></p><ul><li><code>while(p[x]!=x) x=p[x]</code>;</li><li>复杂度优化（路径压缩）：当x往上找的时候，一旦找到根节点，就把这条路径上的所有节点的父节点都指向根节点；基本上就能看成O（1）</li></ul><p><strong>如何合并两个集合</strong></p><ul><li>p[x]是x的集合编号，p[y]是y的集合编号：<code>p[x]=y</code></li></ul><hr><h1 id="AcWing836-合并集合（模板题）"><a href="#AcWing836-合并集合（模板题）" class="headerlink" title="AcWing836 合并集合（模板题）"></a>AcWing836 合并集合（模板题）</h1><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>进行 m个操作，操作有两种：</p><ol><li><code>M a b</code>，将编号为 a和 b的两个数所在的集合<strong>合并</strong>，如果两个数已经在同一个集合中，则忽略这个操作；</li><li><code>Q a b</code>，<strong>询问</strong>编号为 a和 b 的两个数是否在<strong>同一个集合</strong>中；</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];<span class="comment">//p[i]:编号为i的节点的父节点 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关键方法find：返回x所在集合的编号（祖宗节点）+路径压缩 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="comment">//如果x不是祖宗节点的话，就让它的父节点=它父节点的祖宗节点：往上递归</span></span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]); </span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">char</span> op;<span class="keyword">int</span> a,b;cin&gt;&gt;op&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">'M'</span>) p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b); <span class="comment">//合并两个集合</span></span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"No"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="AcWing837-连通块中点的数量"><a href="#AcWing837-连通块中点的数量" class="headerlink" title="AcWing837 连通块中点的数量"></a>AcWing837 连通块中点的数量</h1><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>给定一个包含 n个点（编号为 1∼n1∼n）的<strong>无向</strong>图，初始时图中<strong>没有</strong>边。</p><p>进行 m 个操作，操作共有三种：</p><ol><li><code>C a b</code>，在点 a 和点 b间<strong>连一条边</strong>，a和 b 可能相等；</li><li><code>Q1 a b</code>，<strong>询问</strong>点 a 和点 b 是否在<strong>同一个</strong>连通块中，a和 b可能相等；</li><li><code>Q2 a</code>，询问点 a <strong>所在</strong>连通块中<strong>点的数量</strong>；</li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>两个点之间连一条边==合并两个集合；</li><li>只是多了一个统计集合中点的数量的操作而已</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N],cnt[N];</span><br><span class="line"><span class="comment">//cnt[i]表示的是 根节点i 所在集合的大小 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">p[i]=i;</span><br><span class="line">cnt[i]=<span class="number">1</span>;</span><br><span class="line">} <span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line">string op;<span class="keyword">int</span> a,b;cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">"C"</span>){</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//下面这两行顺便别颠倒了 </span></span><br><span class="line">cnt[<span class="built_in">find</span>(b)]+=cnt[<span class="built_in">find</span>(a)]; </span><br><span class="line">p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">"Q1"</span>){</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"No"</span>&lt;&lt;endl;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">cout&lt;&lt;cnt[<span class="built_in">find</span>(a)]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;主要内容：并查集&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>【SE】数据库</title>
    <link href="http://example.com/2022/07/22/2022-07-22-%E3%80%90SE%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2022/07/22/2022-07-22-%E3%80%90SE%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-07-22T01:55:34.000Z</published>
    <updated>2022-08-08T08:35:17.560Z</updated>
    
    <content type="html"><![CDATA[<p>依稀记得大二考数据库熬夜通宵复习完大早上直接去考试 结果只考了79分的痛QAQ</p><span id="more"></span><h1 id="面试重点"><a href="#面试重点" class="headerlink" title="面试重点"></a>面试重点</h1><blockquote><p>总结自网络</p><p>参考：</p></blockquote><ul><li><p>BC范式和第三范式区别</p></li><li><p>解释范式</p></li><li><p>数据库的四个特性是什么？（类似地：解释事务的隔离性？</p></li><li><p>DBS 和 DBMS 的区别</p></li><li><p>数据库的索引有哪些分类</p></li><li><p>数据库中的选择操作，什么时候应该用到索引？</p></li></ul><h1 id="SQL一些语法"><a href="#SQL一些语法" class="headerlink" title="SQL一些语法"></a>SQL一些语法</h1><p><strong>关系型数据库</strong>（RDBMS）：建立在关系模型基础上，由多张互相连接的<strong>二维表</strong>组成的数据库</p><ul><li>特点：使用表存储：格式统一；使用SQL语言操作：标准统一</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>DDL：数据<strong>定义</strong>（define）语言；定义数据库对象（数据库、表、字段）</li><li>DML：数据<strong>操作</strong>（manipulation）语言；对数据库表的<strong>数据进行增删改</strong></li><li>DQL：数据<strong>查询</strong>（query）语言；查询数据库表的<strong>记录</strong></li><li>DCL： 数据<strong>控制</strong>（control）语言；创建数据库用户、控制数据库访问权限</li></ul><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><p>(中括号代表可选)</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES; </span><br><span class="line"># 查询当前所处的数据库</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE(); </span><br><span class="line"># 创建,字符集建议用utf8mb4不用utf8</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 数据库名[<span class="keyword">DEFAULT</span> CHARSET 字符集] [<span class="keyword">COLLATE</span> 排序规则];</span><br><span class="line"># 删除</span><br><span class="line"><span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] 数据库名;</span><br><span class="line"># 使用；</span><br><span class="line">USE 数据库名;</span><br></pre></td></tr></tbody></table></figure><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 查询当前数据库的 所有表</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"># 查询表结构</span><br><span class="line"><span class="keyword">DESC</span> 表名;</span><br><span class="line"># 查询指定表的建表语句</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"></span><br><span class="line"># 创建表，最后一个字段没有逗号</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型[COMMENT 字段<span class="number">1</span>注释],</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型[COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br><span class="line"></span><br><span class="line"># 修改表</span><br><span class="line"># 添加字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度) [COMMENT 注释][约束];</span><br><span class="line"></span><br><span class="line"># 修改字段</span><br><span class="line"># 修改：字段类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型(长度);</span><br><span class="line"># 修改：字段名 和 字段类型</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束];</span><br><span class="line"></span><br><span class="line"># 删除字段</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> 字段名;</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 RENAME <span class="keyword">TO</span> 新表名;</span><br><span class="line"></span><br><span class="line"># 删除表</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span>[IF <span class="keyword">EXISTS</span>]表名;</span><br><span class="line"># 删除指定表，并重新创建该表：清除了数据，只剩下表jie</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br></pre></td></tr></tbody></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>char 和 varchar</strong>：</p><ul><li>char性能比varchar好</li><li>char定长，varchar变长</li></ul><p><strong>日期类型</strong>：</p><ul><li>DATE、TIME、YEAR、DATETIME、TIMESTAMP</li></ul><h1 id="数据库安全性"><a href="#数据库安全性" class="headerlink" title="数据库安全性"></a>数据库安全性</h1><p>指 DBMS应该保证数据库：<strong>免受非法、非授权用户的使用、泄露、更改和破坏</strong></p><h2 id="DBMS的安全机制分类"><a href="#DBMS的安全机制分类" class="headerlink" title="DBMS的安全机制分类"></a>DBMS的安全机制分类</h2><ul><li><strong>自主</strong>安全性机制：存取控制<ul><li>通过权限在用户之间的传递，使用户自主管理数据库安全性</li></ul></li><li><strong>强制</strong>安全性机制<ul><li>通过对数据和用户强制分类，使得不同类别用户能访问不同类别的数据</li></ul></li><li><strong>推断</strong>控制机制<ul><li>防止通过历史信息，推断出不该被其知道的信息</li><li>防止通过历史信息推断出私密信息，通常在一些由个体数据构成的公共数据库中此问题尤为重要</li></ul></li><li>数据加密存储机制<ul><li>加解密保护数据</li></ul></li></ul><h2 id="自主安全性机制"><a href="#自主安全性机制" class="headerlink" title="自主安全性机制"></a>自主安全性机制</h2><h3 id="通过授权机制实现"><a href="#通过授权机制实现" class="headerlink" title="通过授权机制实现"></a>通过<strong>授权机制</strong>实现</h3><ul><li>授权者：决定用户权利的人；授权：授予用户访问的权利</li></ul><blockquote><p>用户使用DB前，必须由DBA处获得一个账户，由DBA授予该账户一定权限；</p><p>该账户用户也可将所拥有的权限转授给其他用户，实现权限在用户间的传播和控制</p></blockquote><p>🛑 $\textcolor{red}{DBMS如何自动实现自主安全性？}$</p><ul><li>DBMS允许用户定义一些<strong>安全性控制规则</strong>（DCL）</li><li>当有DB访问操作时，DBMS<strong>自动</strong>按照安全性控制规则进行<strong>检查</strong>（安全性控制程序），检查通过则允许访问。</li></ul><p>🛑 $\textcolor{red}{自主安全性访问规则}$</p><blockquote><p>DBMS将权利和用户结合，形成一个访问规则表，依据该规则表实现对DB的安全性控制</p></blockquote><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S这个用户对O这个访问对象，在满足在P这个条件下拥有的访问权利t：</span><br><span class="line">    <span class="attr">AcessRule</span> ::= (S, O, t, P)</span><br><span class="line">        S：访问主体（用户）：用户多时，可按用户组建立访问规则</span><br><span class="line">        O：访问对象：可大可小，属性/字段、记录/元组、关系、数据库</span><br><span class="line">        t：访问权利：创建、增删改查等</span><br><span class="line">        P：谓词：拥有权利需满足的条件</span><br></pre></td></tr></tbody></table></figure><p><code>{AcessRule}</code>存放在数据字典 或称系统目录中，构成所有用户对DB的访问控制</p><p>🛑 $\textcolor{red}{下面是一个例子}$</p><p>对一个员工管理数据库<code>Employee(Pno, Pname, Page, Psex, Psalary, Dno, HEAD)</code>有如下安全性访问要求：</p><div class="table-container"><table><thead><tr><th style="text-align:center">S</th><th style="text-align:center">O</th><th style="text-align:center">t</th><th style="text-align:center">P</th></tr></thead><tbody><tr><td style="text-align:center">员工管理人员</td><td style="text-align:center">Employee</td><td style="text-align:center">读、删、插、改</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">收发人员</td><td style="text-align:center">Employee（Pname，Dno）</td><td style="text-align:center">读</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">每个员工</td><td style="text-align:center">Employee</td><td style="text-align:center">读</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">部门领导</td><td style="text-align:center">Employee</td><td style="text-align:center">读</td><td style="text-align:center">Pno=UserId</td></tr><tr><td style="text-align:center">高级领导</td><td style="text-align:center">Employee</td><td style="text-align:center">读</td><td style="text-align:center">Head=UserId</td></tr></tbody></table></div><p>🛑 $\textcolor{red}{按名控制安全性的实现方式}$</p><p><strong>实现方式一：存储矩阵</strong></p><p><img src="https://s2.loli.net/2022/08/05/1d37qUwLjeMXGrE.png" alt="image.png"></p><p><strong>实现方式二：视图</strong></p><ul><li><p>给不同用户用不同视图，就是相当于给与了不同的数据访问范围，相比矩阵更省空间</p></li><li><p>通过视图限制用户对关系中某些数据项的存取，例如</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">视图1：create view EmpV1 as select * from Employee</span><br><span class="line">视图2：create view EmpV2 as select Pname,Dno from Employee</span><br></pre></td></tr></tbody></table></figure></li><li><p>通过视图 可将数据访问对象和谓词结合起来，限制用户对关系中某些元组的存取，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">视图1：create view EmpV3 as select * from Employee where Pno=:UserId</span><br></pre></td></tr></tbody></table></figure></li><li><p>用户定义视图后，视图便成为一新的对象，参与到存储矩阵与能力表中进行描述</p></li></ul><h3 id="用户与权利"><a href="#用户与权利" class="headerlink" title="用户与权利"></a>用户与权利</h3><p>🛑 $\textcolor{red}{SQL语言将用户分为三个级别}$</p><ul><li>超级用户（DBA）</li><li>账户级别（程序员用户）</li><li>关系级别（普通用户）</li></ul><p>🛑 $\textcolor{red}{SQL语言将权利分级}$</p><p>级别更高的权利自动包含级别低的权利；在有些DBMS中，将级别3的权利称为账户级别的权利，1和2称为关系级别的权利</p><ul><li>（级别1）<code>Select</code>：读（DB，Table，Record，Attribute…）</li><li>（级别2）<code>Modify</code>：更新<ul><li><code>Insert</code>、<code>Update</code>、<code>Delete</code></li></ul></li><li>（级别3）<code>Create</code>：创建（表空间、模式、表、索引、视图等）<ul><li><code>Create</code>、<code>Alter</code>、<code>Drop</code></li></ul></li></ul><h3 id="DCL授权命令"><a href="#DCL授权命令" class="headerlink" title="DCL授权命令"></a>DCL授权命令</h3><p>🛑 $\textcolor{red}{授权：grant}$</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GRANT {all PRIVILEGES | privilege {,privilege..}} </span><br><span class="line">ON [TABLE] tablename | viewname</span><br><span class="line">TO {public | user-id {, user-id...}}</span><br><span class="line">[WITH GRANT OPTION];</span><br></pre></td></tr></tbody></table></figure><ul><li><code>user-id</code>：某一个用户账户，由DBA创建的合法账户</li><li><code>public</code>：允许所有有效用户使用授予的权利</li><li><code>privilege</code>：这些权利：<code>Select、Insert、Update、Delete、All privileges</code></li><li><code>with grant option</code>：允许被授权者在传播这些权利</li></ul><p>❗ 授予视图访问的权利，并不意味着授予基本表的访问权利（两个级别：关系级别和视图级别）</p><p>🛑 $\textcolor{red}{收回授权：revoke}$</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REVOKE {all privilEges | priv {, priv..}} ON tablename | viewname</span><br><span class="line">FROM {public | user {, user..} };</span><br></pre></td></tr></tbody></table></figure><p>🛑$\textcolor{red}{授权过程}$</p><ul><li>DBA创建DB，并为每个用户创建一个账户</li><li>DBA授予某用户账户级别的权利</li><li>具有账户级别的用户可以创建基本表或视图，他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问权利</li><li>拥有属主账户的用户可以将其中的部分权利授权给另外的用户，该用户也可将权利进一步授权给其他用户</li></ul><h2 id="强制安全性机制"><a href="#强制安全性机制" class="headerlink" title="强制安全性机制"></a>强制安全性机制</h2><p>🛑$\textcolor{red}{原理}$</p><ul><li>通过对数据对象进行安全性分级<ul><li>绝密(Top Secret)、机密(Secret)、可信(Confidential)、无分类(Unclassified)</li></ul></li><li>同时对用户也进行上述安全性分级</li><li>从而强制实现不同级别用户访问不同级别数据的一种机制</li></ul><p>🛑$\textcolor{red}{访问规则}$</p><ul><li>高级别用户 可以访问 低级别数据对象：<ul><li>用户S，不能读取数据对象O，除非<code>Level(S) &gt;= Level(D)</code></li></ul></li><li>高级别用户 不可以修改 低级别数据对象<ul><li>用户S，不能写数据对象O，除非<code>Level(S) &lt;= Level(O)</code></li></ul></li></ul><h1 id="嵌入式SQL语言"><a href="#嵌入式SQL语言" class="headerlink" title="嵌入式SQL语言"></a>嵌入式SQL语言</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><blockquote><p>特别复杂的检索结果难以用一条交互式SQL语句完成,此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理</p><p>将SQL语言嵌入到某种高级语言中使用，如C/C++, Java, PowerBuilder等,又称宿主语言(Host Language)</p></blockquote><p><img src="https://s2.loli.net/2022/08/05/8SrCF41tNLgWdb6.png" alt="image.png" style="zoom: 50%;"></p><h2 id="SQL执行的提交和撤销-事务"><a href="#SQL执行的提交和撤销-事务" class="headerlink" title="SQL执行的提交和撤销+事务"></a>SQL执行的提交和撤销+事务</h2><p>SQL执行过程中，必须有<strong>提交和撤销</strong>语句才能确认其操作结果</p><p>🛑$\textcolor{red}{事务}$</p><p><strong>概念</strong>：（从应用程序员角度），事务是一个存取或改变数据库内容的程序的一次执行；或者说<strong>一条或多条SQL语句的一次执行</strong>被看作一个事务</p><p>由应用程序员提出，有开始和结束，结束前需要提交或撤销</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>概念</strong>：（从DBMS角度），事务是DBMS提供的控制数据操作的一种手段，通过这种手段，应用程序将<strong>一系列数据库操作组合</strong>在一起<strong>作为一个整体进行操作和控制</strong>，以便DBMS能提供移植性状态转换的保证。</p><p>🛑$\textcolor{red}{事务的特性：ACID}$</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p><strong>静态SQL</strong>: SQL语句在程序中已经按要求写好,只需要把一些参数通过变量传送给嵌入式SQL语句即可</p><p><strong>动态SQL</strong>: SQL语句可以<strong>在程序中动态构造</strong>，形成一个<strong>字符串</strong> ，然后再交给DBMS执行，交给DBMS执行时仍可以传递变量</p><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><p>🛑$\textcolor{red}{概念}$</p><p>又称系统目录（目录表、系统视图），是系统维护的一些表或视图的集合，这些表或视图存储了数据库中<strong>各类对象的定义信息</strong>，这些对象包括用create定义的表、列、索引、视图、权限、约束等。这些信息又称为数据库的<strong>元信息</strong>（关于数据的数据；即 模式本身的信息）</p><p>🛑$\textcolor{red}{数据字典的内容构成}$</p><ul><li>与关系相关的信息<ul><li>关系名字、每个关系的属性名及类型、视图名字及定义、完整性约束</li></ul></li><li>用户与账户信息，包括密码</li><li>统计和描述性数据：比如每个关系中的元组数目</li><li>物理文件组织信息<ul><li>关系如何存储（顺序、无序、散列）</li><li>关系的物理位置</li></ul></li><li>索引相关的信息</li></ul><h2 id="ODBC-和-JDBC"><a href="#ODBC-和-JDBC" class="headerlink" title="ODBC 和 JDBC"></a>ODBC 和 JDBC</h2><p>🛑$\textcolor{red}{ODBC}$</p><p>ODBC（open database connectivit开放式数据库连接）是一种 不同语言的语应用程序和不同数据库服务器之间<strong>通讯的标准</strong>，包含：</p><ul><li>一组API，支持<strong>应用程序和数据库服务器</strong>的交互</li><li>应用程序通过调用 ODBC API，实现<ul><li>与数据库服务器的连接</li><li>向数据库服务器发送SQL命令</li><li>逐条提取数据库检索结果中的元组传递给应用程序的变量</li></ul></li><li>具体的DBMS提供一套<strong>驱动程序</strong>（Driver库函数），供ODBC调用，以便实现数据库和应用程序的连接</li></ul><blockquote><p>⭕ 当应用程序调用<strong>ODBC API</strong>时，ODBC API会<strong>调用具体DBMS Driver库函数</strong>，DBMS Driver库函数 <strong>与 数据库服务器通信</strong>，执行相应的请求动作并返回检索结果</p></blockquote><p>🛑$\textcolor{red}{JDBC}$</p><blockquote><p>简单了解，反正会用jiu’x🤣真想深入学就去看专门讲JDBC运用的视频</p></blockquote><p>JDBC是一组Java版的应用程序接口API ，提供了<strong>Java应用程序与数据库服务</strong><br><strong>器</strong>的连接和通讯能力。</p><p><strong>概念性的基本过程</strong>：打开一个连接，创建“Statement”对象，并设置查询语句，使用Statement对象执行查询，发送查询给数据库服务器，返回结果给应用程序；处理错误的例外机制</p><p><strong>具体实施过程</strong> ：</p><ul><li><p>传一个Driver给DriverManager，<strong>加载数据库驱动</strong>。<code>Class.forName()</code></p></li><li><p>通过URL得到一个Connection对象，<strong>建立数据库连接</strong></p><p><code>DriverManager.getConnection(sDBUrI)</code></p><p><code>DriverManager.getConnection(sDBUrl,sDBUserlD,sDBPassword)</code></p></li><li><p>接着<strong>创建一个Statement对 象</strong>(PreparedStatement或CallableStatement)，用来查询或者修改数据库。<code>Statement stmt=con.createStatement()</code></p></li><li><p>查询<strong>返回</strong>一个ResultSet.<code>ResultSet rs =stmt.executeQuery(sSQL)</code></p></li></ul><h1 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h1><blockquote><p>包含：数据依赖理论、关系范式理论、模式分解理论</p></blockquote><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><blockquote><p>FD：Functional Dependence</p><p>参考书籍：《数据库系统基础教程》Jeffrey.D Ullman Jennifer Widom著</p><p>参考文章：</p><p><a href="https://blog.csdn.net/Jeremy_Tsang/article/details/108949656">完全/部分/函数依赖【通俗易懂，博主会讲人话】Jeremy_Tsang的博客</a></p><p><a href="https://blog.csdn.net/shuaishuai__/article/details/106076537?ops_request_misc=%7B%22request%5Fid%22%3A%22165979845916782391847571%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=165979845916782391847571&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-2-106076537-null-null.nonecase&amp;utm_term=数据库闭包&amp;spm=1018.2226.3001.4450">数据库中的闭包到底是什么？_三看的博客</a></p></blockquote><p>🛑$\textcolor{red}{函数依赖的定义}$</p><p>设$R(U)$是属性集合$U=\{A_1,A_2,\dots,A_n\}$上的一个关系模式，$X$，$Y$是$U$上的两个子集，若对$R(U)$的任意一个可能的关系$r$，$r$中<font color="red">不可能有两个元组</font>满足在$X$中的属性值相等而在$Y$中的属性值不等（即：$X$中的每一个属性值，$Y$都有唯一值与之对应），则称 “$X$函数决定$Y$”  或者 ” $Y$ 函数依赖于$X$“，记作$X \rightarrow Y$。$X$为决定因素</p><blockquote><p>两个属性(集)之间的取值关系，对于R(U)，X、Y为属性集，t1、t2为R的元组，若t1[X]＝t2[X]，则t1[Y]＝t2[Y]</p></blockquote><p><img src="https://s2.loli.net/2022/08/06/CaA3EhOpzT4eQ9M.png" alt="image.png" style="zoom:50%;"></p><ul><li><p><strong>例如：</strong>U = {学号，姓名，年龄，班号，班长，课号，成绩}；那么：学号 → { 姓名，年龄 } ：意思就是学号相同的话，那么姓名和年龄也一定相同；学号 决定 姓名+年龄 </p></li><li><p><strong>非平凡的函数依赖</strong>：对$X\rightarrow Y$，但$Y\not\subset X$，则称$X\rightarrow Y$为非平凡的函数依赖；反之，则是平凡的函数依赖</p><blockquote><p>说人话：Y不是X的子集</p></blockquote></li><li><p><strong>平凡的函数依赖</strong>：</p><blockquote><p>X 可以推导出自己或者自己的一部分</p></blockquote></li></ul><p><img src="https://s2.loli.net/2022/08/06/j3rwi94VoPHC6c1.png" alt="image.png" style="zoom: 50%;"></p><p>🛑$\textcolor{red}{完全函数依赖和部分函数依赖}$</p><p>在$R(U)$中，若$X\rightarrow Y$并且对于$X$的任何真子集$X’$都有$X’\nrightarrow Y$，则称$Y$<strong>完全函数依赖</strong>于$X$，记为$X \xrightarrow{f} Y $，否则称作Y<strong>部分函数</strong>依赖于X，记为$X \xrightarrow{p} Y $</p><blockquote><p>说人话：完全函数依赖就是必须由<strong>X中的全部属性值</strong> 才能确定唯一的Y的值，X属性集中缺少任何一个属性 都不能 确定唯一的Y；</p><p>比如，想知道某位学生的某门课成绩Grade，必须得同时知道他的学号Sno和课程号Cno。如果只知道部分信息，比如只知道Sno或者Cno，无法确定Grade！此时 称Y[Grade]<strong>完全函数依赖</strong>于X[Sno,Cno]。</p><p>而想知道某位学生姓名Sname，那知道他的学号Sno就可。也就是Y[Sname]只函数依赖于X[Sno,Cno]中的子集x[Sno]，此时称Y<strong>部分函数依赖</strong>于X</p></blockquote><p>🛑$\textcolor{red}{传递函数依赖}$</p><p> 在$R(U)$中，若$X\rightarrow Y,Y\rightarrow Z$ 且 $Y\not\subset X,Z\not\subset Y,Z \not\subset X,Y\nrightarrow X$，则称$Z$传递函数依赖于$X$</p><blockquote><p>例如：知道一个学生的学号Sno，就能知道他所在的系Sdept。那知道某一个系Sdept，就能知道这个系的系主任的姓名Mname。<br>也就是，我知道了一个学生的<u>学号</u>Sno，其实我就知道了他所在系的<u>系主任的姓名</u>Mname。但这个过程中，他们是<strong>不存在直接函数依赖</strong>的，我需要通过<strong>系名称</strong>Sdept<strong>作为一个桥梁</strong>去把二者联系起来。</p></blockquote><p>🛑$\textcolor{red}{函数依赖的几个重要概念}$</p><ul><li><p><font color="red">候选键</font>（Candidate Key）：设$K$为$R(U)$中的属性或属性集合，若$K \xrightarrow{f} U $，则称$K$为$R(U)$上的候选键（最小性+唯一性）</p><ul><li>可以任选一候选键作为<font color="red">主键</font>（Primary Key）</li><li><font color="red">主属性</font>：包含在任一候选键中的属性；其他称为<font color="red">非主属性</font></li><li><font color="red">超键</font>：若$K$是$R$的一个候选键，$S\supset K$，则称$S$是$R$的一个超键（即：一个包含键的属性集，没有最小性）</li></ul></li><li><p><font color="red">外键</font>（Foreign Key）：若$R(U)$中的属性或属性组合$X$<strong>并非</strong>$R$的候选键，但<strong>却是</strong>另一关系的候选键，则称$X$为$R$的外键</p></li><li><p><font color="red">逻辑蕴涵</font>：设$F$是关系模式$R(U)$中的一个<strong>函数依赖集合</strong>, $X, Y$是$R$的属性子集，如果从$F$ 中的函数依赖能够逻辑推导出$X \to Y$ ，则称$F$逻辑蕴涵$X \to Y$，或称$X \to Y$是$F$的逻辑蕴涵。记作$\mathbf{F} \models \mathbf{X} \rightarrow \mathbf{Y}$。</p><blockquote><p>由已给出的函数依赖集，推导出其他函数依赖。<strong>推导出来的函数依赖</strong>就称作F所逻辑蕴涵的函数依赖。<br>就好像是侦探破案，掌握了几条线索，然后根据这几条线索推出来另外的线索，这另外推出来的线索就是之前线索集的逻辑蕴涵的线索。</p></blockquote></li><li><p><font color="red">闭包</font>（Closure）：被$F$逻辑蕴含的所有函数依赖集合称为$F$的闭包，记作$F^{+}$</p><blockquote><p>即：<strong>F中能所有的</strong>函数依赖 以及 能<strong>推导出来的</strong>所有的函数依赖 在一起的集合就是 F的闭包</p><p>若$F^{+}=F$，则称$F$是一个<strong>全函数依赖</strong>（函数依赖完备集）</p></blockquote></li></ul><p>🛑$\textcolor{red}{函数依赖的Armstrong公理}$</p><p>设$R(U)$是属性集$U=\{A_1,A_2,\dots,A_n\}$上的一个关系模式，$F$为$R(U)$的一组函数依赖，记作$R(U,F)$，有如下规则成立：</p><ul><li>自反律：若$Y\subseteq X \subseteq U$，则$X \to Y$ 被 $F$ 逻辑蕴涵</li><li>增广律：若$X\to Y \in F$，且$Z\subseteq U$，则$XZ \to YZ$  被 $F$ 逻辑蕴涵</li><li>传递律：若$X\to Y\in F$，且$Y\to Z$，则$X\to Z$  被 $F$ 逻辑蕴涵</li></ul><p>由$Armstrong$公理可推出如下结论（定理）：</p><ul><li>合并律：若$X\to Y$且$X\to Z$，则$X\to YZ$</li><li>伪传递律：若$X\to Y$且$WY \to Z$，则 $XW \to Z$</li><li>分解律：若$X\to Y$且$Z\subseteq Y$，则$X\to Z$</li></ul><p>一个引理：</p><ul><li>若$A_1,A_2,\dots,A_n$是属性，则$X\to A_1,A_2,\dots,A_n$当且仅当每个$A_i$有$X\to A_i(1\leq i\leq n)$</li></ul><p>🛑$\textcolor{red}{覆盖和最小覆盖}$</p><p>覆盖：对$R(U)$上的两个函数依赖集合$F、G$，如果$F^{+}=G^{+}$，则称$F$ 和$G$ 是等价的，也称$F$ 覆盖$G$ 或者$G$ 覆盖$F$ 。</p><p><strong>最小覆盖</strong>：若$F$满足以下条件，则称$F$为最小覆盖或最小依赖集：</p><ul><li>$F$ 中的每个函数依赖 的右部都是单个属性</li><li>对任何 $X\to A\in F$，有$F-\{X\to A\}$不等价于$F$：指 每个函数依赖$X\to A$ 都是不可获取的</li><li>对任何 $X\to A\in F,Z\subset X$，有$(F-\{X\to A\})\cup \{Z\to A\}$不等价于$F$：也就是说$X$ 中没有多余的属性</li></ul><p><strong>定理</strong>：每个函数依赖集$F$ 都有等价的最小覆盖$F’$</p><p>🛑$\textcolor{red}{属性闭包的计算}$</p><p><strong>思想</strong>：从一个给定的属性集合出发，重复地扩展这个集合，只要某个FD<u>左边的属性 全部 包含在这个集合</u>中，就把此FD右边的属性也包含进去。反复使用这个方法，直到不再产生新的属性为止。最后的结果集合就是给定属性集合的闭包。</p><p><strong>算法：</strong></p><p><img src="https://s2.loli.net/2022/08/06/zWLhMkYqSVbCsl1.png" alt="image.png" style="zoom: 50%;"></p><hr><h2 id="关系范式"><a href="#关系范式" class="headerlink" title="关系范式"></a>关系范式</h2><blockquote><p>范式（数据库的设计范式）是<strong>符合某一种级别</strong>的<strong>关系模式的集合</strong>。<strong>构造数据库必须遵循一定的规则</strong>。在关系数据库中，这种规则就是范式。关系数据库中的关系必须满足一定的要求，即满足不同的范式</p></blockquote><h3 id="第一范式：1NF"><a href="#第一范式：1NF" class="headerlink" title="第一范式：1NF"></a>第一范式：1NF</h3><p>🛑$\textcolor{red}{定义}$</p><p>若关系模式$R(U)$中，关系的<strong>每个分量都是不可再分</strong>的数据项（值、原子），则称$R(U)$ 属于第一范式，记作$R(U)\in 1NF$</p><p><strong>例如</strong>：<code>Star(name, address(street, city))</code>就不属于第一范式，因为<code>address</code>包含两个属性，这个分量不是原子的，可以再分</p><p>🛑$\textcolor{red}{非1NF转换为1NF}$</p><ul><li>将<strong>复合</strong>属性处理为<strong>简单</strong>属性；将多值属性与关键字单独组成一新的关系</li><li>引入新的数据模型处理：面向对象的数据模型（封装）</li></ul><h3 id="第二范式：2NF"><a href="#第二范式：2NF" class="headerlink" title="第二范式：2NF"></a>第二范式：2NF</h3><p>🛑$\textcolor{red}{定义:1NF+消除非主属性对码的部分依赖}$</p><p>若$R(U)\in 1NF$ 且$U$中的每一<font color="red">非主属性</font>都<strong>完全函数依赖</strong>于候选键，则称$R(U)$属于第二范式，记作$R(U)\in 2NF$</p><blockquote><p>2NF要求数据库表的每个实例或行 <strong>必须可以被唯一地区分</strong>。不能存在仅依赖主关键字一部分的属性。如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系</p></blockquote><p><img src="https://s2.loli.net/2022/08/07/sBloZvnj7qhCOVX.png" alt="image.png" style="zoom:50%;"></p><h3 id="第三范式：3NF"><a href="#第三范式：3NF" class="headerlink" title="第三范式：3NF"></a>第三范式：3NF</h3><p>🛑$\textcolor{red}{定义：2NF+消除非主属性对码的传递依赖}$</p><p>若$R(U,F)\in 2NF$且$R$ 中<strong>不存在这样的情况</strong>：候选键$X$，属性组$Y\subseteq U$和非主属性$A$，且$A\notin X, A\notin Y,Y\not\subset X,Y\not\to X$，使得$X\to Y,Y\to A$成立。满足上述条件的$R(U)$属于第三范式，记为$R(U)\in 3NF$</p><blockquote><p>3NF要求一个数据库表中 <strong>不包含</strong>   已在<strong>其它表中已包含的非主关键字</strong>信息。</p></blockquote><h3 id="Boyce-Codd范式"><a href="#Boyce-Codd范式" class="headerlink" title="Boyce-Codd范式"></a>Boyce-Codd范式</h3><p>🛑$\textcolor{red}{定义：3NF+消除主属性对码的部分和传递依赖}$<br>若$R(U,F)\in 1NF$，若对任何$X\to Y\in F$（或$X\to A\in F$），当$Y\not\subset X$（或$A\not\subset X$）时，$X$必含有候选键，则称$R(U)$属于BC范式，记为：$R(U)\in BCNF$</p><blockquote><p>每个非平凡函数依赖的左边都必须<strong>包含键</strong>（可以是超键，不一定要最小化）</p><p>有传递依赖的，或者说不满足3NF的，也一定不满足BCNF</p></blockquote><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><h2 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h2><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>🛑$\textcolor{red}{定义}$</p><p>索引是定义在存储表（Table）的基础上，有助于 无需检查所有记录而<strong>快速定位</strong>所需记录的 一种<strong>辅助存储结构</strong>。由一系列存储在磁盘上的<strong>索引项</strong>组成，每一索引项分成以下两部分：</p><ul><li><strong>索引字段</strong>：由Table中某些列中的值串接而成。索引中通常存储了索引字段的每一个值（也有不是这样的），类似于词典中的词条</li><li><strong>行指针</strong>：指向Table中包含索引字段值的<strong>记录在磁盘上的存储位置</strong>，类似于词典中的页码<br><img src="https://s2.loli.net/2022/08/07/nLqDUCgx7BpiFH1.png" alt="image.png" style="zoom: 50%;"></li></ul><p>索引文件：存储索引项的文件；主文件：存储表</p><blockquote><p>索引文件是一种辅助存储结构，存在与否不改变存储表的物理存储结构；存在就可以明显提高存储表的访问速度：索引文件比主文件<strong>小</strong>很多，可以<strong>全部装进</strong>内存</p><p>有索引时，更新操作必须<strong>同步更新</strong>索引文件和主文件</p></blockquote><p>排序码：对主文件进行排序存储的那些属性或属性组</p><p>索引码：即索引字段，不一定具有唯一性</p><p>搜索码：在主文件中查找记录的属性或属性集</p><p>🛑$\textcolor{red}{索引文件的组织方式}$</p><ul><li><strong>排序</strong>索引文件：按索引字段值的某一种<strong>顺序</strong>组织存储</li><li><strong>散列</strong>索引文件：依据索引字段值使用<strong>散列函数</strong>分配散列桶的方式存储</li></ul><h2 id="稠密索引和稀疏索引"><a href="#稠密索引和稀疏索引" class="headerlink" title="稠密索引和稀疏索引"></a>稠密索引和稀疏索引</h2><p>🛑$\textcolor{red}{定义}$</p><p><strong>稠密索引</strong>：对于主文件中的<strong>每一个记录</strong>，都有一个索引项与之对应，指明该记录所在位置</p><p><strong>稀疏索引</strong>：部分记录</p><blockquote><p>稠密索引文件中 包含了主文件对应字段的<strong>所有不同值</strong></p><p>稀疏索引的使用：要求主文件必须按对应索引字段属性排序存储</p></blockquote><h2 id="主索引和辅助索引"><a href="#主索引和辅助索引" class="headerlink" title="主索引和辅助索引"></a>主索引和辅助索引</h2><p>🛑$\textcolor{red}{主索引}$</p><p>通常是对每一<strong>存储块</strong>有一个素引项 ，索引项的总数和存储表所占的存储块数目相同，存储表的每一个存储块的第一条记录，又称为<strong>锚记录或简称为块锚</strong></p><blockquote><p>主索引的索引字段值为<strong>块锚</strong>的索引字段值，指针指向其所在的存储块。<br>主索引是按索引字段值进行排序的一个有序文件，通常建立在有序主文件的基于主码的排序字段上，即主索引的<strong>索引字段与主文件的排序码(主码)</strong>有对应关系</p><p>主索引 是稀疏索引</p></blockquote><p>🛑$\textcolor{red}{辅助索引}$</p><p>是定义在主文件的任一或多个非排序字段上的辅助存储结构</p><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><p>🛑$\textcolor{red}{聚簇索引}$</p><p>索引中<strong>邻近的记录</strong>在主文件中也是<strong>邻近存储</strong>的</p><p>🛑$\textcolor{red}{非聚簇索引}$</p><p>索引中<strong>邻近的记录</strong>在主文件中<strong>不一定是邻近存储</strong>的</p><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><blockquote><p>多级索引：对索引再建立索引</p></blockquote><p>🛑$\textcolor{red}{定义}$</p><p>B+树的每一个结点都是如下这样的存储块：</p><div class="table-container"><table><thead><tr><th>$P_1$</th><th>$K_1$</th><th>$P_2$</th><th>…</th><th>$P_{n-1}$</th><th>$K_{n-1}$</th><th>$P_{n}$</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><blockquote><p>$K_i$：索引字段值</p><p>$P_i$：指针，指向索引块或数据块或数据块中记录的指针</p></blockquote><ul><li>一个存储块中有$n-1$个索引项$<p_i,k_i>$ + $1$个指针$P_n$</p_i,k_i></li><li>索引字段值$x$，若$K_{i-1}\leq x\lt K_i$的由$P_i$ 指向；在$K_{i}\leq x\lt K_{i+1}$的由$P_{i+1}$指向</li><li>非叶结点：指针指向索引块</li><li>叶结点：指针指向主文件的数据库或数据记录（叶结点的最后一个指针始终指向其下一个数据块）</li></ul><p>🛑$\textcolor{red}{B+树的两个特性}$</p><ul><li>能自动保持与主文件大小相适应的树的层次</li><li>每个索引块的指针利用率都在50%-100%之间</li></ul><p>🛑$\textcolor{red}{B+树的存储约定}$</p><p><img src="https://s2.loli.net/2022/08/07/MSxj4rwPq3dV9eR.png" alt="image.png"></p><ul><li>索引字段值重复出现于叶结点和非叶结点</li><li>指向主文件的指针 仅出现在 叶结点</li><li>所有叶结点 即可覆盖所有键值的索引</li><li>索引字段值在叶结点中按顺序排列</li></ul><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是数据库的事务？"><a href="#什么是数据库的事务？" class="headerlink" title="什么是数据库的事务？"></a><font color="red">什么是数据库的事务？</font></h2><p>🔸 DB的<strong>事务</strong>是一个不可分割的数据库操作<strong>序列</strong>，也是DB并发控制的基本单位；这组逻辑上的操作要么都执行，要么都不执行；其执行的结果必须使DB从一种<strong>一致性状态</strong>变到<strong>另一种一致性</strong>状态。</p><blockquote><p>将一系列数据库操作组合在一起，作为一个整体进行操作和控制</p><p>从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行；或者说<strong>一条或多条SQL语句的一次执行</strong>被看作一个事务；由应用程序员提出，有开始和结束，结束前需要提交或撤销</p><p>在嵌入式SQL程序中,任何一条数据库操纵语句(如exec sql select等)都会引发一个新事务的开始，只要该程序当前没有正在处理的事务。而事务的结束是需要应用程序员通过commit或rollback确认的。因此Begin Transaction 和End Transaction两行语句是不需要的。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Begin Transaction</span><br><span class="line">exec sql...</span><br><span class="line">...</span><br><span class="line">exec sql...</span><br><span class="line">exec sql commit work | exec sql rollback work</span><br><span class="line">End Transaction</span><br></pre></td></tr></tbody></table></figure><h2 id="什么是数据库的四大特性ACID？"><a href="#什么是数据库的四大特性ACID？" class="headerlink" title="什么是数据库的四大特性ACID？"></a><font color="red">什么是数据库的四大特性ACID？</font></h2><p>🔸 <strong>原子性</strong>（Atomicity）：DBMS保证事务的一组<strong>更新操作</strong>是<strong>原子不可分</strong>的，确保操作要么全做，要么全不做</p><blockquote><p>事务中任何一个sql执行失败，那么执行成功的sql也必须撤销，数据库状态回退到执行事务之前的状态</p></blockquote><p>🔸 <strong>一致性</strong>（Consistency）：事务执行前后，所有数据都必须处于<strong>一致性状态</strong>，多个事务对同一个数据读取的结果是相同的</p><blockquote><p>比如：假设用户A和用户B的钱加起来一共5000，那不管A和B之间如何转账，转账几次，事务结束后两个用户的钱加起来应该还是5000，这就是事务的一致性。</p></blockquote><p>🔸 <strong>隔离性</strong>（Isolation）：DBMS保证<strong>并发执行的多个事务之间互相不受影响</strong>。</p><blockquote><p>一个事务<strong>内部的操作</strong>及<strong>正在操作的数据</strong> 对 其他并发执行的事务是隔离的。例如事务T1和T2即使并发执行，也相当于先执行T1，再执行T2（或者相反</p></blockquote><p>🔸 <strong>持久性</strong>（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p><h2 id="事务的并发会带来什么问题？如何解决？"><a href="#事务的并发会带来什么问题？如何解决？" class="headerlink" title="事务的并发会带来什么问题？如何解决？"></a><font color="red">事务的并发会带来什么问题？如何解决？</font></h2><p>🔸 <strong>脏读</strong>：一个事务读取到另一个事务更新但<strong>尚未提交的数据</strong>。 </p><blockquote><p>事务 A 读取事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</p><p>T1修改某个数据，并将其写回磁盘，T2读取之后，T1由于某种原因被撤销，这时T1已修改过的数据恢复原值，导致T2读脏数据</p></blockquote><p>🔸 <strong>不可重复读</strong>：一个事务中<strong>两次读取</strong>的数据的<strong>内容不一致</strong></p><blockquote><p>T1读取数据后，T2执行更新操作，T1再次读取时，无法再读到之前的数据</p></blockquote><p>🔸<strong>幻读</strong>：一个事务中两次读取的<strong>数据量不一致</strong>。 事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据 </p><blockquote><p>当同一条查询在不同的时间产生不同的结果集</p></blockquote><p>🔸<strong>丢失更新</strong>：两个事务读入同一数据并修改，后一提交的事务会覆盖前一事务提交的结果，就会导致前一事务的修改被丢失。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;依稀记得大二考数据库熬夜通宵复习完大早上直接去考试 结果只考了79分的痛QAQ&lt;/p&gt;</summary>
    
    
    
    <category term="专业课" scheme="http://example.com/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】最短路+最小生成树+二分图</title>
    <link href="http://example.com/2022/07/22/2022-07-22-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF+%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91+%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>http://example.com/2022/07/22/2022-07-22-%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF+%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91+%E4%BA%8C%E5%88%86%E5%9B%BE/</id>
    <published>2022-07-22T01:55:34.000Z</published>
    <updated>2022-08-14T09:31:38.266Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>Content</strong><ul><li><strong>最短路</strong>：Dijkstra、Bellman-Ford、SPFA、Floyd</li><li><strong>最小生成树</strong>：Prim、Kruskal</li><li><strong>二分图</strong>：染色法、匈牙利算法</li><li><strong>拓扑排序</strong></li></ul></li></ul><span id="more"></span><h1 id="1️⃣-最短路介绍"><a href="#1️⃣-最短路介绍" class="headerlink" title="1️⃣ 最短路介绍"></a>1️⃣ 最短路介绍</h1><p><strong>补充</strong>：稠密图和稀疏图的定义较模糊，邻接矩阵所需空间$O(n^2)$，邻接表所需空间$O(m)$，计算时间和空间复杂度，选择一个满足的即可。</p><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><p>求一个点到其他所有点的最短距离</p><p>​    分类：</p><ul><li><p><strong>所有边权都是正数</strong></p><ul><li>朴素Dijkstra算法：O(n^2)  （n点数，m边数）、稠密图；用邻接矩阵</li><li>堆优化版的Dijkstra算法：O(mlogn)、稀疏图；用邻接表</li></ul></li><li><p><strong>存在负权边</strong></p><ul><li>Bellman-Ford：O(nm)</li><li>SPFA：一般情况下O(m)，最坏O(nm)，也适合正权边；※但是：能用dijkstra的就别用spfa</li></ul></li></ul><h2 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h2><ul><li>Floyd算法：O(n^3)</li></ul><h1 id="Dijkstra-正权边"><a href="#Dijkstra-正权边" class="headerlink" title="Dijkstra - 正权边"></a>Dijkstra - 正权边</h1><p>从<strong>1号点到其他所有点</strong>的最短距离</p><h2 id="朴素版-稠密图-邻接矩阵"><a href="#朴素版-稠密图-邻接矩阵" class="headerlink" title="朴素版 - 稠密图 - 邻接矩阵"></a>朴素版 - 稠密图 - 邻接矩阵</h2><ul><li><strong>初始化距离</strong>：$dist[1] = 0, dist[i]= +∞$：1号点到起点的距离是1，其他所有点到起点的距离是+∞</li><li>集合S：当前<strong>已经确定</strong>的最短距离的点</li><li>for 迭代n次：<ul><li>找到不在S中的<strong>距离最近的点 t</strong></li><li>把t加入S</li><li>用t更新其他点的距离$dist[j]=min(dist[j],dist[t]+g[t][j]);$</li></ul></li></ul><blockquote><p>给定一个 n个点 m条边的有向图，图中可能存在重边和自环，所有边权均为正值。</p><p>请你求出 1 号点到 n号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。</p></blockquote><p>注意：若要求任意点i到任意个点j的最短距离，只需修改dijkstra方法中的起源位置dist[i] = 0，以及返回为dist[j]</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];<span class="comment">//dist[i]: 从第一个点到第i个点的最短距离 </span></span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//st[i]:标记第i个点是否在S中 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){ <span class="comment">//迭代n次 </span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){<span class="comment">//找 不在S中距离的 到第一个点的距离最短的那个点 </span></span><br><span class="line"><span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[j]&lt;dist[t]))</span><br><span class="line">t=j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){ <span class="comment">//用这个点 去更新其他点到第一个点的距离 </span></span><br><span class="line">dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">}</span><br><span class="line">st[t]=<span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">g[a][b]=<span class="built_in">min</span>(g[a][b],c);<span class="comment">//处理重边 </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">dijkstra</span>();</span><br><span class="line">cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><h2 id="堆优化版-稀疏图-邻接表"><a href="#堆优化版-稀疏图-邻接表" class="headerlink" title="堆优化版 - 稀疏图 - 邻接表"></a>堆优化版 - 稀疏图 - 邻接表</h2><p>适合稀疏图，<code>邻接表</code>存储图</p><p>优化：用 <code>堆</code>来 存储距离：$mlogn$</p><ul><li><code>找 不在S中距离的 到源点的距离最短的那个点</code> 👉找一堆数中的最小数👉堆👉$O(1)$</li><li><code>用这个点 去更新其他点到第一个点的距离</code>👉堆中修改一个数👉$O(logn)$；</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">150005</span>,M=<span class="number">150005</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>{</span><br><span class="line">e[idx]=y,ne[idx]=h[x],w[idx]=z,h[x]=idx,idx++;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap; <span class="comment">//小根堆</span></span><br><span class="line"><span class="comment">//heap维护的是 不在S中的点以及它们离起点的距离 </span></span><br><span class="line">heap.<span class="built_in">push</span>({<span class="number">0</span>,<span class="number">1</span>});<span class="comment">//dist=0 point=1；</span></span><br><span class="line"><span class="keyword">while</span>(heap.<span class="built_in">size</span>()){ </span><br><span class="line">PII k=heap.<span class="built_in">top</span>();   <span class="comment">//O(m) * O(1) -&gt; O(m)</span></span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> ver=k.second,distance=k.first;</span><br><span class="line"><span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver]=<span class="literal">true</span>;  <span class="comment">//O(m) * O(1) -&gt; O(m)</span></span><br><span class="line"><span class="comment">//用当前点更新其他点的距离 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;distance+w[i]){</span><br><span class="line">dist[j]=distance+w[i];</span><br><span class="line">heap.<span class="built_in">push</span>({dist[j],j});  <span class="comment">// 堆的插入操作时间复杂度是 O(log(n))</span></span><br><span class="line">                                         <span class="comment">// O(m) * O(log(n)) -&gt; O(mlog(n))</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="built_in">add</span>(x,y,z);</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Bellman-Ford-负权边"><a href="#Bellman-Ford-负权边" class="headerlink" title="Bellman-Ford - 负权边"></a>Bellman-Ford - 负权边</h1><p><strong>思想</strong>：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化源点到各顶点的路径距离。</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> 进行n - <span class="number">1</span>次遍历，每次遍历对 所有边 进行 “松弛操作”。</span><br><span class="line">   松弛操作：以a为起点，b为终点，ab边长度为w为例：</span><br><span class="line">    dist[a]代表 源点 到 a点 的路径长度，dist[b]代表源点s到b点的路径长度。</span><br><span class="line">    <span class="keyword">if</span>：dist[b] &gt; dist[a] + wthen：dist[b] = dist[a] + w。</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> 遍历都结束后，若再进行一次遍历，还能得到s到某些节点更短的路径的话，则说明存在负权回路</span><br></pre></td></tr></tbody></table></figure><p><a href="https://blog.csdn.net/hahahahahaha5/article/details/119022511">参考阅读：Bellman——Ford算法</a></p><h2 id="AcWing-853-有边数限制的最短路-结构体"><a href="#AcWing-853-有边数限制的最短路-结构体" class="headerlink" title="AcWing 853 有边数限制的最短路 - 结构体"></a><a href="https://www.acwing.com/problem/content/855/">AcWing 853 有边数限制的最短路</a> - 结构体</h2><p>对所有边操作，可以直接采用一个<code>结构体</code>定义每条边</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代n次 <span class="comment">//这个n其实就是限制了从源点经过不超过n条边到达某些点</span></span><br><span class="line">    <span class="keyword">for</span> 所有m条边a-b：w</span><br><span class="line">        dist[b]=<span class="built_in">min</span>(dist[b],dist[a]+w);</span><br></pre></td></tr></tbody></table></figure><blockquote><p> n 个点 m 条边有向图，可能存在重边和自环， <strong>边权可能为负数</strong>。</p><p>求从 1 号点到 n 号点的<strong>最多经过 k 条边</strong>的最短距离</p><p>注意：图中可能 <strong>存在负权回路</strong> ，则不一定存在最短距离。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">505</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line"><span class="keyword">int</span> a,b,w;</span><br><span class="line">}edges[M]; </span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">int</span> last[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line"><span class="built_in">memcpy</span>(last,dist,<span class="keyword">sizeof</span> dist);  <span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line"><span class="keyword">auto</span> e = edges[j];</span><br><span class="line">dist[e.b] = <span class="built_in">min</span>(dist[e.b],last[e.a]+e.w); </span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">edges[i] ={x,y,z};</span><br><span class="line">}</span><br><span class="line"><span class="built_in">bellman_ford</span>();</span><br><span class="line"><span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)  cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;dist[n]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="SPFA-正-负权"><a href="#SPFA-正-负权" class="headerlink" title="SPFA - 正/负权"></a>SPFA - 正/负权</h1><blockquote><p>Shortest Path Faster Algorithm</p></blockquote><p>思想：</p><ul><li>对Bellman-Ford算法的优化：<strong>队列</strong></li><li>Bellman_ford算法会遍历所有的边，但其实只有当一个点的<strong>前驱结点更新</strong>，该点才会更新；所以只需遍历那些<strong>到源点距离变小的点所连接的边</strong>即可👉创建一个队列存放每一次加入距离<strong>被更新（变小）的结点</strong></li></ul><h2 id="AcWing-851-spfa求最短路"><a href="#AcWing-851-spfa求最短路" class="headerlink" title="AcWing 851 spfa求最短路"></a><a href="https://www.acwing.com/activity/content/problem/content/920/">AcWing 851 spfa求最短路</a></h2><blockquote><p>1≤n,m≤$10^5$,用bellman-ford会TLE</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],w[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;<span class="comment">//存放距离变小的边 </span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">st[<span class="number">1</span>]=<span class="literal">true</span>; <span class="comment">//st：当前点是否在队列中，防止存重复点 </span></span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">st[t]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){<span class="comment">//t变小了，说明所有t的出边对应的点也会变小 </span></span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]){</span><br><span class="line">dist[j]=dist[t]+w[i];</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">st[j]=<span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span>(m--){</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="built_in">add</span>(a,b,c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">spfa</span>();</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">0x3f3f3f3f</span>) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing-852-spfa判断负环"><a href="#AcWing-852-spfa判断负环" class="headerlink" title="AcWing 852 spfa判断负环"></a><a href="https://www.acwing.com/activity/content/problem/content/921/">AcWing 852 spfa判断负环</a></h2><p>加一个cnt数组，<code>cnt[i]</code>记录到顶点<code>i</code>经过的最短路径条数，大于等于<code>n</code>说明存在负环</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],w[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">//关键是看dist有没有更新，值不重要</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N]; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfa</span><span class="params">()</span></span>{</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">st[i]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line">}<span class="comment">//判断是否存在负环，而不是 是否存在从1开始到达的负环，所以要把所有点加进去，此时dist也不用初始化了</span></span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">st[t]=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i]){</span><br><span class="line">dist[j]=dist[t]+w[i];</span><br><span class="line">cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt[j]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line">st[j]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="built_in">add</span>(a,b,c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Floyd-任意两点之间"><a href="#Floyd-任意两点之间" class="headerlink" title="Floyd - 任意两点之间"></a>Floyd - 任意两点之间</h1><p>⭐<strong>一个踩坑点</strong>⭐：</p><p><code>ios::sync_with_stdio(false)</code> 取消cin的同步（就是iostream的缓冲跟stdio的同步） 取消后就<strong>cin就不能</strong>和scanf，sscanf, getchar, fgets，puts之类同时用，💔<strong>否则就可能导致输出和预期的不一样</strong>。</p><blockquote><p>刚开始取消同步，用puts输出impossible，发现顺序不对，还以为是代码问题QAQ，后来改成cout就AC了</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">210</span>,M=<span class="number">20010</span>,INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> dist[N][N];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">dist[i][j]=<span class="built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line"><span class="keyword">if</span>(i==j) dist[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> dist[i][j]=INF;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">dist[x][y]=<span class="built_in">min</span>(dist[x][y],z);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">floyd</span>();</span><br><span class="line"><span class="keyword">while</span>(k--){</span><br><span class="line"><span class="keyword">int</span> x,y; cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(dist[x][y]&gt;INF/<span class="number">2</span>) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;dist[x][y]&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="💦分层图💦：堆优化Dijkstra-建图"><a href="#💦分层图💦：堆优化Dijkstra-建图" class="headerlink" title="💦分层图💦：堆优化Dijkstra+建图"></a>💦分层图💦：堆优化Dijkstra+建图</h1><p><a href="https://blog.csdn.net/qq_40736036/article/details/85041838">参考阅读： 分层图</a></p><p>$n$ 个点 $m$ 条边构成一张<strong>带权</strong>无向连通图。现在可以从中选出 $k$ 条边，将<strong>边权变为零</strong>。求给定两点间<strong>最短路径</strong>。</p><blockquote><p>将点拆开，复制多层图，并利用特殊构造的边将各层相连的建图方法。</p><p>一般用于边或点有特殊限制的问题(如重复经过次数、多种价值可选等)。</p><p>需要保证拆开后的总点数规模可接受。</p></blockquote><ul><li><strong>空间复杂度及时间复杂度较高，（可以理解为2个点互连的有向图）</strong><ul><li>空间复杂度为$m\times (k+1)$，无向图在此基础上乘2</li></ul></li></ul><p>关键在<code>建图</code></p><ul><li><strong>两种方法解决：</strong><ol><li>建图时直接建成k+1层。</li><li>多开一维记录机会信息。</li></ol></li></ul><h2 id="P4568-飞行路线-洛谷"><a href="#P4568-飞行路线-洛谷" class="headerlink" title="P4568 飞行路线 - 洛谷"></a><a href="https://www.luogu.com.cn/problem/P4568">P4568 飞行路线 - 洛谷</a></h2><p><strong>题意</strong>： n 个城市，这些城市分别标记为 0 到 n-1，共 m种航线，每种航线连接两城市，航线有一定的价格。从一个城市沿着航线到达另一个城市，途中可进行转机。可免费在<strong>最多</strong> k种航线上搭乘飞机。问这次出行最少花费</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>,M=<span class="number">5e4</span>+<span class="number">10</span>,K=<span class="number">50</span>; <span class="comment">//注意这里的数据范围，不然被TLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N*K],e[M*K&lt;&lt;<span class="number">1</span>],ne[M*K&lt;&lt;<span class="number">1</span>],w[M*K&lt;&lt;<span class="number">1</span>],idx;</span><br><span class="line"><span class="keyword">int</span> dist[N*K];</span><br><span class="line"><span class="keyword">bool</span> st[N*K];</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 规定顶点编号从1开始 </span></span><br><span class="line"><span class="comment">// 稀疏图，堆优化dijkstra </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[s]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;heap;</span><br><span class="line">heap.<span class="built_in">push</span>({<span class="number">0</span>,s});</span><br><span class="line"><span class="keyword">while</span>(!heap.<span class="built_in">empty</span>()){</span><br><span class="line">PII k=heap.<span class="built_in">top</span>();</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">int</span> ver=k.second,distance=k.first;</span><br><span class="line"><span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;distance+w[i]){</span><br><span class="line">dist[j]=distance+w[i];</span><br><span class="line">heap.<span class="built_in">push</span>({dist[j],j});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;</span><br><span class="line">s++;t++;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h); </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">a++;b++;</span><br><span class="line"><span class="built_in">add</span>(a,b,c),<span class="built_in">add</span>(b,a,c);</span><br><span class="line"><span class="comment">//建立分层图</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++){</span><br><span class="line"><span class="built_in">add</span>(n*i+a,n*i+b,c);</span><br><span class="line"><span class="built_in">add</span>(n*i+b,n*i+a,c);</span><br><span class="line"><span class="comment">//两层之间建边</span></span><br><span class="line"><span class="built_in">add</span>(n*(i<span class="number">-1</span>)+a,n*i+b,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">add</span>(n*(i<span class="number">-1</span>)+b,n*i+a,<span class="number">0</span>); </span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//for(int i=1;i&lt;=k;i++) add(n*(i-1)+t,n*i+t,0);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dijkstra</span>();</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) ans=<span class="built_in">min</span>(ans,dist[t+i*n]);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>同类题目：<a href="https://www.luogu.com.cn/problem/P4822">P4822 冻结 - 洛谷 </a></p><ul><li>修改一下起止点，两层之间建边的权值改为c/2 即可</li></ul><h1 id="2️⃣-最小生成树"><a href="#2️⃣-最小生成树" class="headerlink" title="2️⃣ 最小生成树"></a>2️⃣ 最小生成树</h1><ul><li><p>生成树：包含 <strong>所有顶点</strong>的 <strong>极小连通子图</strong> </p></li><li><p>最小生成树：带权连通无向图的  <strong>边的权值之和最小</strong>的那棵生成树</p></li></ul><h1 id="Prim-稠密图：-O-n-2"><a href="#Prim-稠密图：-O-n-2" class="headerlink" title="Prim-稠密图：$O(n^2)$"></a>Prim-稠密图：$O(n^2)$</h1><p>基于<strong>贪心</strong>：每次加入距离连通部分（已确定最小生成树的部分）的<strong>最近的点</strong>和<strong>对应边</strong>，连通部分逐渐扩大至整个图连通，且边权和最小。</p><p><a href="https://www.acwing.com/activity/content/code/content/48767/">参考阅读题解</a></p><ul><li><p>针对<strong>无向图</strong></p></li><li><p>先<strong>累加再更新</strong>，<strong>避免t有自环</strong>影响答案。</p><ul><li>后更新不会影响后面的结果：因为<code>dist[i]</code>为<code>i</code>到集合S的距离，当<code>t</code>放入S后，其<code>dist[t]</code>就已经没有意义，再更新也不会影响答案的正确性。</li></ul></li><li>特判一下第一次迭代，在没有做特殊处理时，第一次迭代中所有点到集合S的距离都为无穷大，且不会进行更新(也没有必要)，不需要将这条边 (第一次迭代时，找到的距离集合S最短的边) 累加到答案中，<strong>也不能认定为图不连通</strong>。</li><li>如果设置起点为i的话，在初始化<code>dist</code>数组之后，<code>dist[i] = 0</code>即可，省去每轮迭代中的两个<code>if</code>判断。</li></ul><h2 id="AcWing-858-Prim算法求最小生成树"><a href="#AcWing-858-Prim算法求最小生成树" class="headerlink" title="AcWing 858 Prim算法求最小生成树"></a><a href="https://www.acwing.com/activity/content/problem/content/924/">AcWing 858 Prim算法求最小生成树</a></h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> g[N][N]; <span class="comment">//结点 i 到 j 的距离</span></span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">//存储各个结点到已确定的生成树（顶点集S）的距离；区分dijkstra：到源点的距离 </span></span><br><span class="line"><span class="keyword">bool</span> st[N];  <span class="comment">//顶点是否加入到MST</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 找剩余点到已确定生成树距离最近的点 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line"><span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dist[j]&lt;dist[t]))</span><br><span class="line">t=j;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(i&amp;&amp;dist[t]==INF) <span class="keyword">return</span> INF;<span class="comment">//图不连通</span></span><br><span class="line"><span class="keyword">if</span>(i) res+=dist[t];</span><br><span class="line">st[t]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)  <span class="comment">//更新剩余点到已确定的生成树的距离 </span></span><br><span class="line">dist[j]=<span class="built_in">min</span>(dist[j],g[t][j]); <span class="comment">//区分dijkstra：dist[t]+g[t][j] </span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">g[a][b]= g[b][a]=<span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">prim</span>();</span><br><span class="line"><span class="keyword">if</span>(t==INF) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="堆优化Prim-稀疏图"><a href="#堆优化Prim-稀疏图" class="headerlink" title="堆优化Prim-稀疏图"></a>堆优化Prim-稀疏图</h1><p>$O(mlogn)$（不常用、略过，一般遇见稀疏图用下面的Kruskal）</p><h1 id="Kruskal-稀疏图：-O-mlogm"><a href="#Kruskal-稀疏图：-O-mlogm" class="headerlink" title="Kruskal-稀疏图：$O(mlogm)$"></a>Kruskal-稀疏图：$O(mlogm)$</h1><ul><li>主要对边进行操作，比如对边进行排序，考虑采用 <code>结构体</code> 建图</li><li>一条边依附的两个顶点在不同连通分量上：<code>并查集</code></li><li>prim算法需要更新其他点到集合的距离，用到边的权重，需要两条<br>但在kruskal用并差集维护，枚举的是边不是点，</li></ul><p><strong>思想</strong>：</p><ul><li>初始：n个顶点而无边 的非连通图，每个顶点自成一个连通分量 </li><li>按边的权值<strong>从小到大</strong>的顺序</li><li>不断选取当前<strong>未被选过且权值最小</strong>的边<ul><li>若该边 依附的两顶点落在T中不同的连通分量上，加入T </li><li>否则，舍弃此边，选择下一条权值最小的边；</li></ul></li><li>直到所有顶点都在一个连通分量上</li></ul><p><strong>结构体排序</strong>：</p><ul><li><p>结构体内部定义</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">const</span>&lt; (<span class="keyword">const</span> Edge&amp;W)<span class="keyword">const</span>{</span><br><span class="line">    <span class="keyword">return</span> w&lt;W.w</span><br><span class="line">} <span class="comment">// sort(edges,edges+m);</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>cmp外部函数定义</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(struct Edge A, struct Edge B)</span></span>{</span><br><span class="line"><span class="keyword">return</span> A.w &lt; B.w;</span><br><span class="line">} <span class="comment">// sort(edges,edges+m,cmp);</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>Lambda表达式</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(edges ,edges + m,[](<span class="keyword">auto</span> &amp; u,<span class="keyword">auto</span> &amp; v){<span class="keyword">return</span> u.w &lt; v.w ;});</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="AcWing-859-Kruskal算法求最小生成树"><a href="#AcWing-859-Kruskal算法求最小生成树" class="headerlink" title="AcWing 859 Kruskal算法求最小生成树 "></a><a href="https://www.acwing.com/activity/content/problem/content/925/">AcWing 859 Kruskal算法求最小生成树 </a></h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2</span>*N,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line"><span class="keyword">int</span> a,b,w;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge&amp;W)<span class="keyword">const</span>{</span><br><span class="line"><span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">}</span><br><span class="line">}edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a=edges[i].a, b=edges[i].b, w=edges[i].w;</span><br><span class="line">a=<span class="built_in">find</span>(a),b=<span class="built_in">find</span>(b);</span><br><span class="line"><span class="keyword">if</span>(a!=b){</span><br><span class="line">p[a]=b;</span><br><span class="line">res+=w;</span><br><span class="line">cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">edges[i]={a,b,c};</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> t=<span class="built_in">kruskal</span>();</span><br><span class="line"><span class="keyword">if</span>(t==INF) cout&lt;&lt;<span class="string">"impossible"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3️⃣-二分图"><a href="#3️⃣-二分图" class="headerlink" title="3️⃣ 二分图"></a>3️⃣ 二分图</h1><p><a href="https://blog.csdn.net/u011815404/article/details/84260940">参考阅读：图论 —— 二分图</a></p><p><strong>概念</strong>：</p><p>⭕ <strong>二分图定义</strong>：设G=(V,E)是一个<strong>无向图</strong>，如果顶点集V 可分割为<strong>两个互不相交的子集</strong> $(A,B)$，并且图中的每条边$（i，j）$所关联的两个<strong>顶点</strong> $i$ 和 $j$ <strong>分别属于</strong>这两个不同的顶点集$(i \in A,j \in B)$，则称图G为一个二分图（二部图、偶图）</p><p>⭕ 完全二分图：集合A中的所有顶点都与集合B中的所有顶点相连的 二分图</p><p>⭕ 判定二分图的<strong>充要条件</strong>：<strong>图 G 中至少存在两个点，且图中所有回路的长度均为偶数</strong></p><h2 id="AcWing-860-判定二分图：染色法"><a href="#AcWing-860-判定二分图：染色法" class="headerlink" title="AcWing 860 判定二分图：染色法"></a><a href="https://www.acwing.com/activity/content/problem/content/926/">AcWing 860 判定二分图：染色法</a></h2><p>$O(m+n)$</p><p><strong>染色法思想</strong>：</p><ul><li><p>开始：对<strong>任意一个</strong>未染色的顶点染色。</p></li><li><p>判断其相邻的顶点中，若<strong>未染色</strong>，则将其<strong>染上</strong>和相邻顶点<strong>不同</strong>的颜色。</p></li><li><p>若<strong>已经染色</strong>且<strong>颜色和相邻顶点的颜色相同</strong>则说明不是二分图，若颜色不同则继续判断。</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=<span class="number">2</span>*N;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> color[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> c)</span></span>{</span><br><span class="line">color[u]=c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(!color[j]){</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line"><span class="keyword">if</span>(color[j]==c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!color[i]){</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>)){</span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"No"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing-861-二分图的最大匹配：匈牙利算法"><a href="#AcWing-861-二分图的最大匹配：匈牙利算法" class="headerlink" title="AcWing 861 二分图的最大匹配：匈牙利算法"></a><a href="https://www.acwing.com/activity/content/problem/content/927/">AcWing 861 二分图的最大匹配：匈牙利算法</a></h2><p>最坏$O(mn)$，<strong>实际运行一般远小于它</strong></p><p><strong>二分图的匹配</strong>：</p><p>⭕ <strong>匹配</strong>：在给定一个二分图 G，在 G 的一个子图 M 中，若 <strong>M 的边集中的任意两条边都不依附于同一个顶点</strong>，则称 M 是一个匹配。</p><blockquote><p>匹配：一个二分图中边的集合，其中任意两条边都没有公共顶点</p><p>完美匹配：一个图的某个匹配中，所有的顶点都是匹配点</p><p>交替路：从一个<strong>未</strong>匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p><p>增广路：从一个<strong>未</strong>匹配点出发，走交替路，途径另一个未匹配点（出发的点不算）</p></blockquote><p>⭕ <strong>最大匹配</strong>：给定二分图 G 中的所有匹配，所含匹配<strong>边数最多</strong>的匹配</p><blockquote><p>st[ ]数组：可以理解为“预定数组”，比如：看成男女配对，即某一轮中某个女孩是不是被男生预定了。如果find函数 递归下去能够 帮心仪对象的对象找到备胎，那皆大欢喜；找不到备胎，预定姑娘就保持不动。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">510</span>,M=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n1,n2,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> match[N]; <span class="comment">//match[j]=x：右边的j和左边的x配对</span></span><br><span class="line"><span class="keyword">bool</span> st[N];   <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line">st[j]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(match[j]==<span class="number">0</span>||<span class="built_in">find</span>(match[j])){</span><br><span class="line">match[j]=x;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="built_in">add</span>(u,v);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n1;i++){</span><br><span class="line"><span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(i)) ans++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4️⃣-拓扑排序"><a href="#4️⃣-拓扑排序" class="headerlink" title="4️⃣ 拓扑排序"></a>4️⃣ 拓扑排序</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="AcWing1224-交换瓶子"><a href="#AcWing1224-交换瓶子" class="headerlink" title="AcWing1224 交换瓶子"></a>AcWing1224 交换瓶子</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>N个随机排列的数字，编号1-N，<strong>每次交换任意两个数字</strong>，直到最后序号为1-N的升序，求最小交换次数</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li><p>把每个瓶子看成一个点，将每个瓶子向它应该在的位置的编号</p><p><img src="https://i.bmp.ovh/imgs/2022/04/03/194ca1fb2eaee9a7.png" style="zoom: 33%;"></p></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        {</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; !st[j]; j = b[j])</span><br><span class="line">                st[j] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">作者：yxc</span><br><span class="line">链接：https:<span class="comment">//www.acwing.com/activity/content/code/content/174698/</span></span><br><span class="line">来源：AcWing</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></tbody></table></figure><p>另外，暴力出奇迹</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n,cnt=<span class="number">0</span>;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(a[i]!=i){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line"><span class="keyword">if</span>(a[j]==i){</span><br><span class="line"><span class="built_in">swap</span>(a[i],a[j]);cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Content&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最短路&lt;/strong&gt;：Dijkstra、Bellman-Ford、SPFA、Floyd&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最小生成树&lt;/strong&gt;：Prim、Kruskal&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二分图&lt;/strong&gt;：染色法、匈牙利算法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拓扑排序&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="图论" scheme="http://example.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【总结】数据结构（总结自《算法笔记》和《王道》）</title>
    <link href="http://example.com/2022/07/08/2022-07-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%80%BB%E7%BB%93%E8%87%AA%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%EF%BC%89/"/>
    <id>http://example.com/2022/07/08/2022-07-08-%E3%80%90%E6%80%BB%E7%BB%93%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E6%80%BB%E7%BB%93%E8%87%AA%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E3%80%8B%EF%BC%89/</id>
    <published>2022-07-08T11:08:20.000Z</published>
    <updated>2022-07-27T05:42:00.785Z</updated>
    
    <content type="html"><![CDATA[<ul><li>随便记记</li></ul><span id="more"></span><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt;st;</span><br><span class="line">st.<span class="built_in">push</span>(i);<span class="comment">//O(1)</span></span><br><span class="line">st.<span class="built_in">top</span>();<span class="comment">//O(1) 取得栈顶元素</span></span><br><span class="line">st.<span class="built_in">pop</span>();<span class="comment">//O(1) 弹出栈顶元素</span></span><br></pre></td></tr></tbody></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;<span class="comment">//以下时间复杂度都是O(1)</span></span><br><span class="line">q.<span class="built_in">front</span>(); q.<span class="built_in">back</span>();</span><br><span class="line">q.<span class="built_in">push</span>();  q.<span class="built_in">pop</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="中缀转后缀-求后缀表达式"><a href="#中缀转后缀-求后缀表达式" class="headerlink" title="中缀转后缀,求后缀表达式"></a>中缀转后缀,求后缀表达式</h2><p><a href="http://codeup.hustoj.com/problem.php?cid=100000602&amp;pid=0">题目链接</a></p><p>《算法笔记》P249</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line"><span class="keyword">double</span> num;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">};</span><br><span class="line">string str;</span><br><span class="line">queue&lt;node&gt;q;<span class="comment">//后缀表达式 </span></span><br><span class="line">stack&lt;node&gt;s;<span class="comment">//符号栈 </span></span><br><span class="line">map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;op;</span><br><span class="line"><span class="comment">//中缀转后缀 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">double</span> num;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();){</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>){</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp.num=str[i]-<span class="string">'0'</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">while</span>(i&lt;str.<span class="built_in">length</span>()&amp;&amp;str[i]&gt;=<span class="string">'0'</span>&amp;&amp;str[i]&lt;=<span class="string">'9'</span>){</span><br><span class="line">temp.num = temp.num*<span class="number">10</span>+(str[i]-<span class="string">'0'</span>);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">q.<span class="built_in">push</span>(temp); <span class="comment">//数字存入后缀表达式队列中</span></span><br><span class="line">}<span class="keyword">else</span>{</span><br><span class="line">temp.flag=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()&amp;&amp;op[str[i]]&lt;=op[s.<span class="built_in">top</span>().op]){</span><br><span class="line">q.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">}<span class="comment">//如果优先级不大于栈顶符号,把栈顶符号弹出,压入到后缀表达式中</span></span><br><span class="line">temp.op=str[i];<span class="comment">//直到优先级大于栈顶符号时,压入符号栈中</span></span><br><span class="line">s.<span class="built_in">push</span>(temp);</span><br><span class="line">i++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()){<span class="comment">//符号栈剩余符号压入后缀表达式中</span></span><br><span class="line">q.<span class="built_in">push</span>(s.<span class="built_in">top</span>());</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//计算后缀表达式 </span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cal</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">double</span> temp1,temp2;</span><br><span class="line">node temp;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t.flag) s.<span class="built_in">push</span>(t);</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">temp.flag=<span class="literal">true</span>;</span><br><span class="line">temp2=s.<span class="built_in">top</span>().num; s.<span class="built_in">pop</span>();</span><br><span class="line">temp1=s.<span class="built_in">top</span>().num; s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t.op==<span class="string">'+'</span>) temp.num =temp1+temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t.op==<span class="string">'-'</span>) temp.num=temp1-temp2;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t.op==<span class="string">'*'</span>) temp.num=temp1*temp2;</span><br><span class="line"><span class="keyword">else</span> temp.num=temp1/temp2;</span><br><span class="line">s.<span class="built_in">push</span>(temp);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> s.<span class="built_in">top</span>().num;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">op[<span class="string">'+'</span>]=op[<span class="string">'-'</span>]=<span class="number">1</span>;</span><br><span class="line">op[<span class="string">'/'</span>]=op[<span class="string">'*'</span>]=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin,str),str!=<span class="string">"0"</span>){</span><br><span class="line"><span class="keyword">for</span>(string::iterator it=str.<span class="built_in">end</span>();it!=str.<span class="built_in">begin</span>();it--){</span><br><span class="line"><span class="keyword">if</span>(*it==<span class="string">' '</span>) str.<span class="built_in">erase</span>(it);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>()) s.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">Change</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,<span class="built_in">Cal</span>());</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h2><p><a href="http://codeup.hustoj.com/problem.php?cid=100000605&amp;pid=1">题目链接</a></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line">string str;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line">stack&lt;<span class="keyword">char</span>&gt;s;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++){</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'['</span>||str[i]==<span class="string">'('</span>||str[i]==<span class="string">'{'</span>) s.<span class="built_in">push</span>(str[i]);</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">']'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'['</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">')'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'('</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(str[i]==<span class="string">'}'</span>){</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">empty</span>()||s.<span class="built_in">top</span>()!=<span class="string">'{'</span>){</span><br><span class="line">flag = <span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">}<span class="keyword">else</span> s.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(!flag||!s.<span class="built_in">empty</span>()) cout&lt;&lt;<span class="string">"no"</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"yes"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><h2 id="图的邻接表转换为邻接矩阵存储"><a href="#图的邻接表转换为邻接矩阵存储" class="headerlink" title="图的邻接表转换为邻接矩阵存储"></a>图的邻接表转换为邻接矩阵存储</h2><p><strong>算法思想</strong>： 设图的顶点分别存储在数组<code>v[n]</code>中。首先初始化邻接矩阵。遍历邻接表，在依次遍历顶点<code>v[i]</code>的边链表时，修改邻接矩阵的第<code>i</code>行的元素值。若链表边结点的值为<code>j</code>，则置<code>arcs[i][j]=1</code>。无向、有向图均适用。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Convert</span><span class="params">(ALGraph &amp;G, <span class="keyword">int</span> arcs[M][N])</span></span>{</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++){</span><br><span class="line">        p = (G -&gt; v[i]).firstarc;</span><br><span class="line">        <span class="keyword">while</span>(p != null){</span><br><span class="line">            arcs[i][p -&gt; data] = <span class="number">1</span>;</span><br><span class="line">            p = p -&gt;nextarc;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;随便记记&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="算法笔记" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】BFS &amp; DFS</title>
    <link href="http://example.com/2022/06/19/2022-06-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91BFS/"/>
    <id>http://example.com/2022/06/19/2022-06-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91BFS/</id>
    <published>2022-06-19T01:55:34.000Z</published>
    <updated>2022-07-31T03:11:12.259Z</updated>
    
    <content type="html"><![CDATA[<ul><li>一些BFS</li></ul><span id="more"></span><h1 id="Easy-Part"><a href="#Easy-Part" class="headerlink" title="Easy Part"></a>Easy Part</h1><p>队列queue、O(2^h)、最短路(只有所有边权都是1 的时候才可以用BFS做最短路问题)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">queue←初始</span><br><span class="line"><span class="keyword">while</span> queue非空{</span><br><span class="line">t←队头；扩展队头<span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcW-844-走迷宫"><a href="#AcW-844-走迷宫" class="headerlink" title="AcW-844. 走迷宫 "></a><a href="https://www.acwing.com/problem/content/846/">AcW-844. 走迷宫 </a></h2><p>给定地图，求左上走到右下的步数</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>({<span class="number">1</span>,<span class="number">1</span>});</span><br><span class="line">d[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> temp=q.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">int</span> x=temp.first,y=temp.second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx&gt;=<span class="number">1</span>&amp;&amp;xx&lt;=n&amp;&amp;yy&gt;=<span class="number">1</span>&amp;&amp;yy&lt;=m&amp;&amp;d[xx][yy]==<span class="number">-1</span>&amp;&amp;g[x][y]==<span class="number">0</span>){</span><br><span class="line">d[xx][yy]=d[x][y]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({xx,yy});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;d[n][m]&lt;&lt;endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing843-n皇后问题"><a href="#AcWing843-n皇后问题" class="headerlink" title="AcWing843 n皇后问题"></a>AcWing843 n皇后问题</h2><ul><li><p>对于第r行第i列所在的对角线和反对角线</p><p><strong>对角线</strong> <code>dg[r+i]</code>，<strong>反对角线</strong><code>udg[n−r+i]</code>中的下标  <code>r+i</code>和  <code>n−r+i</code>  表示的是<strong>截距</strong></p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> a[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> dg[N],udg[N],col[N];</span><br><span class="line"><span class="comment">//dfs(r)在第r行上放皇后 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(r==n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">puts</span>(a[i]);<span class="comment">//cout&lt;&lt;a[i]&lt;&lt;endl; </span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>); <span class="comment">//换行 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//针对当前第r行，枚举 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!col[i] &amp;&amp; !dg[r + i] &amp;&amp; !udg[n - r + i]){</span><br><span class="line">a[r][i]=<span class="string">'Q'</span>;</span><br><span class="line">col[i] = dg[r + i] = udg[n - r + i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(r+<span class="number">1</span>);</span><br><span class="line">col[i] = dg[r + i] = udg[n - r + i] = <span class="literal">false</span>; </span><br><span class="line">a[r][i]=<span class="string">'.'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) a[i][j]=<span class="string">'.'</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1101-献给阿尔吉侬的花束"><a href="#AcWing1101-献给阿尔吉侬的花束" class="headerlink" title="AcWing1101 献给阿尔吉侬的花束"></a>AcWing1101 献给阿尔吉侬的花束</h2><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n,r,c;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(PII st,PII ed)</span></span>{</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line">d[st.first][st.second]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;r&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;c&amp;&amp;g[x][y]!=<span class="string">'#'</span>&amp;&amp;d[x][y]==<span class="number">-1</span>){</span><br><span class="line">d[x][y]=d[t.first][t.second]+<span class="number">1</span>;</span><br><span class="line">PII xy={x,y};</span><br><span class="line"><span class="keyword">if</span>(xy==ed) <span class="keyword">return</span> d[x][y];</span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">PII st,ed;</span><br><span class="line"><span class="keyword">while</span>(n--){</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">cin&gt;&gt;r&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;r;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++){</span><br><span class="line">cin&gt;&gt;g[i][j]; </span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'S'</span>) st={i,j};</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'E'</span>) ed={i,j};</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line"><span class="keyword">int</span> ans=<span class="built_in">bfs</span>(st,ed);</span><br><span class="line"><span class="keyword">if</span>(ans!=<span class="number">-1</span>) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"oop!"</span>&lt;&lt;endl; </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1113-红与黑"><a href="#AcWing1113-红与黑" class="headerlink" title="AcWing1113 红与黑"></a>AcWing1113 红与黑</h2><h3 id="BFS写法"><a href="#BFS写法" class="headerlink" title="BFS写法"></a>BFS写法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> w,h;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(PII st)</span></span>{</span><br><span class="line">d[st.first][st.second]=<span class="number">1</span>;</span><br><span class="line">queue&lt;PII&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;h&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;w&amp;&amp;d[x][y]==<span class="number">-1</span>&amp;&amp;g[x][y]==<span class="string">'.'</span>){</span><br><span class="line">d[x][y]=<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">cin&gt;&gt;w&gt;&gt;h;<span class="keyword">if</span>(w==<span class="number">0</span>&amp;&amp;h==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">PII st;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w;j++){</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'@'</span>) st={i,j};</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">bfs</span>(st);</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;h;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w;j++){</span><br><span class="line"><span class="keyword">if</span>(d[i][j]==<span class="number">1</span>) cnt++;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="DFS写法"><a href="#DFS写法" class="headerlink" title="DFS写法"></a>DFS写法</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>},dy[]={<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>{</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">g[x][y]=<span class="string">'#'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> a=x+dx[i],b=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(a&gt;=<span class="number">0</span>&amp;&amp;a&lt;n&amp;&amp;b&gt;=<span class="number">0</span>&amp;&amp;b&lt;m&amp;&amp;g[a][b]==<span class="string">'.'</span>){</span><br><span class="line">res+=<span class="built_in">dfs</span>(a,b);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;m&gt;&gt;n,n||m){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;g[i];</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'@'</span>){</span><br><span class="line">x=i,y=j;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;<span class="built_in">dfs</span>(x,y)&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1096-地牢大师（三维）"><a href="#AcWing1096-地牢大师（三维）" class="headerlink" title="AcWing1096 地牢大师（三维）"></a>AcWing1096 地牢大师（三维）</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>发现有时候代码写不对注意检查：初始点的状态设置是否遗漏，bfs里面坐标的判断有无遗漏，标志数组是否遗漏</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Coo</span>{</span></span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line">};<span class="comment">//存储xyz坐标 </span></span><br><span class="line"><span class="keyword">char</span> g[N][N][N]; <span class="comment">//xyz</span></span><br><span class="line"><span class="keyword">int</span> d[N][N][N];<span class="comment">//存储走到xyz的距离 </span></span><br><span class="line"><span class="keyword">int</span> l,r,c;</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>},dy[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>},dz[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Coo st,Coo ed)</span></span>{</span><br><span class="line">d[st.x][st.y][st.z]=<span class="number">0</span>;</span><br><span class="line">queue&lt;Coo&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.x+dx[i],y=t.y+dy[i],z=t.z+dz[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;r&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;c&amp;&amp;z&gt;=<span class="number">0</span>&amp;&amp;z&lt;l){<span class="comment">//坐标合法 </span></span><br><span class="line"><span class="keyword">if</span>(d[x][y][z]==<span class="number">-1</span>&amp;&amp;g[x][y][z]!=<span class="string">'#'</span>){<span class="comment">//且没有被走过且可以走 </span></span><br><span class="line">d[x][y][z]=d[t.x][t.y][t.z]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>({x,y,z});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(d[ed.x][ed.y][ed.z]!=<span class="number">-1</span>) cout&lt;&lt;<span class="string">"Escaped in "</span>&lt;&lt;d[ed.x][ed.y][ed.z]&lt;&lt;<span class="string">" minute(s)."</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">"Trapped!"</span>&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>){</span><br><span class="line">Coo st,ed;</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d); </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;c);<span class="keyword">if</span>(l==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;r;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;c;k++){</span><br><span class="line">cin&gt;&gt;g[j][k][i];</span><br><span class="line"><span class="keyword">if</span>(g[j][k][i]==<span class="string">'S'</span>) st={j,k,i};</span><br><span class="line">i</span><br><span class="line">                        ed={j,k,i};</span><br><span class="line">} </span><br><span class="line"><span class="built_in">bfs</span>(st,ed); </span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Flood-Fill算法"><a href="#Flood-Fill算法" class="headerlink" title="Flood Fill算法"></a>Flood Fill算法</h1><ul><li>针对网格图的题，找连通的块的数目</li><li>dfs，bfs；dfs有时候可能会有爆栈的风险；都能实现的话用dfs更加方便</li><li>bfs：</li></ul><hr><h2 id="AcWing1233-全球变暖"><a href="#AcWing1233-全球变暖" class="headerlink" title="AcWing1233 全球变暖"></a>AcWing1233 全球变暖</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>多少个连通块，遍历<ul><li>找连通块：遍历BFSorDFS 、或者 并查集</li></ul></li><li>多少个连通块会被淹没掉<ul><li>如何判断被淹没：一共有多少个单元totoal，多少个单元在边界bound上</li><li>等价于==》 total=bound</li></ul></li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> st[N][N];<span class="comment">//当前点是否被搜索过 </span></span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>},dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> sx,<span class="keyword">int</span> sy,<span class="keyword">int</span> &amp;total,<span class="keyword">int</span> &amp;bound)</span></span>{</span><br><span class="line">PII pi={sx,sy};</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(pi);</span><br><span class="line">st[sx][sy]=<span class="literal">true</span>;<span class="comment">//当前第一个点被遍历 记得要标记 </span></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">total++;</span><br><span class="line"><span class="keyword">int</span> is_bound=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//判断当前t是否临海 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line">            <span class="comment">//当前t周围的点的坐标合法，且岛屿没有被遍历过</span></span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n&amp;&amp;(!st[x][y])){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'.'</span>) is_bound=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'#'</span>){</span><br><span class="line">st[x][y]=<span class="literal">true</span>; q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">bound+=is_bound;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;g[i];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;<span class="comment">//被淹没的 岛屿的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line"><span class="keyword">if</span>(!st[i][j]&amp;&amp;g[i][j]==<span class="string">'#'</span>){</span><br><span class="line"><span class="keyword">int</span> total=<span class="number">0</span>,bound=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//从当前点开始，统计这个点所在的连通块 </span></span><br><span class="line"><span class="built_in">bfs</span>(i,j,total,bound);</span><br><span class="line"><span class="keyword">if</span>(total==bound) cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,cnt); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AcWing1097-池塘计数"><a href="#AcWing1097-池塘计数" class="headerlink" title="AcWing1097 池塘计数"></a>AcWing1097 池塘计数</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ul><li>dfs：遍历每个W，标记，从当前W开始八个方向深搜；每次从一个W搜完，与之相连的W都变成. </li><li>bfs：遍历每个W，标记，从当前W开始八个方向宽搜。。。。。</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">g[a][b]=<span class="string">'.'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=a+dx[i],y=b+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'W'</span>)</span><br><span class="line"><span class="built_in">dfs</span>(x,y);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//cin&gt;&gt;g[i];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) cin&gt;&gt;g[i][j];</span><br><span class="line">    <span class="comment">//连通块问题，从每个点开始bfs or dfs</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'W'</span>){</span><br><span class="line"><span class="built_in">dfs</span>(i,j);</span><br><span class="line">cnt++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p><strong>标记数组的位置很重要，一定要放在入队（q.push())之前</strong>，不然会T掉！<br>    在bfs中，如果对于之后的某个合法位置，应该入队，那么标记数组会有两种方法，第一种是在每次取队首元素的时候，标记已经遍历过当前点了，还有一种方法是在入队之前就马上标记。之前没太注意这个，但是是完全不一样的，对于8个方向，比如向<strong>左走一步是合法</strong>的，然后不马上标记的话，例如当前<strong>向下和向左</strong>都是合法的，那么当<strong>向下走时候(比如向下先入队了)，那么向左走还会被记录一次</strong>，这个很难debug出来，很奇怪的感觉</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dx[]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">PII pi={a,b};</span><br><span class="line">queue&lt;PII&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(pi);</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//g[t.first][t.second]='.'; 不要在这个位置标记</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> x=t.first+dx[i],y=t.second+dy[i];</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m){</span><br><span class="line"><span class="keyword">if</span>(g[x][y]==<span class="string">'W'</span>){</span><br><span class="line">                    g[x][y]=<span class="string">'.'</span>;<span class="comment">//要在这个位置标记！！！！！！！！！！！</span></span><br><span class="line">q.<span class="built_in">push</span>({x,y});</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">cin&gt;&gt;g[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++){</span><br><span class="line"><span class="keyword">if</span>(g[i][j]==<span class="string">'W'</span>){</span><br><span class="line"><span class="built_in">bfs</span>(i,j);</span><br><span class="line">cnt++;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="树与图的DFS"><a href="#树与图的DFS" class="headerlink" title="树与图的DFS"></a>树与图的DFS</h2><ul><li>有向图存储<ul><li>邻接矩阵（用的比较少，g[a] [b])，不能存储重边</li><li><strong>邻接表</strong>：每个节点开了一个表，存着<strong>这个点可以走到哪个点</strong>（内部点的存储次序无关紧要）</li></ul></li></ul><h3 id="AcW-846-树的重心"><a href="#AcW-846-树的重心" class="headerlink" title="AcW-846. 树的重心"></a><a href="https://www.acwing.com/activity/content/problem/content/909/">AcW-846. 树的重心</a></h3><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一颗树，包含 <strong>n个结点</strong>（编号 1∼n）和 n−1 条<strong>无向边</strong>。</p><p>找树的重心，并输出将重心删除后，<strong>剩余各个连通块中节点数</strong>的<strong>最大值</strong>。</p><p>重心定义：重心是指树中的一个结点，如果将这个点删除后，<strong>剩余各个连通块中点数的最大值最小</strong>，那么这个节点被称为树的重心。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ul><li>无向图：建立边的时候两个方向都要建边</li><li>枚举删掉每一个点剩余连通块的节点数量的最大值，从各个最大值中找到最小值</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>,M=N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="keyword">int</span> ans=N,n;</span><br><span class="line"><span class="keyword">bool</span> st[N];<span class="comment">//标记是否被遍历 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">idx=<span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//插入一条a到b的边：</span></span><br><span class="line"><span class="comment">//在a所对应的邻接表里面插入一个节点b(头插) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//从节点u深搜，返回size:以u为根的树中 点的数量 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">st[u]=<span class="literal">true</span>;<span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> size=<span class="number">1</span>,res=<span class="number">0</span>;<span class="comment">//sum：删掉这个点的连通块大小的最大值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[u];i!=<span class="number">-1</span>;i=ne[i]){<span class="comment">//遍历u节点的子节点</span></span><br><span class="line"><span class="keyword">int</span> j=e[i];</span><br><span class="line"><span class="keyword">if</span>(!st[j]){</span><br><span class="line"><span class="keyword">int</span> s=<span class="built_in">dfs</span>(j);<span class="comment">//s：当前子树的大小 </span></span><br><span class="line">size+=s;<span class="comment">//</span></span><br><span class="line">res=<span class="built_in">max</span>(res,s);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//和删除该点后的父节点的连通块大小 比较 </span></span><br><span class="line">res=<span class="built_in">max</span>(res,n-size);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,res); </span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="树与图的BFS"><a href="#树与图的BFS" class="headerlink" title="树与图的BFS"></a>树与图的BFS</h2><h3 id="AcW-847-图中点的层次"><a href="#AcW-847-图中点的层次" class="headerlink" title="AcW-847. 图中点的层次 "></a><a href="https://www.acwing.com/activity/content/problem/content/910/">AcW-847. 图中点的层次 </a></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//d[i]存储1号点走到i号点的距离 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>{</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);<span class="comment">//-1标记没走过 </span></span><br><span class="line">d[<span class="number">1</span>]=<span class="number">0</span>;<span class="comment">//初始化，然后入队 </span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//扩展 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];<span class="comment">//通过索引i找到t能到的节点编号 </span></span><br><span class="line"><span class="keyword">if</span>(d[j]==<span class="number">-1</span>){</span><br><span class="line">d[j]=d[t]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line">cout&lt;&lt;d[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="AcW-848-有向图的拓扑序列"><a href="#AcW-848-有向图的拓扑序列" class="headerlink" title="AcW-848. 有向图的拓扑序列"></a><a href="https://www.acwing.com/problem/content/850/">AcW-848. 有向图的拓扑序列</a></h3><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>给定有向图（可能有重边和自环）</p><p>若存在拓扑序列，则输出；不存在则输出-1</p><p>若一个由图中<strong>所有点</strong>构成的序列 A满足：对于图中的每条边 <strong>(x,y)</strong>，x 在 序列A 中都出现在 y <strong>之前</strong>，则称 A 是该图的一个拓扑序列。（即：所有的边都是从前指向后的）</p><p><strong>有向无环图一定存在拓扑序列：拓扑图</strong></p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul><li>入度=0：<strong>没有任何一条边指向它</strong>，所以可以排在当前最前面的位置：将其<strong>入队</strong></li><li>宽搜，枚举所有出边，t→j ，删掉t→j：j的入度-1，</li><li>如果j的入度=0，说明j前面的都排好序了，所以j可以入队</li></ul><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;top;<span class="comment">//存放最终序列 </span></span><br><span class="line"><span class="keyword">int</span> d[N];<span class="comment">//入度 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">e[idx]=b,ne[idx]=h[a],h[a]=idx,idx++;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topsort</span><span class="params">()</span></span>{</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="comment">//把所有入度为0的点插入队列 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!d[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">top.<span class="built_in">push</span>(t);</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i]){</span><br><span class="line"><span class="keyword">int</span> j=e[i];<span class="comment">//出边的点</span></span><br><span class="line">d[j]--; </span><br><span class="line"><span class="keyword">if</span>(d[j]==<span class="number">0</span>) q.<span class="built_in">push</span>(j);</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="comment">//判断是否所有点都入队</span></span><br><span class="line"><span class="keyword">return</span> top.<span class="built_in">size</span>()==n;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line"><span class="keyword">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">add</span>(a,b);</span><br><span class="line">d[b]++;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">topsort</span>()){</span><br><span class="line"><span class="keyword">while</span>(!top.<span class="built_in">empty</span>()){</span><br><span class="line">cout&lt;&lt;top.<span class="built_in">front</span>()&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">top.<span class="built_in">pop</span>();</span><br><span class="line">}</span><br><span class="line">}<span class="keyword">else</span> cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="Medium-Part"><a href="#Medium-Part" class="headerlink" title="Medium Part"></a>Medium Part</h1><h2 id="最小步数模型：状态的转变"><a href="#最小步数模型：状态的转变" class="headerlink" title="最小步数模型：状态的转变"></a>最小步数模型：状态的转变</h2><p>区分最短路模型：从一个点到另一个点的最短距离（比如AcW-844走迷宫）</p><p>关键：</p><ol><li>状态的存储：<ul><li><code>queue&lt;状态&gt;</code></li><li><code>unordered_map&lt;状态，步数&gt;dist</code>：记录到达状态的距离</li><li><code>unordered_map&lt;状态，&lt;前一个状态,转移操作&gt;</code>：记录前驱，用于路径输出</li></ul></li><li>状态的切换<ul><li>根据题意;</li><li>（下标从0开始）二维到一维：<code>int x = index / row_length, y = index % col_length</code></li></ul></li><li>思路：<ul><li>将初始状态加入到队列，然后BFS扩展，直到找到目标状态为止</li></ul></li></ol><h3 id="AcW-845-八数码"><a href="#AcW-845-八数码" class="headerlink" title="AcW-845. 八数码"></a><a href="https://www.acwing.com/problem/content/description/847/">AcW-845. 八数码</a></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1、将每个3x3 理解成一个状态</span></span><br><span class="line"><span class="comment">2、从初始3x3到12345678x最小步数 -&gt; 从初始状态到目标状态 最短路</span></span><br><span class="line"><span class="comment">类比走迷宫那道题：从左上到右下的最小步数 </span></span><br><span class="line"><span class="comment">3、到达每个状态的对应一个步数：unordered_map&lt;string,int&gt;</span></span><br><span class="line"><span class="comment">4、unordered_map的count()用以统计key在unordered_map中出现的次数。</span></span><br><span class="line"><span class="comment">实际上，unordered_map不允许有重复的key。</span></span><br><span class="line"><span class="comment">因此，如果key存在，则count返回1，如果不存在，则count返回0. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]={<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>};</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>]={<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(string start)</span></span>{</span><br><span class="line">queue&lt;string&gt;q;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt;d;</span><br><span class="line"></span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line">d[start]=<span class="number">0</span>;<span class="comment">//unordered_map[key]=value;</span></span><br><span class="line">string end=<span class="string">"12345678x"</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(t==end) <span class="keyword">return</span> d[t];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx=t.<span class="built_in">find</span>(<span class="string">'x'</span>);</span><br><span class="line"><span class="keyword">int</span> x=idx/<span class="number">3</span>,y=idx%<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> dist=d[t];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line"><span class="keyword">int</span> xx=x+dx[i],yy=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx&gt;=<span class="number">0</span>&amp;&amp;xx&lt;<span class="number">3</span>&amp;&amp;yy&gt;=<span class="number">0</span>&amp;&amp;yy&lt;<span class="number">3</span>){</span><br><span class="line"><span class="built_in">swap</span>(t[idx],t[xx*<span class="number">3</span>+yy]);</span><br><span class="line"><span class="keyword">if</span>(!d.<span class="built_in">count</span>(t)){</span><br><span class="line">d[t]=dist+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">swap</span>(t[idx],t[xx*<span class="number">3</span>+yy]);</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>];</span><br><span class="line">string start=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++){</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">start+=s[<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"><span class="comment">//cout&lt;&lt;start&lt;&lt;endl;</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">bfs</span>(start)&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">}</span><br><span class="line"><span class="comment">// 2  3  4  1  5  x  7  6  8 </span></span><br></pre></td></tr></tbody></table></figure><h3 id="AcW-1107-魔板"><a href="#AcW-1107-魔板" class="headerlink" title="AcW-1107. 魔板 "></a><a href="https://www.acwing.com/problem/content/1109/">AcW-1107. 魔板 </a></h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> temp[<span class="number">2</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//每个状态string，存储上一个状态string </span></span><br><span class="line"><span class="comment">//经过操作char到达 </span></span><br><span class="line">unordered_map&lt;string,pair&lt;string,<span class="keyword">char</span>&gt;&gt;pre;</span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt;d;<span class="comment">//存储步数 </span></span><br><span class="line"><span class="keyword">void</span> _set(string s){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) temp[<span class="number">0</span>][i]=s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">7</span>;i&lt;<span class="number">4</span>,j&gt;<span class="number">3</span>;i++,j--) temp[<span class="number">1</span>][i]=s[j];</span><br><span class="line">}</span><br><span class="line"><span class="function">string <span class="title">get</span><span class="params">()</span></span>{</span><br><span class="line">string res;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) res+=temp[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--) res+=temp[<span class="number">1</span>][i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//A:交换上下 </span></span><br><span class="line"><span class="function">string <span class="title">move0</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"> <span class="built_in">swap</span>(temp[<span class="number">0</span>],temp[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//B: </span></span><br><span class="line"><span class="function">string <span class="title">move1</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"><span class="keyword">char</span> a=temp[<span class="number">0</span>][<span class="number">3</span>],b=temp[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">temp[<span class="number">0</span>][i]=temp[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">temp[<span class="number">1</span>][i]=temp[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">} </span><br><span class="line">temp[<span class="number">0</span>][<span class="number">0</span>]=a;</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">0</span>]=b;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//C: </span></span><br><span class="line"><span class="function">string <span class="title">move2</span><span class="params">(string s)</span></span>{</span><br><span class="line">_set(s);</span><br><span class="line"><span class="keyword">char</span> t=temp[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">temp[<span class="number">0</span>][<span class="number">2</span>]=temp[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">temp[<span class="number">0</span>][<span class="number">1</span>]=temp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">1</span>]=temp[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">temp[<span class="number">1</span>][<span class="number">2</span>]=t;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(string start,string end)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(start==end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">queue&lt;string&gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(start);</span><br><span class="line">d[start]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()){</span><br><span class="line"><span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">string state[<span class="number">3</span>];</span><br><span class="line">state[<span class="number">0</span>]=<span class="built_in">move0</span>(t);</span><br><span class="line">state[<span class="number">1</span>]=<span class="built_in">move1</span>(t);</span><br><span class="line">state[<span class="number">2</span>]=<span class="built_in">move2</span>(t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++){</span><br><span class="line"><span class="keyword">if</span>(!d.<span class="built_in">count</span>(state[i])){</span><br><span class="line">d[state[i]]=d[t]+<span class="number">1</span>;</span><br><span class="line">pre[state[i]]={t,<span class="string">'A'</span>+i};</span><br><span class="line">q.<span class="built_in">push</span>(state[i]); </span><br><span class="line"><span class="keyword">if</span>(state[i]==end){</span><br><span class="line"><span class="keyword">return</span> d[state[i]];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">string start=<span class="string">"12345678"</span>;</span><br><span class="line">string end=<span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++){</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">end+=<span class="built_in"><span class="keyword">char</span></span>(c+<span class="string">'0'</span>);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> ans=<span class="built_in">bfs</span>(start,end);</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">string res;<span class="comment">//从end往前找前驱 </span></span><br><span class="line"><span class="keyword">while</span>(end!=start){</span><br><span class="line">res+=pre[end].second;</span><br><span class="line">end=pre[end].first;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(ans&gt;<span class="number">0</span>) cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;一些BFS&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="BFS" scheme="http://example.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>【生活】Days Counter</title>
    <link href="http://example.com/2022/06/17/DaysCounter/"/>
    <id>http://example.com/2022/06/17/DaysCounter/</id>
    <published>2022-06-17T01:55:34.000Z</published>
    <updated>2022-09-02T16:05:56.643Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉喵, 密码不太对噢" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="317cf17243fddc17eeefd103b1f669429a44757e5d3d98851473ccf40450697f">9c5e86699b9cc94cc6fd0216b9a4d800cc9c939e74d22d4f668a890be5553b8b7b4deca89eecea77109d9c9374f0c984ae5287e59710b2d31342ce86ec52051bb9f3af3a8517c26b3734fe4c3950e49d9661f005f3c9191370d66f7980e9f3f5684fde6677c685dced47a4ee2f2094fd3c22ad5b5b797d89ff5059862ffa45cc0f7a265f8138c1dba1b7e9e89c2163e33d0f196054917f5fc0dd58d66729c01e060b252d4a1967ae396c0369a1e28ae02e6577c04a70826069bc4052fa5b0370d2116f300236e109e8eae5cf061c7764c07456fb074e5ce932a143eb684b9d3e566fadab4b5fae4f329932b5e723466e3c114e59f52d1069575f0e57a9eeee2528ead1ef2482d6972fc65f22e766a1d1b9c0dedabe602647d9415c2748be759f06b95daa366c59c7e2f2c228a6f96712bddbd8ae3ead2cf8c249c1b54aa1b9f6e4de92b9a52aa3f9e10db5e2297814a02d95646e0130e8346b99492590d04ae4c6441a1c921dc775c2a6c5dbbc414a88bbaf16b5d178cd510c39c84518102ab42fbb3850242a25b29bf081ca088d215bfe916a5e1bffdc61be9d1ffeb00e1158212d7550175100db7dd6ebec200915abe1d485d6ae530363edad3a657b394c4564ff54ca750fb523938e8b53bf2542b41038a171e8ca69a81690ea23f47ad525a13cc77586010e2815170b523592cc91551450ebba3ec6147a0375225f976c572e9520b5fcfb1ba19126c2b10674bc4f7d3d1c6cc851cbfb31a6a5a2e6282fc30588dc314070f9d3f2396a7c0611f54d7e7eeb94abd5bdd9ef3eec41ef6277d7315b7478b32e129698dfc482f1839a136f0c7f1e73e23fded475293f08d063fa7e0fcf4cce55599adbf132e2a3f3e55b042d4198b8b7839690c461635d5bf4d34006b5cdc52193c13835468eba3d4ddc436f99cc0947e09bfa2469fd6c9e129702047a83e132d54f5cdb0b66132fd9c20ef805466f22f056456a0300699f01e660de865cfe1e1a43f6b2d62e815c6fd83a06ac6e4be0b1d1d4dcafc1320dcf59088673add7d87222e4a41fd2e3d91678226c25c9e982bc24055025cc17b612c08dc5cd8392611c81cb1f2ab8737754dbf30bcb4c1a6967e4d6e293fab5ef6be2414825c25663df3eae8868e95444b72679c1e3c6312c773b70f72b5e7c2ccd52092c940516d8b570f47c4dc140339ebd178ac73a945fe4519ab3fe2dae10c2cb1bacaad7bd571e7387d3c2e53225dfb8709cd869506f1601f0ff26a1160e1e495820929dd55cd91e9898f534b973a78ab6cffc60918da2fd5200435098b842dbf79f1b69ac729e4505088b3406d07cd5559531579b36f40b2acdc5726ad39e2a5b8b119c773d8b9f3f8e6ff02384ecda8be9874dc67745a06a2e18c2fcf29fdbc789da769dc84995fa289808e825d26d2c4112fdb6d33fc4d94b587d069befb8ebba01ab5fb69b68c375c168069ee3a1442811cf6aaf24c5f203596ddad52eb807df0257f2a8c84533358a15894630d1f637fb7e05bfa03ebe27246cee5acf19373a0c55f119167d006ee07bc4ee15c5a152112c0fb08e76899474ddabdfdbf103962bab89255ce1c9d0d3f18b317bdf05357d373dc33395893b9269954ce8950c006238c6d915558112c3ed54a0e516fe780f50e3128dc4e9f9d8bad614ddc8fa8bda5524b9dd311185140559f84ff0c00cab9ca60e4602f494a1dc78f79faf63e4655068aa20e697e5a449d6eb58336ba791c1bda203a8bb298ad68239d89cbc91ea666a34b2de95a702cd5539a8e445d914e11d1fb56f2e6fe737773b5c4299201c20fc1f1ae29a51259104045e1d70db1ee27ca6d24f1da95e034c21021dad6ef910ad42241e890331b0278af2280315f78f7755136ad2d587986ef421f214dee7ca037ff3d553cdb013db41092af387b6b5ac3e14de1a816862a6878ce70931ff9406d036233f21a0acf9bce320e3b56c0a589b882027970e3e5dc6fb23b52c0e144497ea28f748d0094384e620ee14e517ed314d075de7b8425076eb2d179a58444d7cd48c6b40c6bc482925f3f37a0d72080e4b7c235414932c9ab49e1ba01d7a8eff53f3a4d601c520916714f018774e6883531345cfb4389a6ba83c1421de0be09840faf40f1c6ea74852b57376f5bbff21e0fc733e26c8b85475f7f136733d4a7ee55e6f10c43f4893dc2f2545c00af91ff1bddeb70313899585034976a1bf1ff32ffc1014fb13806124b1bbb23faa9dded23ac5b5b2fea1625a4d00a590cfbed39bda2842f53fb0ce5b13aa0294b5d278bb345c2a9f75f8285d7dbe61d61a7d680ce4e145744da7e30648e809bd803eb8fe3542e128e1d3f2e4d6b4fad61b43f214edf3ebb3d49afbde9dd4e629b78f738a722d00c2b09a6bf053a53c76dfd66e93613333264d90c1b703eef5d86fad5bf8b76814086c6333737a19565dd88f74846d8f282d36f9cc533db62ab8e242e4c31ee025221432004264dce15cc10d92c6a6f8c585465ae1b7d80ade8ea1ccfc4567c3e8d2ef6d7a4d2c39b9ccde139e10bff52fdfa8cd5676def968370b1f4e0e19a80116aa48244a4a7fe90ce26c7b62a0b87f60eb460f45cb3ebcfac11b24a3839543c36b98c85dda2f3fec6d9e92c7ac4e86ec2b8ac0dcb32f12e8bf87e39e7166e43ac847d144c9dbbae8f889ba8daaa18be19ebb82183eca98701563b9621b41771a5dbe63b476cd8f6ca14f05666ba48e9d7cbac63882842d94161208bd5c67e54f236c9ce194755acfea5da90f2308a4154d9c7e448b616fb6642978e27fb0d1969acc536d208f1d04a5e12091714973a7f9b6ad5c902d64e1be84bf1fc94a2776bb2e2546a590cce265b604be28dd14578066a52c8dbbb1d78c0ace4ccc5135bc32142312ced400301e45732caa71922f3273cf2d8b0ff129ec1215b741fa78bc73fc716c6c36030ed74aced8cce4604927a9013421c1ecd0757192ca49ee0fe0b21db9a5a5273f8d3facbda5869fbdeaf345d3b439082af9fad1f150116a1800194b830e097be19408c56936083eb8be95c40b9a91f052901808a4d0c03b334266b0745e29800096a446b1f940d00a5e1f3554942b14548318676cc90a65eedb70f5bd1b7102f23cba70c4bcb585f96525678127acdd7c7155fe5e6753c6d7f40bd48cfd66d97a4da2ad44149cf37c93c799b9b1d0116cbc30c180705e6c0b0fe0611bd9536afd43cd594f0903d4e376550e1b23474c2079368e85a48de947474bcb943bec961f2323680d72158c9720530abad612412d5ee83ef6fd61720243e828db996e9c167804953aa2dcd923fc028d54539aea4062cef816209c693abc1a32012d85ab1af756090ce6c94889ab5556fa8226714a52144c6990b3b4a68ddf508c3afacbc880e6fffa2fab36a64d8603cf28012848b25d88901be6a2c1ae667e4d3c0aa70ae0a6db7903cce6b0c14a5891f870de7722550598ad8db699e7ad62022e1417199810fa3915b29d88b5367e18cffcd7d5f7c47bd4ea66053fb70eb67df71dacae19cf539c061d46549044e9860808d3e0bb9267c38105006bda5ab14d9c57bfbc86fc62692b8b86405d8d19a89e392f2fce985c0ecd2806b7260ae0b2a310dc7227f70a145ff47e312b3421c18b0e445ccd63e4c54d1ac932ac80bbd0ccc7d5d206b195158ff3098e658ee39444e8fcc7d2bda02805cd17d5519c68ccdc05327722b67cafee4b06b95b7a154e991b4b2f148a1f8283a9e33f202432342183866c38b1f62eb42fc9db24834a81d1244dc484d62c4a1a8f694cc6bc8f814506998a72600dff82a6dffc06e6a941a398d8c66dbd3542122f842558ee4964fd6ef1aba4057568755036208160b8fa53f0104f8a8bbe6dd6abfb17dc6f951dd32bb4fa358513fdc7c229481318f16f7c9bcfd6e019a9374e6245f441a5ca7a4d6a2a7c0fa1cccbb3a15313032b6d26a8ba7ee814a681dfb3c16de44fb79491acd34699213a63a3df65c9180ec25d492964c3d681329f3383295bf3751c50e432601943a392da4b5ef989674aa5bef9fd75162919a2141c6f3a207ce0a40fb9283f74668bddfe2b0a4b8806f68383294be67c0a8d67530aa203b8e933f08ba49e3ed46c4af0fbad4f8181c4bfbf7ff5699f7911357c1a7026a036cab8d0ffbaf594003b6c936d0fd3c0f7b1a165e529ba41214eae307a40f0b47f6b2812a4fe9d41722ee700cadb0db191d96ef7f1fbd03688b5f4a5202a164ff33b21e02461bea333d9962c9b03a96a4182502901e85b1e457184e1f795d987202991d455c51c91c17cd16e96e8756cb6ad400661a11509826468e894af2fce6c8f9eb7fafd539e2790955d06a3f0a997841cffe06c94a0517932e95f17ad5624ae296a2f39501a34cead840e26c48aced2dcf8c182fde91f24e37a4f7fe4b89bec0cd9503cb518287bb9410cb935707dbd7128a6833167853b11c74ca17155e84e8d9781ca9e7046d944d304b4ba08756ea1c44d1e9d041f6905d572ad5e47e48e378efaf731b4dad1ed160c1cb2ea8579bf96283c12a44806119a344e0aab08f86911b75ea35d6c05174917f902e54aeaa47b4cdcdd9437d03ddae1ef0b79854b0b806b92502cfe6181c83ba69b2b2d934b5048f2736cb8ec277aa3bb75c8289d98cb1379ba1553639c75fc032887c8802eb6a64e3952e9110ac13092ac68aa1d819e46772d188a0f8d25d1e7fb3311e92627cc8719c2ec9bff615646535fdb395af7969c6ad09f6067ce8d461336fc658fa8eab25771f9437396ada83e5b6e2326f52b7f6dc5a7904d0111e5bbea70817effa1d2c31cd4bbe27000d758a4fc2a5eaa52741488a058c1b1d03b4a7686b1f574264754674e6b591b3170307d5f450a5535304e204d55e30ee65f3eff1d8ff3090309b17d752cbb3e235b9f689c76b4df9a988982f3c7073b2fe11fd289e5c6fc868123a0f9e36376e8462670571f6c7fe7ed3921dda083199e827f9a13bf3e9dc69521fc02b4d307bd8f4b79bd19f930689b677490a7b746f3ac5e683e6996ea6f4af96acf2732af5c7dc472cfac8be7a8005f24e6b077f1c7ecd966e9aef7bb7b359e7b163cbbf60dadc21153e4dea6eec358ea92b0a396d5aeeb7f9333aad9f2d15f828feeac1b4aa24b4ba11c3bd67bd570c4592c297674a386d12a4e4b15b1f6fff225c537fa8392cdd1a787fea3259efe14dc4aa4a6cc525bbd65cbdd74be3d5df506b2f27c2077e032fea53f38f541e3c17b972fc279809de6a16d28509d42783ec38fe65591f79257c1d8d7a0481361d100914faaa5a4a4948d9f3e32144dc8b8e10c9b1cae737a5de885b7b0ae451d3d2b7befa8024caca222fbc171fdfb58e160c15a2452a346c957fde09c2f0664b97dd36c681571dc33c6e571692e0d8e6350fd80159a7fcfc6fe9a380f5633cfd225062e7acdc2daa1bd26adc5aba3185fdcb66151e170c1f86acfa3b5fa3744e9bb4749480657ca5b9b41bb4c36c7537d4d64709bab509aea8ab88cf27ef1d05469182ccaff78da6dfd1c3a03947dbc4d2b2f4655918a1885263ec1177cb0a247abe58f38cc602a4f5e4804f0eb2ef0534b517134765776a65e64c977b4677de3088f9e66cf1713c68c472b5899cc6b0c10650394a3cb8137c44fa2dcc1fa45317893f4700e3986f8661480ec1b633a45a5bdb22cb62d1fc5e017eac5d8f741001b9dc7636edca56b40e6997b92427e11a192ba0321b50cebce0e104bb5bebf5e7d7292e7e27f08f0cf4774ef55ecbd432877d7a9ecf300e488a4159ac617f09ba4e1a77e331c380ce5b792930a6930d72771aae619a1135d6fba3d619f6154ad74d0649305fb7f52ac7319c9d055dcca94d015352eb059f8a11f047d8097f470158bad3373d460fdcbfe5d3b46d4aba5a0b741680384686d73306fa35d711169389c3e2a72c8951b25d1d4a8cd70dc5f48d01930483e4c14423570d85c90bc0e3f46099e86b46aa87eb4a4fd4c7cd0fe5f17fbca11474ecdd36c4b6496b6e486f368e87efa8528e15c272bc25d00c9f3af08d58a7a7285f5fa47e37c3df6a936b98bfe9b5b0e0b554e1466d78cb35d16c64e15dd7c63df50568f65aaa42ab1cf0a913e3e3e6eadfe2088ceca1292416344f13466b0eeebd3d13a6c746ee43c0360a58f39fec630a4ec8e9a180af07883312ede4d2b267e034980a40ac82eca4c498b06b7e8a21d1a105f987286ddccf5d5067cf18b410eacc2c1fccc897fae9e3b710489ab455f3eb46086b69208c10cabb789bc3213614ca6bb72534a02e81bb7af4ff2b2fa4d47399d568b9e474f2ea906950003d70af04fd0e42466f17d7a6564de281fee168302adb97e91f2a15a41983ba4d62071f3d38f53f840fd64d1cd2f30ddc154c84758041e04cb3670cf1b83e553df6aca76a53a05661ecb7038d6f971faecef7b4eb0e2cf8d6fca4000c69a0bf58524bc23275e47f40b7ca700ca13465f67a4efef9b3f7d0cd8bf886feae8bdff1900b93bbc9659cde4a8dcce82b5bb69b41f0cde1d3adf6119efce449a927667071771bc0ff62da664519cff392e53dfbaa2d7757566ecc9d935b84ab539db4ce8f12ba4c22afb657a5cb321470b19105cc054c403e94830468540b4bcf7f25449b03948ca496aa96dd96538a56d4d0810f66b0acf60c10221a9d7453bcb45b07c93833df93ccd45a0af0b71c4989446f7d4d79644021da7c0ac131bf4c22146ef25b5f6ac90f30fe571220698841eb34017b3181b396bf6de0e6f731b232b771fd52b55d6e2269dc2d7f96acb0bfbfec4572ecd0c391cf31dd67b404b6b9eef7880be7e942e528ff29dc97a6a26fa31a6474b07e2ca532d3b4a88578671fb7dad260ee041ce517dfbb663e5316ea273d351c61a735df64b21776e44c77d2761b1e7bba78a286433ef568cfb2cab1284e83c7333f887aabf9468d4216b276a655629d753291dd2a97b4b7cfd14381144101c13f82fed9d0f9b18e4c3360095297cdbf2f0f8a6afb4647017fb0da37b392bee9517cfad0045d85221001924b803a933d3d99222fc6d08a8832e801dbef392fd6457bec4fd361c5ea0ee06bd4f414be4b5411ea0d5e7a570c46ee0c9da2015e1af8bf43f29df3580a557f45d73101c7148f005f6efc9223ed4819c9b0937e397d03e2bcbf18f8f475f556354166b4daa2cb1e9539a5c6967a9377bd6a22bd8bea14624892ef26cdbc9112a85e46362f0f2c52a9b768d0895f59ef2b9a3a0354fae45df11c3268742420b75a30bdaf61b19f0d14d9bd680b6dbd81f6f5765238ec5395c930f25270059e91c9a97451fe30c301c34e96b035066ac56d219a398754785fd068119b4f087e2e7330d766a797b9b8b277b0edef4d673fba090c5f19600834bf6040e3600b24520deb20cb70a31b2f1bfaf9b6b7e4668f9cf5d0fbd8d5e8a2d7741bb1f939634caab39ec3d1342b72ed521eb0e0f6f47d7268f7d26d2b1cf6e2902084e389456d69a420e1e8e97fce35fd3d99b13cdf47d904e448c41747bb50b5e6a4bd822a0960d4ffadb3baddc8e0f40f8ff8242de4529c6b0bb64eee30ef785a68cea08549b84a6ba07a800270f222dae833e7443797e4baebb6735ad4b8b47127fcceda48549c7009b83835e3326f047156fd690920223ff324ac98298cc9f8a63b226c30db8d11bf2aef2502ef96cb70f181a5942e0134d789413eb999c851557f5888bdbcded1106202919528436ce8e1121e66f01310e1abcaf3a40d87f6b52316af0fcade10095e5e8ae85253e5352e47d8f596d1ff631a1c07e8c3b40d41a263010d83a0b0e1bbb54ac135e248b8650ed670a6c3dfd29046f1ebe301543cc263f39247a2efa9bb36370f0220cd913f37dfbd71cb0d1b0475a5f4c33aa1a2161b0fe2dec0b482c03481aebe3318abda832e7db703ff142831a51827cfa93ee3acfbe6efe0d5cfe0a880245b9da63d56958504d86ff16785c77bae7220ca444151a5ebaa7c5bb78f3af1f15a6bcfc087ac35bdcb58e0d2446f626d2f82306b44f42e16f2ff0be2537e353636cef92e2ccf29d1b812f40aa18e795264f2fc4d2d546e0e5ac0008b695870ca1e546677bf32f6b7efb6cd23dc77b8ad69c6c4908d45efc2de02d64a7cc6a81e93526272fd545bf575666b9ccaa13b3e1f8e0751d9cdb99049e82e880cbc933babc42e34b241649e6282c89ad34ba97a478788f829c77a750392914030f98c61e629ff65985fab03498c98b4495b596e6fe458972ff0b35f4c99983ffa1f571118255e7c3c628b31f48a1d1834f6e8093eeab2dea8323ccf93cb5333ec23818dc271d9fd3edfee0d9f4891c97999ca228d18243a6b383c0fc3727fade6303569832358b98c29857e6c3b4acd0826080bd8168929220e6f1c57091e4cf9e2cbe1877f8dcaf185e9505ddf52493f7fc33da5b45b592a6513defb4951dc6a617f9db82f5cf86cf0242c3343d11debebc06665e4dae005ec30effa23a87ee4f71ae72187b7d1e3751299e8e91ef2a8355cc7c9309622ae029528f0838513da21f3f3bfeb471205b2356038b32e5c8f6242cf7b093d1ccb6538dc27f9257e42a9a5e342db129d560409cee72c638fb03b0ebf75b925616d4288f9570bb68f1b43e1de040200aa2e986243da1e2d08e297d377bf24f261858ff1482678c88e158a60ecf2085c8849b57a59bd1345cd984f3ebe916187e21972f2d07760cc349960e92d130b1f82c0bdfe26f1cd03af8e79e02cc6c6f6ea4a1dc0debac8f2acc61fb670961cef6d3b296223b8bd382844af952680036b8c5b1c3c3e59dd9c9e49aa55bfd984845bc5f22626fe39e800480aca41a7909024c6ceb8ea8080f1ba57c9d4f111ec9bcca7e2d8829533e2083d581f55fccbb5e38d99f938a16de1b182423bf6b0cfc06ac321baf6f6d19d6e86ed52a145e1eabb1a6d48316325f2b9e30523c3663ba30366e4e3caa0c9b0995f46c90588deef7e1b0754ab51610ee01c763acc2d938c4d6f04299207758148f33febe9adc75be6b342a99a16c40e23726fc60663b3c15d7c48b9dff233349775017a46094d7b1f4e973a97770cdbd6715a92fcf3e1fd83b2f295cb1f04d24af2f2dc529fe5280a458bf25a75a856b5c634a035c9fbf825f4da08cbfbf76dd392a5bfa31e777d0d322bc4aa02dfdabc4995bc4bb02394d33969d909ffcc877a2ea3d2b6dd2123aacc4fb2a7d9fc83e7d7ad07c9ec427920c17f0d5651d616f1cc29f14a7912170bed6005c3fb7537f67f3f2f87cd8819b47db9f58478a344450cbd6aa0081abed0f958bea46b478f2ebc01e5c48f21510cfd33a671c328ccf95b7e8e665d1bf7123514dbe1ce9dd60f3133ac31802dee40511830ba349e11b5e7f0b195a3e5198d6e28c0b2c3a37a2e8dc0ba3d7fd49d1b025214bd3e463a5c20a8bed6b3d3a7a7b0d8fc5e36faf84eb2911771eb3615799e1518d89a4ab8308429a76578912f818d12e87bc9ec37fa6184d398b4b49a73469646dfe597e244e49284dba0fdc32173fba7e8b02f87e58916509c732cb6a5bd5f6c7d06d1a1e4a625e1aa956fee7202cdf3ffe1cbfc1f63f67a75b33489b2d8c18e55dae4444d7f9d8264f47e424da32433fa6ae0e1d33071e179a851885247a5386e77fc898f9c85b8dcb96aa517fce66207edcfae4f7f75092a4a1caa83b1ab7f84611c7d3f6f1069465fc1baa90e125d44de06fbdaf48061564ebec23238c56eedfa84ab56baa89b4b20edf42708383a641d84a57869263ca85d440f57ac1179d8f7af140ea37846787b0f1404252abaa5261bae33bfdbb35bb4ea792343d368ec0fcc29049fe5881b97184175418818d229b78112d7e997d0d664ea46870366e4b9b672782635489ba048715112f9db3a66b4ee18f4e5d62e3492fbc94fb522ba96f664ccf342759534317d8607969f9c5455a593b08be786bf8319cc0dec5c05c13eb1d1ab884a1a92668f909be54705bf3bd117b36410058edd1461b2c23049992a52637872db3d9ba2a03012a6c275a50d45513547b1650373f7ba2132b0305e4bad59f1caab572f485499ce1d720594678e50d2ceefe2020c47d728db5232a8ea336b10cd9530103d8ddf661dd1f0dbaf0d1e4961981659718536eb00437062e0d1c1e7eab43428eb441ee4c2a698b4d23fb5cecc24e98058e88d3e8b48c0aabb4ab2c55708ae99c3f6271b0df231c0f7ea76e381e0ecfe0079bfdde0655cc8a548688bdd47afeb3d740cfc7f801ba06627e3e3077c529a896d85e3bfa27827f28f85b73ef5958493d17c52ab121b48d9e6c92459b0f6e5d4567a3f4b28fdc93b741e0893b19f2c680c98254f258153830d9f55013acde55ef8bcc3348cd998f421f724f5157e245b32c26973305fb64bf5aec1b4730c8b73507b6d842f0da251a5724b4348c9699802951a7ab5053ebac8ffaa0258c47ec7ae20ffb4e070f2d0784cc1111b4fc5b4454fa52b718ddb8e5505d5a4c61361ba53a4c35dfa3b992cc883976df1e9b0de7beefad4bcfc1db2124b861424e81d4fcde3454e0d5d0c5296af02da61b5b2a27f3e137733b41719c57bdbaf84aed9c7b5b864c455bae68483924ab0db8e6984c33c3825bc80b297052cb6b8218bed25566969b6309b02c1ba4adef8eca78eb6eaeceb05d7d30c3139cc94d6c1860fb8544b6f376093461a7c3f3848995cf2dc822d9d50aa1eca855eb0595851d0fadb6f240438134cbe5c63749bee230d93632290b4950fbac53c1902a2c449d8199e7fef794c6a567308f3d55dbbaf18d244635b5f1eb2c08f926156923e663fbad12b6a018470d2c5dafb74369893e8276247ee168899126308210b15c262bbb5b04c832be499e16fa5478e2a7e4ba04c8fd87587491bc5df6b9eb71c5f53776b514d5d0306eb98be7f3d483a3a7d6597b4e0e315da4f6e6478a5d641a3bf3dbda2cda567ebb5159f60c628fdd4684b89877ac77b86ffc624c0bdee819901ec429bc396e3bde5be8fc6a3b53e58b0ff63a94d1c1363b4bda285814bdef64c3531b23159f7472e8ab3e7a30afdbde5ba5f83b4ff4b1120de918878d3023a1c7f78eca4f65a3f0fb797538dd9b707da44010f287a77a31ac05847d4562973a7e4171f5a15e2a7f6ddb129c45a9298bcb0978029e685da80848df81bdeef30d935bef931cd9e2adfd0cd30b275146c2f984d388cc1f7d2c5a7709b3cb603f09ae3191b21d7fc83fcba53fd9ee8a0a473ee40a4ba648f3b1e5decdde5c993c9441560779cafc2c9ed4316fb7ef1d6088aecacb9688390c5e1847971ed75c82c4153190806b3bd2f5a752a3928fbac7cdf50d8f8f190e7248b3e46911ba5aed542f85a324c030d7d4f7cd6f9b9750b0341676ef5d36d7e22d76e8890a69edc423262926d61eb607607ed1fd1114945065851264df3a72e622e28e1ca86e00798b2475ecb8e17f34714372bf5c8b3ef81b42eb0ea8b0f9f642dc88167680570c7eb597361f70421c4a9210fe28a73fdd7f295d08f1d7bed39657b7c96e0acea5478b2780b672ef6d081a581c52317a3ba3c34df3636d71e2f3998824eab841326f3ecb7a925c16da13e94084f6cbe4ea80bc8da9f242852de30d14913a6f5d6a2c6874abb7b61160751ea5ee2698fb46366a30affbb42a812a1a7e438ccecafd6a72284196dea92dea0b360fe1d0b97a6d14dd4c493d51511eadb011fa7b94473bae456e26bfc168e3e2e0f52d83446e84ab7f798a126c5fd60af9696993adf18d2825a0dfc67672bcf7d7e33167b9ac6d00e71565e6b139f4f2556a11a310c1c067e7d430fdcc535bcd86a71f934b7f64df956da177d9fcb0d074cc286e595686d6b1e90232c7e7e119ff599e7920aac597c7935a41ce037a5d856f1d412cf73961e90b0ada8282b1cb5e7477e5e3315a951df0b5526e191c8ec8d3b7ebc66e7cea2e7c559b752b2c0f28fd2e13986c91166cbdf4c5345a4fd4e71422d928de01e779a6497e6e85b2f5e2c72974f6ba7682db121bfb0d1b8b94ad2e413a2409b59e16528b4754b2bfc409592b3d92cd1e341c5978a3f8b060acff945758db5978a7777ec51bfa7d8249ccca4170684170b3e8e3806df9dbff372e6773f733bbc6a533bcd86fc73bc7e72d6c1ed9572bb64cf2eccb87bfc3e46ab027aabf70db9042929f4fe72b06889592f6b1df3121330e54796ae66fc52b4f8d56d97735a408b20780b0edaa582e817a24baeda687be2b5aa130e7a6a9549f1f8abbb063d47401e422e5e0b63c9b23d874cd7a991ed97b402ba5696615fe6594d170e13eef1c68ff33309ef9dfefea59d26df71f04a6b57cf63ef23f3c0a1fd53aa7b463e37e57dfbb8fcd077c0bbf2fb4544dfd9b41239c990aa6b31755ae683dfd4342385ceeafdbebcf3403f08ada55981110382e310cfd75bdfc7296ef9db3fe00e98c05d4b9f5b2c0473f98f229ac5777d9db66d3c6ecfaafc7134be6baa90cf985c4c92bf55426bf1ba1d98bfc767fca40ee42b94af1fed18f1f5bea21f9add667ac0b6cd655248efb0fd44ecfd2b93610310d273a2a15e5319fc2a23a7fb060aaabd5f98b104dfaf9f5b9e5c3be42f8556abdb113dfa310cfc083be3d9ce0bf3f1770aa76dae9322665b42786f7d2dfd54d68dfbfdb517066d3444a19901deabf03f4839c152806f1c91560c7d287f3aadf22fb3acd521ce0d9897afb2ed045c5b8d425ba0754702d8e5e3d52181bf19a39f277d41d2c22110d03f6fd969cfec595fdc67ce0f85cc90c3f18a15c2422949f30ed72f414116e87dd5d6f6e9ab0ef12ce6f08df9172523d679eda2725dd4513a6d80c87c1f54432ec4e32cce132768496b1e87755ec9e021a9a8570997b4146cbc76bd8915a2b722f1ad9da36121064807f5c124241275a79f22bd4b3aff89c548033f2020fff58b54925bfc6fd6a72bc03a601465be4046d582fbd1912b0a59304e94591f8eadaab2f1e09cb036bec5b6bd9c06cf0a5949eb7b3d298839a3b9a3094ca6a8753b7a9482c111661fdad078a0c7fd6ff8a95e47e7a74b9ee199523f28562ee457ff577b1da06ff9d35e71427b3f43dedfff6d86fee293e12bd8a11e84d4e318f43f696d4be3bc149d1109e38cec5c07c1cd92655c73edd1811b3f2b4c3b2a73b6039f46d146c5b844923d1bd0bb1fc7d99f59f75b53e856fbf7075068de6059a77771e7628ec768df272a379704329ea7c257f770d0ca63c8d2e0a17757dc69882f3415c6d121eaf6f3350779cb08e6aef4fd3073588417c1c76a6841a002f72c9c0fc296b8656d5daffcb8772c82b22e5526ae85051bcb592ddfe805d8c7f161ab933da6d3685daaf0d88544424c47ffc226b1455b9fc8772b6cf385af260d815435fd8a621f1b0c84b6e8f6e6a7f34fa621c2dab0ebc71011aee97f6eda54d24eb63c512dd8bd0e011f9a87d315ff6651134e47ba6c098786c97e9a76c601ae8114a583bd316632fcec20729d6edcd7c4fc9222e148d6e0673b8e9e2749417e076d9db7763793d3d38a029b85c170ee0f054567fa08a78f2d7c3682c13581b2ed8b9e12d19972f360458b5f0bc2dadd909e01864b801b211af1d527d6cf52af5b9a92e3b1ec5463b68a4eeff134f538c00dcf05b9b97005f2b3562435c27c3d6dbaaa4d89baf06af0ceba8e368e3f3af03466c567b8dce647f9780001a87e2d089b0f59f670b902929fb4481c2ac3eae01576d769778ba3482b6a86ff55d2a40a9ed2035a0f5830688928314e9aa9d74f8e7c308ba9ff7b2ada2e615416172004f25bedca32bc00890be258fcf29da46c039a5787c9fa1873a5936954d2d2ab46fcd389cd19cb1b264037a9f41f899eeec8ffeff59a53b9bb30f02be36de93a9e1f42e4d19ebe0d09763c79d8b1ce0d1cf16065cc1cdbdcf3a1d6ff3a8396f2b8fcacf1a952b8a4a2791a8f1368deb63b71219ba7c7c5a333115e748dae87350d6dda45afa270bb33ea8394d28666338a39e206c029e68c60c443f01b72d368a09bcb43eac45b8b0eb8f5d47fc895e70f70d8eb51a66faf6322ee9d2b25dec107a4dd0b25c1e469dc893bea5139513ccf673561b86b915bf1d826b8d943a709ab4c181e3092f0a1c781c833341495dd61a4d0b49a1dc9a60ecce88a6fdae5a69d19eea5b4882db50fc3b52d8c1571cde5c56826bb4d14b1bb3f63a1f2963f71865c608324bcdcc212db83206e8061fbfa63e6e5b120e7509f671d16093a2d857e59aa6f6fef1da348f7184cb8020784f934a5cb852db22bc2c6b575264a491b58cf193a02849a3d09b2bf98f0ed49d500ec800f731f559743801d48902348acde5d2ce58aa210c51a82e93b09fd2bba26092e994dc418aa1339edb99af9b515d8a511c8cb3fd574b51b5f497fa3a1fcc52c3b3dc379baa82491dfe3c996c425270e87c145024f865b71a32a3d052d7e2ad1081a7cc6d1214d8b921c748d460a2e2e026c0d9342f7ba497207fc9f7ec1d2a2f37455412215588947742274d13c8f5ed6b7aa87380917b4e3d199855d466411cc5bd3c3c9f6eb6b0c7be75f8fc7d3611f82583c6cf7b4f0156026cd57fb2529f8d1f0b455fda8cca8faf59214a9dcd51f2b5ce52050515994673fe7309e4823666bf94a0588eff032fa34adbf9e8a9b0b1d865f437fa9a3d2400b49c4f53a75cd5eec84a570785fc38002e9bce5bb022227e752b20e4b045cbb0cb04b015ddc9e1668654c5e975ca6f7eed36b29d1be7b4e1232c684321c738624e23ab96bb4ffff2540e47cbcf1bc50af3d3bf21a982d4a66c98350690d9e320f1b1d3a2880cdf48f9e21acf9085d901004e9623f00716e1e780a166a4ef02189d0d4f2d85cb2925c556de901fc4c150a13078792fe12ab839d816c3affd609f00b377c83fc3453fcceccf497215677ab76a547806876cc87a4de90ba1c96d8683d893578122c0a486dd75f717a6276a17c84ccb00c142bc03726b5218cb6b17f624b3b6b7ec101e6bc2af913b0752cccf5bf54af5093f7f0fc616aee19130a8d9c39e4e48e06b894bab6b04aa5f39c55e50922ee7cadeeffb9e73edae16acc4b8bbb8488d3cc4bfd99ab2fb1340a2eeac6864f28c4371591c287316858ad202f03be72cd1a17f2498abb1668d51a90af14965dabfafc4e87f36e31da721f5634b197b0a76fd11ae11309fea94faf3bdb76e9d64a8dcd2d54fb160d21bf69aff564af20938ed08eb99d4ec1201dccce9acae84ba0c6f94d7eec9dca5a8a2c50f0c5d7801c67f055d0aec4f5f01781a69d7b85f258bf9d086b0a4200d013fa71698e412f3b8179033b82ac2761d1f51cf9280d383d72498b6802da6408e0593db204aab1bb537671cd14266d0d3bb67311cc6530f65ecf211485fc069e31c07c6e22df3fee1333bf9d9137be9c8f9487f668efa4c698b87408387c7272a3629c7064d8ecc14eda08771990d8bda62f2ad6d55ae1e963781c9a265831e1190f2192182f6ce66723bb40c29a9379db3306f2a26f812333e85226d660bb878ccdc4d058abf0df86c71ef3ca4421e7168382bba7f30af28f514e320eac7bc5a0a20bdd368e5d9ada98390feedd325e054df2fac170e5f46be98738be398f5f0fcbecc178ab48fd5c886373fb0e97e3235daef2ea73e30533c6ba7b0175b5be8aaaf4e51656e4dd16ad7b1f24873aa579f8b1b642f74f8b1d2e41d82853fd96411963db317b907870684b47e94ce1681e44313903fc4bb7a5fe301a7fab652ba20a4b4d1e72ada184ab05e2d8ea658d09f874db5f7ac02e38e6e3a67d547fb979403f38fc21644d975c812d12e101e48551b23b3f67096e812e1b9afa6eeffe473fad83d8d9295e03bdf9fcb60eff2d54f4ae4a0fd236c9e88ed6ed8e25b05ebc8193136ce0cfef7f75595ebbb67bc95a44a5f8f10c436504ee0fff736a19398059ff59fe9d43139df04a0021e73755b0f0068efa5c3e45d43559d24331afa4b49933f507201756e7e70c8283f515c6d7979553de58065d8f8b8807e926bff76abea06280c31cc2636721ce43e0192619fe3c58c93a57cb52d7f8acf8549e84f46217a19476d332932ef29a99e79d2d01fa0337cbc5e03aab44f629efc80f7a7a472043ab239248b566d652515aee2ef105e22c3b70754183d8e6633ce98d8822edf2ea20fa17e90ab07054132abea1c252a2dde698110490dc6be0a0b4573a4c9117fe21ffc19af0aaf6a64f476d4bb1f2b4e2f7587c6874c351f386f8e390f7e47c0e63ba8dbcd8b4c7305992952c799be5a92d292244b1d3700f718c666b0d558f6da0e494f1268f20ee954eb980c840812ac31e6f00323a1592acf2b0023f8af4f95d513b5e14a3fd59e86381cf9c7b5c897bb4664626e366060f85bd6b10f1fa797fc1815e950a460908190af748215484ce341f9808e3c9c6c210aa35baf0e79194ca3852855443d1811c884ac6881ba2c1d0390f12f43caca24457e21dee06c26016bda167f49aa2c5aa0de766d9cd71d06a9b95fd1bff1d7d349ca1eaac6bb019b8316f102a2d07d341e14bfa5cccad48ab4adc3d0b5d180992dc343d04ebbc3603b2fd4b6f0a4a959b904cf7739cc3fa2e44fa85bf76e2990870cf68155c8b8ed4d15dce7e8bdb988018f01e23ad3eb4ac6341fe28d6b758e0055018a19f57a411d5c4700ca0ca6b240fc9d5fca9e30c249c727ed142e699659fb153db30d450e64361ea8815fdc880b0c9f4c3c976b12716dee2a49aa59869ed83e27decb2b3ded090157e796d5520d4afcc0bb2347c8f2f21f71915bb063c15c11326f22ebf8fb7b33c300fb324ad0a9a88d015bed54633f15c10d865b66b698fef19482c360423931a1ff2292be1a6dfe99d873cb06ad4e6883404bc05c97c1e11898b7310e63049c8da563c711ae437203a07a894aaf9aaa08cafbd8e7bee77c3441c814a1355b01dd7628aadc38d563c5dab521535c6ec03bb87cb7f47190e865824e9a790581ff99a08e40dc793387c1ebd5ae0223c88f28fe082ccd32c50342f62a100266621c3bf81b350fde0a5d6d4d27b20976b2f7a5114563c4a0b22a9b4e73f02866c699a2c3970542f60507c5d6b339f3477434f128e2688484441dfebc34803bfef72fc091372f4d655cfa8277eb29b9d3dcaa242b0e6b08a45d9a4fb09d65e3a26f5f08a747ef87bcb9c601bfe2087346b874a5909befb05d0b8b84eb77d62e458f9f3188da18b622dc7a5d612acf6ee53633bcf5a09058b106586960c28bcdf5e2808e09a6672f5cd01852ae80d9158d683cc87416ade561046aafbf644ca88c65a0a635668b54712aee8fd7fd638b316b431b7a95242d6fab2d1c6ae0c0271f5066eddca3d61e01ddf2525eb8dbdd3b5be00ea7a52fe783e7d7b39182f807e9037b43fd0dd2376911f0e8897a143e9d659e3f6acafc43f53a5cdebc6deac4c401bed195dfc9336b25134a3156b9facabce47a0bcf57a65ccc54b39bbabdaba731dec868656258242b6e03d7a58af0e59923effbe5f449c481ebd645df91ddd1913c1c7f694bf5ddaa66d6919409a81f5aa482fa58940b22462c81d32697b542ea0ca1a1c38cc845fc8713dfbb2d78671f16d9e5e67c40076213738ba52524ed89d6cdf8ce6d25934e7d20da7328c5691a5dcb5dd5c9bd3fe4b01b16faad266737b012c14a89b9581e57e0b9aa2f5e8df700e72f49648b0b2452f9ec2d1821b5b10e42851f107ced37a0b65db944cbfd854d762457b063d9ffd9704b1a25249106c9b467ad5707480da2a950ef7d12499bf5f75c83a94624f500baae0efbca51353b1cad089eaa72afb28e1ecabbda2c1d9b3081c43560d1b34537010bf4e1f6b22ba9564cb4f4bf164c495dc0620113dccd27a1c93572eeb4aeea01a929c83b282a54f6e7360832cea0d7fb05ff8a4d0758d7b1d9d690bb5a981b71105fa9b9d87e05ceab88c23bfccb0179003f4b704722a2432b0b813718ffef77282d997574a0d4bd815b20ee19d018561922de60a78ec218fbab1654269cdfa4b12f3659203ff49806f7611be01057e4ae9aea4ccb692398b0efac65c456a6b59445b343a1fd6148ad9dadf3d4a90bf42041fa1da4b5e08cd68bdd9eda01de0134eedb94dca93928026708eee8fb4eed869c6938ae586eedcf482d8086408a0082f6b1ece316970edc53d318d279b654de5d2c710bef64f1c5a11532a99a839b10cff6038b34db1cf6520d78565bf361824d952796e79878284dba96e6f83350d710723d9d9f4c7c66039b9cad586e696ee5dc704fd47ad14d34849b1cb0500b2ad686f84a3eca01020d615562177c81a2b4a73fa7677b809ccd3216366ab22f5519b9fbcd38bbd7c24db655505c0b74b3c75122a56284566744b27d44ea705349759953f941413bd266caebebb46e11c4884088807b153af5da58485776b537788862732b4d429b69cf47471b97098d978069bf569bc02f1e660d7145396ca80bf6657af114ee83857f2e0baa98af45bc3f7f6a841c3807dfef31672b99ca33106e10d73be85d870a5ea0529a4c23b92cfa36701d937d023af08b0b29ea3136c2e65cb8a21f6986a37a6269599269b05296111fd8a8111de69f32e01338c3164b322b6b4177773b8e594b6c85a09e6ea3fb8122b485ec7043c7742707a242fa05e22a666eca0de60f33d1f8cad85842d8bb15682261b8af26d1e769208c280fdf550332a2220e916b0375211a422096d690a0f48abf0e144afdabf7e1da5a5b922c2ddc6ade1715f16c5c13380c041de3c478ef03344f1590952979c6f515bef41e6dc7ac7dadcf4888305889da8c8c6dd2b0a637e28a48ee4835aaab2d2304e18e6a7afdd668c2573a048a0586944425a940d3f267aec35dae97ce1fd20b195b6977fd6f4ac7e7876486bd18737d977969b881f339b63159cb8277c5e92ee5c226ed103e67c19ac088bea4c230dc10367cf0e817a9c578c382ce8d1c0cdc842a5eda6fce09a0fd6d9431a4db372a986fdad33287dcb20d3a3efba23554697dca948773d4573b97e65416669c49aaea77da1f28d2e42604280dcc6ef780b15ffd6880d48ec3d6ebcf1066346044b8a66cdba70ef69c431c6e3f448021e7312e3c75884bed6107169957f54d6b760d1aa84c674af8828c1c69ab7c2b92b559b4b5eef8dc0dc6fba0411b874cba6d1f6dc52ecb99ac857b6b5e31272d685c517642dacf0f9efd0818e431e5228a8b89b68c90bacd40dc6e5688213b0abbf749da4175d701edf3add44b6dba17c0dd98e8b1046b079df5196d223c6108d67c712103e012f6afdaf4f9636187bebd6365b468250a4b1df3b2f0048685108fd35c8c56a2119977bbdcf6a87548f878396bb55ba2add77067eff805ed9fcff5a98294de2e34f1c2e8c6e89a17de1ab8ca7eb151a785ca35971b4d30c1170388ad038eac40fd964c67cb779c9ed3d9a3e20665cbe389272958108f70c1f634ecca0f950acbe6f59d7c190389d3620639859df014b67955761d47e91f1539f1a96e8df9fb27d280705a3d3b4594f386ec01028662024910a710f1d213301a1d4b59a2e2a8176cb9b736ffc69bd1e23f046b940b9928fe6a03411ed8399d3d2385dc101a7d983b27d71ecb8b76cda5abd322403bb4f00d07d8c97efc804d0245b3a572c5a04aac37b12dbda063cbcc47293a32515a8957816e6782a2251795eb0a6e8544f1a5725079a17c13ad80942655252f46291838d58eb60447b479489b6080b2d84138b9908cce6851e81ab59fb8188664ad49248a8fab6242657b73999d2552f7fefae73c3fc3998d8dc2fcb730a54c862a320b64d59a41f7d5e84f095b142a1eb50789ce266fc50105245cc58327d3f55c6e930fb989287bf6c66b22aaae6b36ff3f8cedf03927947035696539e0cbe411235bd5113e9126159ac003bd3fb8801657e4b7e249ec4b753ef4a774e3efb4a602cb23741b56d4d7314f5ec37e5a580d16a5c139d45e241e154c81b6307f8ba722b8df6461f03111f8c8467be0d747fd69677a9f5808d0359e134d7b95c6829ed881be050a6884f0b4131b99ce2f3403a5d49020307273c27af08232758a54bb65a66d950e5adcf0970bf54f5d3939377c3e740d5449f5129c0ab2ff925c015ccb97bd6da99000729f5d13c5d646022b83f1b51cc844a96ef6e2a9408d086dc352f05f43ce9c266374524804c76f9d116cb92a2480e657e6ca21d07395eadbfbeb17e13c24faa532790e60e6e7b84c7947cf19d932f02ed1edefbe70ebea37809e6dcca45cef3d76babf72705ab2de628df2faaee4ce83096fb0913777d1a83e907aaf2aa609eefbdc227211c9aa579baf626598be05e008d45389dfe292e2ea16fe960d719bbca3d4dbf42b3aae06794741b55eefca6363eae94547bf72f5d27ad7eab2687ce90db2ed7b4274793c757437c4ea80f36620b0612af10f0f1c2413426e9c1389a5b05d773b026cdaa0eb0ebe34e70a5f0343c8b57d77ed35de30f705dcef92bae0ce45b217f79dc24d8365aa7eaa0ac113acf21e577e451f1d53b9ba87566c0d7e01e12d3175188b89e7a23400464ad0d5bd1a9bad31549b17758d612528f8c8ea39f3b0e656babb48edc0ed4fd49918b9b75d4e8b128305d176c6975616ae7e9ebe4a1c1b94382300804ac552dccbe498efab4144ff88f368808ba9f0c65606dd0d25f4b9cf0cae5c9917f5b811e53a1c086db4db890d1c91d326af99784e63c2147ac8a1658f93f1c98b1b7f1ffd0f34c595ef4af67fd439e9eaf13190cb663b4d60eb4f6e94a62fe92ed17917dd913801403dbd3502d09b2b9bf119f40c7768fb9c88880d049ddce85b6453023824de7d36685211de48906fafdaf941f83fb89ed6f348ae491dc51fcaa3ed56f7228dee56242d5699918aa82e032a71e9090c2d1353c146e9366c9f2dd50009d3893085317304311b0cf2b223861f4b19787931409c5e3049a907d7c28de3f17db3e239badbcaf9d69c95011e0914816207f409f2bee5527d1293cbbf189e6bac6a99c41e2a1641bf89d1444c779cbc01104d5fb2dbd20d766e952cfccd0fc015eb5bfb8803f869319ed04cf913a421e4e1a580a04bc6acf5433f7d7f14ed0ac7255d65a3f1dbf6ff85158d9c5428e6543f95319658abfdad0c353462a7a61e066ad7dbd347955dde633eb1731ea443140bef8fd3da2e263ceda49d2b1871f807590d4992f0c26934c3a5146e013d1911d18131d90aed5d342e71ee4febd185c3595142f3d4256532ab9ceb9b549d38ec7b1f684dcccf599cec73d6f32e95dd44a5362f15407e1130031ccb9865ffd4bbba1d8df418b78784929f33c7591a0b90275f5d6ec125b0b491a0ceb133b002164eb00fbdc481511402f76709536be35d91ee32919c3733a8a86137d48490670ed088744d7102dbed34ad25e207122b987886e9ecea2fe4ce47c1979a7e532cb25a045cb967544de0d375657a00cd79d1411b36e825fe5389f7337391a508b60db8eb798032708bd591efc03eed1560a896051559b9a805057eccc74196e278eace9c7fe0e7b3012fbb2ba6f1e196e2c1403f378ce1163ba1039d92fbb804c18cfece55ad753171f49fe1c562437349b34a3521531cf1e05d6c359f988bfb1a8609aab1ebc0985b3489428b9714291bc45114545b60ede6219f956e6d5b9be767260d639ef8509da10d956470b10b5bc02dfadae88bdc30def82270c702e50aabef99cc49b5f7428779d0ab6e4fe2b0ad136a85c6f5adf65ef287e6f7cecdfce1d019329eb147fc41fff4907b23ba41be3e5aeb49dfa023c64aa1b9ef0b6f39e2f6942c3d72e254916c561241b5eb60182bc7aeef14a39f7a0ecca9545341706fe742b1ef5c6c930e6d126d587e20a6821adfe27f5519cc1a76582128b084e07c38f0f693d40c4ba5e5bd27f5161f23742a2738183325556cba0c75fb2c7cff6aa3e2772b0fa7c5807bc4f22e16d41efc62acedd5346683796d32317db9032aa58d1b62f702450cb6890c4614d06313237a109f8fa0ef97b08b021b927122ad607a49bfcf34227b4a7f6604f5d52ffa2750f27adcea6ef29c3f5cbbf2773bc69181e7a49fe5ce024dee23462802675e3ac8c52b9dd9c70b8b09994921a0fea96ebad8d2c5de7b4c8344751ea559cd802b62e3f3675196de96147ae35949f04c15da9ff41271a4ab7eb564fe86a0a4a8f2fd87bab8abfe4a406796811c955791b094dc7d03175f8e8953ef96e56d7995ed4f1dea1dba38054907d249afaca7850c890b4a7fc358b62c3d9b41d9097f9f55d1235084fb8ee05eeac4a3af50923e15e3ac4b67611be2616f2749a4424a3fe0ea3020a6cf5fe9b243a53a7366236b910a3240f2d1d9da81b5ade76526e67eb02d94d117363055d63f111139e1f47ef7fb2eae82750de09a89e94623e792dbacca500906a230aaacbbb3d23ca01d055e0f553e933907c80faa175868176a6d82559d38f7b905eae29602048b5f171679d1bd78d538c22c5f9ad7b8b6d0ef4f25679ced07be569791bb39757e724289ad6a8b7661995e7eaa4d38402878e4fcb0476353757a078c3021d511667188ab7f522d2d442367941d42d1bc6fb5fbb2e09160a41d0fbabdd61e9b862a13f5a7bd980194dff93765e8230e104f855c52fec8957e7823625d3322c93edf980bb128c4baab3e7aa2e6eb709dd3d9ba875e25f0ccb470526e122d6c905b54b75dc29f2ca0180aaf0b160d45f412ee29bcec9172aa4d2ce7facbf37b28c2eb14eb3ef96070592db546cbdad548df308168a1c0e6851ff717a9ac8cc804bc45db21e68c000524c054d15797af235c7095e5bbd6832ce237b718248c80fa9092a3d9077e6240b3c6a80874c0f24f37841bbab9af58c33e6c053e17b88eaaff510dab7c5cb3b40037df1c1f966d30af556da388529f952c53a9287a5f12661bca0cad5701b79711ee0ff96d87a7b0532a31649f65a662e2d4d203db7312dd1317c69f81051aa7b7d1974d34386e8e429f01ff12d2a52be1a444d884c74053e39e8424135adb09ae5d85f490ee0dd547eeb861e4acb0fa13f192f2b5d72ebf75893bfd7ecd70b2b8c41425575834690aba8475b658566038c86dad7d7c91e1fab228c1b6f7a783effbe875e03e012fc6f5986f29ac9f970f3fd99da83879305da65c118ad4181dc6b435d74dc6ff44eacbf57449297d86f3e48a3a40a4cb1b67ceb093a90e52703da21821ff4dc5539511cf10dd3d2ef99b7919353c6d2ef0cfb1e74a724c5ff3b248ca2aed00a984de92a33766743e9322efde355561d65303dc8fdaab35789a4d609a2fb44625aaac5f9b1ba40806ef767b6ab7c07da47d89cce8302c80977f9e313e0522f1076e2b4f84738d19fb84c5c71ea60a3cb6829ed308a88a972d3bb97d2042e2489dc9a718baf628a255f0c8675423d42188bd9474d926aef467f478ded67ae6cd37e3393ac432821272cc85dc612c80847e4ba9659cef285939e84ad1c7389c03da339ebbfad7122346ccfbd1328374132f2a15675911b0e8e303731319aa6ab76e6549d639fb55112018fa8c9fb8655b66ff5dc28e6fb5c5c3162d5fce5b8d7d0bb77d700f47c641128b59067d7731e248d4a9364571e55ed4e0b699ba62e60dd17d03acfd4a027390880e2eb3dda1401ba7d1b1878a8e74dc096f2a9e7d4243c7fe7dec803bec17d4a35817987483f112fb21c5793fe02c9d30ca0ace9ea46d2505617f0e86f1cd32007efb521254756cda034c5f644d173095838e4916e210c66617924a3544f17342bb200f4bcb4ebe383b78347816f237998e68ce0890dad51e53699bff53cb65c030e6c3e97f94fae8c618c299561d696fc50f3a6edf4be277e0914936bf10a7d336d68857877e8c207e8c0ff72b9551c123ac367a90cd4dd0ebfba1f26fba777b302c3b36d4fbb0c73c33c210f0d82564fd9ecb85f9f2a195224568b6152742eb95905bac461f1a6040a4497d6065adafd071d99e6da4ad81135643ed814d811b0de4433167e47ed8c557b1cba3020d4feab4840f36dc99bb58d72265db024edc117714802033c00eef19e230ec2701133c5117fadb01970b254d216d8605e96cb259793127d25a480e94ab8791f821b2be11ae3b4075174267bfb8e1ada23647da30470acc8c2d393a842be6743836e4f728b79098eff494bf6249bf1f33c10cd081c6604c48f315ff2d563bc0b3d88f71d8ff4d53ea3e91f3f8cafb6ece0497806eff88a693176fe0f13a8d3e2bf2526f427651b7e9f2a033bdfc092e40caedd871e7c29f40010bc2c8e574fc8501b4619f524870f609ceba5387f2c26557d82eed2d810e55a993c0a08a15bbb0db39422054fb8e091afd4b004482f8da37999f25ba9ddd4ef045a6d75f90a5d5719db3c3014a50bb94a2dc17105ddcb87c50bfa9964992287c47274ce4943499dad3056584b3cfe3ca53d6342c4c3a6dfd8311a121555a62590f9c092fd3a79453b7d4c9744f5c3a75eb39b7420e84bdbded64dc155cca3b7d687543dcf57b0ce356fdf86db8fed113f01c12db53471d408ae14c81ea1d13056d7903894352cca8e1e0ff580c94de17e429e6e4a6d021799532b9573edd71c4cd63f5789cdc9bb3ac464c7985d079b935e9cffe4fe07b06eb4ce5cdb389fde6bf3cb34407fcef9df58715e4ef68976f870e7067a14043b0c49eeaf77b7a548a87f38f5af3a11ea593394d3af5e023d5730ba0b0f131338ca2f86f5091e6db0089a8de1da98e88532d847e9b70bb32be17a85fc24b7929e883dc5b416653e599c3433281684fac94e2e2065ab740b380918f1d1d71150a43c7458d2d54e694f302239116c364b6b099c546a3e52bad6a6f410d0f0e957611eb506717645523827ad77ef89f65a338a6d464516f5cb6552b6fbbb67ae4b3514ca7b4005f3d9440c94681400d90825296270c4db78fe9208ac9e6e0fae690ebfee7094fc1915a6356317e71070e27bdcbdb922337476bf6a1ba1f1753f883d3da03efceb40a57a14baf51b078ee38f2455c1364f0064256c1b43255c179abc173758be95f19b1376f767a594449fa3514b63b65bbb2c0a5b56e8e1ecaecced7ad2c5acd816855a47827cc5447a8f7954ef96ff752279f979952f6b66e961d7526014a2b46799c95e28cfae07271bb942cdd2e76c7307e080a50c17ca3ff2beb89059dbec2d17289dc35c57bcbc88aa602243cf23315c79bdfe56044d7d2f07d0bebba1f0082fe38c81dccf1c6a97e4c428baf3029ac2fc28a12f1e8f0f15ba797e9dcef9f91592e96a333fd18b03995be4b8361eba61b883550201b2b3159c7f1bc3c8443e9cd5d92a53c5b54ed802c7e6b13055ece5229b0b7d6a0b0538c3df8b7b0f38a77990a65f92c654613ab576205b45d9ad41a5e0b75ace4522b4b3f63697d268046b0840f98e33ba94c1e56149031d531b4207df0d181a2f847be132231cf9738c1927ab5810e5a5c85b93fdb08de743db445d2c177e8d11ce6362249aafcb8826bcc59510b5af339c8f643c1a38aedaad310de82c27fe4579a5032388c8b9813ebaa307e3ff040e6d257822716c985065492021e7e2d771b01bfbadc4c6fad6aafe2aefbac2e9a4954f58001fcbfe8fff4d9b7cdda9ac8844c20720c2df92aa0f97f7dcd345a4330fd12c4b24892615c90885d425e92a0698057aef589f0b0a1bcdf10d58b4bba435627f39f49e4ac76ee0159ef5583e7b8aa0b76f94d4f5605ee97c69c6d5c05e16209263ccd505fc98623afc7743a05a5a012ae25bde5e462bfb38e48ce0b287f400c8217d123e960f781a6dbd9e5abe09408334e9c2bcbd8b380cb0bff874d1ba1c8021557c5343f70c70f0711a6831ccdfc8a7f04e6da0c5139e651e6ce40f271cd0685df056f03dc7752710d0e347760c13ded4ac72826c69e2f74dad8f8909b07ca695b5a41c337621819b17ee3f6e76073a240ef452b3dd8d1ac92f003f8c73d6755f6baaa5a0fa0030ed47d4edc42d70f22b6138fd618f4c7ea4503b7505886c938b15f9ce04768d2e88fc4278a0d01b7ac5b10a38534bf6176ef18822a65c364f7ca8c2e3750e1b6a9029c123a5c6aba263ac8f078a92e62880fe908e78e0c317f0a2ebe14f7f366628e6b3f0d1669b818d7dac9b7ee7af2c99e975a4661fa61fbe5a6ef2a703cd791380b594f5da1d1be50dccf77a370b140c3ea28bfa609465a98ada06e2bca49bc07b48dc06780b6a4f0bdd5d2ada6c8911b35c59d9a82462d9983fceb8ba6084d8cd3d2c88402d698a669b93f54e5861ff3ca24afdb8fa05e766d1e678efadf287d4a982dfe33bbae501baa9087960a94a5f75a9db87496497ae0221157593021727bf6ec0fd7ff3682fbccbaf4efa7b925009d97d3a683e4df1ca0dc96076e95e384d183de7b430bca3bae7610a89f4fe6078fd1d5d57ac0232c076149f89367cc033dec07cef45778629344f087fe4a35305717c247708dd5278d47e9938f3d1b96d8016f5f8b42bc6b91016577ce8992ef4ac63c47417b66abed29980e8ce13133f9b8c3f7a396b28f2c083337592d772b9f0525d0a0978c4a80ab09d6ae9c3a0b9d3b45caf406e6bbff436503a0c063e3cae066c10e9aeeee006a9ffaf9bc0eda0fc293a308b4e70ffeca548c85ca93cacc79f784a09ccb3ce405d7e36bb17209bd37032f9bc08e314246204e00717a5b5aff6273b373ecbd55600554ba7c83707394066033492386cccd933cfc398da893be1f77ae87ecdc14591de4f2824127d61cbd39e14a5335ac39c8c85a32a5e871aaf4b369dc444484afa51138159d0c3aa56e6106f818c853a7966997d9b19acb46aebe2ee9b1daf8513fce1bfe6086c1270a428db5dd3bcf2ee67cd09cd7bd9779e8f7f5b86a3764e310bf75b31b0f63b5740575a2282fa143fc38d0a19014ce3b1dc7fad7799e75e84bcdc96aeed1e06d8a871c87b99127ffa38c4408278f6bab867e0729e5cd1c14c20ae238569146bd129e838210155b02e7918c4a9ecfbf89669cd93f8e318bcf7be20e6f1e12caf5f09bd55f4b7a52e4ea43c777c8fd62627090e4b60da3a9e3d82199e05e6c64815524c821a20d6b61d2fd9db1d64b1d8f58a6a3477fc7fa29014421684efdd055ab55bc859ab4ba7bd0e8e1cf9d014e6e183a9abf5b26a37ae519814128c97f6c09b4f3c3625570be7ce32a1ffc63c390089f0e4266834081f378fddaf5da45d009eab13e9aad2b92096a45191db620005451a3d135cc5374ea8989fce9a45f117e51d83d41455824994593b0a581163eaf98c9f27a48d8c087851ed6421a6699f744645b9c8f9dfb798a490d719e5b87e5bde5f6fd99c0541181e43bd0afb4c78232d15b356f7ba19aadc4d70b7cb7dbe4a867680c9cfa5e9f4be0044cd49587ed058d98eaa82a249b8b3d35480558d916ddc2c5b2a0cbcf613100a6a2f6f4a12c045b91c04a643aa49e6394098d8e98c7f0403275f111123855d50c44ea0e0a1c4228f13464efe292205976d667ffd745cd1b13197728df45c6c4efe7c3ff478de6f452adc2b60fe0f1958b0cb013da9beaa1c41f1276b8ca7be00e0757030ebba3c144d3eb466471397e7beccb21558f82bca1bc3f4da749ffc5af5dfdf9baf6fe21c2ab0431949b889b9c40ce0340fdee29c6116eb4bdd88f34098ff656498df5441667d61b51acb34c782bab63c887f5f782249a51ee0447a2b89bcc0f53e42476d74f739744f270f294622ff9d651674abe16ca23740b5f2caa18dafec7aee13fddaae3217c58b82a87c30d02c643089a5cbd12f2d799dd3bee1a1f4790493dd2f534693e66ef8ae52482ae03025fd55095964371258c4e714032ae9cb42af6a31f70739b205288872279630cd3f95c35a46c230a6bceb44787111cfc3d2bfc5b813867ccdb7e0fdfcc7acec3c13894894fc6c28fad95ab411e07654fb11efbf1f716ed1e6a74dd1ceb332e0ca6bae8d2de20ff47e01aed4097e5c0655810aba65a84605bb8186d454ffc5908e457059a6004f3bc75076fa095ddde69af1da64af2429f84aa7825ed8052a3c8a4713948c63f638e0797ee169cda91e83d3651b15ff4a089aa13fcf34a99471877f2d6f42d5b0e862841dffbced61fb039eb9b7ca851704571f624c6f5e669e574cb872ea8bf85656db16690df3541dc949d67fef9776e1e238858b3fc2faea6a6653f405f00d74b83f23c12e4831c0fefa7209c3807f9b47caef72ae7b70e563efdbb780126e86d26419dca0a6a82279ed5ff58471cc44e29840328d40ecd883a5c7194606302a401ecb4f6e8f711af8f2d8a3ddabde4bb00256649e4cc8209ee078413bbe166d609a868eb2b075cc53486e345f2a94ca6b8ea6e540205fc943b6d06848b30eac6fef0d67e993b4d612dd35c3d13238022baa99636a022842cb32bd881d0e0bd15525567c806ba60d87a7008b0e948020db519984ebc75ac9e7a4f5348697743616757291e2346995b7cbc709840c65b1da0bb6e35bbf06c9df45854a3b8e5516629dbc9e23fda321a98e66de23732fad2d73523764f6b3bca9a3d7ee8c3b6e6cffe84289f92d04cf9c6b2114b6000c4ce6e08adf34fc1a8b044fe9d4279bbd505004fa2cd2aee60a79c6eb38ef893bd4acc4f74485487521f32e71548ddb49eea540bbf65077b82ee99c8d25cf426cbc7c448d92aaf675a63625d25398ad7a92eaee212901ec869873b2b169d1cd556f65482501efabcdb17891f02abb4925d081c72ee9a5c87b6fa554f0ab940ac7f15b7953b756d3076cff741b15856afc3fb38dccb24af23460351a0e8f50462958314af6569a9b5f54d1af12b2693d1cc67e594c4493dd86ae0b7c5ebc1702d2ffec4d4aaa77b21e699d9a655918b9d516b34db90697e077dfa6e26c798a39024a4d728600c86582be59d5c641c4b1844581834b4d168907fd38a687ccd84db323c8b0377feb8bf9cf68a16b4220a85ca88c9d0d550e2d578ff004d6256b3b2d35ca47559726c15ab81406946ef103c8fd5d4a382193cde0b6732516c2aba77b970020e975bf7b8f2268019a7cade1254b805e23d713fc0178c64a65f3cab75c9a93b8230d904547b0dcae2e6ed7f0ab4dbd9026b67db737fb2da6a9871d8b575e5eeaa3b188af752700e2bddbedec40bb3e6aadf75a88982eafe2a22dc16978b605f822d5aa293be9308a94052bd4578ee80ea8714998e0a2e3a9e9b4145c3ba4e632146f07a9d1f5ba8808556bcc4920d9dde35fecb5a9d63276b420c686fd28c936627421213f8828e72da93b651657edd483d7d6307a53a61f4422cb6cc2d246255750f451f1a5e0ff0d41ea92861577ede937dd212ab97190eefa65a2c58974d42a0ab08575d334f6262ccbd7842be73bc9a2b9552b29d6a7d5cd7de926a52921647bd33b33f70cdb8b096361559686dbbb4ac84637b94bea1e6cea6c86d06fa49e00416859dc8f522a2cfdb24487979c20ab6cba385feecd63c2ee69a24f7312463a7b83f98291a8d094f1b431c6b02317c4f5335ab73265d870eab63aeed142e16b8321dee44465d058958e614e04eb436d38300ddb8b79988ba4559505e8d58c9f656d22eee64b6a9d19de188e009ec1d4bade8dd320919403dc1614486bb2e91e7557cc73c8818d9dc3c8b9aab4677073ba754a43904d7dc10e1dfcfaa153873f7788454316095cb5bb227547f1f82a5501fe162da081b4d312053465d04078b6e2c9e8bdf632f271a9eda11fe99e2a6a1cf449959f9e9f76d750dd9f3d52e5fe2c94c2a891a1f26a8d0ca4431578c83cccea3dcd3e2c68f43473a65270e2d80adfa921a59b5c46ad14eaed6d866bbbe2870dead083d543a33c7c23ccd0010783de500e2d52a8655d2537945d21d541e726abc5e1dbc2dd8367f0c37f202d9ab853c912e17597bfface8fa39fa2139ff6d7772208835855414d9fc526f7d8c554a11c67f878f763d9430f5641b223f71c241ca3c82cb193ae642cd0ef68bcda88eadad5e20f78fe22603f9c72faa10721a35e5c7d7e0af9fedae912d0611ac8cbf49f8b4975f79b4d836a58be4506a285f9b6ef7d119d31aee98a68fab61b2b4bbd1e89f7bd414b622e31c652d240ffde211b82ea3db27c55a04f2305b59afa5c23be597f0900175ce4e0f32409cd659bd088de96bd330bdc1bc4eeed1b4e4d1f41be481d5967b0b1975993e57357c06ef80a7f3b8d4c8c91b6ef06064b0421cbd2457be24b12dce80e0e267faae429bbe36669cdd7a7816e4762212bcfeee3a69bc41f32db5f42f938a142d3dbb1bc8899ef3d756c395fdee7f736a215d7e6dc354a907c4145c38a7f092ba0c35a1ea799e4c061f7c6913ff1e71621e3815ac9a04546e5fe9ec90cba169b92552881aa09252bf50befb8f2f78771d54abdcd170709545069d24b9f0afac4a8659192d8aa5d53322a8345d157df994f92c218c19951af59d999fa967328ffb0a502022e6d6d3e9996e8e8967fc8a6f053dbe67e0aadeb9c01c5af47a3870b23bb6f51f56c28dc58101e02a69086a602cbb0911659402d859fb6184e035ebda3f3b8a04383a7dae96ad593360d2f4341c4cb52d3936f96a51e8072868c4efd8e07a9dc4412b93a1efead149e4f216b68182d6af57f12a164432ec117bf21c846dd16a72f88784ce62787f36dc07922d28960d787e3eb08345185b67a452cc28f3fe62032fa753ef4826e94abb756ef6d998b5494cc9101597685b7ca92d0db3ff58fd4ffd4f1e06140bc3291aed57f32053a1c51cf1335222485842fe2a12d8f62df46275f90c5b93c8f9a7346e470d4dad7cc1d79eb3e229e1d1be208eb8492ea1779ffbcc4de837598965bc396b6de22f28933f4e417f0469dd3a1b045c5df099147a2ba894ad4d348c15322a2259c8edeb26ea03aeb40aca1f7733ca108eccc532c9176f65385fb1fb275461e0bea5e20be607414dd542583b2ee78d102628ba2e6ebea2777392c8186390dda8df7f152fc96f6b2c47ba1dfd308a5c825a1874e4166ab4f00b1acdeb054f0e9226a509b4afdb05f97aff8920666b14a03ef25d4ad4e898cf890ddac17adeff5a01f26c0953924e7dffcdfd7f8ad2bf6971d96d06b7c796261694dbdeb03bcfb49b0bd4008f521f1a03a4cac1b5ad1fbfa5396001fcc0233fe36c6c395c27afa6b38e7ac604a363a09a04131ffe29aff9be708bb2d59353520bde96ad0e1f78a5f42c638ed7e4b1922080b858cc1c0314203c43d5b8caa80a642439ce7b4683f5d6dd3e26c3618e0ded0ce967555baf6a5c186cf2610391bccf158f4cafbdbf313d32c7715c2874bee89b6e705ce3dc9ec4bd19cb22ce419f36204301060bbd013909fbaecb80d5be21122f0656d16207ffae8da30979e8f21bb4f2c6b435fc07ecdbdae06ebab85744b08809fb8d2188967487d4b310bc58cb6a7ddfe0da0da5bd2ffe568dd329d18e706697b1a7d40025c12af2093d7f30d9957b288139eea4664ff3d262503849b710b9f3a9a88dab4f4a4147e13d5167948c12daa8fa6ae850aa8b05039ca442c533f0822824ba6c6d0682c41d0f50b339cd74a62e2ec28030a99c50c12769024bbf90e4d5948d444e52825adcbc36ba9b5e016c181359965dfcc15a1cce83ec87e7c7433b8015f9dc9795633112268790534659e5e03719337e56a1967ae222fcfac2fb442f74fcdfecaab42f6aa22d9013f33f7f0fd23a525599042967b7b268f5d306febe27c864f5d7200932f566dd53b2e5c235279405187886556954d358ca695b995f1f67414638fadf664e534bc2b5abf692fd96a0ae9b1eccd19e34ad37c6aba9e82448adede26dfe7330def6f60c35249fc4ffd1dd4524fd30c8439675a9831bd6b0bfe0a9719c06a0bcb290c1c9469567618c16afbc09cae498a0ffe8f59a776b3636ba82a9658f61b6da98b7d751694ac0e44c1e15f2f3dfc7eaad64066f293c1ae02df8ee3fcf01cc2b3a9f7c13ad4c418d0cb2e5caa64ccb93b97b6cddb0a61ae17051f41114fba9f7564c7afcc5e486ffec5bc805737bee6b1a6c06be80f69fe2fd53b8793871120de60b342ed8793147e4984bf7135393036622761e5a40b48336f4cbff21aa05bb129edfa5bcfef8c77535539f38e54e91569b93ec8b207848c5b63b455b002fd25fd09720709d1ed934b399bf73aea8297458409e20109cf2d255ca924bcc19233766fbfcd5d4e76d8aa3bbd517c1e3cf58594ac32eec32ba23aaaf6ebbd576c0ebe6d95f5df1d420dbbb9e18a95dcbde5fb2ae7331323afb72676afdc7774e77d72b02481db84ff454da4de011805cfedb560fa09b30e60ac6bf57bde9e90f627ef8913d547d7a6767f4e53c7f339094b4c7a925a8e9ed1c7861db409f38a2e4310bfb65d746636aa0f56756002b56eb0baa00919e3c3b8283dcf91e4fd2db49d696676fbe63d2cee710af698edffb6c3f7d0d4fc4d19c0c7e5c958335075fcaca31ebd93aa8b2e7837d011c9995edecbea3eccd404fcb8398827418c17897c7a09c55b0d868ef3d5cd56d1bc4ce54f31f6a14e073a19994624597e9294108dd6bb5bea340872e6e33d7befe29ccf644fe6b8cb4e267ad86cdba3bc3600b22a2a22d7a097c0cc9ac58499823384f1ca61a685d84e9f173436d7b7e0299caaa02984cfc5bc86b22f3fc8d3453576fc3dc349d1706ddccf7f014614316959d3a98a22cf6b7ac617787e49b6bd0f27e3677b03eb57637da893dae9baf3333a7bd9c8b9a48ebe2fd492c5cb1669321301463463af42efadc7bcff9b5b5f4626b488fa133837b27ccafa0d577f7a2d2d411f63e716023b9526b47027b8485a5b7303e21fed7c3c27dd532adae445df4360294cfd0d327e8260bab654ba768ee38256c2a627db6d0b2530fddd4245d34fb017d5a953964afd63408c514980a33a4ddcd6d6ae3ebc94bb3816b4168013ecffaa4d1e4ac9d8fcf496bac8d87ba1920385b28a8f67ce4a93274de126dc1b4f4caa57979ad8ad001c277d8876d505f759c34e169d8415663155c3c256e0be2b24a0baa32829efde874726c95c1907985f8a7a48dbc3c15582c6f24bd710ba991820eb08e28cf99c12ec4bcba741c60f0cd772437091b3d6ca88c9ce37ead3d36fad35775d7ccec7297af649e99794915028727f2637fc6991d6bfcae4cc14731c9482b7691b148040cd724955fc6f3b17ee62f18ea7224df0b9d7e18025eb432eca26fb509caa1165a26a2a92afb2c1c9b91089caa12c6dc4bdd2a48dafe83d3f8951a32499fe89fd8d4506ee14ae8e7f6492a92ded7b8e5da0d09ef4c51ca2d1e505d917d8d9d0b218c8d52ff753a14736fb2422b48d53ce522e9ee74576c0a5f04f0aacecaffda224bf8f6916474ea6d02c7458bb32bcf4102e5d6817851180cedc92a3982ea64f41acf5bcf370e302357330c2cf4d6f7ac75e5276e177b5c9da8fccd15e4cbb4c86b424bd933937ed89373f02d0599a7c14e714c62905ea5cad64134f885bb71b2f17041f130b4ee5286bb59a673f74431d5137ea2db7382da84f6b831f30327993ea913e007324960482b64622ef224039aa70977edcedfad2c81a74cbaac89032cd063036e39e84b6a618dc34b849e8e30a42ed6dd3d1aa7b7245cd87276ceec48d1c0db323a1fe8e35154c0450e01a70aa215d61fa118c2c0e57d0b8f73035282289151ad1adeb5e3be40ff6f82ff6143d88fdcaf36034c824be9e24d2972dab919fdb1355b9491836e2ca9e446d2761b7a6938633c47af195ee90de50413d9c441de3c8561d36b8a5d9f846a021769e219f89761771555bd0d2d999337f7dc179ae5c38eb3abaaf4d99b898ee6a0c607a0d36b48a9f2b4732e3eacb625b090d42d67f9171cef90efc4e90b9bb70db50bb29a09deb55b7960cb047c221c370ff6cb5cf4732cb7c247c54459fbf12b23a6065306a632b17c20e2d085837a4e72d4d483bf57fe2dfa273a35c1d5ae3ebcb584f9fc31470e1a8fe96f06a873a38c5429e1d21b036c0c46061d14e22c1677398adc90375856d61d6bb7f589de27dc0c1bf6bb72e879158fb16a2b35bb3d13adcfe1ea928edbf285be20c14b58329f0f9da93e2721856b56c5b0fdaaf15fd554798b3a70e7778d7f11b5849d31d16dc28a93dac453a7dbb9906c91503d27f27620238db136ac39d51157b5ac3b2c892e1803ef2353e4b32fd940de0ad04db58aa350dee69af49a82807b2baa8b9309a53c0c1aa4d0d57db3ef1b0984ab54afe451bb2ac8365f01f564d61416aef0d896d8c3f530142216906818d249a1fe1a9dd97e8a9a448c2490abe2b9481d6bdbd02d8c209da5e0b196296b8975a11f246f3d2efd70295c370e76248b26a4b979a97fc8430f45c5538cf26673e920d4c4a2599800d30c16e1bdf97f1032ae3217dd4519e0f86898c508928892c394b0502d790f18e6afbdaa8302ed8ce08e3cd6b4376e3a0688ecabc3a08249a93edf81880d1ddc754dc79b736b848c3d75ec9c067730c75f763d2ebc2fdfcbdb03a12774ff985411c72c93acf6511d58e14b4d162255cf772e8b16833cca80acca7e2bdcde590a07f49fcd9c60d1e2b24c77bdbebaab205b2d2047c70ba34de695936ce519bb26ccc7cd489b60231a69e3694ecdf3b48aa77407e24c2eea7744195bb12a8e503ce433d9b0d50884eea31f5b01e19b320a0850215af1b3d0741d0bdf506b372ba3df546d5064e8358f7d4e4160a1f0373688e848e963b793a1c9b7d6c3ee52fbff45df5abadf1f38029c63d63c85b39a742afc22581e3a6d03735650e9ef2b881a87d6708cd8cb7880f61dec4539fda3958933aefc470085d6503e5cd60cd99948c51766707545d043c0d72554d36ee2af4aa23f22e40fc6421dafa2c02a063627f097e6bd2cb639580a0306f45f907334548a4b866ad37fd5db8b865759b84140bb98dd88bf6b3d76d5bd521e009178d3aa78d6a9b7fea81f2cd79d2ce601433a6b72b94bdc18879906e6e2f4a46bc38a7cbfe9578769826ac96d8e78ab77363d1efac9fe8189d448fa9342d545bb2650277be9aaa8669aaae9018857db08b1a884efd596928b7d1a96f0ac7c762192ae4063f5c1092822125a5df79949c6396683d476b7a923f7237c70f63610665055aa719027d9f438a2f87aa4ff718f8f948011aa3ebd8fce9eca31d8115b3e12e8491d5c0b6a214e31b2678dc750dafd450e994ad42ebc217f963c8a06c2389c00b0068a6158488b9ad179d8d18c69564f5b2119ca78628f7f66d7a8bbedecea7079924294ed36f6c355c1a9e6bd75d882e183c68e966f5a345ccf494d91776af6963f730b518b5f14b917cc9fc9b7d8bc0dbd6b4614042c2ff0ddc8da83c124cbd20d3eecf0f2b9e7c0e82084f1c479caf4ff26fc7775c307ccdea79f9bc1938bd59ba88367df99ecd2cf9c3a00700a7a4b0b6a9dab2b097d2514467cc33c7b910d2d60c7f70c7e21df00c0870c50a65611db6b31725afac274e6bc5d1ca495fac17c217010e51d79b7b7e3bf44640d9140385240512e0b5378dc5f95a2184359567a8bae00cf98e2c78c1a63822abe77f956d2936d7c641ab7f0fcb65cf6d3d54239c688ee8ec34b7dbb6b5080b0f3229cc6d1ee8e1c7439e027310cea81e570b2a89660a85ac09ea8d0c1c6f2e06665045664f32bc438c13c7aaff08066503e11d26e4afb9f4716eac866a931641c4a5ecf89881f2b10cda1db79725707ba66826b1f7c0d8306964bf62f27b8b9a54227de996fa1b8722092b8897f2f9d5a5aa370d450afc09c58e51f2646beebda316025902a2b92d424b212caefe1a7cc48edc21dc065fef49fb932acfa0b011077afa60fb4fe250f7d53a1d2ac09144cc3650b50efff78ba8cac26f165065f672744fdf4dfcfd4b6865b7f8319b0246b554985234552ae1af59a95aba5162c195632dac189625a24f64aad737f1f9e11653e65bc21cd97d54af233568f628a700aab9e83f06112fc67c2187594d7f0a29edce8c56757e5979437f858cf02d1953100110b24f2e74643f0dd6a77b60c07db939661f8d9bfc48288998288a7c83144066c4910bb74ec9648402e9300b282fb4ac81eac78eb648232b474bc678635451af8386c33975003deb0b0cf41254a1297116638ae1aff7b4f1f331be4cbcbdf2eeaa754686f1676d63b2db46917b6e89d41a4f434c201d8db15167d3835307c2c17b29dbf2555bee7224c8d1e6d51887ca7d4d20d1c274b39ab009812ada95f78c67d52e789f18ee4ae8a4b448e63ec9dea1ffdb3434f3b8a0cc50407cfbc713e876d65d54d1043da270e02bc9fc5544b8e6ccc04e86cc037607b45fe6e10f7bcc330a69bce2d91b8020517bd73b3efad109aae0421c373c263d6e652173262cccd52c8767e472c75c0fd50ca50c6b8256afa981a29cd3aa9c00879e3f682b55ec60a36343b987d5429c06572afdfe6a3af43ec802cb82d2964929c00c1350b7364d85246a0d99d3580aa2be95a2aeb5863f5eb247eb726d088b00103868d6fbbed86327c44381f5d354061970dc1201408ea4754c53db82e086089284f8d82942bc0f5f511051fd9c3f17c1427c52cbfe5b9d3879646371dc373e417bea16530f1439c6603f405a462b6d01dcaef39224616c99bb3f985b369d8f78d81029cb7194c8fb11c808a9f7c34d7022de596ca950965d56b1b38b856a1cd20d8fac03b780445c46b6d194e63cde363012dd55f36f723d3a2bff55e351d560cd1b46a7bab851a9b1a1dfdbdecbb2f75b1a7aa7d58cd3c645f74b8d865bdb062f5a8ce9de03c000ad252f178787ea98ec9ee9a548af63ee52b58b3720acbffea9339f248c68ce914e1522beb7e1a7dbe1d95c525b9124d9e31e12a5a0382fe502a3c4e786a3b4c288ab8cdaa65f4922305b8a4ca48306ee79561866a04bc507fa4c537ff15470a1b4e9c3b0961af4564c498234665096f56e1292578a19c747b4559e43e1c3da359abf2565d7afee9b05ead28698fd9c2d8cdc98dd2d63fc4bc81847ed51a1db9a5992397ff98490328e58d5a076a2c91390df91ec4c2b93632232f720459b2324e8c9bf34387c3896a208ca8197a5bb41ae4a46c6854363186699ba670d7c68d4fb959935c8e82954623ee7e31d2a7b5e7a4434f893492bea8fcec4e6ec923b6888854b4d62a888ae276021fe9e45d01047f466343d94263adc5d8e309ae83741f0ee788b361bbd49decd7dc5809ef02b76a7aa867c4a0c44d5e2b6ffef742c428d878da9dc32865c7e79ded8c96b58f2d2847c51f88bb286f069d531dfa9d82bdefab882f48cee9e51a06f797c46725a99fba38f69ea1c151a33f0a309fc905577a8f1b68de525ff570a8d01bd69506478aa5d7fd6fef2db111b34d8251e514e2965329e8a495f540ec50960f8132c26c730da1971471cf04161ac6be06123de3f864ba986034be833095e9ebffd431a0b77ef21e3a791479b3f8391e06b0ac6e9295b2f3dcacb1fb7fa7fad1f2c93291d01c68d838f6bfd5a85f1094608b28861180083dbdaf290a1c5fe8ecb2f1f91ae2f65393db474dd5baa69685d7ff80300001b177b974c3716e34edabffb051a612b4f44fa1c9ddd742e3729c3f160132cc6de8a850e0208773f15e20bc54204cd8a956b3df04d338648ca013029ad9c5976b704010c820d65cce8792fdad8fb679623990127cb9aefd97f15485e9b3a47e8f5eb29272a27b32585a066b99a21d21c412703ae82061450f9c5f002e43440eb3eb8177550852b36e8582cc7a8c8632b2a642ba1d4375a1459514fdd12835d86dadc370b793b3b4c30ebb5259a8c5de38025b06d05908b55067167f74c6f3e82b891d916917adffcb513fa9c06f8aa33904d7cdf46216a41d9062881c57c0e658c24ab3be895c24c3024db1516096c718949d02141d9e11df34933e53c3f67a1400df55f66259ef0c6fb75315c9bbfeb92cc81cfe6d712bf3e69c9bbd8c48c133d9fb2cd4df17371857acd38b34be2e7e53192750c339c158a4661dbeae3752657c2444af1a3f4cbec1a615aea2ef183eee66b35c66519c47949a1cce98490e93172b6e8b4765a4673375ed49a78d00a3f75915457e92ee3b7e8aae40355cbfe75a39dc50a3560b05b939f7a210cc9b0772ed1967a7a49502b31c648390c4b854490554cc83f05ac3a459d83cc54ce58800094d23743e706b54b3a1fa157291dc50286c48dd59db291929f7fd6ee9d26a542bec017b1a1fcd6f9dfbc7d9c84e688bccbf5266129859c9b4bbfe10cc3491d63c576195e241d02cbd7ef7ad1ca609d01b4c949554e18cbb7a74baee017f88d3f1211fa16055ce661f1a00dd7e2645cf751044715c299b3487b31bc136899b735517d29a3e24447979c561d006bab10b1e2e9e1fb2e1c1911aad438ac98dfbac684264fc51b3b9c07435d5c1911e9af0e67b646198be5b4173f2174d93f498b383fd4f77922f6c3b0b269dbaf0fcb37ff15c57fa96ba5b32d38f8617e3517ab555ce3bc76ca748b778aa2df64efa769ee08dbea9d1165b39594dff0a1180256cade90e73bd0e1e2967f365bf3698f3e35f2094644e39b4a21265a0121a31dff15e53dbe51960518146bbbccd0880030222f341d41575a442877234c33b0b2e14ad6c7061cb83c2f6e30acafe9b9c00e67b8491a03889a282914399d46aea5f6f20c4b101d485c081b7828b0e381a033c6ab827d2a6e8cde5cc2e169280b7309ad7b42cbccdb99a4eed4ff6e6d3e99e6e67687ea6744c9c83bb7c5eac2fd586acaa4589dd3d63fa9f4215b5f98441d316080561fdeef7dc19752e01ddabe07092aa31f5d294951296e9bae1d7b6c593760301f85756cbe59bc5515154a9713d271f60f556d1e195ea59d63804da14c43b1e64ba1634d0c82af71807701c55fa015b2fce7dc618b85cd1f6fa821baca3e59b10ff2f3dfac52576870d0bf6703163a7f17070a6e51628173280a4b065e7860cbd10617e5f2025948732976a329625fc61a0e4d1048eb781f6a87e1084fe13c9ac17a2a37e45bd8f52ea7cf7230822ad98ac98f3f86ce132ca29b2f6d10a6a3026c5079455902e83168299c5bfec1f8e7fc374642eb22642ddbdd2faf146d944e8f0756b8278760e297dd8e4dd20072d513d0a9758a9222d1e8f2875c990eaff630198d0b40e6f857fb2e96b70424bb8cab68dd071e248c32c6247fc75bc58bf198214a741c0f9df72cc13fb72e59fd5023dddfe5707c57ee3a36ddbfec27d5f4bf138efdfc08c45e4204baa4d5f9e06fd2649e8a20dda386010d55334dd2079ae7a9b3d5f36c6053176924ae22b1cdeb8b754e2348cd687fafe51e8b21dc52420b818389621b2a0f14a9dfc87cf9bbe41917c4a51f0b51411ad13165a663581747e64001252654b9f2d6df114a8bf62c3882596f40ce0cd149256bb4fb3827095d248abce313e3177af99819b13f03037f746982c2fe96009793f7089aa583bcda4ca752fabb5db81c6ce9b9867dafa7466a321e4613bc412c2c64878dfa102f2928e2382aca1bd648e4aa8b959d3b1b109503cbd5324c7a27670250528a2a02970a6f1e42689dba8e8b5dfae5c2eb200048ec6a88e16a78051ebefbc213833656b29c678acf2aee83564ce5b98c3576ef2fb691d5ae808dd3e2e4e3ce5890978a754078e3b59638e88b8870ffa20ceadf0cdde62e9227d6a8b82aee7e00b29286f37ed3f40e5496a9985b48681a599bd2904ff2ccf21510f05321059cb70d188322055d29e97ee2294ba79b7f394ccbc45d9565ead307524407d479557dbca547f796e40fc9e6f7dbb37d30d5bd1c8f4a4b786470d0d01a1558552669042761a216ac8d96c91f06e0d4ced41fbce2cce7de547e7f10e1a4c41a1b36fcb289bfc7591b9d2c060d997b218521189679ff148415995e67538f899e6d6973929e03ddea0b41855d6a0c1690e858ca13363af32a8bb40a8efeb3549351a568e6dc17828e9d9003d2c68b044c0bd22ac2e7b7a292d699df96d5892282ade20bee7489c83c183d3c9023ef3a00d65b20ca11762c2b3dab19f500683b190a9794a3c1e1f093917fadec0fb54742a27028d772b6fd0762d1f293d6dcb637b3b773dbc1cb6c109d65f0f3427ee3124a0a60e559d01e3c42fcaeeecda73ab0c86f628f40e86db52b427ba2670c5fa20484cb04f60cef7329b637e00ca600e2566aa18aa0f7265aff56edbc0e1fb2c78b918781462b5e336d140a570a85af61de0a2b7e355ee69b8030d13ac31c7b8dfb709553d2ae83c27cce80216d01f9ec391a91031353c3b59d1445d91d91bd0c1a2052c901cffb84564dc58b7ee0c5e907b71c9fb6d006dadbfa77ecbaa622cb4fd1845e13222d350bbdd0dd51c8fb8918fd77686fc4b3e72d1d3432dc90d71603e3499bb8f25c7eb7ffbf0586a51aab5736db401864af1feafcc6e659fb60f386530329072404a98ee415e872d1152d209e82f0c84e60fbae7b856546890ed437e2eaec1eddcda000176ccc4c609d889d60bac318c5f6184f651ba19d089ea84b9a7059016b90be74cbd50787b4755d686acf79aa0c0fd64ecb678fcbe06dec29c23f2bc59d8fc57c73f8695c84f106e7dd93f11c76cb0a3d70a276c1b5ffccf43854b981a33d6da036969174c764b320b38c38a4dcd8925d93100422a5ef0bd54a5511866087f5b0c73d435d95661ebafbce3f981eecb41c36fc7d2ab529cb1060efb982b6fc7c1dbd36fda8660dd43bedf5f55d87691e0e31bb091584b6c5614293d9c757616ede638d9dc1d9870facd441b74a17a676fc19093e50eabf22f1620b52b84336838014cfcd1237e21ed7feff856f7a3a84f2b26098c5704c71c98d9ed132643f5af071d2fd6fb2581cd1b349fb9dea9020b3ea36762f96b6e329358119dda1f02ed94a47ca6244b5bc93787ceb8bc35f34e83e735de189315b6b40214f2d226540fb94b3e2fcd6176e1e8458c62adeb1f41bc17cc2df01c4f887e765430c9c50f6e47486086e78efe3dbb9e3efcbd0f72df0eb3d832b6a31b41e1b19702f66e91c1012e8044d3e613fbbdad0423a2112fc0422fccf6d0e5a124d995b92cf86548ce9fa6bb2307a14ab4951d3d03cadfe260ccc7e471f1b47d9f1fc1ed4f5ee77c9ed8baa013c38a35c3b96f190b58ade3238105ad7df9787b354bba5ef808e7d100cd7ae3089127935e4f4556b6ca2043c59219e1f311e1e9942b4a24ee9deafdb9f5d740bd589ffea839fe11f4d50c36f951332ea11ee334b1fb03fc27ecfc8214a94a1aa7ce3f26fb94cfd4cecf0b7959ef6de2c05997f828447cc116d62f283939023db58be8904a235e21276e6228ea6c42225cc77d02630ffea48bbf90533f4f27e73f656f1b5de6cc4a70ebe75e2f1f6870aebfa830d231a624f63815c157a7680b1a13ece752a7512e4d8abc728845f1568630ffc5e36f4042c4e25579c84cdf01f4090612756c3fe77225c8da293a1c3e099f496ab9e7d9663f39d7421fcbd753c48503df8f5041ce296344a37cf6f06c2ce7753b4a3ba0f87aaf152d2bf52ed118ffb8c6386569f4d7c6b92a2b27d8d031e051fda985a8247fe94cd3bb9e224825970c49bda9674b39d8fa729883592bbb26dce47a52285a996a11db7ac83b8e66e00179cd877f98495fd1dd6481dc2e2e4f4759264982de6459f2ab019eb39936dae9680013fc393f821aa71cb3de9638b331887996427e2e8cf22fe785f65ef0e8e592c1e5abd76a2d1f08efe3ba3e719176c792fa485a370ca9e9f23ea4d755d4c6c1458cd13bad85c5e4e4bbd655ccfa221c39555604f66b42e9f2381eac5a3bedadcc653c05b979993d0f1bae8b73aba6867d5eefef09cb3e8dd5e5570aea9360eb06cf00a578e617e8513b4fa0f267c5596124f1e85ddec38f16493f033b719e872efa1956e9589c081c73dcef5aaa365dc52692952ad3e4a2f470ab61a467427125bfb1fac0cb5c792ce46d0af9993d11e8f76d44fe78e1d56a5b0e528c061cb5fa45bf312d7dc4ef5d60da313650646f2b9dbaecb16972ce3f991d5d513679f58b239ed271b962aab8f67292bec1f5a7c969b68a66ade09677b670ec0fb844420a13e97f1699ea71fdf3a1126a79657e041563ca1a04f4ade5e065bb292d95038d0bbf9d8722555cac75ea650f025dd988272c6426bcc8f947c21ff8bf26ffd43f392d2f870aeef1e817b6676dfa959507ef09f521f0519427624c2a3d90c0fe6b4ea2036f482bce8fa44492356392f4231f8c58bfc504cb46861288c98db34807d99412d1d4351fa21072f25d15a67f9b1959939feb9db131ae71657847a3366ff255f9302602c1b1f30f591b400815f8346855e80528771bb8c2cfff4693442e92f0fd9e3d548bd3fb9a5773bbfb8d4f3826aacdaf7d052d11c72421be80ec7bfd36734bce361c266b32642c1177b5ed73170138457b3509d0466e52f264a2ab67dcc72cf44d56d1093b7d33c743ac64c082c28305e289dcd75dcfc54a86bcc0d77479b1f9df359fb2321a57cbad41262c6ae60d5bcc1ef65b459243ba8f621ba0fdaa379fac79129628531d7e4822362b0872e1c4778311aa50a18949ec2ef144a0c8f3f47255a4062dbccb6c46d11849a5ab9a33b99c261af6d8a52d117406aa087fc10668d81db5352c2e71faa6385672d1ee89484d847b52c50e72004fe9c750b7856844aacbe97ccadc541b26650be8f4d4d84fea295387c6ed5d1cfe9e7f1352c2ec123c3156b286951793d281df81270f03fb93984afe57e7d87c1d822f4ce4104f40704b0c61022d48b09f9217968b4ead7aa8e1e48052ea367fd264bede601fb7cd400b6fd6045c1d176f91ca510e57626e84980ee50711ae15fe3cf21b2924d3f6e78d24f0bdd545b83a259f82be2cefe3e80aebffaea050e66252934c065e4dba4e6b8d6a1eb9e40488d96bfc469abdf7aa67508bb16db752f00204aae9b587756feeec957c70b5c201528079b1acd25acb33e40a9bc9a055e4e7bc5450999d8b29a2615d767d9bca0ff7ded6c95c10393415a8c5ab971433b58a8a847c0bb48ef74fdf1bbecf835e1de4f3fbc8d0f0cab21269738eca4b536c492276447828a906d35c411e7dfc45e4d205f0d000907831762cb8eb37de48c5e50a84a08da57a1dd3add9a666fb89e199a1d483a049ac4c9c0e0050c25cc1f6b7f695764e60ba6ca1e33419e2e7890cf226d9b21d116a5aa100ec30c0a26026625bc06ba5472b6f652d2e322b33b7815c4e508d600ffa2c772bd91f0166560c9851da7196aada643fa1d464c32b3ca52c4f83611dc73f50fc259d907f77cba3c1b82e9ce41e9e7b82641f9e96ca380606e397b2f73768f83bffc144cdf44de847466938630eca62c0fe6d5d3e14e4a84d77cfb61bfa712ded0a88c57c1d3d9c84dbd8b94fe233d47e29cda039f08a7c4972ef5ef6f088efceefad1e66d47c3fd188d550265e0da5b42910a3b0d40cac14884c56af1a933b1c7229d34526a93283118a33dbaf5852a06bd74fbe00787650765c4a22237824d54437b8c04d9888951de0f02f86fe2556aa2da27fa056c4c60020892dd064976d6d8b1bbb9b4e3b866116f3cc4196972ad5b2c38388a336f179ae1509cd165a4a3204c9ce9a99c4d64f1279a83180e02f226275c34c67e08df19b145bf176566fea7a7b194e24ed2806ef92092046a0419e5577929121ea721dc1735b60d30bcd13e9ba8edc4da3ac389f8947fbcfc76824d0d5397ffb4fb993d96256aada20b9def9686bb273e3ffcbd39dc839d456a5d1b67fe9b6ba3b694c09d646852bec19e685e2457acf352c67167893dbf760fcfb87c9762a976f9695118bcb28968490b7a878d6be26a991408668c9d4a49cc4afe40a62f2c9e32d114eb2a161df86ca1e339ef00f415b8fdbd6dfdab5d540db2eeef0eb2689a38469320c480d8089a8d409851ce980cecac5b3adc73a0a9fbe3dc4355a35205eb4a392d1fdc391641e82fa89afd79b2f518a3f1fb6477a305890e1b06f81cbc5137953d1b36f4ffa8f821f66a3d8b24c84845329caa301722bfab63903d64b74e70e48f8d8ae527c3d5fa22d1f9c70fc0e7f3426ce65e8a530a6ff126c533e444b4ade2578ac171aebc49b969ba4782ea251eaedf760067ed137a2f4684b16b34d53937e1b7726beb8cd5445dc99b1f71c9c5b414fd50c926f51d45a09772ba4520ed5258379279a0718ac1e224f934cf529058be99f33b4da42fcd331737cb74e3f2efdabb0e77b0497e8bc8da17f50ef4ec3029ac8f2da13478f1a8c37c787647ab7d5317a2f1943f59ef861f2bb49978590e67f53096b172756818063b7b11c79414c8225b25637aa1309e005459f36b333601cde327e4a82ca45821596638e0de8049d9bfda4c8f4ee0cc575570b310bd5f75b057b2eb1b50e111a28841d969963f09b93ad31adc3b07035861e1309c7d08c7fab78339bacf7371e8f1bd13dd18426372bc71f9f3e6b1da2f2f8720ce68d2a8f0f53c31c8db5eae3a6129b93a1277b615d408180b8e7c39e8c56a4de3d6f0c18847cfe37da1a0b3bcdbc450286cda0a843fa3fa3a942d8d5c17fa1a7507b1975e1e4a9bf7de669930edfacbcc66750bd0e71decc8b34a735598f9d3228e365998dcd31af473c465b38e4f22c5defc10107e332d7af3cdd4c49e13fc6b545a69a62b3bf8c0f15c9da23333b1281b88757bc12baa2965102f253dd00cc660000c8b66972b93b16c22bb6c94ff7ad0aab6c65370b4d921f37d899d5bfd5b4c1f86686e78dabb23a93b80ebf4412cdc280dddbde2f08c22a153149f7c73c01c1f6aa7ea20a13a48e5ac6ef80fb140638957031a9e534e8a1dcd714d4cb4e811f17a1293757122d2e219fd89ad85100a8466676a6b0bb647c907c7c2783eaffc90c13d8ecd5158b51ee147677c9fe33beaf5e9d04cf9c0205b8cca18a142ade08b9c16ea9ac204d549e4dba97bf09ed25653e94b14bd694bf39a4b715d25548c5bf46ec9a2aba683c2b97da25ed3d8a385639b123431fded241b8d80791ef72d411633e5dba71365830206d9ed6f6b13f13f058e2d6751eed30e58ea2989e45cbbccbaf9eca0590b5930efab610d82085fd7b95461442c631099caa2e5b72e57e4a29dd6c497776d6c19f9a57932f2add4b516ef31029e406e3a2cca8bbe4601932bd4a95aceecf745a5b861280dc90f78465d33f60ae1e3f00de8a11f5a3e887978694eabf76e9979a263264a1fbe86065ae3a54bce1db60791446b1adb4f4bf264f639053087af7c358b817352f64648072d8283f863b5486611e5e3b6f2f67b39157969fb9ea8421de23735e75b4a675177cb452537962c2fe77aea80a9d5fc6e9d7d3ec307edfaf26f1a88629bc4e43e6d4b44ba251a57ac5fb44868d00f41771972c8c1727264d0b5a5e5abc25c4c39cf738fcbdc019074d3343641747926aadbfd6da29320734fdc1d5176e810ed707a85f98b94bbe1a4bf111cd48a9bb3c32179ddbac9c769f7af7b215352dd7e61027a858c6dd8382b0064c8614dcc58b570ddafcaa917e7c2c61fa8c2461838ffeeb8af6500b9584742dfceb296c761db54aa7b7a35c4258e119c801090e08f080728b17440c8e4b40caa82cd114b0c79cfc5b6b0c993c519e79a8c9aa5237ee7f39c00d51014d132afb724c05148cf4e0c7ea8cb47a711c8984e46e9708d7c7519e3e63f030e4eba23c45b050c9093396534672ac72078ace4171152f54daf4e314996ea1cbc5a94eda19ea4309a61817583c04f8e2ecb0e1c745de5e1e379192bf243d9fd0c8329a149d909bcebbcbe635597ecfc69bf5740d4eeb7bcdcbb41c79677d2343a242287e90bedf8fcd6663d4bd223a09e1a707839b1bdee60f593fe81495f671c2ff107f1bc6914b94501296d45e831f600fbd3be8a47f2b1d6bc8ab9e99d9273dab2513f8322c58fd1e3e66cece0463151be980b8ffb95acefcff65e79a70363504de48dcb54ea145c7b2d41105c90ef1325bac76beb03f54505bb140236ff09646b80281c96c72e7fcfe2564f6a7f54b76484fbe338a7b2ce433a8ac088926c6f4c022467c6ea7df10af073ccf4cdc6023665e185f91f5e02e9207fc3209618978c5860f69f859b803048b81d81627542d6c444e0fbee4d5b189e81a8505d9818b2f3fa80880a77c1aa602a2bd92c53a5508039f642b12b7b6654c7b7040a0f0f6bc32de51ac13a882e8d720072e052dd9d944e7f87498ec170b05f710092c49fb396f63e54a1e38d2d32c6913044fb61c419bc3a4c8a61aa192cb4fa922c368f56b187ec1df326d21422458f8e89f8ddc078cbf2bb97b93d38a0178945a1e08c4fe6d087fd84da984399c73610a83e53b0fac23913d392b2fe602cab6d524f9bb059b50ae1a7cfe81f7c1ea4c3142d85dd66ff953b3f7f9d3f0fe5621b0759ddb3a92163937001771188cb729d5df795a9e56b7b12c3f22a145f007e45785b54d40ce2244a9487ac92570460a0ebabed3eecf03c2d453ae4092d722397ca42b74ff2fce7ec0be51d1389e849a29672816757b959b024aca390585c90d4a9e222eebda9e29d896a184773aeaa89d7d3109f3fdb76b1a2401a598611878c747fedc404caffc5892e5594fe5ecc0503a86bdf5aad574b08d25c12ee9930a0a9473af4d3934df979216bc69e3e2e0e3a590a0d1af3643553e0b7afd9eb55909d4ded7b06eeac61c172e40760f53687b0d092840a99b0ef22e64fbc7760c832920d25400d945d9dca19676627949e6c5de7e3faad87daef57173b8c3bd1856d73bcc94186b96d009fd314aec74df612069e2b852f7958f381b2f7a1d080d6a607176c599c57b004747a81bd6e715739a20d9fb44648153a089362c04c7135fb61c130910b219266cbcf3a17724bb0f2797ecdb50697865106123492765bc54b21dffeaf62a196380bf4a437498c4d3b51bc95e11ebf618597d03ec90f646d59216e40ccbef301ec4ae2c5c30c2fe4e5f92f3e22648fca71055145b2aa8ef4682741b44ffd26c71d751b5b3759c0194ab37c414aefd474093c35694366570c5bb8ec8677e2c2f151a2155cb09a03f91c1a085dad97e925e3b9173b12efcc72d1e9bc6054983652375307c84c05f65994210d34199ddb27ca2162ba87e68fb1e35672ac05746a4d3d608cf9bf35e7b90e01ad64a3d8f9ef2c0d10ed0715c088e11d8d6571471e4f02339090360ae975e46ee337a70d217cc678871100cccc0b6d9295389b966e51329a86c4825fa448e24a2416b46cb69295701444759156dafd679894a6ccfb3029d78104c951c8c8c68fbbff16e4f124cc2a4272d11012d8494e7a326ba8bab062d96b6806b55ac4cfcc52588b432b8a14828636d7b24b7e689a83624334a0e655cfbee279eb8049f3ade383c697c303613d7204aecf1c7720a188638399f97d536ddf59442ae6e3c38a4793a87dcfd47c49a12ffafb061cef27b9bdfdbc106512467c3713007530c1a063be81cfeeb0ae2d841c6d69b4aea096cfcb9eac91036a0d2b33a6d054ec12b6938d173f7b1870fd632a897a5e1ffdd51f08fff7778dd8d763c0df01a34d7f062a5f72e890b84eb92cf11d8c976aedd03e76aa0b41e4a0d390bfc06f79dc706fcb259076755f2d15b9a444d467c134a68246dc4b920f4e086b42998dd3f8121f00df60e116f49e5c2ad1267a42f8e127a45a10e4fb5d2bd74add6d74b3cdef3eb27db600c10b7679fad0a19f383b0acec81325d61f4cae0873ea58a0571c46328a73c63972f7f6719a80b62089cca507a32bdd0d0ff4537f5872bc2164c17b91551fb8155365f02368908dcdcab7c4d02676c65dc3509cc2304364ea1deb0ffa1a7904636896ff1939fcaa018748de47275d91e3ec9d313a3f045b04237efa4c4d611c7fb478d24f121079020cf1dc720304d6d3494f0e55d92cabf33b93370917393dc655e5e9f14e5a864311286540d5684961b4e6c7df5cfccf585902ad690f2c176b2aff062626172df03d4de4840185b24de3ab3db915957eb5633aea294582795d771a1101e5011624294ee2484abf3e7b56a1b222ccd2028ccbf006bffb5316f280bb14d01bdc0cbcd6613f4036e93bcb3d4252f6586304a93b801437ea435f987695179c5a35b4e43da021032a357a888d1dbfd4f4d44edbca8659b1c0471ddc4efd4e8ccc3a4f58ac4b5334881c3057f2dba0f6da2abb1c30d5dca1f4b6d5ba622b7007f49f03a868fcb2a2619684ae7cabdf870f63f99676500cc27fd805ac03323d2228f59610657978516ec8b033db83e5a34e3ed0c71b6b9369ef301620fe14198205daf7b6eff78f5f400bec9720fc24462c0d443392a635b6f8c75de73683fffecf210f6689957578af259d04eb54ea0ab99d9860e758e1caecfc58ee75d1f6351b0d6b0d4cbd325bab830d41e7be74efc9254ca0826376b2912eff986c4b954208073b646fcc3e5f067be2e1191e3948aa38c3f863962452b703c9c9972786fc72694e43abcfeae681f687c7d21826440d2a139c0032ed32452566ace32d4b095e3000db81929d17897f070e47d93e00e154ba60ba8481434d086924e17209b4d7668318ceab7e0d28f7618be305f827d745afa604b76cefb14c127457a84b06d217f2a24405719a84f3c69ff8dfe98a844d11ad7f6f6eaa9b4bb820e3487bfef2072050fb2201f46679843c442d68ab72f94fc0ef75f6b62ac4b6390a2db61e48e000d90dc74699bf6ce277e4639d1541704d6113828f39cb00c1364829b1ffcaa5caf9db5638957e3e3fb07c21ed730c990cf6c7c10d6164b6d98b2e6c4526e505b21d79d06905bcaf537743e4007e47c9f1c8a125986eb5f2007223a183db125546a5b4544dd3994d20c2d5f4e85fa7cc2a69633ccc47d46920f940a108c3e439207ba653b66d67289c00af248a8c1e69fed657934003f6525511e53b80ace6b5ba668d57b429e33c27680939d2df7f7fe5cb8f3b36b4cf5ca4c557c483c01e4f5e132d10ed54f8db1fe6109548b4dd87484fedd9660b9e37b36505188b5271137563d8d2377a1941f09866a03f4f6bb992b3ec09c33e0a762e80d488a22be26a1ed5237bedb8acce32f05e8c74567d44f92ca59838bebe21830dfa1af71e7133743ef6268924959b30376f88a30c75f63c406258ba6e046159f815dd2d07adf8d5539834cad2b830272950778e5642f900190bf56f6d409f8da761ec47c2b7ef83d1533da441aff2acde9bafb6224b2c53909bf58312d424a03757ccd37e6396a246a8abd30d524cf6d90c08b503e44f4d41e0be18be697054f6b92534dc2dcf3f650aac89cd48e32c7caa2c6f11c8a7a5ecb020c27c173acf3d555de867ebabe6623b699a6cb151beec774722f4e951182bdbfe830f66d55dd53edc8f09c97417edfd8c4de91a1e600417f267f8b3fa47212dcaeebec6d20c71a5e6a312edc1734c9bc86201bc15e41f6229705af68e29a9bd4446975d92629b8a5a37aad79154e9e74efc1274a3edf336c6ade481854d56f38316d6a6d2be2833167c5923a386282cc00dc968f9b066b5e025cd8610dbbf86e4e5c9a519e0e20f66f21b329bb2bae77096d93420a1550af181ce9d025c3f77ac1f9c4684ffe08d843d8b58c86e0623e3e674b7b3e7e9975c22406134070f2835913f78da4b5549f0f3b3b55f8730cfcc7dc64f200ab1c5884e154df0b8b79ee4d4db5dc29d35d1e9e232e01a311621e113ba118531921d166caea0cb6748054dd14ae6352e856b519be356c8e985cabec5272fd1e3a346210ddc15c646a142c4faf0057f4e9d1fdc287eb800d58be7c8bb4df041db86a983552058a158b7f8ad4d3e340c9a5f7215f0b1178c9a5749483b4e9211e51ea0be12ebf4de1ac8cefd83f7b0381b9d98f21192379ffe426d481a275ed08bf82d982b3436ea9f68aae48f3df8338f0272a6c0552aea819486d5610f22f3c962c1de76329172b88022d3d04f739dee2558fd68628557d7388ac78c2ce9141797cc8c585ce4d311c2511f15fbaff7a121b1f500f5b21b4a98fed25a34cc9c439bf9fe59e3f04bdfcdc9c24c47d4ceb4394a92fae18e99abb7f9aa2b44265096832b2a02037f48f84a1fa9c879d94be23262766f3c45eab168399316bc200691dab68c3c53ed1c169c199ac89ca6d8222bd245311d105f9a60071bea2e920789fbabe6326e05888f392165f42db4752bb74e098df6f09682d2638fcd0d4eda355f636e47232bace3f5f1d423ee3623c6d4d6875a5a703dda3dd82029d2c5961fdf775628a352fef9aa8ca1bdceb828d29c6476e66cda9c7d5e717955c7159fac14d337d4a0a6080ea27c5f67bffcd51f727a3eba048bca7078739ddcb6217b0236d4120adfba3cda17cd4602f0ed2ce4613506fdb952d9c205638c9e781daa5bca2b6d462d3b6a708a11d5afb3779e872688c43569aaff6e3aa1816bad59b5b9815c5a0612c1f0817d110615617ebdaf11c01605b34b3b667c41ec73eaefe7c3162799f346c6de1bcd3a765d3b54e18913d451f859982d30aeded8db0f0e5688088b352ff4530c520afe0493594512f2febf7b5519b91201794164ffacfb4dfbcac7039afcf10b87fa9b6156638be4b283b7388e99c38b40446c778e4502ac78441900e113e3c6a96b88372ef09f3731e06b47e0cd7ae3737140890918ad9b6787ca3e59c3c3f2c8d2e55c047f303718af28804717a108d82e80cdbbb5a26569f4a4b8003d4b6810af9ad158e077f06ea35c9dbb684b82b4429cc94467fb2462e8c7c69b56c4dcfa835821351d37b045be7db7ecdfd65f9523f9d8f34b90742be9b662765d4cea3ec0776308c53f3e1374356937a33804f498be77fbbeed216034da4ffc5aef62b443c8ede3c004e93eaa28e769c68a84b96bf59ffb1f1440883ab177021049e2bc531a1b3742be71eccc4be31e028c326799852127d9fa8ab189e208c102fc56fc486428a7e260cb84ea96073919ba0d9492604cd9c1713d07cece8f7b55c99b7d81a66ace8fdf7efd7c490355ec786df2486fc82106df9e838161c6fcba363e18b8451b23970db0bf180496cb260e5655e0cf76b31232ba44771237b27b64a1774b8d58c72a7b68148676a12418748a68ed6da6bb3b4df09784836d6164c81c738d0bcb3c802f10871442473a33b0733d85d2849d6ceea3e83b0a98b93ddf8f6d144eafa08cc969fd2d2f10ff58524812f18900da993bf2e9b5412c806871dc9ae9a7e8f897bbb9f24e58c34bccd0d261fabbb95e52d1472184b4f728bbf8f864ce4d41147e651941c5ad8e79cf677813e11c933127663a30032b3762c7e001b846cfb7c8c0f85fe8fd04c2534e42da98a9e6b89e08f8bb548bd1dfa6a65ff2e3e7027545bb935b0491b331110770c4058bf0ce5b8b3db3ecb71a3bbfc9bd772d000a5dae066c882099779e874c468c010354683f72a5bb62d1eb746f34f5e7d102e16056001a94afe2f49e14dcb56310211a12a145a00985a90bf73f0e8c012bd427f9f63e3c198147bdf11230ca9ce668483b99e0ad3e30c84f620c0113ec971913cdf86d74a24e3d32c129ef490ca3467412e21a42fbb846499fbd889c6ab1435633ef11e4fdabe728661ea902b187ebf07bf5a30071b4a6c273f4208884f3ac364cc611ab5a57708fc52780c63aa50b72f2e0277c7f5b569f8b3a708e8e11225dc538d779b8edd89973734d352bace318025c36f988741c93c5f8b855dad31b0b5f73c11b5794d3cd517ebfbd64ac666160748391b254e4ebd384f2e6e07ccc95076d384ad644807f69bd08ccb763685266e823571c09b52d4bcbd092ecf588594f27d6c135b6a941f4677275b0c40ed5bf641aeca2c0635ca355a5a07d1cec31c705a50e3a4cf43b899219ceda1bbcf044b855facad8b171ee11939f579ca61291fb286d290bd6360bf840aaaad9d641b116be5c5c4b68815b481e445a268c416a27b47ceaf6cebcaf552e39c9ad36fbdca2cdbd06b29a15d4df07f95fb1ffb31d641300867ce3e5637edc98856339297b7a1341f95a3ff2ae50f3aec03137435702d1ba2b79a0988fc88d237a5ab89727a904e6fceafdab28af89c96a838540271a2e4fdc40bd4465dedd0885a41f4d169d91fcf91c0be24792f7ca76a0a8f88f0411ff0be4d572abfb55f84d1ccb803439ae54b1962501b117ad05a74a27010df72eee89e296a543057a0fa52bdbf095f755a43ec834256b378107487067b8a2180baae98e05f3e3c27cfe652fb47cfc7c0ccf57a979533ae49983cca0d5dcf331fce4a0ace9415d095a2862463669d4efeb65109205e7c74663628ef20be3344aecffe182f2110b8763624c4815608bf72e218a174224f3f2e9f21330a43e2edd082c82aea15987a5f4d3c4ba430a4f30bad011d1c44974580ee9ccf0804afab2fea1c4bf53c0a92ea81c48401cd78c67665fa38be290ddd60db53ac60925bf6d446c99146e4fe835825971b3eebb3e9cc6f05bc425684953c8faf34a048fe69001818622150aec83a3f5dc4693420028b140b46de69a7e080f754b465eb32fc91ceb82956071125ab7c626d7466a61c415b0684bfade60dfc06997c186e2cdcf90eb761f418812338772f4a9ad8afd8a1a59be1a404c5cbf885fd9c599fedb7caccde806079f0cbc5c94968f5c9d61b2cc29ae2835beffa0f832ae0bcc72668ca75bd8cd98df2a5ce3e96494a46cc27dba26102cf3f28f3773f7cb07707593c9de364da01b3180ad086f05829b237189ba179cd4b5e01b3b16e02c16d451b0ad1784f1e18b492b466d3ff87e68ea7308b64b36b584a3178a8e951b5ae7b98bf5636e8aec917587e2437d5425d393b62053dfdc15d527547de8a938d2710def49bb6f0f136f421f15ba1e91bbbc392a63747830df42d7def8179ab4909fc0d8fc8db095a9c942965f5906bb171e4d7ecefb90f4e4f7d85e41d356e4c578e88b826242b2b8ebe896be7cee44d08d01c60a2758df29cfb1bf169516a6ddffb45ef42d60f00da9bef9ccca93306990bdd4a9df4cc667e653573fc87e9f3a7d068fce832264cf6e9f7915e1ae61abcc04e9436b2993de30a9b5f006c6ffc67409ecfbeba044c9dfb9a112dddf75234d9db7a6704c4368743635956eaef8b46c8f0c14dfa68a8f17d45e0cf834dfc35426a56cc51f3048d017ba6af3a73dcd7e4708924b29508f0d1e03c24938ff38d3cea8a549eaa6ba86b04f289b4525a8f6101a8c9ff39912e39e4d60bcc1a62075bf09dff75b060bac1ae7ed6a516d67efc4b2ac78339c0ffc26fcc527c6728f637b5b2ee6d44136fe2731b311a051953be8f6fce7a36bb3d59ee10019b9dc1645c0c79c0b16d7bac9432aee93e25ad6278629271ce5c717f08cceefa0d6ad73232a134399b1f53f4e65c0fe17642cb8d6e937b1425f56af5360d70f1f99bc74cab58d63b2ce4786ba3b6ed5dd2b9e6265f0f39049091daed402f150f198210176d0288e3e1ac4fbb112f91e53c0b4f121ae101010bc60f74713ed3abbcbb0f18fd180d77ba4f6c6cbd605dfb7c0db2c0c60e0cbe0ccb923fa2cbe5339a59754e43b45fdcfd0e27294023e3ede8a4c3a75d10c7312e7707a61155dcbaebc5069e9562dce4818332d3de31ef84fffe595bd46762942c52c64a4315f39a9ffddf47d214ffab408c918628229ac0dfb430a9726c9a6446e4b80750e0b5d615583aa60edd64826110ad2e6652d5cba12aaeb4e84dfca41c438639351e5406412969c54b40e0750c0312c065040a98cc4a70f4ee80980c53b885fb46ee693347b581c1d1bf52eeb62d4876ceb1c00a1340a75660434df82382b875b3af5b27e2afda5fc6656fe170aa09f6b38a578a18bf7d83b2eada091640ca46454cef3f0f5b96a54faa64622c30368c5e9a919feee5b81bc3d8e846c240762d56dd7e6558a9fa1a6682fa09b217ea20e7defa174cf5c619f4e6a29470dab049135d2f91c3e162b72ae133eb3d5de6256600eb919cce7f5736b1b87f426f961e27f0f8273a54754b207b7d8d49cdc8fc39ad53f13781234a5f9dc0b46c9801bfb7d5beac8886aa8d34f7c7cd60c160fcc15c7995586db63ca1c0b7da9a42e0f21d7a5f4a659617f8b5d97a4bc563d89b30a72112669c12fb6cfe5371c3b9791c28226c8ff1fa8464586c01f1d3f444baab41d23372523b935f2c36720dbe4832d0ee7a54c1a305ffabd7662acc099ca6738fa4324c6dda4239967388034de15a0a6163b71d359ab6787bc170ceb9b9e9b013ca7602ad815e356d49d44dcab39020e66c122d1339875163f47e86a580e6cb8973a6a1192ae023fcd0aa744e8ac71c86301bee9913019a8f82a8e0f5129712b967eb7715f8dbc5e1f8695cf15c9ab1ee77dc4380fbc0c4895ea3a86d5c444aac9a68754055bb4ce3ea54fa5e5b6a370b775cf46c988f9e48dd4515c6e84b846e0414e6070a1cef60c0d9c0ec161b8b9179884c4ee4ac73500556bc364dd46e8762a2067ad1b138e674c776a81cdd163baf09c1878a1be1fad4e9fd26e8b15c710aece7e981b752ff8b868e89b568b728d43cd0ad94fd560690618030be77e53e5ad704678affe7cf4df9b7f5b0f196bf6087397075188a260041cb90d06aaf2a7c56f811f95b6b51df48983e8a10cb910fab12e37d93fa095919d7fbe6d36702dfbfcac93a79a2ee8e488b23ffb2f2389893ad3f3c7e285982e8c5aa1c89fce1b18260f1a4f07e951448445863b3ab20487c19e0dbc8e3a95ae2013fb216b9d09fe11617dfa0dc6bce397f72f8f3e1dfda534da56d3d7f8acff18265d23494b0b6d897eaad37ad5e1e94a97223cf33a090daa2900a3ec87d2af8bebbaba3c9672cdb30c07e1ac6cb6a47245325331c62c6ca5fd4bec7ce78f53a9f5ab70625e839204080de1759c43a023249a3ecfe782f4d1d9c4ffbbeb2f0c21ad833729d133021d7bdc3b752e89dae29fb509062411a5bec390feef448610548ec0c2ddf69cbe290f5150129b4aac009a6aded2bbbf1f591cd47c3489c3e94b680bb1cab8b4928cfe74c4d0a89b818802d0d28685941c029ba067a5c2fd8aa4700723ea4b46d000b5e9cb9eabcdc3d20a3f6f6229b192f48fbe6f045c73d0ad136a45e1e63ff8965e5358c3d717a5f6b9cdc5237e99f3e0f49f99b99500dc5af67ba9fdf57b879339d5d796926971c2404595d055013b9b3e66df1e4785dad554ee2605b4ae8193f461f83fb68c82ceeffd66fae856ec18f327aaec8ed5543fe577dde091cc468de2f656882390e3f0d66181361c2ff02fe79b58b486dd8e70cc11efe83afb9bed17b6528cab0ac35ef88f1a6f29e1dafecb168171d8aa68776f04b0e4ec5947afc9f91da2e27ad0a2d68f16c5febfdb1dd431e5bb2b38093499cbc1b5257fd9dfcf8336d9f00c1ed9c09692828a6113a21dbe0c69ce5454150a32573276240264497efa853d090490c7f84596adb230222b742d6a225ff9d90fbc2c8d46085315e4e1943817c2e56ad9f5bdc65a56bdcfa0dc09c8e84cac230dc8b17992c528007215e651de20686b8e5056958a6632f1b9bbe697d10d1659b9eeb6aee6531e68012ede15b3dfab0a8fee859e471def3acd91d46f916b142cc6ff62a62f1f4d3638e8e96a0c1c0c09c0d0dc2186db96b2819c1877e6432e8d18548d10595531aed04e5b33f353ef9b55443c014c57466a0a05d21c71b1e0561b857e45ef43c522ca13f500c37e2ea4d55c710c924e1e41c608f60c81bb0e04069fd6e5c42a7feccb33222059fefcde7a250269a112450ae1fcbbfea32de5dd2584f8ec6256c2652518ab441cc65c06e2d2eaeb122e4799067b0ddfa5b8282904e4af7c701fc98590a56e122b1f4ab0414d9c21c1c23e997357b884f9637dfe26e9407ceb1f72dcb64e5ae3ac4ce8573c2804a07ef3e1c42866f54302e1090cd71da797f46bdded252b21d9ce36f20004ca6b63b9568a745af0df7dbe6b83184021af0f302739f051137a1b862e9760830bb4810552132222f15361b1eeec14ff04d51f58f583f4e78038441ed9e6e1800c74b5b23d155a926a104a8a5a7f6e0b38019c3c30145ced894d98faf5a6288b5818bdb26d73c3d49fd64ba2aae5d71acf6f29f57dbeeb6fa9deffe652d4ab6b2a7cc6277fdead305bba8be409761d2e4e0f7432e7cc5a0f6d3ddf9c96576214e01b48aaeb013b23a634f87bd0158e5ae1fd4c9bc134317892d186b9b60a1be4e2c40c2620de10e94f5f8e66e5e3150c9d29b097bae59f55c4204b96cb14bc49747fc835164bc4387166b160ba2d1203b9d15905108ec0c8d17e4578be985f299105f3aa6e7f1078495d31b5c0f41a8d3b8e01c696529259670566a97043eeaaec489bbb20106ee6f6e87cb70d6c43b4ba78a91c40783304cd8663e0bf17e487ff393f84c62d6efb1e95c35e6ad87bd2c9f51800eaa5bedea6e3c367267c1613b28990c131246c203d569592b6bd5e41b27c36b62e6c06ab729431334f2990ced8134d9377c8d6ccd8e525355b2db4329eae9b97c5b6428176f337068375947baee537216fddf047f22dc6197be980d308030f90fcd14c30a6fa80a11a1acbdf9404e96c79ddeae86d4e894c152671618169f31565f225548624f1d50c7c27beac6f90f0b6aa84210849bdf32e0db8d1723be5a45d1fa2b91b60a01349bc03651b9e2bfcc822f948175d2c5027e5ff7f5257707f1bf7ee6c24cddc1d39f8c2469dd9094d484d24ba7c2534c490f79a933feb14cbb67d67fb878fd2091da9cf367dac434006396a8b85ea0ced9c6a3f710fa552030cc72b99267e30428571e1ff8ab7e7f949bf191b438dbc7d4806aaf4897ea30f0c9b1153e93aec5e2b319cd4189683a81fcd719531faba83608c88fc93f7a4d782f8681cc05dc96f1f5ae644f426228d99204a24f0e473a09bbc115f882a886ca575644ac4f25e86568f5ea3a6e55c12709699ebdd959b93536792feef813870d484f46a206826bcf64c0bd2a14c078bed3691dfd72b8380efba6c144fd1368f03c5cb8fadfb568e8fc266039ff85978edfdba2dcf42bdcf7ad8f62d6d1ba6a1db6d979faec4b149280fd776d608ef2901dea08c97b9bbd51fd6317938215d71c3549506e0464def09f39fbb70c54ff74fdfa87169b34a8f1d4029a71f20dbf94b8e1b12da914d48211cebc2845d95b874e281e88d75e9e931dc3aeadb48fe84597f05522178eb76950e3f13ccdd86ac393e4fb64b53540ffc9a8292af44c179696107465af4f6ee49b69b9e9c8c6182defc3b692e5e5d3a4bff016823f85a378a8365ec08a4c083d190a8e7f0e2696289a4ae899ce293eff09a1a48245622c203bab5b8fea2e3dfde03808f7e1eb850b36836cb7790fe60cda10b5e01a0d1f9fb13896b488fe056c8b2c5c7cceb8ecdd36e51cce496b8ebf3f048b8adc022eb672f57b1bc9b505074366e470e07ac1a709fbf77d13d6fe1b50dd63427911372878bdb6ccb0ec365bedf6f1d7627946ee80101410b42a6327d6ae855eae4470b2b2bec1506ed45f63dd0645352cfa57ed469399f96425c0036852cca39082739bb0d0577bba0c41e52970ef6b41c6938c972afdfc1823e037b0d43df2a9c435c44b47efdee938f3183496011cbabafe50f55601f904c91dbd2cc80bb9a56c06f741c2515fc1d3e0d21ca33b11bd7d0dbdf540ea51a4988c3bf90465122e519d5ccd74c46ed806de92ab12b2f2594f18b4096b643c0b98dc9d214d548983f638011fba7e396cf6fcbb24f7bfddc66e3f509c7bfaacd84214bf49ef5723a53984dedfe0156f407be1debe2fa9a759e60c3f49ed4f26d4aebc0ee0bacb9f4421a41b03166903a0f198dbe7de4fead8a6a78445b28c35bce7d5ba1b93fe07d508cd83a99396b19e28d0267504218fefc8b61e062d63e43989d710884b1e0dafb2b17cf985b41f271e2f09af1bf884eec015949328d3eedea3f867c3343665696d6c2aea24ab7d42d2050b73eede9f718c670cfae1761172220c149bf04c20d3100a86a92861adb3099817470c343f2de736b226dc5c911e9d30a822c0d2e0d9b7007597ad69631b0dd4e6f5123df9c5d4053f2c364763a2afbede7ba1b5471075671a7bbbcd111d24d8baa89d574e51a4a013ce2a1885e6df98f468f6b3e8b5d09212be565ee31dd84fb9ed4363f5acd94bafe1a35f91d90e6c8d36be888a8aaf4b153d55994b18f278ca8ede0b3249f6cc23603bd9bf184528cd34764f1fe6ea3dc2e9c639f19f9c7c257f9c19f7fcc2f4c37263fa6e777532910336405117f21ba6924d796a7b2dc16b8c8604336cf90445aaeb94ad6c5ef12cf93befc8864c7c293c4c2c9acf96654173871593d81c47622ddd3ac992d8e3f8c25dab468f974b331e322c34091aecf4d556c0aaa6a04db89b03925f4a0629818be896952bc6a21f86f60dc00244e09b7bbd24a803fb68f873bf6dc335d37de31358680571e33f983743b09d9e6d965ad74270157334a926cf48256064b4307aa78e39e651294286ab882fcf688006d1a144a98411c1efff07bed364d46d0303e63f8e0199974f7f5d164aaf8e6932175c17f71f35d504b7bf4c826cc5bfc2bd6fb303eb8a4e4aae5965e90e5b36cb70311f8169069bcdfca5919b81253caca28893d32855abb7376c0bbeb22a6940c7bb3b035e0e4dabfc28d158bb4d71664ebab9810d9b752ecc0b04e5c0bb8a6cb10c729f3ea66676ed27074aaa52061d0ad0dcc7ad4c87ff02989eb6295520d98de30c96947850a846cff3f9956751dbd3a81bfeec8ee5dbe77ff0d05cd8f11675fa583c8816fc0e53fc6a531e939a6d9aa72c48ab5ba78ff9ccb6142af6c2487b89ddd4eccd9b1eb491afa9d9c8435d511f2b2b46b747e10d186150a272fb00329ec8544a5d319ae92531e9e5161b30b6bef2b9eea1187f12ee00d495f5f2e1a3778776e428b5f77e0cb9210c76a84aec785b85d1404a473c9814fa5b922f025b054d7ce8c3e9fb9618319fdb92249846c6b000c6af9fdf0a5f7203da9af7bb460262079419a9c10000f3b51302fbe959b67ac58388e30ed9f8bc295c589d59a1fae83eca80e9be9258dbf9c60fa205bd8d2f80078e36ae1c9582180acf516583eed25ac77256e6d3f00d5a9e0eaef851df502a81102fcf32853ec17ae22577b0affb2dc8de15b2662f1f668fc6cc6dc9578442b814a98373d550d2578350ff59b3ae1ac8fb46d02eefea04442e79aede7553de05119a381e29aef5faf4d293c90a16d8a79c08c0addc032e9245a7f097674339bfde24d3efe05b183be72cb0e2096f3424a90e5dda1a2cd901a52cf8511e66128ea220db6da8ac00a636b8c34dd9c359d898efd0404db66ffe4fbcdf4296491a8f40d5df7fcf68b617ec0d47ecfa2cf3163138368c37d0ecfa9782d59b86ddae9956b25f09079e35535ba263ab73ec8a6c001bb69c54e28ca9a56051b43b5ae952c388f6633a159c3b587eee5ca96a1e71955f50ae423083af99ebaa93d669138c27801a2acefceb5cbedcd028cddca0d9edfdd09a7136d853cb19f2b4dbd4b8e7507d97b653c303339d9f70665d07a379d8351d37f565169ab582664e06a11a41cb4f0eb2515bb495150af9eaab3a18b0c3a33d8637d3e32a985d836f9e2b2c959e1560bffcd11ae765e5b477564cf1318d147ebfdd0b63a1c8d1016afe85bf1c6a4120e44a17eaeb2014220e7aaa112000ac1ca4abc2e57a7381a6f5721756f155d5f08418a0e846f7328c2b1b0d50c5d40bdccec3fbd26bb2f89e122e0e745e317e6677f55d6e9cb99e60512cae4eba78e868984050f7bd10b4720168419bcc73cc583e39dea2415e30c0f26325a44edfa173b66e6d0fea43d6bc47c8ee5338d91195a47f0a26076babb2c889ff45d5d5cd9dc38a9b2c9e269dad4fa0c52b46e19286fb5ee69d56a96eeb947ee0739c5d21081ff3c959fab88c1d6d97eca5bbd983fab1c22cb9bc30f03a152f0392b3bd04cade85f485b838c71ada460f83fd664df7cfd9144882b264a95693f9141736a379f1a13c30b44f7542bce6e29406a046e3502985f009bd6743f86061301224bfd92f051744a6d7f2025b671530f845b67e9ca72341c1c50765b36de5b6f930390b3181f159454c390d53170445c5eec4baaefe617edcdec0aa7ebed41a0711a0d19ee821f9210d572268a22de164c823fa7370a1cee369c048a0d7726dbf87088f03d3c9cf4c982936ea52e21cced10c9ed8beb15e73b83ec97ec9088ddd0fa22dfbf0e60823f6724a5b5bcaf4a5be91a0aa164ec6fa2a304fb6fe3b882f9d354b97a69e761a4af4194e6a313e79be695607dd498e6a7c8abb1d1ab1d7f46be44fa6da3b5e2b7f6748984b797b9d5ad5e1621bd8a546c715a510d2d07348e3b23f09abcea3885946ac5b28db60d3ea056d24d595802aadecaa871e53c6020e4f8875b843a2e6f83bafc33c48f29adb0c688cb4ebd4deccc70448f8cdefd5fd0fd4168ae3a0329eee06c515601407c6710cc7205de18bf09b50efafd49b19114f0667fc100804fc45c25851f0588bac85f3228d1449a0874d3de6957ca644ed9d6ab38a7067ab75bdb7c18b52a96a4c02a4771a328e84ff8d791870d710a75136bb3201eb638e85cca365f0340bef3bde04d809cb0dd5528d1b7265ffcfe6b44a3ce290b1f0913c7cc317d73b83ab44c6efae6efadb04bf47e938abe938c3ae8130289c61b11b77e680f3a5b7e7b91bebf13722ea53a5d97c1210253c9e94ae2eaf1591b30566de6df479c1c8ea2ddb331def98ccd0427eb091c4bced754d80665ed8e3c7bde5dc34bcc86a24272fb4d8f901f30a59fb5af4a349dc576a43a6d3750e0f6b6ba57c17b8dfea4e5304412e22f95eadbebf8e1940f27101ce2547a3aeca6e3b084587300bf7b82a6a0326dcf9d549d1e6849216fabb6beb9964ae278f315d54df0a630a3acbc0e37ee9a758c9c1e78664e87d67bf850bd9e1f5df23e5e1bf287447f47bf9241d643631d04ecf9a56f0e15597c73663d4bfc9c7863d0c8fbe684c3e0c5480b8a6f97b263e153fe78364d42f222c4de880c1475ee8dc06f4a8059cb38b61e13dd8ad4295530cf5388aa905d5f03f24382c02962ba0c8a535fa5bbfd37f51671d0f367b61088ada35040f27f4b0672aac2f2f89c517568c23eb3d4105a06bb360f5e0f32349fd0c30cd86886d807a352b67c3c98576d29a09d5ef125a55122616668d3bc1ba484baeee62fdca3feac4ea4b6e76d2f357f04864f8a48f4faeb26a5abb2bdc2d0e17dcffb3c627006d8d1df8b09e1fd8bae9bb0db853fa2c769a00fa764225a56a530f8a8833ad39782e7036150fd9b73ba13f5f9930d10b076da6295b05d1fc374f216ab131833972eda6db1142dc0bea462ee6ee531d5037e0581de966a7043c56bf01238fa9ddb477a726c7e35821eb0993726389a753e07e8644fe93b6023f420a47c4d0e82fd9e77f153718a65e53af41294a124073b7c75bd0a589af4b9cf0be65caef7d61d8d4d2e86cc122243125a3db77baa47da6e07db4c58aec0876ed969a05145a1aaf644d7d7f0837e86071a98fa352644f7f68f04830047c97c3add60935a2dd4a982301a6693a447f5ccce18882333b73085b19b246c8af786a999d4442b3c3a6f18e302fc5a0315e0fe484c400c3bbd404a5b5f86a71b509dd6fb3f2f40010b269cb2de385dcf9a83e98f1975504f24053265167faf5aad592871b49a07a81a5b445ddfb7a07cdfe1dbf1f67746a9b92b73c0db87d2b6848b7b6f1efecca48046bc6f59450dc9b0be0e7411004a331f29acc588f274b91c0e3a5279cd36d5cef812b5ab8f2e08134c488f9b98698df874352edcd726d6ac0cfd25286e43490a60f9155ae2ef0bb25332d815b8430e3b62a5ff1712a248f730262c53ba4cbc4288db5509f876482c561edbbc342de35b59c5d5927829cc0bb4122af625876febdea0abece36082c0fc63b68f1e670335f8623be27517826e5079af921fe8c07c3c8175e04a151170d61b39bfeeea080fe7e051ed1a215a8ed0d7de037d196d3075b691c62d3e219565f668edee376f186e3799f02dd6781f23d109ef7310bdb50c96372f9653f8d2ddf7a3af0ecce6851f780ad348357c0dd8d448c00f6f041480028dff013ecf122b534aa10a4d974e400bc25b63e7381ff2b1382660f2bb0555799cf082430462edab9da34bb3d589d7e61f85d24a43e2626e99a6bb2529709fe03b7ac63b62fc7caae28df79dea32b8c92f8d3dd872f49e7a51ca085dd9cac632e5853f48ce0781ed5d75d7e17dc555a821e9d471306c36421f050c0ad1b5ff2e6542683f67e9f05cab8e3479ae3cf763ee5f81cfd04097d9316f8f72ed616b0c5b12331c7f55da244e6014a654f7edd7fe2408d0723d7bf057b1da46d8a658c1f0a2186a096a456a0fca58f1db1199f2ab0f9d9e7d5fa548a191fd486f3a94764fe636e63239e5509b97566ff3a8a6042117dc6de9618b84c22ea208c63be488370bc221dea6019bf8e9250f6d7ceed929294b94c1c6c9282035799fa2f47bc03243778ca540d8c56fb814c171a93d08a7a5df5b7ddf3957d2cb4257918c8c28e1dc4626cd4482262ce13e84231a164684d4684b9e69a8db7588f285948841b4a10898a8c08d86d3115835a3a44d436d4e5ff90ac1a7b66ef9fbfcc27209a7f7ef056b8a252d19d5bcceb50eb8f1218c78aba4e6125d1cc618a495a839c0526d6884afc00d76719055c717cb1cf20241b0b46351a372a6309061c88f8ff83627c4bcf9efe8b02c1db968389f8b23bea41f790c12fdf916ba81c051cb3286355b9c3985b4c7a58e1d863b09868b4740beb7b20496daa5d40f23bf5d10b88e299933ac47a6651bacc3e5350a29e58d0bfc5aac2abb8de1361121a7032553ae721f5f951c14c994af043653c971f54e6b5cf6e710bacbf8cbac3d2386c9cdccfcd2104573c3c0e3ec52ab12b4ee2b58ed6f5039e751c7cc047852d1ede9f649d6e2da06c5d8bcdeaa893be30443ab5ea0f566c9c992c7a99bbf3e4ed9b187f0622cc218cb4e03c0a3aeed0b2a9cf8bd626b4d4436891b6777911acd997878d4a77e3720c34a926c728386ab84b5f7b6c3087eee4ef61936acfc2a6e3923cbecfd100c7b5dbc4d3fd2dc49155d37646379f2e92afd0d099e4d6b6196c7db16386e97813114489cfcd0de45044104e73560903e57a1b0d37cd49dd07dc4eb3b9aef261d23b5dc2cabe341e51424ed8da00356a1333dab305f53603d72d800721dc81f853efb28850b8632183b018c3896808a4ab1370305ae49ac56d805eea56916127925db2dbc66eff1f22316a41a5bc41aacf0a3a68ea3cabcf0dc98ef032904b9a170b56d6605df7f96e935b49e08934c8eb1ffaa58e2372e19c900dcd2ee3fdc9bed3a9b0a19c09d49d882a633069adc9e0197c44e37f0acbd8c1cfed0fac27f0121de5a3c3fb62d0c68d842eae81cd4504e9301507c1bb4e8eee53b468442fe896f8efffbe61eae51958ac460eb07520ea248ebfa53e1a3fffaa6ca02b4390c0bea704984e360f1f07051b5af881abd4e08ead15bee77c561ad378605a884eae73ddcd1ce327ed6b65d087b75707664e9d222cb93aa907431fc3a5930b50afe9cfeffef66523589a9e9d91b1a1b3a384409dafd0b723598fd353004a07e72714931a3d65ac42b15dcca374929096fa9c0c4303cafaf2bf0e76af0f7a8e2a8269d3aa4954e9812a84d2ed0cf12245bffe1172a0d43b1dbfb8a5bdae75f06a3e0023a10fc41da66aec22c76b92a1cc34f6eb4e94a94650003f2ee9f75886d88cc0d58453fc1f1aa612528154c721f884861b461e3a7dc286c0eca9e1eb93c213cd9c0166697819335ec4448a72a4edd644c971549a79bd1950fce5949cdd85ece8ab8738bc0b1062f746614d7ca5e123f6fa80e40ea8763c39602ae6ea5dd35dc902bbd48a5ddc1c324a8ef3900f3fea350fa984f6de29a3e9efcd7009a72e789b5a84db5660c6bffc515821e0792317e91882cb514e80bdee79f4b3fc38bbeada09494336a84a4b2b374aa0fe1ec57f05a94ffabf3e1c5b4b51795c06956993a2238120183a9a8c7f3fccb0fed86b7e4a280132467432d0748e77148c6bf0f7a1fe51d2c24c05cd6011e5f8be1135a36acc198b4909098afa59976d7a52750081e634f8467371aeab5c88d1b04de3429c15a3213b08ecffef8abed6060f5e9ba819a09681623506bb76092ffa6651d3e15a4071b7da18d110eb17486f6caa06b23eed3d8f2341ead17a7a4ee04737ccd243fac4e08010b03a801001aaf096d7ebea1c4cd9913359252420e0435f99f281051ae4dbc9d33065e23e731a8b2e8ebc87e69d7c8f3fc225183041a89aee2d93b8f8549a7d5d0a7d1a18686e3735c9263c66739451a4923e0cec22932cd0609e8b315b5c2e5ab3ea129d1457fab213cd19d260c3dedbe29f770f70a378db06b17e5d8c5a9fd912b65bd4e4bf593ad1601f38838972f65d4cf6764cd47c77e22e3e0b5098bf685687576adecd4ae59eee78c9796df731fffe204f4129a8c447285f5bfa5e0fb59d310d7c3cec09da1c082ea878bd2751ce12534e56ad74d2a59f3acaad32600a882b53558cfb251e5dda5756d20bc36888e4f89d264d0de736ae86de1cf448d7b9d3ddce33adc67fa0bee6201add65dc50377c1c55ce231010dfcd4718481a4a342b128e6e37260f8cca3e361275be693c578eb6d8b3239631e8602b4674429bd85935be1e64eb8947a863d06becf8bafc90a989aa57aa915598a2771e211a3c793ac6f9d70794d021efe63751cafa1ef04af6a290c0162d26738f3fbbb6f44d209622f235055c4fcbb89e28d5f61f1b8a4bbff20979e9af2cd927f40e89ccb4d9354f1b17ecd2880315cbf76018ff59d2d672ed21ffdf975f00cb0c5dc758f9e9a0f785e74d9e8f308745799d70a7970cb1113b7e0cdec144f6101825898f23e1aeec94fa03cdf5bb33495d790ac7b81038fb35fc41b7e6527ed0715c27c3710e9f8f2a1ed784e8ece79ed0b8ae8ee306659a246784cd2014357058b4f05ad4b6678d2bcaba21417f0d55b9ebd8650c387ad1846dfe53a6b3c9537b2bd570ec7fbf625e19d0b63f1ecf312f18889d884ac34ac94ed1afff3077e7621f1a9be9f9f2405e7aea7cbea2060e99b4aee93258200267612cd8b7b4c4c1b19aa7788d039bff7b5896a26c4534041529426fdf3e2c34324ab260fdac668df40d94b75060c6729e22e63e09c78320e1a5164d85f1e51b0e7605e722084f4acd92707a6f6dbaae6778f7be844173e12414c110ae78e486717e0a424d3a1d435bbe27321422a2aedd45bc43b370263e7de6b5878afecba4342f7a64f93d9e89540fdd2be620d65065f3076a56656111c6cf914ac2a5632f1b9617c126548703ba1fdaecb59cfbdc94108ea293934a808f143a3e6935d627d556a552a3f838f877ab2010f4c1b126893d008860dc03b06d7ed5dd9091d1323809190e7eb065879170bd96c390d0b51c99400ce7143cc03abe791c51f8c72271537ea945aa31ed40990463158651aa2dbc043d09003575f8aafb7ac374711af04908f9a1fa2ee986b2b8f7ae476654242ba7bf2498e00f342ed9f2789320cf5ca83043adb84d74663eddf309420564bf5d880590b1a742fd9dcfc14abf249f17f9c35d65830c9ab85bf7932fc4ed5e74df07e2f67ef1cf8840e4c6734b5afd9bbdb86fa62cf1794abaa90e8843ea505a8831d0626d8ed5bac0ba455ed384427763b98fdb19d5edf254321c3fef2aa5425ce6ab34de0c429ba5b8ad9da0c668e945d3f5dddb9037bff624cad65a8029e6b56ed8b31d6a60f827bd2c9f04cf36575753d2778f89d84ed70f4259f80651b679db69cc8eee011e4a61ac1badf9543a5159c91a17dd504e4ec28e49813843f88e28b6eefc33d73a73834da4764bdcbd4c235e4734043700da19e5c4bf0dc0932bdcea2a3275c1c11671a6ed7b04bc58b0ad5d287090fb3760b0aae927a89e04dc1d91e3ad861e9ad3748488a07fb776197666f9cd1ee92140356c712023b25805a81a78209c72adf87e615de585410f1a1b7ec14b93f07281b4c3b8171482bbebf56e13c708dea4c84c49cecbdd325057d4039c62e29be9370501cff47df24521c37e178eac1f84f21c57cbe85086eea54e8e35e09578940c3d3838889345965d47f400de61daacfe83a5051bce3850ad548acd2bc9a9de18ab02ef3477aaf3b333acddc14c6a504e702ab33b1bd4b7b8f49cc6537db13683cb51c8011e6912a90be1055bf9e857a778444b594367951fa36bf730520371e39e111f3b891d5118eb111622d23460d64207ea373f9aec34916f933187577b26c7f5fc1e0fdfa1fc44cab9e909d4cc017993b8bb94fa932bd8177f751b5fc1115946cded461971b6eb401034d80b6e3ead53b6a7c58b463319c10609172e7abe7daa4a4ab873203373c24a7a959e4c1c5b6f12a4927db9d3fffb5fa3d3645229b404f59e498c6343d9d51915789e4b397d41743c09bb05f30de6d6d58b1497e3d91e27540af86a5f13b6c9942fbd3dd1c4b89b3fa29d7fdfec528ce15aa86ec29714d7788be5987eeb34ae339020155659c5efe7cddb61257fd150ef195e01ab4539015226df1c7bf26df0f4fb680ea5c3943c2691d6d5a9061944adfdd4739e87b08531128afa12eb31bbe23af76ff7026d370392494d42c2d1cd6018b096d56ce671ef6fb49042ecd392a81f0f031277b604831ebd7e8471eba6409c1285f889f0a3c3d7746cd869eb9ed6bb694b488dbe41dfa3022767168a5bff91f6dff649afb120700b23009749cbb16edfa3dde17287dfaa6819e3716d6037866527ccfa7994b0363e0bc3734d75385cd09865c40eddfa6359bc374b4f7329e81594c2f1b86929ac912409d79f09859603e4546bffb7a1b590292e89065bb1228be6a2f672bb02820b1196d2629bf8320012d6f8f3b26536b38698e5ab4629f516dcd013210c1f83644ec48e0dbc33ab885469219cedcd82596c0dd05fa788100370cb5b4c871ecbe255247e989ca0425cf696d6a5a4d473833b9fed9e9cf721896ca9d2f4ad0f23ff234ad136f9b9e60d69fa69a177675cbc3217dc55c0b31fd2fb4598b68b5effb202b888e1166a778999d01810fd070de6db740f8b3c4083fad607254ef3de312b751bd126ceb55ddb9fa574f65adcfe60ad8bfbf901750ebdb46ea7624fe3ac53ed9c31400a2eeae8ba2a4ef6cb5b7e76105d6da31108988cf04cc23d4f215a09fa7f3000a3ecf5a72e041c03a82bbac61989d2fc4cedb9fd9b0af44c3e461f3301b6a822ab034af1e6682dd610a9512bb9067b5773fa389ca449a6fdbe22f00d506063a499842b8a45870e007af6f88a7eea16961a11e5866c32cf245750821a994af1fe09deba22fdc33230545ca5b9be8d72a21727628d809cabc21b6c575baa2f147ac5f00f54b883cc301c1ee871890561b605f135640897cb46346df845086b963142252e252194d16e666def60facb69efa77013ab4bb0d9ba956ac7ce7519c1cf2c10ece5531482037978e5de8ca5449dac39d9c979c9ec7289751016dae6ecdf9137d18c7abbdbd4d69220b63dcbfd7da243eeac67afb783888eef287b59776536ed4ca6c9966b85eb93f6982b439735d83dc05e05312571162f56ba946662890f07592460a146c94b2c002c1bd79c0843976774e122881a2bdc2609b23e9139bde93baf26c77939ecf1e6cbf81a8cc1b726febd53c13a3879513de238af9addfb44a42f2228f03edd0f618edc5bd0a408c729752223c82bb264a06676d56589ad060e5c88660021d70c41d11d4a4cba0a2f199db018cecaabb08dc6a9b1b40df4bb17fd5cca525618e545bef08384ad394ce9ebc5e168f2144ba65f1ec13709ce137e872ee27e1bd520d7598ce64eb97b8a5160ea84c6f678e13e5730141784c80b533b073d62970211423464ad7d089085718e3d009c3e38716446ac2b6c5f755244d8cd0d4eba67e16792492ab54a143b46fe42a44b99c5973b3062c8bffd04ed8f57cb08e9b44d6da8f95b00fae3e0a4ef163a68388fe33aff5565e8aad80ad9def31554bc0dba77682bea01b72cd10ba5ea5a3fe998442adc60ccf95469a36d9b2588abf64f85ecd4a892785e0b7973ba2c35d5e7bb9c849460b3bcc22673301f5eb7f29411dc963ab3ba3c6033f17bab0966ff8fdab6d9bc7ef9aeb3d17321b5b2df4e83ed9675416ef19605a9ed4ce18a55c58e9bcaa2844364e6bf8bc7cfde6a4565bcb52f07ed3d85bc9964f36f753655b52f40a6fa411eb56cbac612df5d17ead3af8fb34277a99bb648fa706f4ef4dc9e2ef0767252a6764c899127d6f8b0089ca3e12fd6f2fb02640e395043666c062dce5f0c5099e8a5ca9c59632c6940711b0fc415a273e8a002ad4c84b846ed0b2a9fd85388e64cc0bc860d797e9963c210f52854bf29c1d9b63bd5d96e5c867bb3312a78d6819be5b1347003a6e4a5f1c40051c43cea1bb801f33b542684b52429d596153527fa051dcfcbc214edf540e871a0a80d04e9e2a183d2f505e452961550d12c297018be5f57ba9d791e2d5c9953db5c681d55a3dc7692d28b0707b78f0e984584ad5a28907263e2cbeadf4b2071588b0a34a9b0fcd91176c758424483e7a738b08a234e21ac822809682c63fb26245a1450729e12fae20fa9f5dbc78f572923b3ac98eca63d69abba63c5bbe91376265a37e22dcbc610ba6a5056b3e7f37ed4afb20c9ecaa6b867000807eb59c17aeb0ba0892f068dbc2b33801b5cece0069451ed52cabad2395756d61867208fed1b30be59fd70fa5b26f1a9d6f4fd4c44aed42983c693d139fc4bff73a7501ba6df188f93b1a697322b37cc71a2f243333108197546a828a6c0baedba9c1c292375d5bb83eef06e5e30abf117e7809e21c89b6765fb3b9451648eead4c4c6b107f1dd02db437804faf209e97ad6cafd2dd1752f2491ada0bab46867288b8e6d6e5fc2f7c994315fb39df95a15b63cd87b55b623975c82950eba3c6e99000f14e9d77ff2123cabe0ae829e5de89bc62e4497a123a7708b70c95cb125b72ef4a415aa95fade0d0678cf45e0ae1b4a8a50410991022e4a11c8a7872d5a9f81ee75ecda2b4e9eadb3dbab8b5bf80e3673ddd10556767242209efae11d68e66803346a9c888b28de07e6f6e87a68f4ded130a0cc11514955e3e35de036b17fb8232cc31519c46a1602bba2a56790e76a6c8201fdc2f0ec4961cb633e704b29e02eccd1e443ca11c67277e4302a3ca3955226a8ea861fe286778b2e7821af9a5a601ff8f7d70178174123e4d59f9d193c2dae36a6db068416645a702b56b40ae091ef88299255f41f30660f1c39cb844c2474ba32eb2551d56dc5fcbd4c0f1d3f21932c98889868a26aade133958707bed85ebb0a495a52f72fe28ca3129bacd3a27729f72aa206e40fa55c2985ec72e2caf13145d5dc17652217012c021637f2bb2eacc6b98fc18cff488fc35e457e918f2e90ad5849b81d0cf3d93a6bd966579f8caf73af7763b8217b2da00196146b77c6fd8ac149a7e85c1ae5d1adda549b81aaaf564428eb6d4018237e0ce4719cff71c16607cbd8f4a835d81ef12b550caddb7ccb81b45fb588a097e040800723ea8505e33ea4eb967d05bdd4c23ec10535ef2c978b7965eafa0f74acec5124109fb8525283e98049357687ed5dc73747b9bc23267c82e8e06d2df7806ad8ceb2b5cf808452406ae46279609330b033626e05bad33cac94bda96ff4cd2af8241a2ae364cd0dd3e986099aad31b6368ed571225a0e5d5c7a80e85bf86cd00994925090a64984e8ca3bba8fcd842270448c7ab00fdad767ebff94102c1657e224fdcf18d08ee64d3fc0bc31ee57707ffa9fe7afca4bba630d6a216e6ddd4acf213819166c4ad3004d273afb0fc35cce499f86ba397beba3bbaffcb1e0e57b2419dd3fa3ffed6ca563f96df08bdb6ce9afd729b9b7304264d6c009b296a06355b108457039132ab4b0dc944cd0cddd16b75e9c618363a3b5c261900fd1352e725ac1f7fb58288d5e1e458f538136388494fcd58f17754c07656b415acdabe1cdc21aceebe4f87aa1603f4e8fd4a9b0eaf7a2d083608933600d8d20891266c211c3f6faab0f5f70eefdf587993d9cd0875b12183a3a3baba25bba8cd20c98fca02ef20aaf38de50418dd5d734309bf944b326b1b0f6e1527732623f1f238df5369be72c50d4300d6762c678eff339c01fd2672261e4788063488c85014545308da2f10c121a0da0017c30bfc21b6a5cdec1182c1f4f6407230d45b483195ca44532e7fa32d42a04ff5ba64a49baf34b7d2cc0415006b35197ebd23cc5ee045fc44bd1bea7b2a46e34d945cf6e422f87787cb57b95bcc914c1e6027fc76e4dbc412fb5dea965f2d4bd43b61404f9acb255462473b2b00043f81c98e1086387ace8bb4d0f541f074984cc5a5eda2bdb419d68d6dfc58bd13a4ef4733017a7d201f5f3bfd76ca291bf66d588e35d5b7b3227794766113fc2c553e3e34dbc8786153d72877ef111b80dfd982b3392f4aed527a96e4b78c10e2ec5725006c5c3b7a12fb2d3c9681185c900fc14696f733d2c9675dbb9f24e76601468589a218f779559e2838f502f99a36e61f368a3b3830916e6cb42fff9492ca62ec7b415589fc8e793d61615e6ed872a12b5fe1d5e9757da90edc85f701f79acc6992c1b121ff7df072a9b656c692bdf467eb1abc39362bbfcc6cd4416dd078b90b98f2be9adf8512eef0e543efb76320058aec1f901aae11e130a81b699da0fee1dfba58efa01c71138da13117f3146fbad082965668a3913f9db10fb6cdce117284d62466a0d83ba21f144206a4ef8b8217b57fda9d8969e86df370af166afc6dad87f454708acb6863cae7a108d4daed7d3fe040a14edaa2511ec32a68ae2859d0845d19e4edfba68bd943d017f23cfc5f61cb4ffec65ed0a741ca236c8f9f870c1be3431ec611ac7c17aee0f3beb13130626436831cea4b7c6ef4cc524ac879b0fbff650d43fcdc13a601040bdaa6c2ba32a58070aaf1f7519163653400df1a0c8f4f53328dd4a66dbf30f7271f721551adac146f1154482ba378b829b70c357efbf7909c4e16597449b2c12c2a64f9fc3a8d51a5cd2bb2ddb571cfb28f7deb1c557646d82133d0458922f2b00d522231459a2c9bd4aa8521d0bdc30daf7f0c2329e192e3b48649e5c722c091bcdf2106a380643f79dd204963d93e5e953041f064a3a67206b598d9dee0e6820a35b8640213e61ed22eeaba56402ecbf06884dcc96545d86ec3006edc3182a08d9e66a82edd19c2b4168547c388f082a924e4bf468018c9a416cf54ce0924b36165215cff27678767c2f1c400dc4faac73e15c0fbbd7bd4c7fa5569957c218f63ef6a4bb5a6e49960281ed656fd2be6e0fff0b4990811f3b12927ec6374c8293534b8f3ff7de6570657251ca2c96e1c2f6eb60eef3e2e1c0fa1da917c143e689164177be7f0ae1a8126a807db995661a0e50ed93f2f3cd6a674c40a4572f7b5a455003cb080901317b31c27186d9903188a5e5080cd0f5cb548c463ed794731e4ef18ddfdda1057a59835c50d7ca8896d300e3b9de7796a74eae7a932005d596ea296693636076845ece13cb85e18df751b7fc02eac27987b95d3057b8ece06b5221f88c5e72673c83d208e8b9ea19cdd7a4f1fb87b2714dd895d5a61c5ea07382121c7cb74d933774f34c8fcd4553e526b40c40a6f9d7b245dc829b26d53e6d7a5317ea4bbac7693183fccd862d0a67a404dc0195e36ee44f7ca923b6d0e7e3986bf02bd047c0aa929406b44d79643dd2fa9551b3a9b982e218de60bec000a43b4031fbddde80ac7df52627f0682e4b53ef7ea82c568b7552ca8d8bbf064184de116868de0f45d476fa82c9892ba4462b08fab1e68bdcc45e4075feace496594094175e13a154df3d209d73dd846ca535a6eff43630b868058c272100b58cf15c55aa119f96106e9b30cd793970bbac5a3fe1b569e1257a6f42523a6619a8144005f72c33e85a9ffc15b38992be141d959905b40af37520d20ee4ed3a11bb576c0caf4c1fa58c60743a288ba3fbf068b598cb880188016e766c59c55e296925aa6b0635dcd76a5529763c16719658188778ed0ccf88f98a1ffdfe5524cb6ed82d5b80429d603d77d05ee09bd5d06346c42fa9527ba621be0fedabde9264622d69a1b0de58209f2000d9868207b9fec5d5ec53d161716ac8deaa4aafdae9ed4d9ea584587ae9c4383db35d87cd0c27c9303eaa0108fd0b92ae597ebb8b65e5f7694bcdc8daf168f55aa868f0639bf817bf8671bbeca2cac8d2b4dd9432e7441cd1287e936d3e13dc6fb9c99ab2214cbfb6ca071c6443f64f26a8f4c1ca4ac0209a24321e9393e83ad1411723b30295808636f5eb636545ec7f655292fdd5cca7b4730fd1916c01be5ced4d058744fcbb430e4dfa668341060fefd6a962a89dd5d857f92e20439c261a7a9e6f36895a15046f1421875d6a2938bc0cd108d79f21ebdf08365087195a720e277fc26fd3c5f2e331662ec0e9a01839888c56d114650ef3ba8a6e56fdeb4a946cfd3b89a9cf4c317756752897061b88f7147d337198bb0e23ce7d3e9e33e25a9ca7d6cbe6186177641f612c692aeea203bdeea99f909c8aa4b8fd8a9fc2f4a3a7b7f57c4444178d2f86062ecdca211bc9fc232fd1d6a938c6928063761347c8a39d9998bf0b53ae764a7a6013fe3760b7455342405fbea6366608d39f0dd7a38f04e08ade249b706bb349fbfe7939f7e10fd371955fc22432ac02786f3e62cf7bbb98ade266b075d72712010afc30bc2f0aec0ba4f2eb2100919f155a349cf8a9ce18979d486836e6c02a8db561263c6437c7eeb44b89513c63de2992b94d1de005c90b3bdb4a72ce9eae1fa88d5985865a00bdf3b21b4521c55880520b3e7db5a938f417e46197b034da03c9e6ad96fcf22b373affde9af99e3c123b30092f065eb847cd696eeb6038a81fbc248993e686885096680cb50d36fc1304eaaa40e49385bd9e62050a664f9c0269265b5e35953146ac11386dd5a2862c8833eda2c518054576b1b5cc9268be42bbf8c36e8a2b4d56fcb78c43a47047a6af3920c080255ddb571e2b9904dd2fc46a985b94f417fee9139a4c214fc7d9967dd979c7020397bf6e4917e84266be517d77f01ac4a2fd7011593cd7dc619625572f135537489ed09fc82abdf63bfcdc027e5c2d51df8d533d8531890e8a30e748624e8bf98cf3399f14249789b7e0bb21198d8754da05746b22b3315036ef32c55720906d4e228e50986ab4d054c3f0c0ae3d741716909c91bc197da7f2c9220199d9513d779e2653d636a4856d0b11561c616c3a483feaafb9ea4f373108725b7af0561cf4a71d5c55ced56833b07a38fce6ffb0a486d76b64c82b08887eaa88801c38cded544b8425bcfb9c2c37c0390dbe9d1970d5e87854c4843ddc97baeddeb2d3862214e475c95f3dc48f8ed7dbcf176bf93068e9a4c8e68b9915b26e2c290b93abcbc43b7d6fa3bcf59b0f6cb2f6e89af82a236f245727ad97983660df272c7868750be97c672dcf6d84458a487cb2acda302955c7b5c179b2b4b2d10fe21a43c02b141fd03413c2f81143d69951bc8e2c36719961e5ba423e583e754508ddb2da7a5d73da8ab9e333cd1f9ceacedec60463cfffd001c8bcd0f8ea93d53e969150e5a9b9502e10cc952684799a5d19066ebc7bc46af731abd381abf7d2fbe51991829c938e2e2e040dc0ee166be609d25d30ed85c610fa5e1da806ebf4b2b645eefe5ef1ba4fa7081fe252a236531032f9e4b6b003d5ae00d8a477695c8189a081de4bf705d1b91d7a6095573f563d37aabbcf8f2f60f0e3cd3b5d7a53df0627509dde3f62475529fc8a745b31b0f353bd36da461df8dbd1cc1caab32b74a0ad6668a50001488c5f80c40844e112ad3edb846751f4a3b20edf45bad87ed56fde73d78c61b149fd1915f209fd17708bd69d9ce41e6044b6f7826e4d6bd552b8470b2327a110db8b1228aa3aa1729d913eeb3ee94ad209f2edc51e92788218bfb1cad86cf80de3e0ced1c4b215e74cdcd04730dd520d1425753239e300eb63c715761f1039632cf535a407f8d6d5c6b794dfd23a773ec2143ec8b2cc36a815dfb90b0aabc63498697131ac505db85e6f54358d9b84848db66e4cfb4d10864bfbdb4f34a926ec247463a6e55eca175a21981d5d47c3c95a593abfeadd878d43a2c7b8a23182a0bcfc586fea6dcd948232c8f5256171ba7371de7fd944773a01f816a3dae12d824146775df7d9bb20af55fd92e8c35cc51c08a046e42391861625544f27e3f8947f059eed457b25a268cf5273778db30f96a8529475f2d9c38d9984f28c6bd961cf3d4229b57c5f4f92b4a9d108995cf3675eebfda3269ba7fd8c38fc44b3d31be18cad603cc8a97ed94b3535edcff5b0fd2c7abb7f29d97a1fb0c59613d011167545e80dbf2ab1166790559f88f9ce58750b4db257b2e18df8d8eaf5577200af38e79f4e90443741cbd2c2d193889ef9265047055522dbdbdee3bd07e623f8ce4b1641a2af9f3c1b10c91d331d76c683b5a5e76fdd327a1356da2595a4dc1081a503ac89035733579af44cdef136295daf9f0c025897fcc32507c0214d1fd6a0d688fdbf0ac62407e9519afcceec62be1d9f20ff175cb74326f4f5da228f580ebb5772454b583231fb77a9a7b6b9ecf7e4217cb0666fc8f50b54ccd297db0fd7da1ad83457a2e9874427596c2ffbf4b8bd7b0ccd74c4f2374fe835b4c1cd3d895c77bf2dcb9825701eff9c424182d3dc0d130909d2a2ff7a8fb048126d44ec6928f6ab75cc4a5c6b40004d4c678030c38583dd53d7eb6482771401478905fe17ace2ea006d1f267771922744b1e79ae6023996748c3e3d1e4679e208919e6bcff12eb2ce57d783b0c38b66d87106315ba358adac717c18161d4ea015d8233b975645b667495ec2dc6632bbb192dcfb9aa1a3419dce5a5a30da7319f8257ef9412bccc4e6a275bc88526d50c42091aea72bc2449f09d4195d6a4d6162673e4eed2b46aab443d6dbc8326b9513a8311e64779ed2cd7a84cfd372d2abf1020be520c897d98650661f92d641b31ddc8c1f224e756e12bfe5a48bce7594e541877b5a6df9a153bb40b17bbe329e5d457b8f629e0b491827d6311daaac40a6584855e50be35563372a80cbda5463912baddf42722a9e563a222a3d7581a53497c7e382972e985e5c041a74345c5c92567196be58149b144fc231dde184408fbc2abfec6267e3889d9d326ae8b2924abf393f2ab573a0acf1a748f19af57c06c46335b8af61fc31bd372e324c05437d54b9fb5a25cdfea8080e52c24f368ca62dad9ae2cf930664bce733f3b944242dff</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">点击输入密码...（全是碎碎念废话，也没啥价值QAQ)</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这一篇全是每天的碎碎念废话，天呐居然还丧心病狂地设置了密码，也没啥价值，挺浪费时间的，去看看别的吧,虽然看别的也是浪费时间嘿嘿 OwO。要是认识我的话，为什么不直接找我要密码呢（当然，我也不一定会给OvO）</summary>
    
    
    
    <category term="生活" scheme="http://example.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="胡言乱语" scheme="http://example.com/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>【题解】模板题总结</title>
    <link href="http://example.com/2022/06/15/2022-06-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A8%A1%E6%9D%BF%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/06/15/2022-06-15-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%A8%A1%E6%9D%BF%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-15T08:18:55.000Z</published>
    <updated>2022-06-15T07:51:57.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础算法&quot;&gt;&lt;a href=&quot;#基础算法&quot; class=&quot;headerlink&quot; title=&quot;基础算法&quot;&gt;&lt;/a&gt;基础算法&lt;/h1&gt;&lt;h2 id=&quot;快排&quot;&gt;&lt;a href=&quot;#快排&quot; class=&quot;headerlink&quot; title=&quot;快排&quot;&gt;&lt;/a&gt;快排&lt;/h</summary>
      
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【题解】每日一题</title>
    <link href="http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2022-05-19T03:08:20.000Z</published>
    <updated>2022-05-19T13:46:57.219Z</updated>
    
    <content type="html"><![CDATA[<ul><li>AcWing的每日一题（</li></ul><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;AcWing的每日一题（&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
  </entry>
  
  <entry>
    <title>【题解】DFS</title>
    <link href="http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91DFS/"/>
    <id>http://example.com/2022/05/19/2022-05-19-%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91DFS/</id>
    <published>2022-05-19T01:55:34.000Z</published>
    <updated>2022-06-14T09:01:35.498Z</updated>
    
    <content type="html"><![CDATA[<ul><li>所有用到DFS的题，从简单到难</li><li>栈stack、O(h)、不具有最短性</li><li>回溯、剪枝er~</li></ul><span id="more"></span><h1 id="AcW-842-排列数字"><a href="#AcW-842-排列数字" class="headerlink" title="AcW-842. 排列数字 "></a><a href="https://www.acwing.com/problem/content/844/">AcW-842. 排列数字 </a></h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="comment">//dfs每一个位置 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(x&gt;n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">if</span>(!st[i]){</span><br><span class="line">st[i]=<span class="literal">true</span>;</span><br><span class="line">a[x]=i;</span><br><span class="line"><span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">st[i]=<span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line">} </span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="AcW-843-n-皇后问题"><a href="#AcW-843-n-皇后问题" class="headerlink" title="AcW-843. n-皇后问题"></a><a href="https://www.acwing.com/problem/content/845/">AcW-843. n-皇后问题</a></h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> g[N][N];</span><br><span class="line"><span class="keyword">bool</span> row[N],col[N],rd[N],ld[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line"><span class="keyword">if</span>(x&gt;n){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">cout&lt;&lt;g[i][j];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">1</span>;y&lt;=n;y++){</span><br><span class="line"><span class="keyword">if</span>(!col[y]&amp;&amp;!rd[x+y<span class="number">-1</span>]&amp;&amp;!ld[n+x-y]){</span><br><span class="line">g[x][y]=<span class="string">'Q'</span>;</span><br><span class="line">col[y]=rd[x+y<span class="number">-1</span>]=ld[n+x-y]=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">col[y]=rd[x+y<span class="number">-1</span>]=ld[n+x-y]=<span class="literal">false</span>;</span><br><span class="line">g[x][y]=<span class="string">'.'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) g[i][j]=<span class="string">'.'</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;所有用到DFS的题，从简单到难&lt;/li&gt;
&lt;li&gt;栈stack、O(h)、不具有最短性&lt;/li&gt;
&lt;li&gt;回溯、剪枝er~&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="刷题废物" scheme="http://example.com/categories/%E5%88%B7%E9%A2%98%E5%BA%9F%E7%89%A9/"/>
    
    
    <category term="AcWing" scheme="http://example.com/tags/AcWing/"/>
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
</feed>
